TITLE:Clear Digits
DIFFICULTY:Easy
CATEGORY:String Stack Simulation
QUESTION: 
You are given a string s.

Your task is to remove all digits by doing this operation repeatedly:

Delete the first digit and the closest non-digit character to its left.
Return the resulting string after removing all digits.

Note that the operation cannot be performed on a digit that does not have any non-digit character to its left.

 

Example 1:

Input: s = "abc"

Output: "abc"

Explanation:

There is no digit in the string.

Example 2:

Input: s = "cb34"

Output: ""

Explanation:

First, we apply the operation on s[2], and s becomes "c4".

Then we apply the operation on s[1], and s becomes "".

 

Constraints:

1 <= s.length <= 100
s consists only of lowercase English letters and digits.
The input is generated such that it is possible to delete all digits.
SOLUTION:
class Solution {
public:
    string clearDigits(string s) {
        // This variable keeps track of the actual length of the resulting
        // string
        int answerLength = 0;

        // Iterate through each character in the input string
        for (int charIndex = 0; charIndex < s.size(); charIndex++) {
            // If the current character is a digit
            if (isdigit(s[charIndex])) {
                // Decrement answerLength to remove the last character from the
                // result
                answerLength--;
            } else {
                // Place the character in the "answer" portion of the string
                s[answerLength++] = s[charIndex];
            }
        }

        // Resize the string to match the actual length of the answer
        s.resize(answerLength);

        return s;
    }
};
EXPLANATION:
Intuition
One big advantage of the previous approach is that it does not change the input string. This is helpful in situations where the input is passed by reference (like in Java) and the algorithm runs in a multithreaded environment or when the input needs to be used again after the function call. In these cases, algorithms that modify the input directly should be avoided.

However, when this is not the case, modifying the input can be more space-efficient. In such cases, in-place algorithms like the one weâ€™ll discuss here can be good alternatives.

So, in this approach we will integrate the "stack" logic directly into the input string. Instead of pushing non-digit characters into a separate structure, we overwrite the input string in place so that non-digit characters are positioned exactly where they will appear in the final result.

To achieve this, we use a variable answerLength to track the current length of the result. When adding a new character, we place it at the answerLength position in the string and increase answerLength by 1. When removing a character, we decrease answerLength by 1, which effectively makes the last character irrelevant and ready to be overwritten.

At the end, the result is the prefix of the modified input string up to answerLength.

Algorithm
Initialize answerLength to 0.
Iterate over s with charIndex from 0 to s.length - 1:
If the character at charIndex is a digit:
Decrement answerLength by 1.
Otherwise, if the character at charIndex is not a digit:
Add it to the end of the answer, by setting s[answerLength] = s[charIndex].
Increment answerLength.
Return the first answerLength characters of the modified string s.