def minimum_steps_to_reduce_sum(t, test_cases):
    results = []
    
    for case in test_cases:
        n, k, a = case
        a.sort()  # Sort the array
        total_sum = sum(a)
        
        if total_sum <= k:
            results.append(0)
            continue
        
        # Prefix sum for the smallest elements
        prefix_sum = [0] * (n + 1)
        for i in range(1, n + 1):
            prefix_sum[i] = prefix_sum[i - 1] + a[i - 1]
        
        # Binary search for the minimum steps
        min_steps = float('inf')
        for x in range(n):
            # x is the number of smallest elements we keep
            remaining_sum = total_sum - prefix_sum[x]
            steps = x  # Steps to merge x smallest elements
            
            # Decrease the largest element to make the sum â‰¤ k
            max_element = a[n - 1]
            decrease_steps = max(0, remaining_sum - k)
            steps += decrease_steps
            
            min_steps = min(min_steps, steps)
        
        results.append(min_steps)
    
    return results


# Input reading and output
if __name__ == "__main__":
    import sys
    input = sys.stdin.read
    data = input().split()
    
    t = int(data[0])
    test_cases = []
    idx = 1
    for _ in range(t):
        n, k = map(int, data[idx:idx + 2])
        idx += 2
        a = list(map(int, data[idx:idx + n]))
        idx += n
        test_cases.append((n, k, a))
    
    results = minimum_steps_to_reduce_sum(t, test_cases)
    sys.stdout.write("\n".join(map(str, results)) + "\n")