CURRENT QUESTION:
You are given an integer array a_1, a_2, ..., a_n and integer k.

In one step you can 

  * either choose some index i and decrease a_i by one (make a_i = a_i - 1); 
  * or choose two indices i and j and set a_i equal to a_j (make a_i = a_j). 



What is the minimum number of steps you need to make the sum of array ∑_{i=1}^{n}{a_i} ≤ k? (You are allowed to make values of array negative).

Input

The first line contains a single integer t (1 ≤ t ≤ 10^4) — the number of test cases.

The first line of each test case contains two integers n and k (1 ≤ n ≤ 2 ⋅ 10^5; 1 ≤ k ≤ 10^{15}) — the size of array a and upper bound on its sum.

The second line of each test case contains n integers a_1, a_2, ..., a_n (1 ≤ a_i ≤ 10^9) — the array itself.

It's guaranteed that the sum of n over all test cases doesn't exceed 2 ⋅ 10^5.

Output

For each test case, print one integer — the minimum number of steps to make ∑_{i=1}^{n}{a_i} ≤ k.

Example

Input


4
1 10
20
2 69
6 9
7 8
1 2 1 3 1 2 1
10 1
1 2 3 1 2 6 1 6 8 10


Output


10
0
2
7

Note

In the first test case, you should decrease a_1 10 times to get the sum lower or equal to k = 10.

In the second test case, the sum of array a is already less or equal to 69, so you don't need to change it.

In the third test case, you can, for example: 

  1. set a_4 = a_3 = 1; 
  2. decrease a_4 by one, and get a_4 = 0. 

As a result, you'll get array [1, 2, 1, 0, 1, 2, 1] with sum less or equal to 8 in 1 + 1 = 2 steps.

In the fourth test case, you can, for example: 

  1. choose a_7 and decrease in by one 3 times; you'll get a_7 = -2; 
  2. choose 4 elements a_6, a_8, a_9 and a_{10} and them equal to a_7 = -2. 

As a result, you'll get array [1, 2, 3, 1, 2, -2, -2, -2, -2, -2] with sum less or equal to 1 in 3 + 4 = 7 steps.

EXAMPLE QUESTIONS:
Example question 1:
Name: city-and-flood-1
Tags: []
Description: Fatland is a town that started with N distinct empires, namely empires 1, 2, ..., N. But over time, the armies of some of these empires have taken over other ones. Each takeover occurred when the army of empire i invaded empire j. After each invasion, all of empire j became part of empire i, and empire j was renamed as empire i. 

Empire Huang, leader of Badland, wants to invade Fatland. To do this, he needs to calculate how many distinct empires still remain in Fatland after all the takeovers. Help him with this task.

Input:

The first line contains an integer N, the number of empires that were originally in Fatland.

The second line contains an integer K, denoting the number of takeovers that took place.

Each of the next K lines contains 2 space-separated integers i, j, representing that the army of empire i took over that of empire j. As a result, empire j does not exist anymore and is now renamed as empire i. It is guaranteed that empire i still exists.

Output: Output one integer, the number of empires that exist in Fatland.

Constraints:

1 ≤ N ≤ 10^5

1 ≤ K ≤ 10^5

SAMPLE INPUT
4
2
1 2
4 1

SAMPLE OUTPUT
2

Explanation

Fatland started with empires 1, 2, 3, 4. First, empire 1 invaded empire 2, so empire 2 was renamed to empire 1. Then, empire 4 invaded empire 1. So what were at the beginning empires 1 and 2 were renamed to empire 4. Now, only empires 3 and 4 remain, so the answer is 2.
Difficulty: 0
Solutions: '''
# Read input from stdin and provide input before running code

name = raw_input('What is your name?\n')
print 'Hi, %s.' % name
'''
def root(i):
	global x
	while i != x[i]:
		i = x[i]
	return i
n = raw_input().strip()
if len(n.split()) > 1:
	(n, m) = map(int, n.split())	
else:	
	n = int(n)
	m = int(raw_input().strip())
count = n

x = list(range(n + 1))
size = [1] * ( n + 1 )

for i in range(m):
	(a, b) = map(int, raw_input().strip().split())
	rA = root(a)
	rB = root(b)
	if rA != rB:
		count -= 1
		if size[rA] < size[rB]:
			size[rB] += size[rA]
			x[rB] = rA
		else:
			size[rA] += size[rB]
			x[rA] = rB
print(count)


INSTRUCTIONS:
Solve the current question.
Provide:
1. A complete and efficient code solution, optimized for both time and space complexity.
2. A detailed explanation of the solution, including:
   - The intuition behind the approach;
   - Time and space complexity;
   - Important considerations about the algorithm.
3. If the language has classes, implement in 'Solution' class. Any language is accepted.
4. You can use the example questions as general references for coding patterns and structure, but solve the current problem independently.
5. Don't use any external libraries. Don't need to import any libraries.
