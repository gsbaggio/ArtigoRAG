def min_steps_to_reduce_sum(arr, n, k):
    arr.sort()
    prefix_sum = [0] * n
    prefix_sum[0] = arr[0]
    
    for i in range(1, n):
        prefix_sum[i] = prefix_sum[i - 1] + arr[i]
    
    def can_reduce_with_m_elements(m):
        if m == 0:
            return prefix_sum[-1] <= k
        reduced_sum = prefix_sum[n - m - 1] + arr[0] * m
        return reduced_sum <= k
    
    left, right = 0, n - 1
    while left < right:
        mid = (left + right) // 2
        if can_reduce_with_m_elements(mid):
            right = mid
        else:
            left = mid + 1
    
    m = left
    if m == 0:
        return prefix_sum[-1] - k
    
    reduced_sum = prefix_sum[n - m - 1] + arr[0] * m
    steps = m - 1  # Setting the last m elements to arr[0]
    remaining_sum = reduced_sum - k
    
    if remaining_sum > 0:
        steps += remaining_sum // (arr[0] - arr[n - m - 1])
        if remaining_sum % (arr[0] - arr[n - m - 1]) != 0:
            steps += 1
    
    return steps

# Input reading
import sys
input = sys.stdin.read
data = input().split()

index = 0
t = int(data[index])
index += 1
results = []

for _ in range(t):
    n = int(data[index])
    k = int(data[index + 1])
    index += 2
    arr = list(map(int, data[index:index + n]))
    index += n
    results.append(min_steps_to_reduce_sum(arr, n, k))

# Output results
for result in results:
    print(result)