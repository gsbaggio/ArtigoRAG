CURRENT QUESTION:
You are given an array of integers a of length n. The elements of the array can be either different or the same. 

Each element of the array is colored either blue or red. There are no unpainted elements in the array. One of the two operations described below can be applied to an array in a single step:

  * either you can select any blue element and decrease its value by 1; 
  * or you can select any red element and increase its value by 1. 



Situations in which there are no elements of some color at all are also possible. For example, if the whole array is colored blue or red, one of the operations becomes unavailable.

Determine whether it is possible to make 0 or more steps such that the resulting array is a permutation of numbers from 1 to n?

In other words, check whether there exists a sequence of steps (possibly empty) such that after applying it, the array a contains in some order all numbers from 1 to n (inclusive), each exactly once.

Input

The first line contains an integer t (1 ≤ t ≤ 10^4) — the number of input data sets in the test.

The description of each set of input data consists of three lines. The first line contains an integer n (1 ≤ n ≤ 2 ⋅ 10^5) — the length of the original array a. The second line contains n integers a_1, a_2, ..., a_n (-10^9 ≤ a_i ≤ 10^9) — the array elements themselves.

The third line has length n and consists exclusively of the letters 'B' and/or 'R': ith character is 'B' if a_i is colored blue, and is 'R' if colored red.

It is guaranteed that the sum of n over all input sets does not exceed 2 ⋅ 10^5.

Output

Print t lines, each of which contains the answer to the corresponding test case of the input. Print YES as an answer if the corresponding array can be transformed into a permutation, and NO otherwise.

You can print the answer in any case (for example, the strings yEs, yes, Yes, and YES will be recognized as a positive answer).

Example

Input


8
4
1 2 5 2
BRBR
2
1 1
BB
5
3 1 4 2 5
RBRRB
5
3 1 3 1 3
RBRRB
5
5 1 5 1 5
RBRRB
4
2 2 2 2
BRBR
2
1 -2
BR
4
-2 -1 4 0
RRRR


Output


YES
NO
YES
YES
NO
YES
YES
YES

Note

In the first test case of the example, the following sequence of moves can be performed:

  * choose i=3, element a_3=5 is blue, so we decrease it, we get a=[1,2,4,2]; 
  * choose i=2, element a_2=2 is red, so we increase it, we get a=[1,3,4,2]; 
  * choose i=3, element a_3=4 is blue, so we decrease it, we get a=[1,3,3,2]; 
  * choose i=2, element a_2=2 is red, so we increase it, we get a=[1,4,3,2]. 



We got that a is a permutation. Hence the answer is YES.

EXAMPLE QUESTIONS:
Example question 1:
Name: 847_A. Union of Doubly Linked Lists
Tags: ['implementation']
Description: Doubly linked list is one of the fundamental data structures. A doubly linked list is a sequence of elements, each containing information about the previous and the next elements of the list. In this problem all lists have linear structure. I.e. each element except the first has exactly one previous element, each element except the last has exactly one next element. The list is not closed in a cycle.

In this problem you are given n memory cells forming one or more doubly linked lists. Each cell contains information about element from some list. Memory cells are numbered from 1 to n.

For each cell i you are given two values: 

  * li — cell containing previous element for the element in the cell i; 
  * ri — cell containing next element for the element in the cell i. 



If cell i contains information about the element which has no previous element then li = 0. Similarly, if cell i contains information about the element which has no next element then ri = 0.

<image> Three lists are shown on the picture.

For example, for the picture above the values of l and r are the following: l1 = 4, r1 = 7; l2 = 5, r2 = 0; l3 = 0, r3 = 0; l4 = 6, r4 = 1; l5 = 0, r5 = 2; l6 = 0, r6 = 4; l7 = 1, r7 = 0.

Your task is to unite all given lists in a single list, joining them to each other in any order. In particular, if the input data already contains a single list, then there is no need to perform any actions. Print the resulting list in the form of values li, ri.

Any other action, other than joining the beginning of one list to the end of another, can not be performed.

Input

The first line contains a single integer n (1 ≤ n ≤ 100) — the number of memory cells where the doubly linked lists are located.

Each of the following n lines contains two integers li, ri (0 ≤ li, ri ≤ n) — the cells of the previous and the next element of list for cell i. Value li = 0 if element in cell i has no previous element in its list. Value ri = 0 if element in cell i has no next element in its list.

It is guaranteed that the input contains the correct description of a single or more doubly linked lists. All lists have linear structure: each element of list except the first has exactly one previous element; each element of list except the last has exactly one next element. Each memory cell contains information about one element from some list, each element of each list written in one of n given cells.

Output

Print n lines, the i-th line must contain two integers li and ri — the cells of the previous and the next element of list for cell i after all lists from the input are united in a single list. If there are many solutions print any of them.

Example

Input

7
4 7
5 0
0 0
6 1
0 2
0 4
1 0


Output

4 7
5 6
0 5
6 1
3 2
2 4
1 0
Difficulty: 7
Solutions: n=input()

l=[0]
r=[0]

for i in range(n):
    a=map(int,raw_input().split())
    l=l+[a[0]]
    r=r+[a[1]]
b=[]
c=[1]*(n+1)
e=[]
for i in range(1,1+n):
    if c[i]!=0:
        j=l[i]
        c[j]=0
        d=[i]
        while j!=0:
            c[j]=0
            d=[j]+d
            j=l[j]
        
        k=r[i]
        c[k]=0
        
        while k!=0:
             c[k]=0
             d=d+[k]
             k=r[k]
 
        e=d+e
f=[0]*(n+1)
if len(e)>=2:
    f[e[0]]=[0,e[1]]
    f[e[-1]]=[e[-2],0]
    for i in range(1,len(e)-1):
        f[e[i]]=[e[i-1],e[i+1]]

    for j in range(1,len(f)):
        print f[j][0],f[j][1]

else:
    print a[0],a[1]


Example question 2:
Name: 737_E. Tanya is 5!
Tags: ['graph matchings', 'graphs', 'greedy', 'schedules']
Description: Tanya is now five so all her friends gathered together to celebrate her birthday. There are n children on the celebration, including Tanya.

The celebration is close to its end, and the last planned attraction is gaming machines. There are m machines in the hall, they are numbered 1 through m. Each of the children has a list of machines he wants to play on. Moreover, for each of the machines he knows the exact time he wants to play on it. For every machine, no more than one child can play on this machine at the same time.

It is evening already, so every adult wants to go home. To speed up the process, you can additionally rent second copies of each of the machines. To rent the second copy of the j-th machine, you have to pay pj burles. After you rent a machine, you can use it for as long as you want.

How long it will take to make every child play according to his plan, if you have a budget of b burles for renting additional machines? There is only one copy of each machine, so it's impossible to rent a third machine of the same type.

The children can interrupt the game in any moment and continue it later. If the i-th child wants to play on the j-th machine, it is allowed after you rent the copy of the j-th machine that this child would play some part of the time on the j-th machine and some part of the time on its copy (each of these parts could be empty). The interruptions and changes take no time and can be performed in any integer moment of time. Of course, a child can't play on more than one machine at the same time.

Remember, that it is not needed to save money (no one saves money at the expense of children happiness!), it is needed to minimize the latest moment of time some child ends his game.

Input

The first line contains three integers n, m and b (1 ≤ n ≤ 40, 1 ≤ m ≤ 10, 0 ≤ b ≤ 106) — the number of children, the number of gaming machines and the budget for renting additional machines.

The second line contains m integers p1, p2, ..., pm (1 ≤ pj ≤ 106), where pj is the rent price for the second copy of the j-th machine.

n lines follow, i-th of them describes the wishes of the i-th child. The line starts with an integer ki (0 ≤ ki ≤ m) — the number of machines, the i-th child wants to play on. Then there are ki pairs in the line, the y-th of them is xiy, tiy. It means that, the i-th child wants to play tiy (1 ≤ tiy ≤ 2500) minutes on the xiy-th (1 ≤ xiy ≤ m) machine. In each of these n lines the values xiy are distinct.

Output

In the first line print the minimum time in which all the children can finish their games.

In the second line print a string of length m consisting of zeros and ones. The j-th character is '1', if the copy of j-th machine should be rated, and '0' otherwise.

In the third line print integer g (0 ≤ g ≤ 106) — the total number of time segments of continuous playing for all of the children. Then in g lines print the segments as four integers i, j, s, d, meaning that the i-th child was playing on the j-th machine or its copy from the time moment s (s ≥ 0) for d minutes (d ≥ 1). You can print these lines in arbitrary order.

If there are multiple answers, print any of them.

Examples

Input

2 2 100
3 7
2 1 3 2 1
2 1 3 2 1


Output

4
10
8
1 1 0 1
2 2 0 1
1 1 1 1
2 1 1 1
2 1 2 1
1 1 2 1
1 2 3 1
2 1 3 1


Input

3 2 15
11 7
2 2 10 1 5
1 2 20
2 1 4 2 3


Output

20
01
17
2 2 0 4
2 2 4 1
1 1 5 2
2 2 5 2
1 2 7 5
2 2 7 5
2 2 12 1
1 2 12 1
3 1 13 4
2 2 13 4
1 2 13 4
1 1 17 2
3 2 17 2
2 2 17 2
1 1 19 1
2 2 19 1
3 2 19 1
Difficulty: 11
Solutions: #include <bits/stdc++.h>
using namespace std;
const int N = 70;
int gi() {
  int x = 0, o = 1;
  char ch = getchar();
  while (!isdigit(ch) && ch != '-') ch = getchar();
  if (ch == '-') o = -1, ch = getchar();
  while (isdigit(ch)) x = x * 10 + ch - '0', ch = getchar();
  return x * o;
}
struct dat {
  int i, j, s, d;
};
int mat_r[N], mat_l[N], n, m, b, id[N], sx[N], sy[N], p[N], w[N][N];
bool dup[N], vis[N];
vector<dat> opt;
bool find(int u) {
  for (int v = 1; v <= n + m; v++)
    if (w[u][v] > 0 && !vis[v]) {
      vis[v] = 1;
      if (!mat_r[v] || find(mat_r[v])) {
        mat_r[v] = u;
        return 1;
      }
    }
  return 0;
}
bool cmp(int a, int b) { return sy[a] < sy[b]; }
int main() {
  cin >> n >> m >> b;
  for (int i = 1; i <= m; i++) p[i] = gi();
  for (int i = 1; i <= n; i++) {
    int k = gi();
    while (k--) {
      int id = gi(), t = gi();
      w[i][id] = t;
      sx[i] += t;
      sy[id] += t;
    }
  }
  for (int i = 1; i <= m; i++) id[i] = i;
  sort(id + 1, id + m + 1, cmp);
  int pref = 0;
  for (int i = m; i; i--) {
    if (b >= p[id[i]])
      b -= p[id[i]], dup[id[i]] = 1;
    else {
      pref = i;
      break;
    }
  }
  int ans = 0;
  for (int i = 1; i <= n; i++) ans = max(ans, sx[i]);
  for (int i = 1; i <= pref; i++) ans = max(ans, sy[id[i]]);
  for (int i = pref + 1; i <= m; i++) ans = max(ans, (sy[id[i]] + 1) / 2);
  cout << ans << '\n';
  for (int i = 1; i <= m; i++) cout << dup[i];
  cout << '\n';
  for (int i = 1; i <= m; i++)
    if (dup[i]) sy[i] = sy[i + m] = 0;
  for (int i = 1; i <= n; i++)
    for (int j = 1; j <= m; j++)
      if (dup[j]) {
        int tmp = w[i][j];
        w[i][j] = tmp / 2;
        w[i][j + m] = tmp / 2;
        if (tmp & 1) {
          if (sy[j] < sy[j + m])
            ++w[i][j];
          else
            ++w[i][j + m];
        }
        sy[j] += w[i][j];
        sy[j + m] += w[i][j + m];
      }
  m <<= 1;
  for (int i = 1; i <= n; i++) {
    w[i][i + m] = ans - sx[i];
    sx[i] += w[i][i + m];
    sy[i + m] += w[i][i + m];
  }
  for (int i = 1; i <= m; i++) {
    w[i + n][i] = ans - sy[i];
    sx[i + n] += w[i + n][i];
    sy[i] += w[i + n][i];
  }
  for (int i = n + 1; i <= n + m; i++)
    for (int j = m + 1; j <= m + n; j++) {
      w[i][j] = ans - max(sx[i], sy[j]);
      sx[i] += w[i][j];
      sy[j] += w[i][j];
    }
  int now = 0;
  while (now < ans) {
    memset(mat_r, 0, sizeof(mat_r));
    for (int i = 1; i <= n + m; i++) {
      memset(vis, 0, sizeof(vis));
      assert(find(i));
    }
    for (int i = 1; i <= n + m; i++) mat_l[mat_r[i]] = i;
    int mn = 1e9;
    for (int i = 1; i <= n + m; i++) {
      mn = min(mn, w[i][mat_l[i]]);
    }
    for (int i = 1; i <= n + m; i++) {
      if (i <= n && mat_l[i] <= m) opt.push_back((dat){i, mat_l[i], now, mn});
      w[i][mat_l[i]] -= mn;
    }
    now += mn;
  }
  cout << int(opt.size()) << '\n';
  for (auto t : opt)
    cout << t.i << ' ' << (t.j - 1) % (m / 2) + 1 << ' ' << t.s << ' ' << t.d
         << '\n';
  return 0;
}



INSTRUCTIONS:
Solve the current question.
Provide:
1. A complete and efficient code solution, optimized for both time and space complexity.
2. A detailed explanation of the solution, including:
   - The intuition behind the approach;
   - Time and space complexity;
   - Important considerations about the algorithm.
3. If the language has classes, implement in 'Solution' class. Any language is accepted.
4. You can use the example questions as general references for coding patterns and structure, but solve the current problem independently.
5. Don't use any external libraries. Don't need to import any libraries.
