CURRENT QUESTION:
You are given an array of integers a of length n. The elements of the array can be either different or the same. 

Each element of the array is colored either blue or red. There are no unpainted elements in the array. One of the two operations described below can be applied to an array in a single step:

  * either you can select any blue element and decrease its value by 1; 
  * or you can select any red element and increase its value by 1. 



Situations in which there are no elements of some color at all are also possible. For example, if the whole array is colored blue or red, one of the operations becomes unavailable.

Determine whether it is possible to make 0 or more steps such that the resulting array is a permutation of numbers from 1 to n?

In other words, check whether there exists a sequence of steps (possibly empty) such that after applying it, the array a contains in some order all numbers from 1 to n (inclusive), each exactly once.

Input

The first line contains an integer t (1 ≤ t ≤ 10^4) — the number of input data sets in the test.

The description of each set of input data consists of three lines. The first line contains an integer n (1 ≤ n ≤ 2 ⋅ 10^5) — the length of the original array a. The second line contains n integers a_1, a_2, ..., a_n (-10^9 ≤ a_i ≤ 10^9) — the array elements themselves.

The third line has length n and consists exclusively of the letters 'B' and/or 'R': ith character is 'B' if a_i is colored blue, and is 'R' if colored red.

It is guaranteed that the sum of n over all input sets does not exceed 2 ⋅ 10^5.

Output

Print t lines, each of which contains the answer to the corresponding test case of the input. Print YES as an answer if the corresponding array can be transformed into a permutation, and NO otherwise.

You can print the answer in any case (for example, the strings yEs, yes, Yes, and YES will be recognized as a positive answer).

Example

Input


8
4
1 2 5 2
BRBR
2
1 1
BB
5
3 1 4 2 5
RBRRB
5
3 1 3 1 3
RBRRB
5
5 1 5 1 5
RBRRB
4
2 2 2 2
BRBR
2
1 -2
BR
4
-2 -1 4 0
RRRR


Output


YES
NO
YES
YES
NO
YES
YES
YES

Note

In the first test case of the example, the following sequence of moves can be performed:

  * choose i=3, element a_3=5 is blue, so we decrease it, we get a=[1,2,4,2]; 
  * choose i=2, element a_2=2 is red, so we increase it, we get a=[1,3,4,2]; 
  * choose i=3, element a_3=4 is blue, so we decrease it, we get a=[1,3,3,2]; 
  * choose i=2, element a_2=2 is red, so we increase it, we get a=[1,4,3,2]. 



We got that a is a permutation. Hence the answer is YES.

EXAMPLE QUESTIONS:
Example question 1:
Name: 349_B. Color the Fence
Tags: ['data structures', 'dp', 'greedy', 'implementation']
Description: Igor has fallen in love with Tanya. Now Igor wants to show his feelings and write a number on the fence opposite to Tanya's house. Igor thinks that the larger the number is, the more chance to win Tanya's heart he has. 

Unfortunately, Igor could only get v liters of paint. He did the math and concluded that digit d requires ad liters of paint. Besides, Igor heard that Tanya doesn't like zeroes. That's why Igor won't use them in his number.

Help Igor find the maximum number he can write on the fence.

Input

The first line contains a positive integer v (0 ≤ v ≤ 106). The second line contains nine positive integers a1, a2, ..., a9 (1 ≤ ai ≤ 105).

Output

Print the maximum number Igor can write on the fence. If he has too little paint for any digit (so, he cannot write anything), print -1.

Examples

Input

5
5 4 3 2 1 2 3 4 5


Output

55555


Input

2
9 11 1 12 5 8 9 10 6


Output

33


Input

0
1 1 1 1 1 1 1 1 1


Output

-1
Difficulty: 8
Solutions: import java.util.*;
import java.io.*;
public class Main {
    static BufferedReader reader 
		= new BufferedReader(new InputStreamReader(System.in));       
    static StringBuilder out = new StringBuilder();

    public static void main(String[] args){
        int ink = nextInt();
        int[] cost = nextIntArrayFrom1(); // cost[i] is the cost of painting i

        int cheapestDigit = 0;
        int cheapestCost = (int) 1e6;

        for (int i = 1; i <= 9; i++){
            if (cost[i] <= cheapestCost){
                cheapestCost = cost[i];
                cheapestDigit = i;
            }
        }
        if (ink < cheapestCost){
            out.append(-1);
        } else {
            int len = ink / cheapestCost;
            int[] ans = new int[len];
            Arrays.fill(ans, cheapestDigit);
            ink -=  len * cheapestCost;
            for (int i = 0; ink > 0 && i < ans.length; i++){
                for (int candidate = 9; candidate > cheapestDigit; candidate --){
                    if (ink >= cost[candidate] - cheapestCost){
                        ink -= cost[candidate] - cheapestCost;
                        ans[i] = candidate;
                        break;
                    }
                }
            }
            for (int i : ans) out.append(i);
        }


        System.out.println(out);
    }

    // the followings are methods to take care of inputs.
    static int nextInt(){
        return Integer.parseInt(nextLine());
    }
    static long nextLong(){
        return Long.parseLong(nextLine());
    }
    static int[] nextIntArray(){
        String[] inp = nextLine().split("\\s+");
        int[] ary = new int[inp.length]; for (int i = 0; i < ary.length; i++){
            ary[i] = Integer.parseInt(inp[i]);
        }
        return ary;
    }
    static int[] nextIntArrayFrom1(){
        String[] inp = nextLine().split("\\s+");
        int[] ary = new int[inp.length + 1];
        for (int i = 0; i < inp.length; i++){
            ary[i+1] = Integer.parseInt(inp[i]);
        }
        return ary;
    }
    static long[] nextLongArray(){
        String[] inp = nextLine().split("\\s+");
        long[] ary = new long[inp.length];
        for (int i = 0; i < inp.length; i++){
            ary[i] = Long.parseLong(inp[i]);
        }
        return ary;
    }
    static long[] nextLongArrayFrom1(){
        String[] inp = nextLine().split("\\s+");
        long[] ary = new long[inp.length + 1];
        for (int i = 0; i < inp.length; i++){
            ary[i+1] = Long.parseLong(inp[i]);
        }
        return ary;
    }
	static String nextLine(){
		try { 
			return reader.readLine().trim();
		} catch (Exception e){}
		return null;
	}
}




INSTRUCTIONS:
Solve the current question.
Provide:
1. A complete and efficient code solution, optimized for both time and space complexity.
2. A detailed explanation of the solution, including:
   - The intuition behind the approach;
   - Time and space complexity;
   - Important considerations about the algorithm.
3. You can use the example questions as general references for coding patterns and structure, but solve the current problem independently.
4. Don't use any external libraries. Any language is accepted.