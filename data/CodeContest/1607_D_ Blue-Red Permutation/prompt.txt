CURRENT QUESTION:
You are given an array of integers a of length n. The elements of the array can be either different or the same. 

Each element of the array is colored either blue or red. There are no unpainted elements in the array. One of the two operations described below can be applied to an array in a single step:

  * either you can select any blue element and decrease its value by 1; 
  * or you can select any red element and increase its value by 1. 



Situations in which there are no elements of some color at all are also possible. For example, if the whole array is colored blue or red, one of the operations becomes unavailable.

Determine whether it is possible to make 0 or more steps such that the resulting array is a permutation of numbers from 1 to n?

In other words, check whether there exists a sequence of steps (possibly empty) such that after applying it, the array a contains in some order all numbers from 1 to n (inclusive), each exactly once.

Input

The first line contains an integer t (1 ≤ t ≤ 10^4) — the number of input data sets in the test.

The description of each set of input data consists of three lines. The first line contains an integer n (1 ≤ n ≤ 2 ⋅ 10^5) — the length of the original array a. The second line contains n integers a_1, a_2, ..., a_n (-10^9 ≤ a_i ≤ 10^9) — the array elements themselves.

The third line has length n and consists exclusively of the letters 'B' and/or 'R': ith character is 'B' if a_i is colored blue, and is 'R' if colored red.

It is guaranteed that the sum of n over all input sets does not exceed 2 ⋅ 10^5.

Output

Print t lines, each of which contains the answer to the corresponding test case of the input. Print YES as an answer if the corresponding array can be transformed into a permutation, and NO otherwise.

You can print the answer in any case (for example, the strings yEs, yes, Yes, and YES will be recognized as a positive answer).

Example

Input


8
4
1 2 5 2
BRBR
2
1 1
BB
5
3 1 4 2 5
RBRRB
5
3 1 3 1 3
RBRRB
5
5 1 5 1 5
RBRRB
4
2 2 2 2
BRBR
2
1 -2
BR
4
-2 -1 4 0
RRRR


Output


YES
NO
YES
YES
NO
YES
YES
YES

Note

In the first test case of the example, the following sequence of moves can be performed:

  * choose i=3, element a_3=5 is blue, so we decrease it, we get a=[1,2,4,2]; 
  * choose i=2, element a_2=2 is red, so we increase it, we get a=[1,3,4,2]; 
  * choose i=3, element a_3=4 is blue, so we decrease it, we get a=[1,3,3,2]; 
  * choose i=2, element a_2=2 is red, so we increase it, we get a=[1,4,3,2]. 



We got that a is a permutation. Hence the answer is YES.

SIMILAR QUESTIONS:
Similar question 1 (Similarity score: 0.77):
Name: 1375_C. Element Extermination
Tags: ['constructive algorithms', 'data structures', 'greedy']
Description: You are given an array a of length n, which initially is a permutation of numbers from 1 to n. In one operation, you can choose an index i (1 ≤ i < n) such that a_i < a_{i + 1}, and remove either a_i or a_{i + 1} from the array (after the removal, the remaining parts are concatenated). 

For example, if you have the array [1, 3, 2], you can choose i = 1 (since a_1 = 1 < a_2 = 3), then either remove a_1 which gives the new array [3, 2], or remove a_2 which gives the new array [1, 2].

Is it possible to make the length of this array equal to 1 with these operations?

Input

The first line contains a single integer t (1 ≤ t ≤ 2 ⋅ 10^4) — the number of test cases. The description of the test cases follows.

The first line of each test case contains a single integer n (2 ≤ n ≤ 3 ⋅ 10^5) — the length of the array.

The second line of each test case contains n integers a_1, a_2, ..., a_n (1 ≤ a_i ≤ n, a_i are pairwise distinct) — elements of the array.

It is guaranteed that the sum of n over all test cases doesn't exceed 3 ⋅ 10^5.

Output

For each test case, output on a single line the word "YES" if it is possible to reduce the array to a single element using the aforementioned operation, or "NO" if it is impossible to do so.

Example

Input


4
3
1 2 3
4
3 1 2 4
3
2 3 1
6
2 4 6 1 3 5


Output


YES
YES
NO
YES

Note

For the first two test cases and the fourth test case, we can operate as follow (the bolded elements are the pair chosen for that operation):

[1, 2, 3] → [1, 2] → [1]

[3, 1, 2, 4] → [3, 1, 4] → [3, 4] → [4]

[2, 4, 6, 1, 3, 5] → [4, 6, 1, 3, 5] → [4, 1, 3, 5] → [4, 1, 5] → [4, 5] → [4]
Difficulty: 9
Solutions: from sys import stdin
from math import ceil
inp = lambda : stdin.readline().strip()

t = int(inp())

for _ in range(t):
    n = int(inp())
    a = [int(x) for x in inp().split()]
    if a[0]< a[-1]:
        print('YES')
    else:
        print('NO')
        

Similar question 2 (Similarity score: 0.72):
Name: 1102_B. Array K-Coloring
Tags: ['greedy', 'sortings']
Description: You are given an array a consisting of n integer numbers.

You have to color this array in k colors in such a way that: 

  * Each element of the array should be colored in some color; 
  * For each i from 1 to k there should be at least one element colored in the i-th color in the array; 
  * For each i from 1 to k all elements colored in the i-th color should be distinct. 



Obviously, such coloring might be impossible. In this case, print "NO". Otherwise print "YES" and any coloring (i.e. numbers c_1, c_2, ... c_n, where 1 ≤ c_i ≤ k and c_i is the color of the i-th element of the given array) satisfying the conditions above. If there are multiple answers, you can print any.

Input

The first line of the input contains two integers n and k (1 ≤ k ≤ n ≤ 5000) — the length of the array a and the number of colors, respectively.

The second line of the input contains n integers a_1, a_2, ..., a_n (1 ≤ a_i ≤ 5000) — elements of the array a.

Output

If there is no answer, print "NO". Otherwise print "YES" and any coloring (i.e. numbers c_1, c_2, ... c_n, where 1 ≤ c_i ≤ k and c_i is the color of the i-th element of the given array) satisfying the conditions described in the problem statement. If there are multiple answers, you can print any.

Examples

Input


4 2
1 2 2 3


Output


YES
1 1 2 2


Input


5 2
3 2 1 2 3


Output


YES
2 1 1 2 1


Input


5 2
2 1 1 2 1


Output


NO

Note

In the first example the answer 2~ 1~ 2~ 1 is also acceptable.

In the second example the answer 1~ 1~ 1~ 2~ 2 is also acceptable.

There exist other acceptable answers for both examples.
Difficulty: 8
Solutions: import java.io.*;
import java.util.*;
public class div531B
{
	BufferedReader in;
	PrintWriter ob;
	StringTokenizer st;

	public static void main(String[] args) throws IOException {
		new div531B().run();
	}
	void run() throws IOException {
		in=new BufferedReader(new InputStreamReader(System.in));
		ob=new PrintWriter(System.out);
		solve();
		ob.flush();
	}
	void solve() throws IOException {
		int n = ni();
		int k = ni();
		int a[] = new int[n+1];
		int cnt[] = new int[5002];
		int max = 0;
		for(int i=1 ; i<=n ; i++) {
			a[i] = ni();
			++cnt[a[i]];
			max = Math.max( max , cnt[a[i]] );
		}
		if( max > k )
			ob.println("NO");
		else {
			boolean good = true;
			int color = 1;
			int res[] = new int[n+1];
			Arrays.fill( res , -1 );
			for(int i=1 ; i<=n ; i++) {
				if( res[i] == -1 ) {
					for(int j=1 ; j<=n ; j++) {
						if( res[j] == -1 && a[j] == a[i] )
							{
								res[j] = color++;
								if( color == k+1 ) {
									color = 1;
									good = true;
								}
							}
					}
				}
			}
			if( good ){
				ob.println("YES");
				for(int i=1; i<=n ; i++)
				ob.print(res[i]+" ");
			} else {
				ob.println("NO");
			}
			
		}
	}
	String ns() throws IOException {
		return nextToken();
	}
	long nl() throws IOException {
		return Long.parseLong(nextToken());
	}
	int ni() throws IOException {
		return Integer.parseInt(nextToken());
	}
	double nd() throws IOException {
		return Double.parseDouble(nextToken());
	} 
	String nextToken() throws IOException {
		if(st==null || !st.hasMoreTokens())
			st=new StringTokenizer(in.readLine());
		return st.nextToken();
	}
	int[] nia(int start,int b) throws IOException {
		int a[]=new int[b];
		for(int i=start;i<b;i++)
			a[i]=ni();
		return a;
	}
	long[] nla(int start,int n) throws IOException {
		long a[]=new long[n];
		for (int i=start; i<n ;i++ ) {
			a[i]=nl();
		}
		return a;
	}
}

Similar question 3 (Similarity score: 0.71):
Name: 1506_D. Epic Transformation
Tags: ['constructive algorithms', 'data structures', 'greedy']
Description: You are given an array a of length n consisting of integers. You can apply the following operation, consisting of several steps, on the array a zero or more times: 

  * you select two different numbers in the array a_i and a_j; 
  * you remove i-th and j-th elements from the array. 



For example, if n=6 and a=[1, 6, 1, 1, 4, 4], then you can perform the following sequence of operations: 

  * select i=1, j=5. The array a becomes equal to [6, 1, 1, 4]; 
  * select i=1, j=2. The array a becomes equal to [1, 4]. 



What can be the minimum size of the array after applying some sequence of operations to it?

Input

The first line contains a single integer t (1 ≤ t ≤ 10^4). Then t test cases follow.

The first line of each test case contains a single integer n (1 ≤ n ≤ 2 ⋅ 10^5) is length of the array a.

The second line of each test case contains n integers a_1, a_2, …, a_n (1 ≤ a_i ≤ 10^9).

It is guaranteed that the sum of n over all test cases does not exceed 2 ⋅ 10^5.

Output

For each test case, output the minimum possible size of the array after applying some sequence of operations to it.

Example

Input


5
6
1 6 1 1 4 4
2
1 2
2
1 1
5
4 5 4 5 4
6
2 3 2 1 3 1


Output


0
0
2
1
0
Difficulty: 10
Solutions: import sys
input=sys.stdin.readline

t = int(input())
 
for i in range(t):
    n=int(input())
    a=[int(x) for x in input().split()]
    a.sort()
    temp=1

    if n==1:
        print(1)
        continue

    count=[]

    for i in range(1,n):
        if a[i]==a[i-1]:
            temp+=1
            if i==n-1:
                count.append(temp)
        else:
            count.append(temp)
            temp=1
            if i==n-1:
                count.append(temp)

    count.sort()

    if len(count)==1:
        print(count[0])
        continue

    if count[-1]<=sum(count[:len(count)-1]):
        print(n%2)
    else:
        print(count[-1]-sum(count[:len(count)-1]))



INSTRUCTIONS:
Solve the current question.
Provide:
1. A complete and efficient code solution, optimized for both time and space complexity.
2. A detailed explanation of the solution, including:
   - The intuition behind the approach;
   - Time and space complexity;
   - Important considerations about the algorithm.
3. Use the similar questions as references to improve the solution, but only if they are relevant.
4. Don't use any external libraries. Any language is accepted.