CURRENT QUESTION:
There are n heaps of stone. The i-th heap has h_i stones. You want to change the number of stones in the heap by performing the following process once: 

  * You go through the heaps from the 3-rd heap to the n-th heap, in this order. 
  * Let i be the number of the current heap. 
  * You can choose a number d (0 ≤ 3 ⋅ d ≤ h_i), move d stones from the i-th heap to the (i - 1)-th heap, and 2 ⋅ d stones from the i-th heap to the (i - 2)-th heap. 
  * So after that h_i is decreased by 3 ⋅ d, h_{i - 1} is increased by d, and h_{i - 2} is increased by 2 ⋅ d. 
  * You can choose different or same d for different operations. Some heaps may become empty, but they still count as heaps. 



What is the maximum number of stones in the smallest heap after the process?

Input

Each test contains multiple test cases. The first line contains the number of test cases t (1 ≤ t ≤ 2⋅ 10^5). Description of the test cases follows.

The first line of each test case contains a single integer n (3 ≤ n ≤ 2 ⋅ 10^5).

The second lines of each test case contains n integers h_1, h_2, h_3, …, h_n (1 ≤ h_i ≤ 10^9).

It is guaranteed that the sum of n over all test cases does not exceed 2 ⋅ 10^5.

Output

For each test case, print the maximum number of stones that the smallest heap can contain.

Example

Input


4
4
1 2 10 100
4
100 100 100 1
5
5 1 1 1 8
6
1 2 3 4 5 6


Output


7
1
1
3

Note

In the first test case, the initial heap sizes are [1, 2, 10, 100]. We can move the stones as follows. 

  * move 3 stones and 6 from the 3-rd heap to the 2-nd and 1 heap respectively. The heap sizes will be [7, 5, 1, 100]; 
  * move 6 stones and 12 stones from the last heap to the 3-rd and 2-nd heap respectively. The heap sizes will be [7, 17, 7, 82]. 



In the second test case, the last heap is 1, and we can not increase its size.

In the third test case, it is better not to move any stones.

In the last test case, the final achievable configuration of the heaps can be [3, 5, 3, 4, 3, 3].

EXAMPLE QUESTIONS:
Example question 1:
Name: petersen
Tags: []
Description: The following graph G is called a Petersen graph and its vertices have been numbered from 0 to 9. Some letters have also been assigned to vertices of G, as can be seen from the following picture:





	Let's consider a walk W in graph G, which consists of L vertices W1, W2, ..., WL, such that Wi is connected with Wi + 1 for 1 ≤ i < L. A string S of L letters 'A'-'E' is realized by walk W if the sequence of letters written along W is equal to S. Vertices can be visited multiple times while walking along W.

For example, S = 'ABBECCD' is realized by W = (0, 1, 6, 9, 7, 2, 3).
Your task is to determine whether there is a walk W which realizes a given string S in graph G, and if so, find the lexicographically least such walk.

Input

	The first line of the input contains one integer T denoting the number of testcases to process.


	The only line of each testcase contains one string S. It is guaranteed that S only consists of symbols 'A'-'E'.


Output

	The output should contain exactly T lines, one line per each testcase in the order of their appearance. For each testcase, if there is no walk W which realizes S, then output -1. Otherwise, you should output the least lexicographical walk W which realizes S. Since all of the vertices are numbered from 0 to 9, then it can be encoded as a string consisting of symbols '0'-'9' (see the "Examples" section for more details).


Constraints
1 ≤ T ≤ 8;
1 ≤ |S| ≤ 100000(10^5).

Examples
Input:
2
AAB
AABE

Output:
501
-1
Difficulty: 2
Solutions: def digit(c,present):
	if c=='A':
		if present=='i':
			return "5"
		else:
			return "0"
	elif c=='B':
		if present=='i':
			return "6"
		else:
			return "1"
	elif c=='C':
		if present=='i':
			return "7"
		else:
			return "2"
	elif c=='D':
		if present=='i':
			return "8"
		else:
			return "3"
	elif c=='E':
		if present=='i':
			return "9"
		else:
			return "4"									

def ans(s):
	l=len(s)
	present='i'
	count1=0
	ans1=digit(s[0],present)
	for i in xrange(l-1):
		if s[i]=='A':
			if present=='i':
				if s[i+1] in ['A','D','C']:
					if s[i+1]=='A':
						present='o'
					ans1+=digit(s[i+1],present)
					count1+=1
				else:
					break
			else:
				if s[i+1] in ['A','E','B']:
					if s[i+1]=='A':
						present='i'
					ans1+=digit(s[i+1],present)
					count1+=1
				else:
					break
		elif s[i]=='B':
			if present=='i':
				if s[i+1] in ['B','E','D']:
					if s[i+1]=='B':
						present='o'
					ans1+=digit(s[i+1],present)
					count1+=1
				else:
					break
			else:
				if s[i+1] in ['B','A','C']:
					if s[i+1]=='B':
						present='i'
					ans1+=digit(s[i+1],present)
					count1+=1
				else:
					break
		elif s[i]=='C':
			if present=='i':
				if s[i+1] in ['C','A','E']:
					if s[i+1]=='C':
						present='o'
					ans1+=digit(s[i+1],present)
					count1+=1
				else:
					break
			else:
				if s[i+1] in ['C','B','D']:
					if s[i+1]=='C':
						present='i'
					ans1+=digit(s[i+1],present)
					count1+=1
				else:
					break
		elif s[i]=='D':
			if present=='i':
				if s[i+1] in ['D','A','B']:
					if s[i+1]=='D':
						present='o'
					ans1+=digit(s[i+1],present)
					count1+=1
				else:
					break
			else:
				if s[i+1] in ['D','E','C']:
					if s[i+1]=='D':
						present='i'
					ans1+=digit(s[i+1],present)
					count1+=1
				else:
					break
		elif s[i]=='E':
			if present=='i':
				if s[i+1] in ['E','B','C']:
					if s[i+1]=='E':
						present='o'
					ans1+=digit(s[i+1],present)
					count1+=1
				else:
					break
			else:
				if s[i+1] in ['E','A','D']:
					if s[i+1]=='E':
						present='i'
					ans1+=digit(s[i+1],present)
					count1+=1
				else:
					break
	present='o'				
	count2=0
	ans2=digit(s[0],present)				
	for i in xrange(l-1):
		if s[i]=='A':
			if present=='i':
				if s[i+1] in ['A','D','C']:
					if s[i+1]=='A':
						present='o'
					ans2+=digit(s[i+1],present)
					count2+=1
				else:
					break
			else:
				if s[i+1] in ['A','E','B']:
					if s[i+1]=='A':
						present='i'
					ans2+=digit(s[i+1],present)
					count2+=1
				else:
					break
		elif s[i]=='B':
			if present=='i':
				if s[i+1] in ['B','E','D']:
					if s[i+1]=='B':
						present='o'
					ans2+=digit(s[i+1],present)
					count2+=1
				else:
					break
			else:
				if s[i+1] in ['B','A','C']:
					if s[i+1]=='B':
						present='i'
					ans2+=digit(s[i+1],present)
					count2+=1
				else:
					break
		elif s[i]=='C':
			if present=='i':
				if s[i+1] in ['C','A','E']:
					if s[i+1]=='C':
						present='o'
					ans2+=digit(s[i+1],present)
					count2+=1
				else:
					break
			else:
				if s[i+1] in ['C','B','D']:
					if s[i+1]=='C':
						present='i'
					ans2+=digit(s[i+1],present)
					count2+=1
				else:
					break
		elif s[i]=='D':
			if present=='i':
				if s[i+1] in ['D','A','B']:
					if s[i+1]=='D':
						present='o'
					ans2+=digit(s[i+1],present)
					count2+=1
				else:
					break
			else:
				if s[i+1] in ['D','E','C']:
					if s[i+1]=='D':
						present='i'
					ans2+=digit(s[i+1],present)
					count2+=1
				else:
					break
		elif s[i]=='E':
			if present=='i':
				if s[i+1] in ['E','B','C']:
					if s[i+1]=='E':
						present='o'
					ans2+=digit(s[i+1],present)
					count2+=1
				else:
					break
			else:
				if s[i+1] in ['E','A','D']:
					if s[i+1]=='E':
						present='i'
					ans2+=digit(s[i+1],present)
					count2+=1
				else:
					break
	if count1!=l-1 and count2!=l-1:
		return "-1"
	elif count1==l-1 and count2==l-1:
		return min(ans1,ans2)
	elif count1==l-1:
		return ans1
	return ans2			
t=input()
for test in xrange(t):
	s=raw_input()
	print ans(s)


INSTRUCTIONS:
Solve the current question.
Provide:
1. A complete and efficient code solution, optimized for both time and space complexity.
2. A detailed explanation of the solution, including:
   - The intuition behind the approach;
   - Time and space complexity;
   - Important considerations about the algorithm.
3. If the language has classes, implement in 'Solution' class. Any language is accepted.
4. You can use the example questions as general references for coding patterns and structure, but solve the current problem independently.
5. Don't use any external libraries. Don't need to import any libraries.
