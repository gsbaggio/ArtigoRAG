CURRENT QUESTION:
Monocarp has got an array a consisting of n integers. Let's denote k as the mathematic mean of these elements (note that it's possible that k is not an integer). 

The mathematic mean of an array of n elements is the sum of elements divided by the number of these elements (i. e. sum divided by n).

Monocarp wants to delete exactly two elements from a so that the mathematic mean of the remaining (n - 2) elements is still equal to k.

Your task is to calculate the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a).

Input

The first line contains a single integer t (1 ≤ t ≤ 10^4) — the number of testcases.

The first line of each testcase contains one integer n (3 ≤ n ≤ 2 ⋅ 10^5) — the number of elements in the array.

The second line contains a sequence of integers a_1, a_2, ..., a_n (0 ≤ a_i ≤ 10^{9}), where a_i is the i-th element of the array.

The sum of n over all testcases doesn't exceed 2 ⋅ 10^5.

Output

Print one integer — the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a).

Example

Input


4
4
8 8 8 8
3
50 20 10
5
1 4 7 3 5
7
1 2 3 4 5 6 7


Output


6
0
2
3

Note

In the first example, any pair of elements can be removed since all of them are equal.

In the second example, there is no way to delete two elements so the mathematic mean doesn't change.

In the third example, it is possible to delete the elements on positions 1 and 3, or the elements on positions 4 and 5.

EXAMPLE QUESTIONS:
Example question 1:
Name: 91_B. Queue
Tags: ['binary search', 'data structures']
Description: There are n walruses standing in a queue in an airport. They are numbered starting from the queue's tail: the 1-st walrus stands at the end of the queue and the n-th walrus stands at the beginning of the queue. The i-th walrus has the age equal to ai.

The i-th walrus becomes displeased if there's a younger walrus standing in front of him, that is, if exists such j (i < j), that ai > aj. The displeasure of the i-th walrus is equal to the number of walruses between him and the furthest walrus ahead of him, which is younger than the i-th one. That is, the further that young walrus stands from him, the stronger the displeasure is.

The airport manager asked you to count for each of n walruses in the queue his displeasure.

Input

The first line contains an integer n (2 ≤ n ≤ 105) — the number of walruses in the queue. The second line contains integers ai (1 ≤ ai ≤ 109).

Note that some walruses can have the same age but for the displeasure to emerge the walrus that is closer to the head of the queue needs to be strictly younger than the other one.

Output

Print n numbers: if the i-th walrus is pleased with everything, print "-1" (without the quotes). Otherwise, print the i-th walrus's displeasure: the number of other walruses that stand between him and the furthest from him younger walrus.

Examples

Input

6
10 8 5 3 50 45


Output

2 1 0 -1 0 -1 

Input

7
10 4 6 3 2 8 15


Output

4 2 1 0 -1 -1 -1 

Input

5
10 3 1 10 11


Output

1 0 -1 -1 -1 
Difficulty: 8
Solutions: import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.PrintWriter;
import java.util.StringTokenizer;
import java.util.TreeMap;
import java.util.TreeSet;

public class A {
		
	public static void main(String[] args) throws IOException {

		Scanner sc = new Scanner(System.in);
		PrintWriter out = new PrintWriter(System.out);

		int n = sc.nextInt(), a[] = new int[n];
		TreeSet<Integer> set = new TreeSet<>();
		for(int i = 0; i < n; ++i)
			set.add(a[i] = sc.nextInt());
		TreeMap<Integer, Integer> map = new TreeMap<>();
		int idx = 0;
		for(int x: set)
			map.put(x, ++idx);
		for(int i = 0; i < n; ++i)
			a[i] = map.get(a[i]);
		SegmentTree st = new SegmentTree(idx);
		for(int i = n - 1; i >= 0; --i)
		{
			int q = st.query(0, a[i] - 1);
			st.update(a[i], i + 1);
			a[i] = q == 0 ? -1 : q - (i + 2);
		}
		for(int x: a)
			out.print(x + " ");
		out.flush();
		out.close();
	}
	
	static class SegmentTree
	{
		int[] sTree;
		int N;
		
		SegmentTree(int n)
		{
			N = 1; while(N < n) N <<= 1;
			sTree = new int[N<<1];
		}
		
		void update(int idx, int val)
		{
			idx += N - 1;
			if(sTree[idx] != 0)
				return;
			sTree[idx] = val;
			while(idx > 1)
			{
				idx >>= 1;
				sTree[idx] = Math.max(sTree[idx<<1], sTree[idx<<1|1]);
			}
		}
		
		int query(int l, int r) { return query(1, 1, N, l, r); }
		
		int query(int node, int b, int e, int l, int r)
		{
			if(r < b || e < l)
				return 0;
			if(l <= b && e <= r)
				return sTree[node];
			int mid = b + e >> 1;
			return Math.max(query(node<<1, b, mid, l, r), query(node<<1|1, mid + 1, e, l, r));
		}
	}

	static class Scanner 
	{
		StringTokenizer st;
		BufferedReader br;

		public Scanner(InputStream s){  br = new BufferedReader(new InputStreamReader(s));}

		public String next() throws IOException 
		{
			while (st == null || !st.hasMoreTokens()) 
				st = new StringTokenizer(br.readLine());
			return st.nextToken();
		}

		public int nextInt() throws IOException {return Integer.parseInt(next());}

		public long nextLong() throws IOException {return Long.parseLong(next());}

	}
} 


INSTRUCTIONS:
Solve the current question.
Provide:
1. A complete and efficient code solution, optimized for both time and space complexity.
2. A detailed explanation of the solution, including:
   - The intuition behind the approach;
   - Time and space complexity;
   - Important considerations about the algorithm.
3. If the language has classes, implement in 'Solution' class. Any language is accepted.
4. You can use the example questions as general references for coding patterns and structure, but solve the current problem independently.
5. Don't use any external libraries. Don't need to import any libraries.
