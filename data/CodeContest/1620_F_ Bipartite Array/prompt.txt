CURRENT QUESTION:
You are given a permutation p consisting of n integers 1, 2, ..., n (a permutation is an array where each element from 1 to n occurs exactly once).

Let's call an array a bipartite if the following undirected graph is bipartite:

  * the graph consists of n vertices; 
  * two vertices i and j are connected by an edge if i < j and a_i > a_j. 



Your task is to find a bipartite array of integers a of size n, such that a_i = p_i or a_i = -p_i, or report that no such array exists. If there are multiple answers, print any of them.

Input

The first line contains a single integer t (1 ≤ t ≤ 2 ⋅ 10^5) — the number of test cases.

The first line of each test case contains a single integer n (1 ≤ n ≤ 10^6) — the size of the permutation.

The second line contains n integers p_1, p_2, ..., p_n.

The sum of n over all test cases doesn't exceed 10^6.

Output

For each test case, print the answer in the following format. If such an array a does not exist, print "NO" in a single line. Otherwise, print "YES" in the first line and n integers — array a in the second line.

Example

Input


4
3
1 2 3
6
1 3 2 6 5 4
4
4 1 3 2
8
3 2 1 6 7 8 5 4


Output


YES
1 2 3
NO
YES
-4 -1 -3 -2
YES
-3 -2 1 6 7 -8 -5 -4

SIMILAR QUESTIONS:
Similar question 1 (Similarity score: 0.75):
Name: 1454_A. Special Permutation
Tags: ['constructive algorithms', 'probabilities']
Description: You are given one integer n (n > 1).

Recall that a permutation of length n is an array consisting of n distinct integers from 1 to n in arbitrary order. For example, [2, 3, 1, 5, 4] is a permutation of length 5, but [1, 2, 2] is not a permutation (2 appears twice in the array) and [1, 3, 4] is also not a permutation (n = 3 but there is 4 in the array).

Your task is to find a permutation p of length n that there is no index i (1 ≤ i ≤ n) such that p_i = i (so, for all i from 1 to n the condition p_i ≠ i should be satisfied).

You have to answer t independent test cases.

If there are several answers, you can print any. It can be proven that the answer exists for each n > 1.

Input

The first line of the input contains one integer t (1 ≤ t ≤ 100) — the number of test cases. Then t test cases follow.

The only line of the test case contains one integer n (2 ≤ n ≤ 100) — the length of the permutation you have to find.

Output

For each test case, print n distinct integers p_1, p_2, …, p_n — a permutation that there is no index i (1 ≤ i ≤ n) such that p_i = i (so, for all i from 1 to n the condition p_i ≠ i should be satisfied).

If there are several answers, you can print any. It can be proven that the answer exists for each n > 1.

Example

Input


2
2
5


Output


2 1
2 1 5 3 4
Difficulty: 7
Solutions: def lip(): return list(map(int,input().split()))
def splip(): return map(int,input().split())
def intip(): return int(input())


for _ in range(intip()):
    n = intip()
    l = [i for i in range(1,n+1)]
    l = l[::-1]
    mid = n//2
    if n==2:
        print(*l)
    elif n%2!=0:
        l[mid] , l[mid-1] = l[mid-1],l[mid]
        print(*l)
    else:
        l[mid+1] , l[mid] = l[mid],l[mid+1]
        print(*l)

Similar question 2 (Similarity score: 0.72):
Name: 1541_B. Pleasant Pairs
Tags: ['brute force', 'implementation', 'math', 'number theory']
Description: You are given an array a_1, a_2, ..., a_n consisting of n distinct integers. Count the number of pairs of indices (i, j) such that i < j and a_i ⋅ a_j = i + j.

Input

The first line contains one integer t (1 ≤ t ≤ 10^4) — the number of test cases. Then t cases follow.

The first line of each test case contains one integer n (2 ≤ n ≤ 10^5) — the length of array a.

The second line of each test case contains n space separated integers a_1, a_2, …, a_n (1 ≤ a_i ≤ 2 ⋅ n) — the array a. It is guaranteed that all elements are distinct.

It is guaranteed that the sum of n over all test cases does not exceed 2 ⋅ 10^5.

Output

For each test case, output the number of pairs of indices (i, j) such that i < j and a_i ⋅ a_j = i + j.

Example

Input


3
2
3 1
3
6 1 5
5
3 1 5 9 2


Output


1
1
3

Note

For the first test case, the only pair that satisfies the constraints is (1, 2), as a_1 ⋅ a_2 = 1 + 2 = 3

For the second test case, the only pair that satisfies the constraints is (2, 3).

For the third test case, the pairs that satisfy the constraints are (1, 2), (1, 5), and (2, 3).
Difficulty: 8
Solutions: #include<bits/stdc++.h>
#define ll long long
#define pb push_back
#define fi first
#define se second
#define maxn 200005
#define inf 1e9
#define maxi LONG_LONG_MAX
#define mini LONG_LONG_MIN
#define sz(x) (x).size()
#define ed(x) (x).end()
#define contains(v,i) (v.find(i)!=v.end())
#define grt_sort(x) sort(x.begin(),x.end(),greater<>())
#define pll pair<ll,ll>
#define flash ios_base::sync_with_stdio(false);cin.tie(NULL);

using namespace std;

int main()
{
    flash

    ll t;
    cin>>t;

    while(t--){
      ll n;
      cin>>n;

      vector<pll> v;

      for(ll i=0;i<n;i++){
        ll x;
        cin>>x;
        v.pb({x,i+1});
      }

      sort(v.begin(),v.end());
      ll cnt=0;

      for(ll i=n-1;i>=0;i--){
        for(ll j=0;j<i;j++){
          if((v[i].first * v[j].first)>(2*n-1))
            break;

          if((v[i].first * v[j].first)==(v[i].second+v[j].second))
              cnt++;
        }
      }

      cout<<cnt<<"\n";
    }
}


Similar question 3 (Similarity score: 0.71):
Name: 1520_D. Same Differences
Tags: ['data structures', 'hashing', 'math']
Description: You are given an array a of n integers. Count the number of pairs of indices (i, j) such that i < j and a_j - a_i = j - i.

Input

The first line contains one integer t (1 ≤ t ≤ 10^4). Then t test cases follow.

The first line of each test case contains one integer n (1 ≤ n ≤ 2 ⋅ 10^5).

The second line of each test case contains n integers a_1, a_2, …, a_n (1 ≤ a_i ≤ n) — array a.

It is guaranteed that the sum of n over all test cases does not exceed 2 ⋅ 10^5.

Output

For each test case output the number of pairs of indices (i, j) such that i < j and a_j - a_i = j - i.

Example

Input


4
6
3 5 1 4 6 6
3
1 2 3
4
1 3 3 4
6
1 6 3 4 5 6


Output


1
3
3
10
Difficulty: 10
Solutions: import java.util.*;
import java.io.*;
public class D {
    public static void main(String args[])throws IOException{
        FastReader sc = new FastReader();
        PrintWriter out = new PrintWriter(System.out);
        int  t = sc.nextInt();
        while(t-- > 0){
			int n = sc.nextInt();
			int arr[] = new int[n];
			for(int i = 0; i < n; i++) {
				arr[i] = sc.nextInt();
				arr[i] = arr[i] - i - 1;
			}
			countFreq(arr, n);
			// long ans = 0;
			// long count = 1;
			// for(int i = 2; i <= n; i++) {
			// 	if(arr[i] == arr[i-1]) {
			// 		count++;
			// 	}
			// 	else {
			// 		ans += (count*(count-1))/2;
			// 		count = 1;
			// 	}
			// }
			// if(count > 1) {
			// 	ans += (count*(count-1))/2;
			// }
			// out.println(ans);
			// for(int i = 1; i <= n; i++) {
			// 	out.print(arr[i] + " ");
			// }
			// out.println();
        }
        out.flush();
    }

	static void countFreq(int arr[], int n)
    {
        HashMap<Integer, Integer> mp = new HashMap<Integer, Integer>();
  
        // Traverse through array elements and
        // count frequencies
        for (int i = 0; i < n; i++)
        {
            if (mp.containsKey(arr[i])) 
            {
                mp.put(arr[i], mp.get(arr[i]) + 1);
            } 
            else
            {
                mp.put(arr[i], 1);
            }
        }
        // Traverse through map and print frequencies
		long ans = 0;
        for (Map.Entry<Integer, Integer> entry : mp.entrySet())
        {
            // System.out.println(entry.getKey() + " " + entry.getValue());
			ans += (entry.getValue()*(long)(entry.getValue()-1))/2;
        }
		System.out.println(ans);
    }

    static class FastReader {
		BufferedReader br;
		StringTokenizer st;

		public FastReader()
		{
			br = new BufferedReader(new InputStreamReader(System.in));
		}

		String next()
		{
			while (st == null || !st.hasMoreElements()) {
				try {
					st = new StringTokenizer(br.readLine());
				}
				catch (IOException e) {
					e.printStackTrace();
				}
			}
			return st.nextToken();
		}

		int nextInt() { return Integer.parseInt(next()); }

		long nextLong() { return Long.parseLong(next()); }

		double nextDouble()
		{
			return Double.parseDouble(next());
		}

		String nextLine()
		{
			String str = "";
			try {
				str = br.readLine();
			}
			catch (IOException e) {
				e.printStackTrace();
			}
			return str;
		}
	}
}


INSTRUCTIONS:
Solve the current question.
Provide:
1. A complete and efficient code solution, optimized for both time and space complexity.
2. A detailed explanation of the solution, including:
   - The intuition behind the approach;
   - Time and space complexity;
   - Important considerations about the algorithm.
3. Use the similar questions as references to improve the solution, but only if they are relevant.
4. Don't use any external libraries. Any language is accepted.