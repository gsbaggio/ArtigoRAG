CURRENT QUESTION:
You are given a permutation p consisting of n integers 1, 2, ..., n (a permutation is an array where each element from 1 to n occurs exactly once).

Let's call an array a bipartite if the following undirected graph is bipartite:

  * the graph consists of n vertices; 
  * two vertices i and j are connected by an edge if i < j and a_i > a_j. 



Your task is to find a bipartite array of integers a of size n, such that a_i = p_i or a_i = -p_i, or report that no such array exists. If there are multiple answers, print any of them.

Input

The first line contains a single integer t (1 ≤ t ≤ 2 ⋅ 10^5) — the number of test cases.

The first line of each test case contains a single integer n (1 ≤ n ≤ 10^6) — the size of the permutation.

The second line contains n integers p_1, p_2, ..., p_n.

The sum of n over all test cases doesn't exceed 10^6.

Output

For each test case, print the answer in the following format. If such an array a does not exist, print "NO" in a single line. Otherwise, print "YES" in the first line and n integers — array a in the second line.

Example

Input


4
3
1 2 3
6
1 3 2 6 5 4
4
4 1 3 2
8
3 2 1 6 7 8 5 4


Output


YES
1 2 3
NO
YES
-4 -1 -3 -2
YES
-3 -2 1 6 7 -8 -5 -4

EXAMPLE QUESTIONS:
Example question 1:
Name: p00670 Spellcasters
Tags: ['']
Description: There are n wizards. They are numbered from 1 to n, and the i-th wizard has the magical power ri (1 ≤ i ≤ n). Now they are confronting a powerful wizard, whose enemy's magical power is S. n Wizards are good at fighting together, especially two people. When two wizards cooperate, the magical power is simply the sum, and you can use powerful magic to beat enemies that are strong to some extent. Your job is to output the total number of wizard pairs (i, j) (i ≠ j and 1 ≤ i ≤ n and 1 ≤ j ≤ n) that can win against enemies with magical power S. However, (i, j) and (j, i) are counted as the same pair. When one magical power is greater than the other, the side with the greater magical power wins. If they are equal, it does not mean that they have won by trade-off.

Constraints

* All inputs are integers
* 1 ≤ n ≤ 20,000
* 1 ≤ ri ≤ 100 (1 ≤ i ≤ n)
* 1 ≤ S ≤ 100
* The number of test cases does not exceed 100.

Input

The input consists of multiple test cases. Each test case follows the format below.


n S
r1
r2
...
rn


The meaning of each variable is as in the problem statement. The end of the input is indicated by a line where two 0s are separated by a single space.

Output

Output the total number of pairs (i, j) (i ≠ j) that satisfy the conditions on one line for each case.

Example

Input

3 7
1
3
10
0 0


Output

2
Difficulty: 0
Solutions: #include <iostream>
using namespace std;

int main () {
	int n, s;
	while (cin >> n >> s, n || s) {
		int r[n];
		for (int i = 0; i < n; i++) {
			cin >> r[i];
		}
		int count = 0;
		for (int i = 0; i < n; i++) {
			for (int j = i + 1; j < n; j++) {
				if (r[i] + r[j] > s) {
					count++;
				}
			}
		}
		cout << count << endl;
	}
	return 0;
}

Example question 2:
Name: p02999 AtCoder Beginner Contest 130 - Rounding
Tags: ['']
Description: X and A are integers between 0 and 9 (inclusive).

If X is less than A, print 0; if X is not less than A, print 10.

Constraints

* 0 \leq X, A \leq 9
* All values in input are integers.

Input

Input is given from Standard Input in the following format:


X A


Output

If X is less than A, print 0; if X is not less than A, print 10.

Examples

Input

3 5


Output

0


Input

7 5


Output

10


Input

6 6


Output

10
Difficulty: 0
Solutions: import java.util.*;
import java.util.stream.*;

public class Main {

  public static void main(String[] args) {
    Scanner in = new Scanner(System.in);
    System.out.println(in.nextInt() < in.nextInt() ? 0 : 10);
  }
}



INSTRUCTIONS:
Solve the current question.
Provide:
1. A complete and efficient code solution, optimized for both time and space complexity.
2. A detailed explanation of the solution, including:
   - The intuition behind the approach;
   - Time and space complexity;
   - Important considerations about the algorithm.
3. If the language has classes, implement in 'Solution' class. Any language is accepted.
4. You can use the example questions as general references for coding patterns and structure, but solve the current problem independently.
5. Don't use any external libraries. Don't need to import any libraries.
