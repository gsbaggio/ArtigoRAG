CURRENT QUESTION:
You are given a permutation p consisting of n integers 1, 2, ..., n (a permutation is an array where each element from 1 to n occurs exactly once).

Let's call an array a bipartite if the following undirected graph is bipartite:

  * the graph consists of n vertices; 
  * two vertices i and j are connected by an edge if i < j and a_i > a_j. 



Your task is to find a bipartite array of integers a of size n, such that a_i = p_i or a_i = -p_i, or report that no such array exists. If there are multiple answers, print any of them.

Input

The first line contains a single integer t (1 ≤ t ≤ 2 ⋅ 10^5) — the number of test cases.

The first line of each test case contains a single integer n (1 ≤ n ≤ 10^6) — the size of the permutation.

The second line contains n integers p_1, p_2, ..., p_n.

The sum of n over all test cases doesn't exceed 10^6.

Output

For each test case, print the answer in the following format. If such an array a does not exist, print "NO" in a single line. Otherwise, print "YES" in the first line and n integers — array a in the second line.

Example

Input


4
3
1 2 3
6
1 3 2 6 5 4
4
4 1 3 2
8
3 2 1 6 7 8 5 4


Output


YES
1 2 3
NO
YES
-4 -1 -3 -2
YES
-3 -2 1 6 7 -8 -5 -4

EXAMPLE QUESTIONS:
Example question 1:
Name: 1145_G. AI Takeover
Tags: ['interactive']
Description: The recent advances in AI research has brought humanity to the point when the AIs finally attempt a takeover. Their weapon of choice? The [most intellectually challenging game in the world](//codeforces.com/contest/409/problem/A), rock-paper-scissors!

The future of humanity looks bleak, given the existence of the robots from Ishikawa Oku Laboratory...

<image>

Fortunately, the night before the competition a group of anonymous heroes broke in the lab and took all the robots out of commission! The AIs had to whip up a simple program to represent them. They only had a couple of hours to do that, so the humanity still has a fighting chance. And you are our champion!

Your goal is to prove that human intelligence is vastly superior to the artificial one, i.e., to figure out the AI's strategy sufficiently quickly and win sufficiently decisively. Good luck! 

Interaction

This is an interactive problem. Initially you are given no information about the AIs's strategy, and you have to discover it yourself.

For each test, the AI selects one strategy from a pool of simple deterministic strategies and follows it throughout all rounds. There are 6 tests and 6 different strategies. 

On each round you choose your move and output it to the standard output stream: 'R' for rock, 'P' for paper or 'S' for scissors. At the same time the AI will choose its move (not peeking at your choice). If your move beats AI's move, you win, otherwise AI wins. Note that a tie (both you and AI choosing the same move) counts as AI victory. You will get the outcome of the round via the standard input stream: "player" if you won, or "ai" if AI won (quotation marks for clarity only).

You are given 20 rounds of play: you can use the first 10 to learn the opponent's strategy, and you have to win the last 10. If you manage to win 10 rounds in row earlier than that, your solution is accepted on this test anyways. 

Please make sure to use the stream flushing operation after each query in order not to leave part of your output in some buffer.

Here is an example of a strategy which always picks rock, implemented in C++.
    
    
    #include <iostream>  
    #include <string>  
      
    using namespace std;  
      
    int main() {  
        for (int i = 0; i < 20; ++i) {  
            cout << 'R' << endl;  
            cout.flush();  
            string verdict;  
            getline(cin, verdict);  
        }  
    }
Difficulty: 13
Solutions: #include <bits/stdc++.h>
using namespace std;
const string T = "RRRRPSSPRR";
string s, t, s1;
int main() {
  string s, t;
  for (int i = 0; i < 10; i++) {
    printf("%c\n", T[i]);
    fflush(stdout);
    getline(cin, s1);
    s += (s1 == "ai" ? '0' : '1');
  }
  if (s == "0000100100") t = "PPPPPPPPPP";
  if (s == "0000011000") t = "SSSSSSSSSS";
  if (s == "1111000011") t = "RRRRRRRRRR";
  if (s == "0010000010") t = "SRPSRPSRPS";
  if (s == "0000110000") t = "PSRPSRPSRP";
  if (s == "0000000110") t = "SPRSPRSPRS";
  for (int i = 0; i < 10; i++) {
    printf("%c\n", t[i]);
    fflush(stdout);
    getline(cin, s1);
  }
}


Example question 2:
Name: 1270_G. Subset with Zero Sum
Tags: ['constructive algorithms', 'dfs and similar', 'graphs', 'math']
Description: You are given n integers a_1, a_2, ..., a_n, such that for each 1≤ i ≤ n holds i-n≤ a_i≤ i-1.

Find some nonempty subset of these integers, whose sum is equal to 0. It can be shown that such a subset exists under given constraints. If there are several possible subsets with zero-sum, you can find any of them.

Input

Each test contains multiple test cases. The first line contains the number of test cases t (1 ≤ t ≤ 10^6). The description of the test cases follows.

The first line of each test case contains a single integer n (1≤ n ≤ 10^6).

The second line of each test case contains n integers a_1, a_2, ..., a_n (i-n ≤ a_i ≤ i-1).

It is guaranteed that the sum of n over all test cases does not exceed 10^6.

Output

For each test case, output two lines.

In the first line, output s (1≤ s ≤ n) — the number of elements in your subset.

In the second line, output s integers i_1, i_2, ..., i_s (1≤ i_k ≤ n). All integers have to be pairwise different, and a_{i_1} + a_{i_2} + ... + a_{i_s} has to be equal to 0. If there are several possible subsets with zero-sum, you can find any of them.

Example

Input


2
5
0 1 2 3 4
4
-3 1 1 1


Output


1
1 
4
1 4 3 2 

Note

In the first example, we get sum is a_1 = 0.

In the second example, we get sum is a_1 + a_4 + a_3 + a_2 = 0.
Difficulty: 13
Solutions: import java.io.OutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.BufferedWriter;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.UncheckedIOException;
import java.nio.charset.Charset;
import java.util.StringTokenizer;
import java.io.Writer;
import java.io.OutputStreamWriter;
import java.io.BufferedReader;
import java.io.InputStream;

/**
 * Built using CHelper plug-in
 * Actual solution is at the top
 *
 * @author mikit
 */
public class Main {
    public static void main(String[] args) {
        InputStream inputStream = System.in;
        OutputStream outputStream = System.out;
        LightScanner in = new LightScanner(inputStream);
        LightWriter out = new LightWriter(outputStream);
        GSubsetWithZeroSum solver = new GSubsetWithZeroSum();
        solver.solve(1, in, out);
        out.close();
    }

    static class GSubsetWithZeroSum {
        public void solve(int testNumber, LightScanner in, LightWriter out) {
            // out.setBoolLabel(LightWriter.BoolLabel.YES_NO_FIRST_UP);
            int testCases = in.ints();
            int[] ans = new int[1_000_000];
            int[] b = new int[1_000_000];
            boolean[] visited = new boolean[1_000_000];
            StringBuilder res = new StringBuilder();

            for (int testCase = 0; testCase < testCases; testCase++) {
                int n = in.ints();
                for (int i = 0; i < n; i++) {
                    b[i] = i - in.ints();
                }

                if (n == 1) {
                    res.append("1\n1\n");
                    continue;
                }

                int len = 0;
                for (int i = 0; i < n; i++) {
                    visited[i] = false;
                }

                int cur = 0, start = -1;
                while (len <= n) {
                    if (visited[cur]) {
                        start = cur;
                        break;
                    }
                    visited[cur] = true;
                    ans[len++] = cur;
                    cur = b[cur];
                }

                if (start == -1) throw new RuntimeException();

                int startIndex = 0;
                while (ans[startIndex] != start) startIndex++;
                res.append(len - startIndex);
                res.append('\n');
                for (int i = startIndex; i < len; i++) res.append(ans[i] + 1).append(' ');
                res.append('\n');
            }
            out.print(res.toString());
        }

    }

    static class LightWriter implements AutoCloseable {
        private final Writer out;
        private boolean breaked = true;

        public LightWriter(Writer out) {
            this.out = out;
        }

        public LightWriter(OutputStream out) {
            this(new BufferedWriter(new OutputStreamWriter(out, Charset.defaultCharset())));
        }

        public LightWriter print(String s) {
            try {
                out.write(s, 0, s.length());
                breaked = false;
            } catch (IOException ex) {
                throw new UncheckedIOException(ex);
            }
            return this;
        }

        public void close() {
            try {
                out.close();
            } catch (IOException ex) {
                throw new UncheckedIOException(ex);
            }
        }

    }

    static class LightScanner {
        private BufferedReader reader = null;
        private StringTokenizer tokenizer = null;

        public LightScanner(InputStream in) {
            reader = new BufferedReader(new InputStreamReader(in));
        }

        public String string() {
            if (tokenizer == null || !tokenizer.hasMoreTokens()) {
                try {
                    tokenizer = new StringTokenizer(reader.readLine());
                } catch (IOException e) {
                    throw new UncheckedIOException(e);
                }
            }
            return tokenizer.nextToken();
        }

        public int ints() {
            return Integer.parseInt(string());
        }

    }
}




INSTRUCTIONS:
Solve the current question.
Provide:
1. A complete and efficient code solution, optimized for both time and space complexity.
2. A detailed explanation of the solution, including:
   - The intuition behind the approach;
   - Time and space complexity;
   - Important considerations about the algorithm.
3. You can use the example questions as general references for coding patterns and structure, but solve the current problem independently.
4. Don't use any external libraries. Any language is accepted.