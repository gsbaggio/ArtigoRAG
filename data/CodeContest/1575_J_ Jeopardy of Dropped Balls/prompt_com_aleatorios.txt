CURRENT QUESTION:
Mr. Chanek has a new game called Dropping Balls. Initially, Mr. Chanek has a grid a of size n × m

Each cell (x,y) contains an integer a_{x,y} denoting the direction of how the ball will move.

  * a_{x,y}=1 — the ball will move to the right (the next cell is (x, y + 1)); 
  * a_{x,y}=2 — the ball will move to the bottom (the next cell is (x + 1, y)); 
  * a_{x,y}=3 — the ball will move to the left (the next cell is (x, y - 1)). 



Every time a ball leaves a cell (x,y), the integer a_{x,y} will change to 2. Mr. Chanek will drop k balls sequentially, each starting from the first row, and on the c_1, c_2, ..., c_k-th (1 ≤ c_i ≤ m) columns.

Determine in which column each ball will end up in (position of the ball after leaving the grid).

Input

The first line contains three integers n, m, and k (1 ≤ n, m ≤ 1000, 1 ≤ k ≤ 10^5) — the size of the grid and the number of balls dropped by Mr. Chanek.

The i-th of the next n lines contains m integers a_{i,1},a_{i,2},…,a_{i,m} (1 ≤ a_{i,j} ≤ 3). It will satisfy a_{i, 1} ≠ 3 and a_{i, m} ≠ 1.

The next line contains k integers c_1, c_2, …, c_k (1 ≤ c_i ≤ m) — the balls' column positions dropped by Mr. Chanek sequentially.

Output

Output k integers — the i-th integer denoting the column where the i-th ball will end.

Examples

Input


5 5 3
1 2 3 3 3
2 2 2 2 2
2 2 2 2 2
2 2 2 2 2
2 2 2 2 2
1 2 1


Output


2 2 1 


Input


1 2 2
1 3
1 2


Output


1 2 

Note

In the first example, the first ball will drop as follows. Note that the cell (1, 1) will change direction to the bottom direction.

<image>

The second and third balls will drop as follows. 

<image>

All balls will be dropped from the first row and on the c_1, c_2, ..., c_k-th columns respectively. A ball will stop dropping once it leaves the grid.

EXAMPLE QUESTIONS:
Example question 1:
Name: p01721 Wave Attack
Tags: ['']
Description: The fearless Ikta has finally hunted down the infamous Count Big Bridge! Count Bigbridge is now trapped in a rectangular room w meters wide and h meters deep, waiting for his end.

If you select a corner of the room and take the coordinate system so that the width direction is the x-axis and the depth direction is the y-axis, and the inside of the room is in the positive direction, Count Big Bridge is at the point (p, q). .. At point (x, y), there is a shock wave launcher, which is Ikta's ultimate weapon, from which a shock wave of v meters per second is emitted in all directions. This shock wave is valid for t seconds and is reflected off the walls of the room.

Ikta, who is outside the room, wants to know how much Count Big Bridge will suffer, so let's write a program that asks Count Big Bridge how many shock waves he will hit. At this time, if the shock wave hits the enemy from the n direction at the same time, it is considered to have hit the enemy n times, and it is also effective if the shock wave hits the enemy exactly t seconds later. The shock wave does not disappear due to obstacles such as the launcher itself and Count Big Bridge, and the shock waves do not interfere with each other.



Input

The input is given in the following format.

> w h v t x y p q
>

* Each is a positive integer as explained in the problem statement.



Constraints

* v × t ≤ 106
* 2 ≤ w, h ≤ 108
* 0 <x, p <w
* 0 <y, q <h
* (x, y) ≠ (p, q)

Output

Output the number of times the shock wave hits Count Big Bridge on one line.

Examples

Input

10 10 1 10 3 3 7 7


Output

1


Input

10 10 1 11 3 3 7 7


Output

5


Input

2 3 1000 1000 1 1 1 2


Output

523598775681
Difficulty: 0
Solutions: #include<bits/stdc++.h>
#define inf 1<<29
#define linf 1e16
#define eps (1e-3)
#define mod 1000000007
#define pi acos(-1)
#define phi (1.0+sqrt(5))/2.0
#define f first
#define s second
#define mp make_pair
#define pb push_back
#define all(a) (a).begin(),(a).end()
#define pd(a) printf("%.10f\n",(double)(a))
#define FOR(i,a,b) for(int i=(a);i<(b);i++)
#define RFOR(i,a,b) for(int i=(a)-1;(b)<=i;i--)
#define equals(a,b) (fabs((a)-(b))<eps)
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
typedef pair<int,int> pii;
typedef pair<int,double> pid;
typedef pair<double,int> pdi;
typedef vector<int> vi;
typedef vector<pii> vpi;
const int dx[8]={1,0,-1,0,1,1,-1,-1};
const int dy[8]={0,1,0,-1,1,-1,1,-1};

double w,h,v,t,x,y,p,q,r;

ull count(double W){
  if(r-(W-x)<-eps)return 0;
  double H=sqrt(r*r-(W-x)*(W-x));
  ull res=0;
  res+=(int)((y+H-q)/h)-(int)((y-H-q)/h);
  res+=(int)((y+H+q)/h)-(int)((y-H+q)/h);
  if(y-H<=q && q<=y+H)res++;
  if(y-H<=-q && -q<=y+H)res++;

  return res;
}

ull solve(){
  ull res=0;
  r=v*t;w*=2.0;h*=2.0;
  for(double i=p;i-x-r<eps;i+=w)res+=count(i);
  for(double i=-p;i-x-r<eps;i+=w)res+=count(i);
  for(double i=p-w;x-r-i<eps;i-=w)res+=count(i);
  for(double i=-p-w;x-r-i<eps;i-=w)res+=count(i);
  return res;
}

int main()
{
  cin>>w>>h>>v>>t>>x>>y>>p>>q;
  cout<<solve()<<endl;
  return 0;
}

Example question 2:
Name: 1425_C. Captain of Knights
Tags: ['math']
Description: Mr. Chanek just won the national chess tournament and got a huge chessboard of size N × M. Bored with playing conventional chess, Mr. Chanek now defines a function F(X, Y), which denotes the minimum number of moves to move a knight from square (1, 1) to square (X, Y). It turns out finding F(X, Y) is too simple, so Mr. Chanek defines:

G(X, Y) = ∑_{i=X}^{N} ∑_{j=Y}^{M} F(i, j)

Given X and Y, you are tasked to find G(X, Y).

A knight can move from square (a, b) to square (a', b') if and only if |a - a'| > 0, |b - b'| > 0, and |a - a'| + |b - b'| = 3. Of course, the knight cannot leave the chessboard.

Input

The first line contains an integer T (1 ≤ T ≤ 100), the number of test cases.

Each test case contains a line with four integers X Y N M (3 ≤ X ≤ N ≤ 10^9, 3 ≤ Y ≤ M ≤ 10^9).

Output

For each test case, print a line with the value of G(X, Y) modulo 10^9 + 7.

Example

Input


2
3 4 5 6
5 5 8 8


Output


27
70
Difficulty: 9
Solutions: #include <bits/stdc++.h>
using namespace std;
namespace modular {
const int mod = 1000000007;
inline int add(int x, int y) { return x + y >= mod ? x + y - mod : x + y; }
inline int dec(int x, int y) { return x - y < 0 ? x - y + mod : x - y; }
inline int mul(int x, int y) { return 1ll * x * y % mod; }
}  // namespace modular
using namespace modular;
inline int poww(int a, int b) {
  int ans = 1;
  while (b) {
    if (b & 1) ans = mul(ans, a);
    a = mul(a, a);
    b >>= 1;
  }
  return ans;
}
const int inv2 = poww(2, mod - 2);
const int inv3 = poww(3, mod - 2);
inline int read() {
  int x = 0, f = 1;
  char ch = getchar();
  while (ch < '0' || ch > '9') {
    if (ch == '-') f = -1;
    ch = getchar();
  }
  while (ch >= '0' && ch <= '9') {
    x = (x << 1) + (x << 3) + (ch ^ '0');
    ch = getchar();
  }
  return x * f;
}
int T;
int f(int a, int b, int c, int n) {
  return add(add(mul(a, mul(n, n)), mul(b, n)), c);
}
int s(int n) { return (n / 3) + (n % 3); }
int t(int n) {
  int nn = n / 3;
  int res = f(mul(3, inv2), mul(5, inv2), 0, nn);
  for (int i = nn * 3 + 1; i <= n; i++) res = add(res, s(i));
  return res;
}
int a(int n) {
  int nn = n / 3;
  int res = mul(nn, f(mul(3, inv2), mul(9, inv2), 2, nn));
  for (int i = nn * 3 + 1; i <= n; i++) res = add(res, t(i));
  return res;
}
int b(int n) { return mul(n, f(inv2, 2, mul(3, inv2), n)); }
int c(int n) {
  int nn = n / 2;
  int res = mul(nn, f(1, mul(5, inv2), inv2, nn));
  if (n & 1) res = add(res, t((3ll * n - 1) / 2));
  return res;
}
int C1(int X, int Y) {
  X = min(X, 2 * Y), Y = min(Y, 2 * X);
  int mid = Y / 2;
  if (mid < 3) mid = 2;
  if (mid > X) mid = X;
  return dec(add(dec(b(mid), b(2)), dec(a(X + Y), a(mid + Y))),
             dec(c(X), c(2)));
}
int S1(int n) {
  int opt = n % 4;
  if (!opt) return mul(f(1, mod - 3, mod - 4, n), mul(inv2, inv2));
  if (opt == 1) return mul(f(1, mod - 1, mod - 8, n), mul(inv2, inv2));
  if (opt == 2) return mul(f(1, mod - 3, mod - 2, n), mul(inv2, inv2));
  return mul(f(1, mod - 1, mod - 6, n), mul(inv2, inv2));
}
int d(int n) {
  int nn = n / 4;
  int res = mul(nn, f(mul(16, inv3), mod - 2, dec(0, mul(19, inv3)), nn));
  for (int i = nn * 4 + 1; i <= n; i++) res = add(res, S1(i));
  return res;
}
int up(int x) { return (x + 1) / 2; }
int S2(int n, int Y) {
  int opt = n % 4;
  if (!opt) return dec(add(mul(n / 2, Y - 1), (Y + 1) / 2), 1);
  if (opt == 1) return dec(add(mul((n + 1) / 2, Y - 1), (Y + 1) / 2), 1);
  if (opt == 2) return add(mul(n / 2, Y - 1), Y / 2);
  return add(mul((n + 1) / 2, Y - 1), Y / 2);
}
int e(int n, int Y) {
  int nn = n / 4;
  int res = mul(dec(mul(4, Y), 4), add(mul(nn, nn), nn));
  for (int i = nn * 4 + 1; i <= n; i++) res = add(res, S2(i, Y));
  return res;
}
int C2(int X, int Y) {
  if (2 * Y + 2 >= X) return dec(d(X), d(4));
  return add(dec(d(2 * Y + 2), d(4)), dec(e(X, Y), e(2 * Y + 2, Y)));
}
int P(int X, int Y) {
  if (X < 2 || Y < 2) return 0;
  int ans = 0;
  for (int i = 2; i <= min(4, Y); i++) ans += 6 - i;
  ans = add(ans, C1(X, Y));
  ans = add(ans, C2(X, Y));
  ans = add(ans, C2(Y, X));
  return ans;
}
int main() {
  T = read();
  while (T--) {
    int x = read() - 1, y = read() - 1, n = read() - 1, m = read() - 1;
    printf("%d\n",
           dec(add(P(n, m), P(x - 1, y - 1)), add(P(x - 1, m), P(n, y - 1))));
  }
  return 0;
}



INSTRUCTIONS:
Solve the current question.
Provide:
1. A complete and efficient code solution, optimized for both time and space complexity.
2. A detailed explanation of the solution, including:
   - The intuition behind the approach;
   - Time and space complexity;
   - Important considerations about the algorithm.
3. If the language has classes, implement in 'Solution' class. Any language is accepted.
4. You can use the example questions as general references for coding patterns and structure, but solve the current problem independently.
5. Don't use any external libraries. Don't need to import any libraries.
