CURRENT QUESTION:
Mr. Chanek has a new game called Dropping Balls. Initially, Mr. Chanek has a grid a of size n × m

Each cell (x,y) contains an integer a_{x,y} denoting the direction of how the ball will move.

  * a_{x,y}=1 — the ball will move to the right (the next cell is (x, y + 1)); 
  * a_{x,y}=2 — the ball will move to the bottom (the next cell is (x + 1, y)); 
  * a_{x,y}=3 — the ball will move to the left (the next cell is (x, y - 1)). 



Every time a ball leaves a cell (x,y), the integer a_{x,y} will change to 2. Mr. Chanek will drop k balls sequentially, each starting from the first row, and on the c_1, c_2, ..., c_k-th (1 ≤ c_i ≤ m) columns.

Determine in which column each ball will end up in (position of the ball after leaving the grid).

Input

The first line contains three integers n, m, and k (1 ≤ n, m ≤ 1000, 1 ≤ k ≤ 10^5) — the size of the grid and the number of balls dropped by Mr. Chanek.

The i-th of the next n lines contains m integers a_{i,1},a_{i,2},…,a_{i,m} (1 ≤ a_{i,j} ≤ 3). It will satisfy a_{i, 1} ≠ 3 and a_{i, m} ≠ 1.

The next line contains k integers c_1, c_2, …, c_k (1 ≤ c_i ≤ m) — the balls' column positions dropped by Mr. Chanek sequentially.

Output

Output k integers — the i-th integer denoting the column where the i-th ball will end.

Examples

Input


5 5 3
1 2 3 3 3
2 2 2 2 2
2 2 2 2 2
2 2 2 2 2
2 2 2 2 2
1 2 1


Output


2 2 1 


Input


1 2 2
1 3
1 2


Output


1 2 

Note

In the first example, the first ball will drop as follows. Note that the cell (1, 1) will change direction to the bottom direction.

<image>

The second and third balls will drop as follows. 

<image>

All balls will be dropped from the first row and on the c_1, c_2, ..., c_k-th columns respectively. A ball will stop dropping once it leaves the grid.

SIMILAR QUESTIONS:
Similar question 1 (Similarity score: 0.70):
Name: 1392_E. Omkar and Duck
Tags: ['bitmasks', 'constructive algorithms', 'interactive', 'math']
Description: This is an interactive problem.

Omkar has just come across a duck! The duck is walking on a grid with n rows and n columns (2 ≤ n ≤ 25) so that the grid contains a total of n^2 cells. Let's denote by (x, y) the cell in the x-th row from the top and the y-th column from the left. Right now, the duck is at the cell (1, 1) (the cell in the top left corner) and would like to reach the cell (n, n) (the cell in the bottom right corner) by moving either down 1 cell or to the right 1 cell each second.

Since Omkar thinks ducks are fun, he wants to play a game with you based on the movement of the duck. First, for each cell (x, y) in the grid, you will tell Omkar a nonnegative integer a_{x,y} not exceeding 10^{16}, and Omkar will then put a_{x,y} uninteresting problems in the cell (x, y). After that, the duck will start their journey from (1, 1) to (n, n). For each cell (x, y) that the duck crosses during their journey (including the cells (1, 1) and (n, n)), the duck will eat the a_{x,y} uninteresting problems in that cell. Once the duck has completed their journey, Omkar will measure their mass to determine the total number k of uninteresting problems that the duck ate on their journey, and then tell you k.

Your challenge, given k, is to exactly reproduce the duck's path, i. e. to tell Omkar precisely which cells the duck crossed on their journey. To be sure of your mastery of this game, Omkar will have the duck complete q different journeys (1 ≤ q ≤ 10^3). Note that all journeys are independent: at the beginning of each journey, the cell (x, y) will still contain a_{x,y} uninteresting tasks.

Interaction

The interaction will begin with a line containing a single integer n (2 ≤ n ≤ 25), the amount of rows and columns in the grid. Read it.

Your program should then print n lines. The x-th line should contain n integers a_{x,1}, a_{x,2}, ..., a_{x,n} satisfying 0 ≤ a_{x,y} ≤ 10^{16}, where a_{x,y} is the amount of uninteresting problems Omkar should place in the cell (x, y).

After that, you will first receive a single integer q, the amount of journeys that the duck will take. q queries will follow; each query will consist of a single line containing an integer k, the amount of uninteresting problems that the duck ate on that journey. After each query, given that you have determined that the duck visited the cells (x_1, y_1), (x_2, y_2), ..., (x_{2n - 1}, y_{2n - 1}) in that order (it should always be true that (x_1, y_1) = (1, 1) and (x_{2n - 1}, y_{2n - 1}) = (n, n)), you should output 2n - 1 lines so that the j-th line contains the two integers x_j, y_j.

Bear in mind that if the sum on your path is k, but your path is different from the actual hidden path, then your solution is still wrong!

After printing each line do not forget to output end of line and flush the output. Otherwise, you will get Idleness limit exceeded. To do this, use:

  * fflush(stdout) or cout.flush() in C++;
  * System.out.flush() in Java;
  * flush(output) in Pascal;
  * stdout.flush() in Python;
  * see documentation for other languages.



Hack Format

To hack, first output a line containing n and another line containing q. It must be true that 2 ≤ n ≤ 25 and 1 ≤ q ≤ 1000. Then, output the q journeys taken by the duck in the same format as described above: for each journey, given that the duck visited the cells (x_1, y_1), (x_2, y_2), ..., (x_{2n - 1}, y_{2n - 1}) in that order, you should output 2n - 1 lines so that the j-th line contains the two integers x_j, y_j. It must be true that (x_1, y_1) = (1, 1) and (x_{2n - 1}, y_{2n - 1}) = (n, n). Additionally, for each j such that 2 ≤ j ≤ 2n - 1, it must be true that 1 ≤ x_j, y_j ≤ n and either (x_j, y_j) = (x_{j - 1} + 1, y_{j - 1}) or (x_j, y_j) = (x_{j - 1}, y_{j - 1} + 1).

Example

Input


4




3
23







26







27









Output


1 2 3 6
4 6 2 10
9 0 7 3
2 8 8 2


1 1
1 2
1 3
2 3
2 4
3 4
4 4

1 1
2 1
3 1
3 2
3 3
3 4
4 4

1 1
1 2
1 3
1 4
2 4
3 4
4 4

Note

The duck's three journeys are illustrated below.

1 + 2 + 3 + 2 + 10 + 3 + 2 = 23 

<image>

1 + 4 + 9 + 0 + 7 + 3 + 2 = 26 

<image>

1 + 2 + 3 + 6 + 10 + 3 + 2 = 27 

<image>
Difficulty: 11
Solutions: #include <bits/stdc++.h>
using namespace std;
const long long inf = 2000000000000000000LL;
int main() {
  ios_base::sync_with_stdio(0);
  cin.tie(0);
  cout.tie(0);
  long long t, i, j, k, l, m, n, o, p, q, temp, ans = 0, flag = 0,
                                                mod = 1000000007;
  cin >> n;
  long long a[n][n];
  for (i = 0, temp = 1; i < n; i++, temp *= 2) {
    for (j = 0, k = temp; j < n; j++, k *= 2) {
      if (i % 2)
        a[i][j] = 0;
      else
        a[i][j] = k;
      cout << a[i][j] << endl;
      fflush(stdout);
    }
  }
  cin >> q;
  while (q--) {
    cin >> temp;
    map<long long, long long> mp;
    p = 1LL << 52;
    while (temp) {
      if (temp >= p) {
        mp[p]++;
        temp -= p;
      }
      p /= 2;
    }
    cout << "1 1" << endl;
    fflush(stdout);
    for (i = 0, j = 0, temp = 0; (i != n - 1 || j != n - 1) && temp < 60;
         temp++) {
      if (i + 1 >= n) {
        cout << i + 1 << " " << j + 2 << endl;
        j++;
      } else if (j + 1 >= n) {
        cout << i + 2 << " " << j + 1 << endl;
        i++;
      } else {
        if (i % 2 == 0) {
          if (mp[a[i][j + 1]]) {
            cout << i + 1 << " " << j + 2 << endl;
            j++;
          } else {
            cout << i + 2 << " " << j + 1 << endl;
            i++;
          }
        } else {
          if (mp[a[i + 1][j]]) {
            cout << i + 2 << " " << j + 1 << endl;
            i++;
          } else {
            cout << i + 1 << " " << j + 2 << endl;
            j++;
          }
        }
      }
      fflush(stdout);
    }
  }
}



INSTRUCTIONS:
Solve the current question.
Provide:
1. A complete and efficient code solution, optimized for both time and space complexity.
2. A detailed explanation of the solution, including:
   - The intuition behind the approach;
   - Time and space complexity;
   - Important considerations about the algorithm.
3. If the language has classes, implement in 'Solution' class. Any language is accepted.
4. Use the similar questions as references to improve the solution, but only if they are relevant.
5. Don't use any external libraries. Don't need to import any libraries.
