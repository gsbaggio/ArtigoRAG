def construct_permutation(n, a, b):
    # Check if it's possible to have a local maxima and minima
    if a + b >= n - 1:
        return -1
    
    # Initialize the permutation with increasing order
    perm = list(range(1, n + 1))
    
    # Create local maxima
    max_positions = set()
    for i in range(a):
        # Find a valid position for a local maximum
        j = 1
        while j in max_positions or (j + 1 < n and j + 1 in max_positions) or (j - 1 > 0 and j - 1 in max_positions):
            j += 1
        # Reverse the subarray to create a local maximum
        perm[j-1:j+2] = reversed(perm[j-1:j+2])
        max_positions.add(j)
    
    # Create local minima
    min_positions = set()
    for i in range(b):
        # Find a valid position for a local minimum
        j = 1
        while j in max_positions or j in min_positions or (j + 1 < n and j + 1 in min_positions) or (j - 1 > 0 and j - 1 in min_positions):
            j += 1
        # Reverse the subarray to create a local minimum
        perm[j-1:j+2] = reversed(perm[j-1:j+2])
        min_positions.add(j)
    
    return perm

# Read input
import sys
input = sys.stdin.read().splitlines()

t = int(input[0])
results = []

for i in range(1, t + 1):
    n, a, b = map(int, input[i].split())
    result = construct_permutation(n, a, b)
    if result == -1:
        results.append("-1")
    else:
        results.append(" ".join(map(str, result)))

# Print results
for result in results:
    print(result)