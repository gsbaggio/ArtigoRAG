CURRENT QUESTION:
You are given three integers n, a, b. Determine if there exists a permutation p_1, p_2, …, p_n of integers from 1 to n, such that:

  * There are exactly a integers i with 2 ≤ i ≤ n-1 such that p_{i-1} < p_i > p_{i+1} (in other words, there are exactly a local maximums).

  * There are exactly b integers i with 2 ≤ i ≤ n-1 such that p_{i-1} > p_i < p_{i+1} (in other words, there are exactly b local minimums).




If such permutations exist, find any such permutation.

Input

The first line of the input contains a single integer t (1 ≤ t ≤ 10^4) — the number of test cases. The description of test cases follows.

The only line of each test case contains three integers n, a and b (2 ≤ n ≤ 10^5, 0 ≤ a,b ≤ n).

The sum of n over all test cases doesn't exceed 10^5.

Output

For each test case, if there is no permutation with the requested properties, output -1.

Otherwise, print the permutation that you are found. If there are several such permutations, you may print any of them.

Example

Input


3
4 1 1
6 1 2
6 4 0


Output


1 3 2 4
4 2 3 1 5 6
-1

Note

In the first test case, one example of such permutations is [1, 3, 2, 4]. In it p_1 < p_2 > p_3, and 2 is the only such index, and p_2> p_3 < p_4, and 3 the only such index.

One can show that there is no such permutation for the third test case.

EXAMPLE QUESTIONS:
Example question 1:
Name: p01248 Text Justification
Tags: ['']
Description: You are hired by the ∀I¶אΞ℘, an extraterrestrial intelligence, as a programmer of their typesetting system. Your task today is to design an algorithm for text justification.

Text justification is to equalize the line widths as much as possible by inserting line breaks at appropriate posi- tions, given a word sequence called a paragraph and the width of the paper. Since you have not developed an automatic hyphenation algorithm yet, you cannot break a line in the middle of a word. And since their language does not put spaces between words, you do not need to consider about spacing.

To measure how well the text is justified in one configuration (i.e., a set of lines generated by inserting line breaks to a paragraph), you have defined its cost as follows:

* The total cost of a paragraph is the sum of the cost of each line.
* The cost for the last line is defined as max(0, s - w).
* The cost for other lines are given by |s - w|.



where s is the sum of the widths of the words in the line, and w is the width of the paper.

Please design the algorithm which takes a paragraph and calculates the configuration of the minimum cost.



Input

The input consists of multiple test cases.

The first line of each test case contains two positive integers n and w (0 ≤ n ≤ 1000 and 0 ≤ w ≤ 1,000,000). n is the length of paragraph and w is the width of the used paper. Each of the following n lines contains one positive integer ai which indicates the width of the i-th word in the paragraph. Here it is guaranteed that 0 ≤ ai ≤ w.

The input terminates with the line containing two zeros. This is not a part of any test case and should not be processed.

Output

For each test case, print the case number and the minimum cost for the paragraph.

Example

Input

4 10
8
6
9
1
4 7
1
2
3
4
0 0


Output

Case 1: 4
Case 2: 1
Difficulty: 0
Solutions: #include <bits/stdc++.h>

using namespace std;

typedef long long ll;

#define MAX 1024
#define INF LLONG_MAX/4

ll N, W;
ll memo[MAX];
vector<ll> a;

ll solve(int n)
{
    if (n == N) return 0;
    ll &res = memo[n];
    if (res != -1) return res;
    res = INF;
    ll sum = 0;
    for (int i = n; i < N; i++) {
        sum += a[i];
        res = min(res, solve(i+1) + abs(sum - W));
    }
    res = min(res, solve(N) + max(0LL, sum - W));
    return res;
}

int main()
{
    int T = 1;
    while (cin >> N >> W, N) {
        a.resize(N);
        for (int i = 0; i < N; i++) {
            cin >> a[i];
        }
        memset(memo, -1, sizeof(memo));
        cout << "Case " << T++ << ": " << solve(0) << endl;
    }    
    return 0;
}

Example question 2:
Name: p01987 Casino
Tags: ['']
Description: casino

The company you work for is developing a new casino game. Today I decided to consider a recently proposed game.

In this game, N dice are rolled at the same time, and the total number of rolls is the score. The player plays with the goal of increasing the score. If you don't like the roll, you can roll the dice again, but then you have to roll all N dice at the same time. Also, the maximum number of times the dice can be rolled is M. If you think you have a sufficiently large roll, you may finish the game less than M times, and the total number of dice rolled last will be the score.

In order to set an appropriate stake, the expected value of the score must be obtained. Given N and M, it is your job today to find the expected value of the score you would get if you took the optimal strategy.

However, the dice used in this game have 1 to 6 rolls, and the probability of each roll is the same.

Input

The input consists of up to 100 datasets. Each dataset is represented in the following format.

> N M

The integers N and M satisfy 1 ≤ N ≤ 20, 1 ≤ M ≤ 1010.

The end of the input is represented by a line of two zeros.

Output

For each data set, output the expected value when the optimal strategy is taken in one line. The output must not have an absolute error greater than 10-2. Since a solution method that increases the calculation error is assumed for this problem, it is recommended to use an accurate type.

Sample Input


1 2
twenty one
twenty two
0 0


Output for the Sample Input


4.25
7
7.9722222222






Example

Input

1 2
2 1
2 2
0 0


Output

4.25
7
7.9722222222
Difficulty: 0
Solutions: //#include <bits/stdc++.h>
#include <cstdio>
#include <iostream>
#include <cmath>

using namespace std;

typedef long double ld;
typedef long long ll;
ld dice[23][23*6];

struct Mat{
  ld val[2][2];
  
  Mat operator* (const Mat &b) const{
    Mat res;
    
    for(int i=0;i<2;i++){
      for(int j=0;j<2;j++){
        res.val[i][j] = 0;
        for(int k=0;k<2;k++)
          res.val[i][j] += val[i][k] * b.val[k][j];
      }
    }

    return res;
  }
};

ld pow(ld X, ld Y, ld q, ll n){
  Mat t = {X, Y, 0, 1};
  Mat res = {1,0,0,1};
  
  while(n){
    if(n%2) res = res * t;
    t = t*t;
    n/=2;
  }

  return q * res.val[0][0] + res.val[0][1]; 
}

bool solve(){
  ll n, m;
  
  scanf("%lld%lld", &n, &m);
  if(n == 0) return false;
  
  ld q = 0; ll i = 0;

  while(i < m){
    ll l = i+1, r = m;
    ld X = 0, Y = 0;
    
    for(int j=0;j<=n*6;j++){
      if(j <= q) X += dice[n][j];
      else Y += dice[n][j] * j;
    }
    
    while(l<r){
      ll mid = (l+r)/2;
      
      if(pow(X, Y, q, mid-i) >= floor(q) + 1){
        r = mid;
      }else{
        l = mid + 1;
      }
    }
    
    q = pow(X, Y, q, l-i);
    i = l;
  }

  printf("%.5Lf\n", q);
  
  return true;
}



int main(){
  dice[0][0] = 1;

  for(int i=0;i<20;i++){
    for(int j=0;j<=i*6;j++){
      for(int k=1;k<=6;k++)
        dice[i+1][j+k] += dice[i][j] / 6;
    }
  }
  
  while(solve());
}





INSTRUCTIONS:
Solve the current question.
Provide:
1. A complete and efficient code solution, optimized for both time and space complexity.
2. A detailed explanation of the solution, including:
   - The intuition behind the approach;
   - Time and space complexity;
   - Important considerations about the algorithm.
3. You can use the example questions as general references for coding patterns and structure, but solve the current problem independently.
4. Don't use any external libraries. Any language is accepted.