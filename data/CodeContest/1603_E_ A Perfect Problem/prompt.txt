CURRENT QUESTION:
A sequence of integers b_1, b_2, …, b_m is called good if max(b_1, b_2, …, b_m) ⋅ min(b_1, b_2, …, b_m) ≥ b_1 + b_2 + … + b_m.

A sequence of integers a_1, a_2, …, a_n is called perfect if every non-empty subsequence of a is good.

YouKn0wWho has two integers n and M, M is prime. Help him find the number, modulo M, of perfect sequences a_1, a_2, …, a_n such that 1 ≤ a_i ≤ n + 1 for each integer i from 1 to n.

A sequence d is a subsequence of a sequence c if d can be obtained from c by deletion of several (possibly, zero or all) elements.

Input

The first and only line of the input contains two space-separated integers n and M (1 ≤ n ≤ 200; 10^8 ≤ M ≤ 10^9). It is guaranteed that M is prime.

Output

Print a single integer — the number of perfect sequences modulo M.

Examples

Input


2 998244353


Output


4


Input


4 100000007


Output


32


Input


69 999999937


Output


456886663

Note

In the first test case, the perfect sequences are [2, 2], [2, 3], [3, 2] and [3, 3].

In the second test case, some of the perfect sequences are [3, 4, 3, 5], [4, 5, 4, 4], [4, 5, 5, 5] etc. One example of a sequence which is not perfect is [2, 3, 3, 4], because, for example, the subsequence [2, 3, 4] is not an good as 2 ⋅ 4 < 2 + 3 + 4.

SIMILAR QUESTIONS:
Similar question 1 (Similarity score: 0.73):
Name: 1061_C. Multiplicity
Tags: ['data structures', 'dp', 'implementation', 'math', 'number theory']
Description: You are given an integer array a_1, a_2, …, a_n.

The array b is called to be a subsequence of a if it is possible to remove some elements from a to get b.

Array b_1, b_2, …, b_k is called to be good if it is not empty and for every i (1 ≤ i ≤ k) b_i is divisible by i.

Find the number of good subsequences in a modulo 10^9 + 7. 

Two subsequences are considered different if index sets of numbers included in them are different. That is, the values ​of the elements ​do not matter in the comparison of subsequences. In particular, the array a has exactly 2^n - 1 different subsequences (excluding an empty subsequence).

Input

The first line contains an integer n (1 ≤ n ≤ 100 000) — the length of the array a.

The next line contains integers a_1, a_2, …, a_n (1 ≤ a_i ≤ 10^6).

Output

Print exactly one integer — the number of good subsequences taken modulo 10^9 + 7.

Examples

Input

2
1 2


Output

3

Input

5
2 2 1 22 14


Output

13

Note

In the first example, all three non-empty possible subsequences are good: \{1\}, \{1, 2\}, \{2\}

In the second example, the possible good subsequences are: \{2\}, \{2, 2\}, \{2, 22\}, \{2, 14\}, \{2\}, \{2, 22\}, \{2, 14\}, \{1\}, \{1, 22\}, \{1, 14\}, \{22\}, \{22, 14\}, \{14\}.

Note, that some subsequences are listed more than once, since they occur in the original array multiple times.
Difficulty: 9
Solutions: #!/usr/bin/env python
"""
This file is part of https://github.com/Cheran-Senthil/PyRival.

Copyright 2018 Cheran Senthilkumar all rights reserved,
Cheran Senthilkumar <hello@cheran.io>
Permission to use, modify, and distribute this software is given under the
terms of the MIT License.

"""
from __future__ import division, print_function

import cmath
import itertools
import math
import operator as op
# import random
import sys
from atexit import register
from bisect import bisect_left, bisect_right
# from collections import Counter, MutableSequence, defaultdict, deque
# from copy import deepcopy
# from decimal import Decimal
# from difflib import SequenceMatcher
# from fractions import Fraction
# from heapq import heappop, heappush

if sys.version_info[0] < 3:
    # from cPickle import dumps
    from io import BytesIO as stream
    # from Queue import PriorityQueue, Queue
else:
    # from functools import reduce
    from io import StringIO as stream
    from math import gcd
    # from pickle import dumps
    # from queue import PriorityQueue, Queue


if sys.version_info[0] < 3:
    class dict(dict):
        """dict() -> new empty dictionary"""
        def items(self):
            """D.items() -> a set-like object providing a view on D's items"""
            return dict.iteritems(self)

        def keys(self):
            """D.keys() -> a set-like object providing a view on D's keys"""
            return dict.iterkeys(self)

        def values(self):
            """D.values() -> an object providing a view on D's values"""
            return dict.itervalues(self)

    def gcd(x, y):
        """gcd(x, y) -> int
        greatest common divisor of x and y
        """
        while y:
            x, y = y, x % y
        return x

    input = raw_input
    range = xrange

    filter = itertools.ifilter
    map = itertools.imap
    zip = itertools.izip


def sync_with_stdio(sync=True):
    """Set whether the standard Python streams are allowed to buffer their I/O.

    Args:
        sync (bool, optional): The new synchronization setting.

    """
    global input, flush

    if sync:
        flush = sys.stdout.flush
    else:
        sys.stdin = stream(sys.stdin.read())
        input = lambda: sys.stdin.readline().rstrip('\r\n')

        sys.stdout = stream()
        register(lambda: sys.__stdout__.write(sys.stdout.getvalue()))


def memodict(f):
    """ Memoization decorator for a function taking a single argument. """
    class memodict(dict):
        def __missing__(self, key):
            ret = self[key] = f(key)
            return ret
    return memodict().__getitem__


@memodict
def all_factors(n):
    return set(reduce(list.__add__,
                      ([i, n//i] for i in range(1, int(n**0.5) + 1, 2 if n % 2 else 1) if n % i == 0)))


def main():
    n = int(input())
    a = list(map(int, input().split(' ')))

    div_cnt = [0] * (n + 1)
    div_cnt[0] = 1

    res = 0

    for i in a:
        for j in sorted(all_factors(i), reverse=True):
            try:
                res += div_cnt[j - 1]
                if res > 1000000007:
                    res -= 1000000007

                div_cnt[j] += div_cnt[j - 1]
                if div_cnt[j] > 1000000007:
                    div_cnt[j] -= 1000000007
            except:
                pass

    print(res)


if __name__ == '__main__':
    sync_with_stdio(False)
    main()


Similar question 2 (Similarity score: 0.71):
Name: p02057 MOD Rush
Tags: ['']
Description: F: MOD Rush

problem

Given a positive integer sequence A of length N and a positive integer sequence B of length M.

For all (i, j) (1 \ leq i \ leq N, 1 \ leq j \ leq M), find the remainder of A_i divided by B_j and output the sum of them.

Input format


N M
A_1 A_2 ... A_N
B_1 B_2 ... B_M


Constraint

* 1 \ leq N, M \ leq 2 \ times 10 ^ 5
* 1 \ leq A_i, B_i \ leq 2 \ times 10 ^ 5
* All inputs are given as integers



Output format

Print the answer on one line. Please start a new line at the end.

Input example 1


3 3
5 1 6
2 3 4


Output example 1


9

* Consider the remainder of dividing the first element of sequence A by each element of sequence B. Dividing 5 by 2 gives too much 1, dividing by 3 gives too much 2, and dividing by 4 gives too much 1.
* Similarly, considering the second element, too much is 1, 1, 1, respectively.
* Considering the third element, too much is 0, 0, 2, respectively.
* If you add up too much, you get 1 + 2 + 1 + 1 + 1 + 1 + 0 + 0 + 2 = 9, so 9 is output.



Input example 2


twenty four
2 7
3 3 4 4


Output example 2


16

* The same value may be included more than once in the sequence, but the sum is calculated by calculating too much for each element.



Input example 3


3 1
12 15 21
3


Output example 3


0





Example

Input

3 3
5 1 6
2 3 4


Output

9
Difficulty: 0
Solutions: #include <bits/stdc++.h>
using namespace std;
#define int long long
#define FOR(i, s, n) for (int i = (s); i < (n); i++)
#define RFOR(i, s, n) for (int i = (n) - 1; i >= (s); i--)
#define REP(i, n) FOR(i, 0, n)
#define RREP(i, n) RFOR(i, 0, n)
#define ALL(a) a.begin(), a.end()
#define IN(a, x, b) (a <= x && x < b)
const long long MOD = 1e9+7, INF = 1e18;
template<class T>inline bool CHMAX(T&a,T b){if(a<b){a=b;return true;}return false;}
template<class T>inline bool CHMIN(T&a,T b){if(a>b){a=b;return true;}return false;}



signed main(){
	int N,M;
	cin>>N>>M;
	vector<int>a(N);
	vector<int>cnt(200020,0);
	REP(i,N)cin>>a[i];
	REP(i,M){
		int t;
		cin>>t;
		cnt[t]++;
	}
	
	vector<int>sum(200020,0);
	REP(i,200020){
		if(cnt[i]==0)continue;
		for(int j = 1;j*i<=200020;j++){
			sum[j*i]+=i*cnt[i];
		}
	}
	vector<int>add(200020,0);
	FOR(i,1,200020){
		add[i] = add[i-1] + M - sum[i];
	}
	int ans = 0;
	REP(i,N){
		ans += add[a[i]];
	}
	cout<<ans<<endl;
}


Similar question 3 (Similarity score: 0.71):
Name: p03349 AtCoder Grand Contest 024 - Sequence Growing Hard
Tags: ['']
Description: Find the number of the possible tuples of sequences (A_0,A_1,...,A_N) that satisfy all of the following conditions, modulo M:

* For every i (0\leq i\leq N), A_i is a sequence of length i consisting of integers between 1 and K (inclusive);
* For every i (1\leq i\leq N), A_{i-1} is a subsequence of A_i, that is, there exists 1\leq x_i\leq i such that the removal of the x_i-th element of A_i would result in a sequence equal to A_{i-1};
* For every i (1\leq i\leq N), A_i is lexicographically larger than A_{i-1}.

Constraints

* 1 \leq N,K \leq 300
* 2 \leq M \leq 10^9
* N, K and M are integers.

Input

Input is given from Standard Input in the following format:


N K M


Output

Print the number of the possible tuples of sequences (A_0,A_1,...,A_N), modulo M.

Examples

Input

2 2 100


Output

5


Input

4 3 999999999


Output

358


Input

150 150 998244353


Output

186248260
Difficulty: 0
Solutions: #include <bits/stdc++.h>
using namespace std;

int64_t MOD;
void add(int64_t& a, int64_t b){
    a = (a+b) % MOD;
}
void mul(int64_t& a, int64_t b){
    a = a*b % MOD;
}

int main(){
    int N, K;
    cin >> N >> K >> MOD;

    int64_t pow[302][302] = {0};
    for(int i=1; i<=301; i++){
        pow[i][0] = 1;
        for(int j=1; j<=301; j++) pow[i][j] = pow[i][j-1] * i % MOD;
    }

    int64_t sub[302][302] = {0};
    sub[0][0] = 1;
    for(int i=1; i<=301; i++) for(int j=0; j<=301; j++) for(int k=0; j+k<=301; k++) add(sub[i][j+k], sub[i-1][j] * pow[i][k]);

    int64_t dp[301][301] = {0};
    dp[0][0] = 1;
    for(int i=1; i<=300; i++) for(int j=0; j<=300; j++) for(int k=0; j+k<=300; k++) add(dp[i][j+k], dp[i-1][j] * sub[j+1][k]);

    cout << dp[K][N] << endl;
    return 0;
}



INSTRUCTIONS:
Solve the current question.
Provide:
1. A complete and efficient code solution, optimized for both time and space complexity.
2. A detailed explanation of the solution, including:
   - The intuition behind the approach;
   - Time and space complexity;
   - Important considerations about the algorithm.
3. Use the similar questions as references to improve the solution, but only if they are relevant.
4. Don't use any external libraries. Any language is accepted.