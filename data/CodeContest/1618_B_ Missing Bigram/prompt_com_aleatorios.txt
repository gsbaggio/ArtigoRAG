CURRENT QUESTION:
Polycarp has come up with a new game to play with you. He calls it "A missing bigram".

A bigram of a word is a sequence of two adjacent letters in it.

For example, word "abbaaba" contains bigrams "ab", "bb", "ba", "aa", "ab" and "ba".

The game goes as follows. First, Polycarp comes up with a word, consisting only of lowercase letters 'a' and 'b'. Then, he writes down all its bigrams on a whiteboard in the same order as they appear in the word. After that, he wipes one of them off the whiteboard.

Finally, Polycarp invites you to guess what the word that he has come up with was.

Your goal is to find any word such that it's possible to write down all its bigrams and remove one of them, so that the resulting sequence of bigrams is the same as the one Polycarp ended up with.

The tests are generated in such a way that the answer exists. If there are multiple answers, you can print any of them.

Input

The first line contains a single integer t (1 ≤ t ≤ 2000) — the number of testcases.

The first line of each testcase contains a single integer n (3 ≤ n ≤ 100) — the length of the word Polycarp has come up with.

The second line of each testcase contains n-2 bigrams of that word, separated by a single space. Each bigram consists of two letters, each of them is either 'a' or 'b'.

Additional constraint on the input: there exists at least one string such that it is possible to write down all its bigrams, except one, so that the resulting sequence is the same as the sequence in the input. In other words, the answer exists.

Output

For each testcase print a word, consisting of n letters, each of them should be either 'a' or 'b'. It should be possible to write down all its bigrams and remove one of them, so that the resulting sequence of bigrams is the same as the one Polycarp ended up with.

The tests are generated in such a way that the answer exists. If there are multiple answers, you can print any of them. 

Example

Input


4
7
ab bb ba aa ba
7
ab ba aa ab ba
3
aa
5
bb ab bb


Output


abbaaba
abaabaa
baa
bbabb

Note

The first two testcases from the example are produced from the word "abbaaba". As listed in the statement, it contains bigrams "ab", "bb", "ba", "aa", "ab" and "ba".

In the first testcase, the 5-th bigram is removed. 

In the second testcase, the 2-nd bigram is removed. However, that sequence could also have been produced from the word "abaabaa". It contains bigrams "ab", "ba", "aa", "ab", "ba" and "aa". The missing bigram is the 6-th one.

In the third testcase, all of "baa", "aab" and "aaa" are valid answers.

EXAMPLE QUESTIONS:
Example question 1:
Name: 1336_C. Kaavi and Magic Spell
Tags: ['dp', 'strings']
Description: Kaavi, the mysterious fortune teller, deeply believes that one's fate is inevitable and unavoidable. Of course, she makes her living by predicting others' future. While doing divination, Kaavi believes that magic spells can provide great power for her to see the future. 

<image>

Kaavi has a string T of length m and all the strings with the prefix T are magic spells. Kaavi also has a string S of length n and an empty string A.

During the divination, Kaavi needs to perform a sequence of operations. There are two different operations:

  * Delete the first character of S and add it at the front of A.
  * Delete the first character of S and add it at the back of A.



Kaavi can perform no more than n operations. To finish the divination, she wants to know the number of different operation sequences to make A a magic spell (i.e. with the prefix T). As her assistant, can you help her? The answer might be huge, so Kaavi only needs to know the answer modulo 998 244 353.

Two operation sequences are considered different if they are different in length or there exists an i that their i-th operation is different. 

A substring is a contiguous sequence of characters within a string. A prefix of a string S is a substring of S that occurs at the beginning of S.

Input

The first line contains a string S of length n (1 ≤ n ≤ 3000).

The second line contains a string T of length m (1 ≤ m ≤ n).

Both strings contain only lowercase Latin letters.

Output

The output contains only one integer — the answer modulo 998 244 353.

Examples

Input


abab
ba


Output


12

Input


defineintlonglong
signedmain


Output


0

Input


rotator
rotator


Output


4

Input


cacdcdbbbb
bdcaccdbbb


Output


24

Note

The first test:

<image>

The red ones are the magic spells. In the first operation, Kaavi can either add the first character "a" at the front or the back of A, although the results are the same, they are considered as different operations. So the answer is 6×2=12.
Difficulty: 9
Solutions: #include <bits/stdc++.h>
using namespace std;
inline int read() {
  register int x = 0;
  register int y = 1;
  register char c = getchar();
  while (c < '0' || c > '9') {
    if (c == '-') y = 0;
    c = getchar();
  }
  while (c >= '0' && c <= '9') {
    x = x * 10 + (c ^ 48);
    c = getchar();
  }
  return y ? x : -x;
}
char s[3005], t[3005];
int f[3005][3005];
int main() {
  scanf("%s", s + 1);
  scanf("%s", t + 1);
  int n = strlen(s + 1), m = strlen(t + 1);
  for (register int i = 1; i <= m; i++) f[i][i] = (s[1] == t[i]) << 1;
  for (register int i = m + 1; i <= n; i++) f[i][i] = 2;
  for (register int i = 2, len = 2; i <= n; i++, len++) {
    for (register int l = 1, r = len; r <= n; l++, r++) {
      if (l > m || s[i] == t[l]) f[l][r] += f[l + 1][r], f[l][r] %= 998244353;
      if (r > m || s[i] == t[r]) f[l][r] += f[l][r - 1], f[l][r] %= 998244353;
    }
  }
  int ans = 0;
  for (register int i = m; i <= n; i++) ans = (ans + f[1][i]) % 998244353;
  printf("%d", ans);
  return 0;
}



INSTRUCTIONS:
Solve the current question.
Provide:
1. A complete and efficient code solution, optimized for both time and space complexity.
2. A detailed explanation of the solution, including:
   - The intuition behind the approach;
   - Time and space complexity;
   - Important considerations about the algorithm.
3. You can use the example questions as general references for coding patterns and structure, but solve the current problem independently.
4. Don't use any external libraries. Any language is accepted.