CURRENT QUESTION:
Polycarp has come up with a new game to play with you. He calls it "A missing bigram".

A bigram of a word is a sequence of two adjacent letters in it.

For example, word "abbaaba" contains bigrams "ab", "bb", "ba", "aa", "ab" and "ba".

The game goes as follows. First, Polycarp comes up with a word, consisting only of lowercase letters 'a' and 'b'. Then, he writes down all its bigrams on a whiteboard in the same order as they appear in the word. After that, he wipes one of them off the whiteboard.

Finally, Polycarp invites you to guess what the word that he has come up with was.

Your goal is to find any word such that it's possible to write down all its bigrams and remove one of them, so that the resulting sequence of bigrams is the same as the one Polycarp ended up with.

The tests are generated in such a way that the answer exists. If there are multiple answers, you can print any of them.

Input

The first line contains a single integer t (1 ≤ t ≤ 2000) — the number of testcases.

The first line of each testcase contains a single integer n (3 ≤ n ≤ 100) — the length of the word Polycarp has come up with.

The second line of each testcase contains n-2 bigrams of that word, separated by a single space. Each bigram consists of two letters, each of them is either 'a' or 'b'.

Additional constraint on the input: there exists at least one string such that it is possible to write down all its bigrams, except one, so that the resulting sequence is the same as the sequence in the input. In other words, the answer exists.

Output

For each testcase print a word, consisting of n letters, each of them should be either 'a' or 'b'. It should be possible to write down all its bigrams and remove one of them, so that the resulting sequence of bigrams is the same as the one Polycarp ended up with.

The tests are generated in such a way that the answer exists. If there are multiple answers, you can print any of them. 

Example

Input


4
7
ab bb ba aa ba
7
ab ba aa ab ba
3
aa
5
bb ab bb


Output


abbaaba
abaabaa
baa
bbabb

Note

The first two testcases from the example are produced from the word "abbaaba". As listed in the statement, it contains bigrams "ab", "bb", "ba", "aa", "ab" and "ba".

In the first testcase, the 5-th bigram is removed. 

In the second testcase, the 2-nd bigram is removed. However, that sequence could also have been produced from the word "abaabaa". It contains bigrams "ab", "ba", "aa", "ab", "ba" and "aa". The missing bigram is the 6-th one.

In the third testcase, all of "baa", "aab" and "aaa" are valid answers.

SIMILAR QUESTIONS:
Similar question 1 (Similarity score: 0.70):
Name: 1367_D. Task On The Board
Tags: ['constructive algorithms', 'greedy', 'implementation', 'sortings']
Description: Polycarp wrote on the board a string s containing only lowercase Latin letters ('a'-'z'). This string is known for you and given in the input.

After that, he erased some letters from the string s, and he rewrote the remaining letters in any order. As a result, he got some new string t. You have to find it with some additional information.

Suppose that the string t has length m and the characters are numbered from left to right from 1 to m. You are given a sequence of m integers: b_1, b_2, …, b_m, where b_i is the sum of the distances |i-j| from the index i to all such indices j that t_j > t_i (consider that 'a'<'b'<...<'z'). In other words, to calculate b_i, Polycarp finds all such indices j that the index j contains a letter that is later in the alphabet than t_i and sums all the values |i-j|.

For example, if t = "abzb", then:

  * since t_1='a', all other indices contain letters which are later in the alphabet, that is: b_1=|1-2|+|1-3|+|1-4|=1+2+3=6; 
  * since t_2='b', only the index j=3 contains the letter, which is later in the alphabet, that is: b_2=|2-3|=1; 
  * since t_3='z', then there are no indexes j such that t_j>t_i, thus b_3=0; 
  * since t_4='b', only the index j=3 contains the letter, which is later in the alphabet, that is: b_4=|4-3|=1. 



Thus, if t = "abzb", then b=[6,1,0,1].

Given the string s and the array b, find any possible string t for which the following two requirements are fulfilled simultaneously:

  * t is obtained from s by erasing some letters (possibly zero) and then writing the rest in any order; 
  * the array, constructed from the string t according to the rules above, equals to the array b specified in the input data. 

Input

The first line contains an integer q (1 ≤ q ≤ 100) — the number of test cases in the test. Then q test cases follow.

Each test case consists of three lines:

  * the first line contains string s, which has a length from 1 to 50 and consists of lowercase English letters; 
  * the second line contains positive integer m (1 ≤ m ≤ |s|), where |s| is the length of the string s, and m is the length of the array b; 
  * the third line contains the integers b_1, b_2, ..., b_m (0 ≤ b_i ≤ 1225). 



It is guaranteed that in each test case an answer exists.

Output

Output q lines: the k-th of them should contain the answer (string t) to the k-th test case. It is guaranteed that an answer to each test case exists. If there are several answers, output any.

Example

Input


4
abac
3
2 1 0
abc
1
0
abba
3
1 0 1
ecoosdcefr
10
38 13 24 14 11 5 3 24 17 0


Output


aac
b
aba
codeforces

Note

In the first test case, such strings t are suitable: "aac', "aab".

In the second test case, such trings t are suitable: "a", "b", "c".

In the third test case, only the string t equals to "aba" is suitable, but the character 'b' can be from the second or third position.
Difficulty: 10
Solutions: t=int(input())
for i in range(t):
    s=input()
    b=[]
    d=dict()
    for j in s:
        if j in d.keys():
            d[j]+=1
        else:
            b.append(j)
            d[j]=1
    b.sort(reverse=True)
    n=int(input())
    a=list(map(int,input().split()))
    c=["a"]*(n)
    m=1
    f=dict()
    p=0
    while(m<=n):
        j=0
        k=[]
        while(j<n):
            if a[j]==0 and j not in f.keys():
                f[j]=1
                k.append(j)
            j+=1
        while(p<len(b)):
            if d[b[p]]<len(k):
                p+=1
            else:
                for i in k:
                    c[i]=b[p]
                p+=1
                break
        j=0
        while (j < n):
            if j not in f.keys():
                for i in k:
                    a[j]+=-(abs(i-j))
            j+=1

        m+=len(k)

    print("".join(c))






INSTRUCTIONS:
Solve the current question.
Provide:
1. A complete and efficient code solution, optimized for both time and space complexity.
2. A detailed explanation of the solution, including:
   - The intuition behind the approach;
   - Time and space complexity;
   - Important considerations about the algorithm.
3. Use the similar questions as references to improve the solution, but only if they are relevant.
4. Don't use any external libraries. Any language is accepted.