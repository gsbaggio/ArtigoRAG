CURRENT QUESTION:
n players are playing a game. 

There are two different maps in the game. For each player, we know his strength on each map. When two players fight on a specific map, the player with higher strength on that map always wins. No two players have the same strength on the same map. 

You are the game master and want to organize a tournament. There will be a total of n-1 battles. While there is more than one player in the tournament, choose any map and any two remaining players to fight on it. The player who loses will be eliminated from the tournament. 

In the end, exactly one player will remain, and he is declared the winner of the tournament. For each player determine if he can win the tournament.

Input

The first line contains a single integer t (1 ≤ t ≤ 100) — the number of test cases. The description of test cases follows.

The first line of each test case contains a single integer n (1 ≤ n ≤ 10^5) — the number of players.

The second line of each test case contains n integers a_1, a_2, ..., a_n (1 ≤ a_i ≤ 10^9, a_i ≠ a_j for i ≠ j), where a_i is the strength of the i-th player on the first map. 

The third line of each test case contains n integers b_1, b_2, ..., b_n (1 ≤ b_i ≤ 10^9, b_i ≠ b_j for i ≠ j), where b_i is the strength of the i-th player on the second map. 

It is guaranteed that the sum of n over all test cases does not exceed 10^5.

Output

For each test case print a string of length n. i-th character should be "1" if the i-th player can win the tournament, or "0" otherwise.

Example

Input


3
4
1 2 3 4
1 2 3 4
4
11 12 20 21
44 22 11 30
1
1000000000
1000000000


Output


0001
1111
1

Note

In the first test case, the 4-th player will beat any other player on any game, so he will definitely win the tournament.

In the second test case, everyone can be a winner. 

In the third test case, there is only one player. Clearly, he will win the tournament.

SIMILAR QUESTIONS:
Similar question 1 (Similarity score: 0.75):
Name: 1535_A. Fair Playoff
Tags: ['brute force', 'implementation']
Description: Four players participate in the playoff tournament. The tournament is held according to the following scheme: the first player will play with the second, and the third player with the fourth, then the winners of the pairs will play in the finals of the tournament.

It is known that in a match between two players, the one whose skill is greater will win. The skill of the i-th player is equal to s_i and all skill levels are pairwise different (i. e. there are no two identical values in the array s).

The tournament is called fair if the two players with the highest skills meet in the finals.

Determine whether the given tournament is fair.

Input

The first line contains a single integer t (1 ≤ t ≤ 10^4) — the number of test cases.

A single line of test case contains four integers s_1, s_2, s_3, s_4 (1 ≤ s_i ≤ 100) — skill of the players. It is guaranteed that all the numbers in the array are different.

Output

For each testcase, output YES if the tournament is fair, or NO otherwise.

Example

Input


4
3 7 9 5
4 5 6 9
5 3 8 1
6 5 3 2


Output


YES
NO
YES
NO

Note

Consider the example:

  1. in the first test case, players 2 and 3 with skills 7 and 9 advance to the finals; 
  2. in the second test case, players 2 and 4 with skills 5 and 9 advance to the finals. The player with skill 6 does not advance, but the player with skill 5 advances to the finals, so the tournament is not fair; 
  3. in the third test case, players 1 and 3 with skills 5 and 8 advance to the finals; 
  4. in the fourth test case, players 1 and 3 with skills 6 and 3 advance to the finals. The player with skill 5 does not advance, but the player with skill 3 advances to the finals, so the tournament is not fair. 
Difficulty: 7
Solutions: import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.PrintWriter;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.StringTokenizer;

public class Solve {

	static int mod = 1000000000 + 7;
	static long INF = 1000_000_000_000_000L + 100;

	public static void main(String[] args) throws Exception {
		Scanner sc = new Scanner();
		PrintWriter pw = new PrintWriter(System.out);

		int t = sc.nextInt();
		while (t-- > 0) {
			int a[] = new int[4];
			int s1 = sc.nextInt();
			int s2 = sc.nextInt();

			int s3 = sc.nextInt();
			int s4 = sc.nextInt();
			a[0] = s1;
			a[1] = s2;
			a[2] = s3;
			a[3] = s4;
			Arrays.sort(a);
			int x = Math.max(s1, s2);
			int y = Math.max(s3, s4);
			boolean valid = true;
			if (a[2] != x && a[2] != y)
				valid = false;

			if (a[3] != x && a[3] != y)
				valid = false;

			pw.println(valid ? "YES" : "NO");

		}

		pw.flush();

	}

	static public boolean[] sieve(int n) {
		boolean prime[] = new boolean[n + 1];
		for (int i = 0; i <= n; i++)
			prime[i] = true;

		for (int p = 2; p * p <= n; p++) {
			// If prime[p] is not changed, then it is a
			// prime
			if (prime[p] == true) {
				// Update all multiples of p
				for (int i = p * p; i <= n; i += p)
					prime[i] = false;
			}
		}
		return prime;

	}

	static boolean isPalindrome(String str) {

		// Pointers pointing to the beginning
		// and the end of the string
		int i = 0, j = str.length() - 1;

		// While there are characters to compare
		while (i < j) {

			// If there is a mismatch
			if (str.charAt(i) != str.charAt(j))
				return false;

			// Increment first pointer and
			// decrement the other
			i++;
			j--;
		}

		// Given string is a palindrome
		return true;
	}

	public static int primeFactors(int n) {
		int count = 0;
		// Print the number of 2s that divide n
		while (n % 2 == 0) {
			n /= 2;
		}

		if (n == 1)
			return 0;

		// n must be odd at this point. So we can
		// skip one element (Note i = i +2)
		for (int i = 3; i <= Math.sqrt(n); i += 2) {
			// While i divides n, print i and divide n
			while (n % i == 0) {
				n /= i;
				count++;
			}
		}

		if (n > 1)
			count++;

		return count;

	}

	static int gcd(int a, int b) {
		if (a == 0)
			return b;
		if (b == 0)
			return a;

		return gcd(b, a % b);

	}

	public static int[] swap(int data[], int left, int right) {

		// Swap the data
		int temp = data[left];
		data[left] = data[right];
		data[right] = temp;

		// Return the updated array
		return data;
	}

	static long nCrModp(int n, int r, int p) {
		if (r > n - r)
			r = n - r;

		// The array C is going to store last
		// row of pascal triangle at the end.
		// And last entry of last row is nCr
		int C[] = new int[r + 1];

		C[0] = 1; // Top row of Pascal Triangle

		// One by constructs remaining rows of Pascal
		// Triangle from top to bottom
		for (int i = 1; i <= n; i++) {

			// Fill entries of current row using previous
			// row values
			for (int j = Math.min(i, r); j > 0; j--)

				// nCj = (n-1)Cj + (n-1)C(j-1);
				C[j] = (C[j] + C[j - 1]) % p;
		}
		return C[r];
	}

	static void sort(int[] a) {
		ArrayList<Integer> l = new ArrayList<>();
		for (int i : a)
			l.add(i);
		Collections.sort(l);
		for (int i = 0; i < a.length; i++)
			a[i] = l.get(i);
	}

}

class Pair implements Comparable<Pair> {
	int tower;
	int value = 0;

	Pair(int x, int y) {
		tower = x;
		value = y;
	}

	public int compareTo(Pair o) {
		return this.value - o.value;
	}

}

class Scanner {
	BufferedReader br;
	StringTokenizer st;

	Scanner() {
		br = new BufferedReader(new InputStreamReader(System.in));
	}

	String next() throws IOException {
		while (st == null || !st.hasMoreElements())
			st = new StringTokenizer(br.readLine());
		return st.nextToken();
	}

	int nextInt() throws NumberFormatException, IOException {
		return Integer.parseInt(next());
	}

	int[] nextIntArray(int n) throws NumberFormatException, IOException {
		int a[] = new int[n];
		for (int i = 0; i < n; i++)
			a[i] = Integer.parseInt(next());
		return a;
	}

	long nextLong() throws NumberFormatException, IOException {
		return Long.parseLong(next());
	}

	long[] nextLongArray(int n) throws NumberFormatException, IOException {
		long a[] = new long[n];
		for (int i = 0; i < n; i++)
			a[i] = Long.parseLong(next());
		return a;
	}

	double nextDouble() throws NumberFormatException, IOException {
		return Double.parseDouble(next());
	}
}

Similar question 2 (Similarity score: 0.75):
Name: 1487_A. Arena
Tags: ['implementation', 'sortings']
Description: n heroes fight against each other in the Arena. Initially, the i-th hero has level a_i.

Each minute, a fight between two different heroes occurs. These heroes can be chosen arbitrarily (it's even possible that it is the same two heroes that were fighting during the last minute).

When two heroes of equal levels fight, nobody wins the fight. When two heroes of different levels fight, the one with the higher level wins, and his level increases by 1.

The winner of the tournament is the first hero that wins in at least 100^{500} fights (note that it's possible that the tournament lasts forever if no hero wins this number of fights, then there is no winner). A possible winner is a hero such that there exists a sequence of fights that this hero becomes the winner of the tournament.

Calculate the number of possible winners among n heroes.

Input

The first line contains one integer t (1 ≤ t ≤ 500) — the number of test cases.

Each test case consists of two lines. The first line contains one integer n (2 ≤ n ≤ 100) — the number of heroes. The second line contains n integers a_1, a_2, ..., a_n (1 ≤ a_i ≤ 100), where a_i is the initial level of the i-th hero.

Output

For each test case, print one integer — the number of possible winners among the given n heroes.

Example

Input


3
3
3 2 2
2
5 5
4
1 3 3 7


Output


1
0
3

Note

In the first test case of the example, the only possible winner is the first hero.

In the second test case of the example, each fight between the heroes results in nobody winning it, so the tournament lasts forever and there is no winner.
Difficulty: 7
Solutions: tests = int(input())
for t in range(tests):
    n = int(input())
    heroes = list(map(int, input().split(' ')))
    
    m = min(heroes)
    print(sum([1 for x in heroes if x > m]))

Similar question 3 (Similarity score: 0.73):
Name: p03406 AtCoder Regular Contest 093 - Dark Horse
Tags: ['']
Description: There are 2^N players, numbered 1, 2, ..., 2^N. They decided to hold a tournament.

The tournament proceeds as follows:

* Choose a permutation of 1, 2, ..., 2^N: p_1, p_2, ..., p_{2^N}.
* The players stand in a row in the order of Player p_1, Player p_2, ..., Player p_{2^N}.
* Repeat the following until there is only one player remaining in the row:
* Play the following matches: the first player in the row versus the second player in the row, the third player versus the fourth player, and so on. The players who lose leave the row. The players who win stand in a row again, preserving the relative order of the players.
* The last player who remains in the row is the champion.



It is known that, the result of the match between two players can be written as follows, using M integers A_1, A_2, ..., A_M given as input:

* When y = A_i for some i, the winner of the match between Player 1 and Player y (2 \leq y \leq 2^N) will be Player y.
* When y \neq A_i for every i, the winner of the match between Player 1 and Player y (2 \leq y \leq 2^N) will be Player 1.
* When 2 \leq x < y \leq 2^N, the winner of the match between Player x and Player y will be Player x.



The champion of this tournament depends only on the permutation p_1, p_2, ..., p_{2^N} chosen at the beginning. Find the number of permutation p_1, p_2, ..., p_{2^N} chosen at the beginning of the tournament that would result in Player 1 becoming the champion, modulo 10^9 + 7.

Constraints

* 1 \leq N \leq 16
* 0 \leq M \leq 16
* 2 \leq A_i \leq 2^N (1 \leq i \leq M)
* A_i < A_{i + 1} (1 \leq i < M)

Input

Input is given from Standard Input in the following format:


N M
A_1 A_2 ... A_M


Output

Print the answer.

Examples

Input

2 1
3


Output

8


Input

4 3
2 4 6


Output

0


Input

3 0


Output

40320


Input

3 3
3 4 7


Output

2688


Input

16 16
5489 5490 5491 5492 5493 5494 5495 5497 18993 18995 18997 18999 19000 19001 19002 19003


Output

816646464
Difficulty: 0
Solutions: #include <cstdio>
#include <cstdlib>
#include <algorithm>
#include <vector>
#include <cstring>
#define SIZE 18
#define BT (1<<18)
#define MX 100005
#define MOD 1000000007

using namespace std;
typedef long long int ll;
typedef pair <int,int> P;

ll fac[MX],finv[MX],inv[MX];
int A[SIZE];
ll dp[2][BT];

void make()
{
	fac[0]=fac[1]=1;
	finv[0]=finv[1]=1;
	inv[1]=1;
	for(int i=2;i<MX;i++)
	{
		inv[i]=MOD-inv[MOD%i]*(MOD/i)%MOD;
		fac[i]=fac[i-1]*(ll) i%MOD;
		finv[i]=finv[i-1]*inv[i]%MOD;
	}
}
ll C(int a,int b)
{
	if(a<b) return 0;
	return fac[a]*(finv[b]*finv[a-b]%MOD)%MOD;
}
int main()
{
	make();
	int n,m;
	scanf("%d %d",&n,&m);
	for(int i=0;i<m;i++) scanf("%d",&A[i]);
	int pos=0;
	memset(dp[pos],0,sizeof(dp[pos]));
	dp[pos][0]=1;
	for(int i=m-1;i>=0;i--)
	{
		pos^=1;
		memset(dp[pos],0,sizeof(dp[pos]));
		for(int S=0;S<1<<n;S++)
		{
			if(dp[pos^1][S]==0) continue;
			dp[pos][S]+=dp[pos^1][S];
			if(dp[pos][S]>=MOD) dp[pos][S]-=MOD;
			int zan=(1<<n)-A[i]+1;
			for(int j=0;j<n;j++) if(S>>j&1) zan-=(1<<j);
			for(int j=0;j<n;j++)
			{
				if(!(S>>j&1)&&zan>=(1<<j))
				{
					dp[pos][S|(1<<j)]+=dp[pos^1][S]*C(zan-1,(1<<j)-1)%MOD*fac[1<<j]%MOD;
					if(dp[pos][S|(1<<j)]>=MOD) dp[pos][S|(1<<j)]-=MOD;
				}
			}
		}
	}
	ll all=0;
	for(int S=0;S<1<<n;S++)
	{
		ll way=dp[pos][S];
		int zan=(1<<n)-1;
		int sgn=1;
		for(int i=0;i<n;i++)
		{
			if(S>>i&1)
			{
				zan-=(1<<i);
				sgn*=-1;
			}
		}
		way=way*fac[zan]%MOD;
		//if(way!=0) printf("%d %lld\n",S,way);
		all+=(ll) sgn*way;
		all+=MOD;
		all%=MOD;
	}
	printf("%lld\n",all*(1<<n)%MOD);
	return 0;
}



INSTRUCTIONS:
Solve the current question.
Provide:
1. A complete and efficient code solution, optimized for both time and space complexity.
2. A detailed explanation of the solution, including:
   - The intuition behind the approach;
   - Time and space complexity;
   - Important considerations about the algorithm.
3. If the language has classes, implement in 'Solution' class. Any language is accepted.
4. Use the similar questions as references to improve the solution, but only if they are relevant.
5. Don't use any external libraries. Don't need to import any libraries.
