CURRENT QUESTION:
n players are playing a game. 

There are two different maps in the game. For each player, we know his strength on each map. When two players fight on a specific map, the player with higher strength on that map always wins. No two players have the same strength on the same map. 

You are the game master and want to organize a tournament. There will be a total of n-1 battles. While there is more than one player in the tournament, choose any map and any two remaining players to fight on it. The player who loses will be eliminated from the tournament. 

In the end, exactly one player will remain, and he is declared the winner of the tournament. For each player determine if he can win the tournament.

Input

The first line contains a single integer t (1 ≤ t ≤ 100) — the number of test cases. The description of test cases follows.

The first line of each test case contains a single integer n (1 ≤ n ≤ 10^5) — the number of players.

The second line of each test case contains n integers a_1, a_2, ..., a_n (1 ≤ a_i ≤ 10^9, a_i ≠ a_j for i ≠ j), where a_i is the strength of the i-th player on the first map. 

The third line of each test case contains n integers b_1, b_2, ..., b_n (1 ≤ b_i ≤ 10^9, b_i ≠ b_j for i ≠ j), where b_i is the strength of the i-th player on the second map. 

It is guaranteed that the sum of n over all test cases does not exceed 10^5.

Output

For each test case print a string of length n. i-th character should be "1" if the i-th player can win the tournament, or "0" otherwise.

Example

Input


3
4
1 2 3 4
1 2 3 4
4
11 12 20 21
44 22 11 30
1
1000000000
1000000000


Output


0001
1111
1

Note

In the first test case, the 4-th player will beat any other player on any game, so he will definitely win the tournament.

In the second test case, everyone can be a winner. 

In the third test case, there is only one player. Clearly, he will win the tournament.

EXAMPLE QUESTIONS:
Example question 1:
Name: 298_D. Fish Weight
Tags: ['constructive algorithms', 'greedy']
Description: It is known that there are k fish species in the polar ocean, numbered from 1 to k. They are sorted by non-decreasing order of their weight, which is a positive number. Let the weight of the i-th type of fish be wi, then 0 < w1 ≤ w2 ≤ ... ≤ wk holds.

Polar bears Alice and Bob each have caught some fish, and they are guessing who has the larger sum of weight of the fish he/she's caught. Given the type of the fish they've caught, determine whether it is possible that the fish caught by Alice has a strictly larger total weight than Bob's. In other words, does there exist a sequence of weights wi (not necessary integers), such that the fish caught by Alice has a strictly larger total weight?

Input

The first line contains three integers n, m, k (1 ≤ n, m ≤ 105, 1 ≤ k ≤ 109) — the number of fish caught by Alice and Bob respectively, and the number of fish species.

The second line contains n integers each from 1 to k, the list of fish type caught by Alice. The third line contains m integers each from 1 to k, the list of fish type caught by Bob.

Note that one may have caught more than one fish for a same species.

Output

Output "YES" (without quotes) if it is possible, and "NO" (without quotes) otherwise.

Examples

Input

3 3 3
2 2 2
1 1 3


Output

YES


Input

4 7 9
5 2 7 3
3 5 2 7 3 8 7


Output

NO

Note

In the first sample, if w1 = 1, w2 = 2, w3 = 2.5, then Alice has a total of 2 + 2 + 2 = 6 weight units, while Bob only has 1 + 1 + 2.5 = 4.5.

In the second sample, the fish that Alice caught is a subset of Bob's. Therefore, the total weight of Bob’s fish is always not less than the total weight of Alice’s fish.
Difficulty: 10
Solutions: //package com.congli.codeforces;

import java.io.*;
import java.util.*;

public class C180Div2D_FishWeight {

	BufferedReader in;
	PrintWriter out;
	StringTokenizer tok = new StringTokenizer("");

	public static void main(String[] args) {
		C180Div2D_FishWeight test = new C180Div2D_FishWeight();
		test.start();
	}

	public void solve() throws IOException 
	{
		int n = readInt();
		int m = readInt();
		int k = readInt();
		
		Hash[] hash = new Hash[m+n+10];
		HashMap<Integer, Integer> map = new HashMap<Integer, Integer>();
		
		int hash_ind = 0;
		int weight = 0;
		for(int i = 0; i < n; ++i)
		{
			weight = readInt();
			if(map.containsKey(weight))
				hash[map.get(weight)].count++;
			else
			{
				map.put(weight, hash_ind);
				hash[hash_ind++] = new Hash(weight, 1);
			}
		}
		
		for(int i = 0; i < m; ++i)
		{
			weight = readInt();
			if(map.containsKey(weight))
				hash[map.get(weight)].count--;
			else
			{
				map.put(weight, hash_ind);
				hash[hash_ind++] = new Hash(weight, -1);
			}
		}
		
		while(hash_ind < hash.length)
			hash[hash_ind++] = new Hash(0, 0);
		
		Arrays.sort(hash);
		calculate(hash);
	}
	
	public void calculate(Hash[] hash)
	{
		int i = 0;
		if(hash[0].count > 0)
		{
			out.println("YES");
			return;
		}
		
		int count_plus = 0, count_minus = 0;
		while(i < hash.length && hash[i].key > 0)
		{
			while(i < hash.length && hash[i].count <= 0)
				count_minus -= hash[i++].count;
			
			//count_minus = -count_minus;
			
			while(i < hash.length && hash[i].count >= 0)
				count_plus += hash[i++].count;
			
			if(count_plus > count_minus)
			{
				out.println("YES");
				return;
			}
			
			/*else if(count_plus < count_minus)
			{
				out.println("NO");
				return;
			}*/
		}
		
		out.println("NO");
	}
	
	class Hash implements Comparable<Hash>
	{
		int key;
		int count;
		public Hash(int key, int count)
		{
			this.key = key;
			this.count = count;
		}
		@Override
		public int compareTo(Hash o) {
			// TODO Auto-generated method stub
			return o.key - this.key;
		}

		
	}
	
	public void start()
	{
		try {
			long t1 = System.currentTimeMillis();
			if (System.getProperty("ONLINE_JUDGE") != null) {
				in = new BufferedReader(new InputStreamReader(System.in));
				out = new PrintWriter(System.out);
			} else {
				in = new BufferedReader(new FileReader("..\\Codeforces\\src\\com\\congli\\codeforces\\input.txt"));
				out = new PrintWriter(System.out);
			}
			Locale.setDefault(Locale.US);
			solve();
			in.close();
			out.close();
			long t2 = System.currentTimeMillis();
			System.err.println("Time = " + (t2 - t1));
		} catch (Throwable t) {
			t.printStackTrace(System.err);
			System.exit(-1);
		}
	}
	
	public String readString() throws IOException {
		while (!tok.hasMoreTokens()) {
			tok = new StringTokenizer(in.readLine());
		}
		return tok.nextToken();
	}

	public int readInt() throws IOException {
		return Integer.parseInt(readString());
	}

	public long readLong() throws IOException {
		return Long.parseLong(readString());
	}

	public double readDouble() throws IOException {
		return Double.parseDouble(readString());
	}
}


Example question 2:
Name: p01682 Shipura
Tags: ['']
Description: Problem Statement

Dr. Suposupo developed a programming language called Shipura. Shipura supports only one binary operator ${\tt >>}$ and only one unary function ${\tt S<\ >}$.

$x {\tt >>} y$ is evaluated to $\lfloor x / 2^y \rfloor$ (that is, the greatest integer not exceeding $x / 2^y$), and ${\tt S<} x {\tt >}$ is evaluated to $x^2 \bmod 1{,}000{,}000{,}007$ (that is, the remainder when $x^2$ is divided by $1{,}000{,}000{,}007$).

The operator ${\tt >>}$ is left-associative. For example, the expression $x {\tt >>} y {\tt >>} z$ is interpreted as $(x {\tt >>} y) {\tt >>} z$, not as $x {\tt >>} (y {\tt >>} z)$. Note that these parentheses do not appear in actual Shipura expressions.

The syntax of Shipura is given (in BNF; Backus-Naur Form) as follows:


expr   ::= term | expr sp ">>" sp term
term   ::= number | "S" sp "<" sp expr sp ">"
sp     ::= "" | sp " "
number ::= digit | number digit
digit  ::= "0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9"

The start symbol of this syntax is $\tt expr$ that represents an expression in Shipura. In addition, $\tt number$ is an integer between $0$ and $1{,}000{,}000{,}000$ inclusive, written without extra leading zeros.

Write a program to evaluate Shipura expressions.

Input

The input is a sequence of datasets. Each dataset is represented by a line which contains a valid expression in Shipura.

A line containing a single ${\tt \\#}$ indicates the end of the input. You can assume the number of datasets is at most $100$ and the total size of the input file does not exceed $2{,}000{,}000$ bytes.

Output

For each dataset, output a line containing the evaluated value of the expression.

Sample Input


S< S< 12 >> 2 > >
123 >> 1 >> 1
1000000000   >>129
S<S<S<S<S<2>>>>>
S  <S< S<2013    >>> 11 >>> 10 >


Output for the Sample Input


81
30
0
294967268
14592400





Example

Input

S< S< 12 >> 2 > >
123 >> 1 >> 1
1000000000   >>129
S<S<S<S<S<2>>>>>
S  <S< S<2013    >>> 11 >>> 10 >
#


Output

81
30
0
294967268
14592400
Difficulty: 0
Solutions: #include <iostream>
#include <string>
#include <cctype>
using namespace std;
typedef string::const_iterator State;
typedef long long ll;
ll mod=1000000007;
string s;
ll expression(State &begin);			//term or expr >> term
ll term(State &begin);					//num or S<expr>
ll number(State &begin);				//
string as(State &begin){
	string hoge;
	for(State st=s.begin();st!=s.end();st++){
		if(st==begin) hoge=hoge+" "+(*st)+" "; 
		else hoge+=(*st);
	}
	return hoge;
}
ll expression(State &begin){
//	cout << "expr  " << as(begin) << endl;
	ll ret=term(begin);
	if(*begin == '>'){
		begin--;	//>
//		if(*begin!='>') cout << "> " << as(begin) << endl;
		begin--;
		if(ret>40) ret=0*expression(begin);
		else ret=expression(begin) >> ret;
	}
	return ret;
}
ll term(State &begin){
//	cout << "term  " << as(begin) << endl;
	if(*begin == '>'){
		begin--;
		ll ret=expression(begin);
		ret*=ret;
		ret%=mod;
//		if(*begin!='<') cout << "< " << as(begin) << endl;
		begin--;	//S
//		if(*begin!='S') cout << "S " << as(begin) << endl;
//		cout << "t erm " << as(begin) << endl;
		begin--;
		return ret;
	}else{
		return number(begin);
	}
}
ll number(State &begin){
//	cout << "num   " << as(begin) << endl;
	ll ret=0,dig=1;
	while(isdigit(*begin)){
		ret+=dig*(*begin-'0');
		begin--;
		dig*=10;
	}
//	cout << "n um  " << as(begin) << endl;
	return ret;
}
int main(){
	for(;;){
		getline(cin,s);
		if(s[0]=='#') break;
		s="?"+s;
		string::iterator it;
		for(it=s.begin();it!=s.end();it++){
			if((*it)==' '){
				s.erase(it);
				it--;
			}
		}
		State begin=s.end();
		begin--;
		ll ans=expression(begin);
		cout << ans << endl;
	}
	return 0;
}


INSTRUCTIONS:
Solve the current question.
Provide:
1. A complete and efficient code solution, optimized for both time and space complexity.
2. A detailed explanation of the solution, including:
   - The intuition behind the approach;
   - Time and space complexity;
   - Important considerations about the algorithm.
3. If the language has classes, implement in 'Solution' class. Any language is accepted.
4. You can use the example questions as general references for coding patterns and structure, but solve the current problem independently.
5. Don't use any external libraries. Don't need to import any libraries.
