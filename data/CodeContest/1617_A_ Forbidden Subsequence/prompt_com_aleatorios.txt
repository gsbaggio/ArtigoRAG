CURRENT QUESTION:
You are given strings S and T, consisting of lowercase English letters. It is guaranteed that T is a permutation of the string abc. 

Find string S', the lexicographically smallest permutation of S such that T is not a subsequence of S'.

String a is a permutation of string b if the number of occurrences of each distinct character is the same in both strings.

A string a is a subsequence of a string b if a can be obtained from b by deletion of several (possibly, zero or all) elements.

A string a is lexicographically smaller than a string b if and only if one of the following holds:

  * a is a prefix of b, but a ≠ b;
  * in the first position where a and b differ, the string a has a letter that appears earlier in the alphabet than the corresponding letter in b.

Input

Each test contains multiple test cases. The first line contains a single integer t (1 ≤ t ≤ 1000) — the number of test cases. Description of the test cases follows.

The first line of each test case contains a string S (1 ≤ |S| ≤ 100), consisting of lowercase English letters.

The second line of each test case contains a string T that is a permutation of the string abc. (Hence, |T| = 3).

Note that there is no limit on the sum of |S| across all test cases.

Output

For each test case, output a single string S', the lexicographically smallest permutation of S such that T is not a subsequence of S'.

Example

Input


7
abacaba
abc
cccba
acb
dbsic
bac
abracadabra
abc
dddddddddddd
cba
bbc
abc
ac
abc


Output


aaaacbb
abccc
bcdis
aaaaacbbdrr
dddddddddddd
bbc
ac

Note

In the first test case, both aaaabbc and aaaabcb are lexicographically smaller than aaaacbb, but they contain abc as a subsequence.

In the second test case, abccc is the smallest permutation of cccba and does not contain acb as a subsequence.

In the third test case, bcdis is the smallest permutation of dbsic and does not contain bac as a subsequence.

EXAMPLE QUESTIONS:
Example question 1:
Name: 57_B. Martian Architecture
Tags: ['implementation']
Description: Chris the Rabbit found the traces of an ancient Martian civilization. The brave astronomer managed to see through a small telescope an architecture masterpiece — "A Road to the Sun". The building stands on cubical stones of the same size. The foundation divides the entire "road" into cells, into which the cubical stones are fit tightly. Thus, to any cell of the foundation a coordinate can be assigned. To become the leader of the tribe, a Martian should build a Road to the Sun, that is to build from those cubical stones on a given foundation a stairway. The stairway should be described by the number of stones in the initial coordinate and the coordinates of the stairway's beginning and end. Each following cell in the coordinate's increasing order should contain one cubical stone more than the previous one. At that if the cell has already got stones, they do not count in this building process, the stairways were simply built on them. In other words, let us assume that a stairway is built with the initial coordinate of l, the final coordinate of r and the number of stones in the initial coordinate x. That means that x stones will be added in the cell l, x + 1 stones will be added in the cell l + 1, ..., x + r - l stones will be added in the cell r.

Chris managed to find an ancient manuscript, containing the descriptions of all the stairways. Now he wants to compare the data to be sure that he has really found "A Road to the Sun". For that he chose some road cells and counted the total number of cubical stones that has been accumulated throughout the Martian history and then asked you to count using the manuscript to what the sum should ideally total.

Input

The first line contains three space-separated integers: n, m, k (1 ≤ n, m ≤ 105, 1 ≤ k ≤ min(n, 100)) which is the number of cells, the number of "Roads to the Sun" and the number of cells in the query correspondingly. Each of the following m roads contain three space-separated integers: ai, bi, ci (1 ≤ ai ≤ bi ≤ n, 1 ≤ ci ≤ 1000) which are the stairway's description, its beginning, end and the initial cell's height. Then follow a line, containing k different space-separated integers bi. All these numbers ranging from 1 to n are cells, the number of stones in which interests Chris.

Output

You have to print a single number on a single line which is the sum of stones in all the cells Chris is interested in.

Please, do not use %lld specificator to read or write 64-bit integers in C++. It is preffered to use cin (also you may use %I64d).

Examples

Input

5 2 1
1 5 1
2 4 1
3


Output

5


Input

3 2 1
1 3 1
1 3 1
2


Output

4


Input

3 2 1
1 3 1
1 3 1
3


Output

6
Difficulty: 8
Solutions: #include <bits/stdc++.h>
long long k, n, m, i, ans, j, d, a[100009], b[100009], c[100009];
int main() {
  scanf("%I64d%I64d%I64d", &n, &m, &k);
  for (i = 0; i < m; i++) scanf("%I64d%I64d%I64d", &a[i], &b[i], &c[i]);
  for (i = 0; i < k; i++) {
    scanf("%I64d", &d);
    for (j = 0; j < m; j++)
      if (a[j] <= d && d <= b[j]) ans += d - a[j] + c[j];
  }
  printf("%I64d", ans);
}


Example question 2:
Name: 1070_M. Algoland and Berland
Tags: ['constructive algorithms', 'divide and conquer', 'geometry']
Description: Once upon a time Algoland and Berland were a single country, but those times are long gone. Now they are two different countries, but their cities are scattered on a common territory.

All cities are represented as points on the Cartesian plane. Algoland consists of a cities numbered from 1 to a. The coordinates of the i-th Algoland city are a pair of integer numbers (xa_i, ya_i). Similarly, Berland consists of b cities numbered from 1 to b. The coordinates of the j-th Berland city are a pair of integer numbers (xb_j, yb_j). No three of the a+b mentioned cities lie on a single straight line.

As the first step to unite the countries, Berland decided to build several bidirectional freeways. Each freeway is going to be a line segment that starts in a Berland city and ends in an Algoland city. Freeways can't intersect with each other at any point except freeway's start or end. Moreover, the freeways have to connect all a+b cities. Here, connectivity means that one can get from any of the specified a+b cities to any other of the a+b cities using freeways. Note that all freeways are bidirectional, which means that one can drive on each of them in both directions.

Mayor of each of the b Berland cities allocated a budget to build the freeways that start from this city. Thus, you are given the numbers r_1, r_2, ..., r_b, where r_j is the number of freeways that are going to start in the j-th Berland city. The total allocated budget is very tight and only covers building the minimal necessary set of freeways. In other words, r_1+r_2+...+r_b=a+b-1.

Help Berland to build the freeways so that:

  * each freeway is a line segment connecting a Berland city and an Algoland city, 
  * no freeways intersect with each other except for the freeway's start or end, 
  * freeways connect all a+b cities (all freeways are bidirectional), 
  * there are r_j freeways that start from the j-th Berland city. 

Input

Input contains one or several test cases. The first input line contains a single integer number t (1 ≤ t ≤ 3000) — number of test cases. Then, t test cases follow. Solve test cases separately, test cases are completely independent and do not affect each other.

Each test case starts with a line containing space-separated integers a and b (1 ≤ a, b ≤ 3000) — numbers of Algoland cities and number of Berland cities correspondingly.

The next line contains b space-separated integers r_1, r_2, ..., r_b (1 ≤ r_b ≤ a) where r_j is the number of freeways, that should start in the j-th Berland city. It is guaranteed that r_1+r_2+...+r_b=a+b-1.

The next a lines contain coordinates of the Algoland cities — pairs of space-separated integers xa_i, ya_i (-10000 ≤ xa_i, ya_i ≤ 10000). The next b lines contain coordinates of the Berland cities — pairs of space-separated integers xb_i, yb_i (-10000 ≤ xb_i, yb_i ≤ 10000). All cities are located at distinct points, no three of the a+b cities lie on a single straight line.

Sum of values a across all test cases doesn't exceed 3000. Sum of values b across all test cases doesn't exceed 3000.

Output

For each of the t test cases, first print "YES" if there is an answer or "NO" otherwise.

If there is an answer, print the freeway building plan in the next a+b-1 lines. Each line of the plan should contain two space-separated integers j and i which means that a freeway from the j-th Berland city to the i-th Algoland city should be built. If there are multiple solutions, print any.

Example

Input

2
2 3
1 1 2
0 0
1 1
1 2
3 2
4 0
1 1
1
0 0
0 1


Output

YES
2 2
1 2
3 2
3 1
YES
1 1
Difficulty: 20
Solutions: #include <bits/stdc++.h>
using namespace std;
inline int read() {
  int n = 0, f = 1;
  char c;
  for (c = getchar(); c != '-' && (c < '0' || c > '9'); c = getchar())
    ;
  if (c == '-') c = getchar(), f = -1;
  for (; c >= '0' && c <= '9'; c = getchar()) n = n * 10 + c - 48;
  return n * f;
}
struct ar {
  int x, y, id, d;
} now;
bool operator<(ar a, ar b) { return a.x == b.x ? a.y < b.y : a.x < b.x; }
int i, a, b, d[3005];
vector<ar> p, an;
bool cmp(ar a, ar b) { return a.x * b.y > a.y * b.x; }
void solve(vector<ar> p) {
  int i, j, k, D, n = p.size() - 1;
  if (!n) return;
  for (i = 1; i <= n; i++)
    if (p[i] < p[0]) swap(p[i], p[0]);
  for (i = 1; i <= n; i++) p[i].x -= p[0].x, p[i].y -= p[0].y;
  sort(p.begin() + 1, p.end(), cmp);
  for (i = 1; i <= n; i++) p[i].x += p[0].x, p[i].y += p[0].y;
  if (p[0].d < 0) {
    for (i = 1; i <= n; i++) {
      j = i, D = 0;
      for (;; i++) {
        D += p[i].d;
        if (D >= 0) break;
      }
      p[i].d--, an.push_back((ar){p[i].id, p[0].id});
      p[i].d -= D;
      solve(vector<ar>(p.begin() + j, p.begin() + i + 1));
      p[j = i].d = D - 1;
      for (; D;) D += p[++i].d;
      solve(vector<ar>(p.begin() + j, p.begin() + i + 1));
    }
    return;
  }
  for (i = 1; p[0].d >= 0;) {
    for (j = i, D = 1; D; i++) D += p[i].d;
    p[0].d--, an.push_back((ar){p[0].id, p[i - 1].id});
    solve(vector<ar>(p.begin() + j, p.begin() + i));
  }
  solve(vector<ar>(p.begin() + i - 1, p.end()));
}
void work() {
  a = read(), b = read();
  for (i = 1; i <= b; i++) d[i] = read();
  p.clear(), an.clear();
  for (i = 1; i <= a + b; i++) {
    now.x = read(), now.y = read();
    if (i <= a)
      now.id = i, now.d = -1;
    else
      now.d = d[now.id = i - a] - 1;
    p.push_back(now);
  }
  solve(p);
  puts("YES");
  for (i = 0; i <= a + b - 2; i++) printf("%d %d\n", an[i].x, an[i].y);
}
int main() {
  for (int t = read(); t--;) work();
}


Example question 3:
Name: sort-the-array-5
Tags: []
Description: You have been given an array A of size N and an integer K. This array consists of N integers ranging from 1 to 10^7. Each element in this array is said to have a Special Weight. The special weight of an element a[i] is a[i]\%K.

You now need to sort this array in Non-Increasing order of the weight of each element, i.e the element with the highest weight should appear first, then the element with the second highest weight and so on. In case two elements have the same weight, the one with the lower value should appear in the output first. 

Input Format:

The first line consists of two space separated integers N and K. The next line consists of N space separated integers denoting the elements of array A. 

Output Format:

Print N space separated integers denoting the elements of the array in the order in which they are required.

Constraints:

 1 ≤ N ≤ 10^5 

 1 ≤ A[i] ≤ 10^7 

 1 ≤ K ≤ 10^7 

Note:

You need to print the value of each element and not their weight. 

SAMPLE INPUT
5 2
1 2 3 4 5

SAMPLE OUTPUT
1 3 5 2 4
Difficulty: 0
Solutions: import sys
s=raw_input().split(" ")
s1=raw_input().split(" ")
s1=[int(x) for x in s1]
s1=sorted(s1)
dict={}
for i in range(0,len(s1)):
	dict.update({s1[i]:s1[i]%int(s[1])})
list=sorted(dict,key=dict.__getitem__,reverse=True)
list=[str(x) for x  in list]
print ' '.join(list)


INSTRUCTIONS:
Solve the current question.
Provide:
1. A complete and efficient code solution, optimized for both time and space complexity.
2. A detailed explanation of the solution, including:
   - The intuition behind the approach;
   - Time and space complexity;
   - Important considerations about the algorithm.
3. You can use the example questions as general references for coding patterns and structure, but solve the current problem independently.
4. Don't use any external libraries. Any language is accepted.