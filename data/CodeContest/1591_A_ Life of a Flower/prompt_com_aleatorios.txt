CURRENT QUESTION:
Petya has got an interesting flower. Petya is a busy person, so he sometimes forgets to water it. You are given n days from Petya's live and you have to determine what happened with his flower in the end.

The flower grows as follows: 

  * If the flower isn't watered for two days in a row, it dies. 
  * If the flower is watered in the i-th day, it grows by 1 centimeter. 
  * If the flower is watered in the i-th and in the (i-1)-th day (i > 1), then it grows by 5 centimeters instead of 1. 
  * If the flower is not watered in the i-th day, it does not grow. 



At the beginning of the 1-st day the flower is 1 centimeter tall. What is its height after n days?

Input

Each test contains multiple test cases. The first line contains the number of test cases t (1 ≤ t ≤ 100). Description of the test cases follows.

The first line of each test case contains the only integer n (1 ≤ n ≤ 100).

The second line of each test case contains n integers a_1, a_2, ..., a_n (a_i = 0 or a_i = 1). If a_i = 1, the flower is watered in the i-th day, otherwise it is not watered.

Output

For each test case print a single integer k — the flower's height after n days, or -1, if the flower dies.

Example

Input


4
3
1 0 1
3
0 1 1
4
1 0 0 1
1
0


Output


3
7
-1
1

EXAMPLE QUESTIONS:
Example question 1:
Name: 558_E. A Simple Task
Tags: ['data structures', 'sortings', 'strings']
Description: This task is very simple. Given a string S of length n and q queries each query is on the format i j k which means sort the substring consisting of the characters from i to j in non-decreasing order if k = 1 or in non-increasing order if k = 0.

Output the final string after applying the queries.

Input

The first line will contain two integers n, q (1 ≤ n ≤ 105, 0 ≤ q ≤ 50 000), the length of the string and the number of queries respectively. 

Next line contains a string S itself. It contains only lowercase English letters.

Next q lines will contain three integers each i, j, k (1 ≤ i ≤ j ≤ n, <image>).

Output

Output one line, the string S after applying the queries.

Examples

Input

10 5
abacdabcda
7 10 0
5 8 1
1 4 0
3 6 0
7 10 1


Output

cbcaaaabdd

Input

10 1
agjucbvdfk
1 10 1


Output

abcdfgjkuv

Note

First sample test explanation:

<image>

<image>

<image>

<image>

<image>
Difficulty: 11
Solutions: #include <bits/stdc++.h>
using namespace std;
struct ST {
  int sum[4 * 100000 + 2];
  int lazy[4 * 100000 + 2];
  ST() {
    for (int i = 0; i < 4 * 100000 + 2; i++) sum[i] = 0, lazy[i] = -1;
  }
  void propagate(int node, int l, int r) {
    if (lazy[node] == -1) return;
    for (int i = 0; i < 2; i++) {
      lazy[2 * node + i] = lazy[node];
      sum[2 * node + i] =
          lazy[node] * (((r - l + 1) >> 1) + ((r - l + 1) & 1) * (1 - i));
    }
    lazy[node] = -1;
    return;
  }
  void update(int node, int l, int r, int a, int b, int val) {
    if (l > b || r < a) return;
    if (l >= a && r <= b) {
      lazy[node] = val;
      sum[node] = (r - l + 1) * val;
      return;
    }
    propagate(node, l, r);
    int mid = (l + r) >> 1;
    update(2 * node + 0, l, mid + 0, a, b, val);
    update(2 * node + 1, mid + 1, r, a, b, val);
    sum[node] = sum[2 * node] + sum[2 * node + 1];
    return;
  }
  int query(int node, int l, int r, int a, int b) {
    if (l > b || r < a) return 0;
    if (l >= a && r <= b) return sum[node];
    propagate(node, l, r);
    int mid = (l + r) >> 1;
    return query(2 * node, l, mid, a, b) +
           query(2 * node + 1, mid + 1, r, a, b);
  }
};
int n, q;
char s[100000 + 2];
ST alfa[26];
int main() {
  scanf("%d %d\n", &n, &q);
  gets(s);
  for (int i = 0; i < n; i++) alfa[s[i] - 'a'].update(1, 1, n, i + 1, i + 1, 1);
  int l, r, k;
  while (q--) {
    scanf("%d %d %d", &l, &r, &k);
    if (k) {
      int now = l;
      for (int i = 0; i < 26; i++) {
        int tmp = alfa[i].query(1, 1, n, l, r);
        alfa[i].update(1, 1, n, l, r, 0);
        alfa[i].update(1, 1, n, now, now + tmp - 1, 1);
        now += tmp;
      }
    } else {
      int now = r;
      for (int i = 0; i < 26; i++) {
        int tmp = alfa[i].query(1, 1, n, l, r);
        alfa[i].update(1, 1, n, l, r, 0);
        alfa[i].update(1, 1, n, now - tmp + 1, now, 1);
        now -= tmp;
      }
    }
  }
  for (int i = 0; i < n; i++) {
    for (int j = 0; j < 26; j++)
      if (alfa[j].query(1, 1, n, i + 1, i + 1)) {
        printf("%c", j + 'a');
        break;
      }
  }
  printf("\n");
  return 0;
}



INSTRUCTIONS:
Solve the current question.
Provide:
1. A complete and efficient code solution, optimized for both time and space complexity.
2. A detailed explanation of the solution, including:
   - The intuition behind the approach;
   - Time and space complexity;
   - Important considerations about the algorithm.
3. You can use the example questions as general references for coding patterns and structure, but solve the current problem independently.
4. Don't use any external libraries. Any language is accepted.