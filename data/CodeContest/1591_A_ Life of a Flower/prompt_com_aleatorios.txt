CURRENT QUESTION:
Petya has got an interesting flower. Petya is a busy person, so he sometimes forgets to water it. You are given n days from Petya's live and you have to determine what happened with his flower in the end.

The flower grows as follows: 

  * If the flower isn't watered for two days in a row, it dies. 
  * If the flower is watered in the i-th day, it grows by 1 centimeter. 
  * If the flower is watered in the i-th and in the (i-1)-th day (i > 1), then it grows by 5 centimeters instead of 1. 
  * If the flower is not watered in the i-th day, it does not grow. 



At the beginning of the 1-st day the flower is 1 centimeter tall. What is its height after n days?

Input

Each test contains multiple test cases. The first line contains the number of test cases t (1 ≤ t ≤ 100). Description of the test cases follows.

The first line of each test case contains the only integer n (1 ≤ n ≤ 100).

The second line of each test case contains n integers a_1, a_2, ..., a_n (a_i = 0 or a_i = 1). If a_i = 1, the flower is watered in the i-th day, otherwise it is not watered.

Output

For each test case print a single integer k — the flower's height after n days, or -1, if the flower dies.

Example

Input


4
3
1 0 1
3
0 1 1
4
1 0 0 1
1
0


Output


3
7
-1
1

EXAMPLE QUESTIONS:
Example question 1:
Name: 224_D. Two Strings
Tags: ['data structures', 'dp', 'strings']
Description: A subsequence of length |x| of string s = s1s2... s|s| (where |s| is the length of string s) is a string x = sk1sk2... sk|x| (1 ≤ k1 < k2 < ... < k|x| ≤ |s|).

You've got two strings — s and t. Let's consider all subsequences of string s, coinciding with string t. Is it true that each character of string s occurs in at least one of these subsequences? In other words, is it true that for all i (1 ≤ i ≤ |s|), there is such subsequence x = sk1sk2... sk|x| of string s, that x = t and for some j (1 ≤ j ≤ |x|) kj = i.

Input

The first line contains string s, the second line contains string t. Each line consists only of lowercase English letters. The given strings are non-empty, the length of each string does not exceed 2·105.

Output

Print "Yes" (without the quotes), if each character of the string s occurs in at least one of the described subsequences, or "No" (without the quotes) otherwise.

Examples

Input

abab
ab


Output

Yes


Input

abacaba
aba


Output

No


Input

abc
ba


Output

No

Note

In the first sample string t can occur in the string s as a subsequence in three ways: abab, abab and abab. In these occurrences each character of string s occurs at least once.

In the second sample the 4-th character of the string s doesn't occur in any occurrence of string t.

In the third sample there is no occurrence of string t in string s.
Difficulty: 10
Solutions: #include <bits/stdc++.h>
using namespace std;
vector<int> LP(const string& S, const string& T) {
  const int M = int((T).size());
  vector<int> last_pos_in_T(26, 0);
  const int N = int((S).size());
  vector<int> res(N, -1);
  for (int i = 0, j = 0; i < N; ++i) {
    int ch_id = S[i] - 'a';
    if (j < M && S[i] == T[j]) {
      res[i] = ++j;
      last_pos_in_T[ch_id] = j;
    } else {
      res[i] = last_pos_in_T[ch_id];
    }
  }
  return res;
}
int main(int argc, char* argv[]) {
  ios_base::sync_with_stdio(false);
  cin.tie(NULL);
  string S, T;
  cin >> S;
  cin >> T;
  vector<int> L = LP(S, T);
  reverse(S.begin(), S.end());
  reverse(T.begin(), T.end());
  vector<int> R = LP(S, T);
  reverse(R.begin(), R.end());
  for (int& x : R) x = int((T).size()) - x + 1;
  bool ok = true;
  for (int i = 0; i < int((S).size()); ++i) {
    if (L[i] < 0 || R[i] < 0 || L[i] < R[i]) {
      ok = false;
      break;
    }
  }
  cout << (ok ? "Yes" : "No") << endl;
  return 0;
}


Example question 2:
Name: 624_C. Graph and String
Tags: ['constructive algorithms', 'graphs']
Description: One day student Vasya was sitting on a lecture and mentioned a string s1s2... sn, consisting of letters "a", "b" and "c" that was written on his desk. As the lecture was boring, Vasya decided to complete the picture by composing a graph G with the following properties: 

  * G has exactly n vertices, numbered from 1 to n. 
  * For all pairs of vertices i and j, where i ≠ j, there is an edge connecting them if and only if characters si and sj are either equal or neighbouring in the alphabet. That is, letters in pairs "a"-"b" and "b"-"c" are neighbouring, while letters "a"-"c" are not. 



Vasya painted the resulting graph near the string and then erased the string. Next day Vasya's friend Petya came to a lecture and found some graph at his desk. He had heard of Vasya's adventure and now he wants to find out whether it could be the original graph G, painted by Vasya. In order to verify this, Petya needs to know whether there exists a string s, such that if Vasya used this s he would produce the given graph G.

Input

The first line of the input contains two integers n and m <image> — the number of vertices and edges in the graph found by Petya, respectively.

Each of the next m lines contains two integers ui and vi (1 ≤ ui, vi ≤ n, ui ≠ vi) — the edges of the graph G. It is guaranteed, that there are no multiple edges, that is any pair of vertexes appear in this list no more than once.

Output

In the first line print "Yes" (without the quotes), if the string s Petya is interested in really exists and "No" (without the quotes) otherwise.

If the string s exists, then print it on the second line of the output. The length of s must be exactly n, it must consist of only letters "a", "b" and "c" only, and the graph built using this string must coincide with G. If there are multiple possible answers, you may print any of them.

Examples

Input

2 1
1 2


Output

Yes
aa


Input

4 3
1 2
1 3
1 4


Output

No

Note

In the first sample you are given a graph made of two vertices with an edge between them. So, these vertices can correspond to both the same and adjacent letters. Any of the following strings "aa", "ab", "ba", "bb", "bc", "cb", "cc" meets the graph's conditions. 

In the second sample the first vertex is connected to all three other vertices, but these three vertices are not connected with each other. That means that they must correspond to distinct letters that are not adjacent, but that is impossible as there are only two such letters: a and c.
Difficulty: 9
Solutions: #include <bits/stdc++.h>
using namespace std;
int n, m, u, v, k, vis[505];
char ans[505];
char mp[] = {'a', 'c', 'b'};
set<int> nodes[3];
vector<int> edges[505];
int main() {
  cin >> n >> m;
  while (m--) {
    scanf("%d %d", &u, &v);
    edges[u].push_back(v);
    edges[v].push_back(u);
  }
  bool same = true;
  for (u = 1; u <= n; ++u) {
    if (edges[u].size() != n - 1) {
      same = false;
      break;
    }
  }
  if (same) return printf("Yes\n%s", string(n, 'a').c_str()), 0;
  for (u = 1; u <= n && k < 2; ++u) {
    if (edges[u].size() == n - 1 || vis[u] > 0) {
      continue;
    }
    for (int v : edges[u]) {
      vis[v]++;
      nodes[k].insert(v);
    }
    nodes[k++].insert(u);
  }
  for (u = 1; u <= n; ++u) {
    if (vis[u] == 2) {
      nodes[0].erase(u);
      nodes[1].erase(u);
      nodes[2].insert(u);
    }
  }
  if (nodes[0].size() + nodes[1].size() + nodes[2].size() != n)
    return cout << "No", 0;
  for (k = 0; k < 2; ++k)
    for (int u : nodes[k])
      if (edges[u].size() != nodes[k].size() + nodes[2].size() - 1)
        return cout << "No", 0;
  for (int u : nodes[2])
    if (edges[u].size() !=
        nodes[0].size() + nodes[1].size() + nodes[2].size() - 1)
      return cout << "No", 0;
  for (k = 0; k < 3; ++k)
    for (int u : nodes[k]) ans[u] = mp[k];
  printf("Yes\n%s", ans + 1);
  return 0;
}



INSTRUCTIONS:
Solve the current question.
Provide:
1. A complete and efficient code solution, optimized for both time and space complexity.
2. A detailed explanation of the solution, including:
   - The intuition behind the approach;
   - Time and space complexity;
   - Important considerations about the algorithm.
3. If the language has classes, implement in 'Solution' class. Any language is accepted.
4. You can use the example questions as general references for coding patterns and structure, but solve the current problem independently.
5. Don't use any external libraries. Don't need to import any libraries.
