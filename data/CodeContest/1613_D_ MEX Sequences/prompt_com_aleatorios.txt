CURRENT QUESTION:
Let's call a sequence of integers x_1, x_2, ..., x_k MEX-correct if for all i (1 ≤ i ≤ k) |x_i - \operatorname{MEX}(x_1, x_2, ..., x_i)| ≤ 1 holds. Where \operatorname{MEX}(x_1, ..., x_k) is the minimum non-negative integer that doesn't belong to the set x_1, ..., x_k. For example, \operatorname{MEX}(1, 0, 1, 3) = 2 and \operatorname{MEX}(2, 1, 5) = 0.

You are given an array a consisting of n non-negative integers. Calculate the number of non-empty MEX-correct subsequences of a given array. The number of subsequences can be very large, so print it modulo 998244353. 

Note: a subsequence of an array a is a sequence [a_{i_1}, a_{i_2}, ..., a_{i_m}] meeting the constraints 1 ≤ i_1 < i_2 < ... < i_m ≤ n. If two different ways to choose the sequence of indices [i_1, i_2, ..., i_m] yield the same subsequence, the resulting subsequence should be counted twice (i. e. two subsequences are different if their sequences of indices [i_1, i_2, ..., i_m] are not the same).

Input

The first line contains a single integer t (1 ≤ t ≤ 10^5) — the number of test cases.

The first line of each test case contains a single integer n (1 ≤ n ≤ 5 ⋅ 10^5).

The second line contains n integers a_1, a_2, ..., a_n (0 ≤ a_i ≤ n).

The sum of n over all test cases doesn't exceed 5 ⋅ 10^5.

Output

For each test case, print a single integer — the number of non-empty MEX-correct subsequences of a given array, taken modulo 998244353.

Example

Input


4
3
0 2 1
2
1 0
5
0 0 0 0 0
4
0 1 2 3


Output


4
2
31
7

Note

In the first example, the valid subsequences are [0], [1], [0,1] and [0,2].

In the second example, the valid subsequences are [0] and [1].

In the third example, any non-empty subsequence is valid. 

EXAMPLE QUESTIONS:
Example question 1:
Name: 147_B. Smile House
Tags: ['binary search', 'graphs', 'matrices']
Description: A smile house is created to raise the mood. It has n rooms. Some of the rooms are connected by doors. For each two rooms (number i and j), which are connected by a door, Petya knows their value cij — the value which is being added to his mood when he moves from room i to room j.

Petya wondered whether he can raise his mood infinitely, moving along some cycle? And if he can, then what minimum number of rooms he will need to visit during one period of a cycle?

Input

The first line contains two positive integers n and m (<image>), where n is the number of rooms, and m is the number of doors in the Smile House. Then follows the description of the doors: m lines each containing four integers i, j, cij и cji (1 ≤ i, j ≤ n, i ≠ j, - 104 ≤ cij, cji ≤ 104). It is guaranteed that no more than one door connects any two rooms. No door connects the room with itself.

Output

Print the minimum number of rooms that one needs to visit during one traverse of the cycle that can raise mood infinitely. If such cycle does not exist, print number 0.

Examples

Input

4 4
1 2 -10 3
1 3 1 -10
2 4 -10 -1
3 4 0 -3


Output

4

Note

Cycle is such a sequence of rooms a1, a2, ..., ak, that a1 is connected with a2, a2 is connected with a3, ..., ak - 1 is connected with ak, ak is connected with a1. Some elements of the sequence can coincide, that is, the cycle should not necessarily be simple. The number of rooms in the cycle is considered as k, the sequence's length. Note that the minimum possible length equals two.
Difficulty: 8
Solutions: #include <bits/stdc++.h>
using namespace std;
int gi() {
  int w = 0;
  bool q = 1;
  char c = getchar();
  while ((c < '0' || c > '9') && c != '-') c = getchar();
  if (c == '-') q = 0, c = getchar();
  while (c >= '0' && c <= '9') w = w * 10 + c - '0', c = getchar();
  return q ? w : -w;
}
const int N = 510;
long long f[10][N][N], g[10][N][N];
long long h[N][N], H[N][N];
int main() {
  int n = gi(), m = gi(), i, j, k, a, b, t, ans;
  for (i = 1; i <= n; i++)
    for (j = 1; j <= n; j++) f[0][i][j] = -1LL << 60;
  while (m--) {
    a = gi(), b = gi();
    f[0][a][b] = max(f[0][a][b], (long long)gi());
    f[0][b][a] = max(f[0][b][a], (long long)gi());
  }
  for (i = 1; i <= n; i++)
    for (j = 1; j <= n; j++) g[0][i][j] = f[0][i][j];
  for (t = 1; t < 10; t++) {
    for (i = 1; i <= n; i++)
      for (j = 1; j <= n; j++) {
        g[t][i][j] = -1LL << 60;
        f[t][i][j] = f[t - 1][i][j];
        for (k = 1; k <= n; k++) {
          g[t][i][j] = max(g[t][i][j], g[t - 1][i][k] + g[t - 1][k][j]);
          f[t][i][j] = max(f[t][i][j], g[t - 1][i][k] + f[t - 1][k][j]);
        }
      }
    for (i = 1; i <= n; i++)
      if (f[t][i][i] > 0) break;
    if (i <= n) break;
  }
  if (t == 10) return puts("0"), 0;
  for (i = 1, ans = 1 << (--t); i <= n; i++)
    for (j = 1; j <= n; j++) h[i][j] = g[t][i][j];
  while (--t >= 0) {
    for (i = 1; i <= n; i++) {
      for (k = 1; k <= n; k++)
        if (h[i][k] + f[t][k][i] > 0) break;
      if (k <= n) break;
    }
    if (i > n) {
      ans |= 1 << t;
      for (i = 1; i <= n; i++)
        for (j = 1; j <= n; j++) {
          H[i][j] = -1LL << 60;
          for (k = 1; k <= n; k++) H[i][j] = max(H[i][j], h[i][k] + g[t][k][j]);
        }
      for (i = 1; i <= n; i++)
        for (j = 1; j <= n; j++) h[i][j] = H[i][j];
    }
  }
  printf("%d\n", ans + 1);
  return 0;
}



INSTRUCTIONS:
Solve the current question.
Provide:
1. A complete and efficient code solution, optimized for both time and space complexity.
2. A detailed explanation of the solution, including:
   - The intuition behind the approach;
   - Time and space complexity;
   - Important considerations about the algorithm.
3. If the language has classes, implement in 'Solution' class. Any language is accepted.
4. You can use the example questions as general references for coding patterns and structure, but solve the current problem independently.
5. Don't use any external libraries. Don't need to import any libraries.
