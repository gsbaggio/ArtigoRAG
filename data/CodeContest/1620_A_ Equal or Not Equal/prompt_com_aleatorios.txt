CURRENT QUESTION:
You had n positive integers a_1, a_2, ..., a_n arranged in a circle. For each pair of neighboring numbers (a_1 and a_2, a_2 and a_3, ..., a_{n - 1} and a_n, and a_n and a_1), you wrote down: are the numbers in the pair equal or not.

Unfortunately, you've lost a piece of paper with the array a. Moreover, you are afraid that even information about equality of neighboring elements may be inconsistent. So, you are wondering: is there any array a which is consistent with information you have about equality or non-equality of corresponding pairs?

Input

The first line contains a single integer t (1 ≤ t ≤ 1000) — the number of test cases. Next t cases follow.

The first and only line of each test case contains a non-empty string s consisting of characters E and/or N. The length of s is equal to the size of array n and 2 ≤ n ≤ 50. For each i from 1 to n: 

  * if s_i = E then a_i is equal to a_{i + 1} (a_n = a_1 for i = n); 
  * if s_i = N then a_i is not equal to a_{i + 1} (a_n ≠ a_1 for i = n). 

Output

For each test case, print YES if it's possible to choose array a that are consistent with information from s you know. Otherwise, print NO.

It can be proved, that if there exists some array a, then there exists an array a of positive integers with values less or equal to 10^9.

Example

Input


4
EEE
EN
ENNEENE
NENN


Output


YES
NO
YES
YES

Note

In the first test case, you can choose, for example, a_1 = a_2 = a_3 = 5.

In the second test case, there is no array a, since, according to s_1, a_1 is equal to a_2, but, according to s_2, a_2 is not equal to a_1.

In the third test case, you can, for example, choose array a = [20, 20, 4, 50, 50, 50, 20].

In the fourth test case, you can, for example, choose a = [1, 3, 3, 7].

EXAMPLE QUESTIONS:
Example question 1:
Name: 1264_C. Beautiful Mirrors with queries
Tags: ['data structures', 'probabilities']
Description: Creatnx has n mirrors, numbered from 1 to n. Every day, Creatnx asks exactly one mirror "Am I beautiful?". The i-th mirror will tell Creatnx that he is beautiful with probability (p_i)/(100) for all 1 ≤ i ≤ n.

Some mirrors are called checkpoints. Initially, only the 1st mirror is a checkpoint. It remains a checkpoint all the time.

Creatnx asks the mirrors one by one, starting from the 1-st mirror. Every day, if he asks i-th mirror, there are two possibilities:

  * The i-th mirror tells Creatnx that he is beautiful. In this case, if i = n Creatnx will stop and become happy, otherwise he will continue asking the i+1-th mirror next day; 
  * In the other case, Creatnx will feel upset. The next day, Creatnx will start asking from the checkpoint with a maximal number that is less or equal to i. 



There are some changes occur over time: some mirrors become new checkpoints and some mirrors are no longer checkpoints. You are given q queries, each query is represented by an integer u: If the u-th mirror isn't a checkpoint then we set it as a checkpoint. Otherwise, the u-th mirror is no longer a checkpoint.

After each query, you need to calculate [the expected number](https://en.wikipedia.org/wiki/Expected_value) of days until Creatnx becomes happy.

Each of this numbers should be found by modulo 998244353. Formally, let M = 998244353. It can be shown that the answer can be expressed as an irreducible fraction p/q, where p and q are integers and q not ≡ 0 \pmod{M}. Output the integer equal to p ⋅ q^{-1} mod M. In other words, output such an integer x that 0 ≤ x < M and x ⋅ q ≡ p \pmod{M}.

Input

The first line contains two integers n, q (2 ≤ n, q ≤ 2 ⋅ 10^5) — the number of mirrors and queries.

The second line contains n integers: p_1, p_2, …, p_n (1 ≤ p_i ≤ 100).

Each of q following lines contains a single integer u (2 ≤ u ≤ n) — next query.

Output

Print q numbers – the answers after each query by modulo 998244353.

Examples

Input


2 2
50 50
2
2


Output


4
6


Input


5 5
10 20 30 40 50
2
3
4
5
3


Output


117
665496274
332748143
831870317
499122211

Note

In the first test after the first query, the first and the second mirrors are checkpoints. Creatnx will ask the first mirror until it will say that he is beautiful, after that he will ask the second mirror until it will say that he is beautiful because the second mirror is a checkpoint. After that, he will become happy. Probabilities that the mirrors will say, that he is beautiful are equal to 1/2. So, the expected number of days, until one mirror will say, that he is beautiful is equal to 2 and the answer will be equal to 4 = 2 + 2.
Difficulty: 9
Solutions: #include <bits/stdc++.h>
using namespace std;
long long mod = 998244353;
long long qpow(long long a, long long b) {
  long long ans = 1;
  while (b) {
    if (b & 1) ans = ans * a % mod;
    b >>= 1;
    a = a * a % mod;
  }
  return ans;
}
long long mul[800005];
long long p[200005], ip[200005];
long long multi[800005], sum[800005], add[800005], a[800005];
void pushup(long long rt) { sum[rt] = (sum[rt << 1] + sum[rt << 1 | 1]) % mod; }
void build(long long l, long long r, long long rt) {
  mul[rt] = 1;
  if (l == r) {
    sum[rt] = a[l];
    sum[rt] %= mod;
    return;
  }
  long long m = (l + r) >> 1;
  build(l, m, rt << 1);
  build(m + 1, r, rt << 1 | 1);
  pushup(rt);
}
void pushdown(long long l, long long r, long long rt) {
  long long m = (l + r) >> 1;
  sum[rt << 1] = (sum[rt << 1] * mul[rt] + add[rt] * (m - l + 1)) % mod;
  sum[rt << 1 | 1] = (sum[rt << 1 | 1] * mul[rt] + add[rt] * (r - m)) % mod;
  mul[rt << 1] = (mul[rt << 1] * mul[rt]) % mod;
  mul[rt << 1 | 1] = (mul[rt << 1 | 1] * mul[rt]) % mod;
  add[rt << 1] = (add[rt << 1] * mul[rt] + add[rt]) % mod;
  add[rt << 1 | 1] = (add[rt << 1 | 1] * mul[rt] + add[rt]) % mod;
  mul[rt] = 1;
  add[rt] = 0;
}
void update1(long long L, long long R, long long k, long long l, long long r,
             long long rt) {
  if (L <= l && r <= R) {
    sum[rt] = (sum[rt] * k) % mod;
    mul[rt] = (mul[rt] * k) % mod;
    add[rt] = (add[rt] * k) % mod;
    return;
  }
  pushdown(l, r, rt);
  long long m = (l + r) >> 1;
  if (L <= m) update1(L, R, k, l, m, rt << 1);
  if (R > m) update1(L, R, k, m + 1, r, rt << 1 | 1);
  pushup(rt);
  return;
}
long long query(long long L, long long R, long long l, long long r,
                long long rt) {
  if (L <= l && r <= R) return sum[rt];
  long long m = (l + r) >> 1;
  pushdown(l, r, rt);
  long long ans = 0;
  if (L <= m) ans = (ans + query(L, R, l, m, rt << 1)) % mod;
  if (R > m) ans = (ans + query(L, R, m + 1, r, rt << 1 | 1)) % mod;
  return ans;
}
set<int> s;
int f[200005];
int main() {
  int T = 1;
  while (T--) {
    int n, q;
    cin >> n >> q;
    for (int i = 1; i <= n; i++)
      scanf("%lld", &p[i]), ip[i] = qpow(p[i], mod - 2) * 100 % mod;
    multi[0] = 1;
    for (int i = 1; i <= n; i++) multi[i] = multi[i - 1] * ip[i] % mod;
    for (int i = n; i >= 1; i--)
      a[i] = multi[n] * qpow(multi[i - 1], mod - 2) % mod;
    build(1, n, 1);
    s.insert(1);
    s.insert(n + 1);
    for (int i = 1; i <= q; i++) {
      int x;
      scanf("%d", &x);
      if (!f[x]) s.insert(x);
      set<int>::iterator it = s.lower_bound(x);
      int pre = *(--it);
      ++it;
      int suf = *(++it);
      if (!f[x]) {
        update1(
            pre, x - 1,
            qpow(multi[suf - 1] * qpow(multi[x - 1], mod - 2) % mod, mod - 2),
            1, n, 1);
      } else
        update1(pre, x - 1, multi[suf - 1] * qpow(multi[x - 1], mod - 2) % mod,
                1, n, 1);
      f[x] ^= 1;
      if (!f[x]) s.erase(x);
      printf("%lld\n", query(1, n, 1, n, 1));
    }
  }
  return 0;
}


Example question 2:
Name: 1054_F. Electric Scheme
Tags: ['flows', 'graph matchings']
Description: Pasha is a young technician, nevertheless, he has already got a huge goal: to assemble a PC. The first task he has to become familiar with is to assemble an electric scheme.

The scheme Pasha assembled yesterday consists of several wires. Each wire is a segment that connects two points on a plane with integer coordinates within the segment [1, 10^9].

There are wires of two colors in the scheme: 

  * red wires: these wires are horizontal segments, i.e. if such a wire connects two points (x_1, y_1) and (x_2, y_2), then y_1 = y_2; 
  * blue wires: these wires are vertical segments, i.e. if such a wire connects two points (x_1, y_1) and (x_2, y_2), then x_1 = x_2. 



Note that if a wire connects a point to itself, it may be blue, and it can be red. Also, in Pasha's scheme no two wires of the same color intersect, i.e. there are no two wires of same color that have common points.

The imperfection of Pasha's scheme was that the wires were not isolated, so in the points where two wires of different colors intersect, Pasha saw sparks. Pasha wrote down all the points where he saw sparks and obtained a set of n distinct points. After that he disassembled the scheme.

Next morning Pasha looked at the set of n points where he had seen sparks and wondered how many wires had he used. Unfortunately, he does not remember that, so he wonders now what is the smallest number of wires he might have used in the scheme. Help him to determine this number and place the wires in such a way that in the resulting scheme the sparks occur in the same places.

Input

The first line contains a single integer n (1 ≤ n ≤ 1000) — the number of points where Pasha saw sparks.

Each of the next n lines contain two integers x and y (1 ≤ x, y ≤ 10^9) — the coordinates of a point with sparks. It is guaranteed that all points are distinct.

Output

Print the description of the scheme in the following format.

In the first line print h — the number of horizontal red wires (0 ≤ h). In each of the next h lines print 4 integers x_1, y_1, x_2, y_2 — the coordinates of two points (x_1, y_1) and (x_2, y_2) that are connected with this red wire. The segmenst must be horizontal, i.e. y_1 = y_2 must hold. Also, the constraint 1 ≤ x_1, y_1, x_2, y_2 ≤ 10^9 must hold.

After that print v — the number of vertical blue wires (0 ≤ v). In each of the next v lines print 4 integers x_1, y_1, x_2, y_2 — the coordinates of two points (x_1, y_1) and (x_2, y_2) that are connected with this blue wire. The segmenst must be vertical, i.e. x_1 = x_2 shomustuld hold. Also, the constraint 1 ≤ x_1, y_1, x_2, y_2 ≤ 10^9 must hold.

No two segments of the same color should have common points. The set of points where sparks appear should be the same as given in the input.

The number of segments (h + v) should be minimum possible. It's easy to see that the answer always exists. If there are multiple possible answers, print any.

Examples

Input

4
2 2
2 4
4 2
4 4


Output

2
5 2 1 2
1 4 5 4
2
2 1 2 5
4 5 4 1


Input

4
2 1
3 2
2 3
1 2


Output

4
2 1 2 1
3 2 3 2
1 2 1 2
2 3 2 3
3
1 2 1 2
3 2 3 2
2 3 2 1

Note

In the first example Pasha could have assembled the following scheme:

<image>

In this scheme there are 2 wires of each color: red ones connecting (5, 2) with (1, 2) and (1, 4) with (5, 4), blue ones connecting (2, 1) with (2, 5) and (4, 5) with (4, 1). Note that the sparks appear in the points that are described in the input, they are shown in yellow on the picture. For example, Pasha will see the spark in the point (2, 4) because the second red wire and the first blue wire intersect there. It is possible to show that we can't have less than 4 wires to produce a scheme with same sparks positions.
Difficulty: 12
Solutions: #include <bits/stdc++.h>
using namespace std;
struct VerSeg {
  int x, y_1, y_2;
  VerSeg(int x_, int y_1_, int y_2_) : x(x_), y_1(y_1_), y_2(y_2_) {}
  VerSeg() {}
};
struct HorSeg {
  int y, x_1, x_2;
  HorSeg(int y_, int x_1_, int x_2_) : y(y_), x_1(x_1_), x_2(x_2_) {}
  HorSeg() {}
};
vector<VerSeg> ver, versAns;
vector<HorSeg> hor, horsAns;
set<pair<int, int> > was;
const int MAX_N = 2e3 + 100;
int n, m, paired[2 * MAX_N], used[2 * MAX_N], maxIndependent[2 * MAX_N];
vector<int> g[MAX_N];
pair<int, int> a[MAX_N];
bool dfs(int v) {
  if (used[v]) return false;
  used[v] = 1;
  for (int to : g[v])
    if (paired[to] == -1 || dfs(paired[to])) {
      paired[to] = v;
      paired[v] = to;
      return true;
    }
  return false;
}
int kuhn() {
  int ans = 0;
  for (int i = 0; (i) < (n + m); ++i) paired[i] = -1;
  for (int run = 1; run;) {
    run = 0;
    memset(used, 0, sizeof(used));
    for (int i = 0; (i) < (n); ++i)
      if (!used[i] && paired[i] == -1 && dfs(i)) {
        ans++;
        run = 1;
      }
  }
  return ans;
}
void dfsCoverIndependent(int v) {
  if (used[v]) return;
  used[v] = 1;
  for (int to : g[v])
    if (!used[to]) used[to] = 1, dfsCoverIndependent(paired[to]);
}
void findCoverIndependent() {
  memset(used, 0, sizeof(used));
  for (int i = 0; (i) < (n); ++i)
    if (paired[i] == -1) dfsCoverIndependent(i);
  for (int i = 0; (i) < (n); ++i)
    if (used[i]) maxIndependent[i] = 1;
  for (int i = (n); (i) < (n + m); ++i)
    if (!used[i]) maxIndependent[i] = 1;
}
int main() {
  int k;
  scanf("%d", &k);
  for (int i = 0; (i) < (k); ++i) {
    scanf("%d%d", &a[i].first, &a[i].second);
  }
  sort(a, a + k);
  for (int i = (1); (i) < (k); ++i)
    if (a[i].first == a[i - 1].first) {
      ver.push_back(VerSeg(a[i].first, a[i - 1].second, a[i].second));
    }
  for (int i = 0; (i) < (k); ++i) swap(a[i].first, a[i].second);
  sort(a, a + k);
  for (int i = 0; (i) < (k); ++i) swap(a[i].first, a[i].second);
  for (int i = (1); (i) < (k); ++i)
    if (a[i].second == a[i - 1].second) {
      hor.push_back(HorSeg(a[i].second, a[i - 1].first, a[i].first));
    }
  n = (int)((ver).size()), m = (int)((hor).size());
  for (int i = 0; (i) < (n); ++i)
    for (int j = 0; (j) < (m); ++j) {
      if (ver[i].y_1 < hor[j].y && ver[i].y_2 > hor[j].y &&
          hor[j].x_1 < ver[i].x && hor[j].x_2 > ver[i].x)
        g[i].push_back(n + j), g[n + j].push_back(i);
    }
  kuhn();
  findCoverIndependent();
  was.clear();
  for (int i = 0; (i) < (n); ++i) {
    if (maxIndependent[i]) {
      int ind = n;
      for (int j = (i); (j) < (n); ++j) {
        if (!maxIndependent[j] || ver[j].x != ver[i].x) {
          ind = j;
          break;
        }
        was.insert(make_pair(ver[j].x, ver[j].y_1));
        was.insert(make_pair(ver[j].x, ver[j].y_2));
      }
      versAns.push_back(VerSeg(ver[i].x, ver[i].y_1, ver[ind - 1].y_2));
      i = ind - 1;
    }
  }
  for (int i = 0; (i) < (k); ++i)
    if (!was.count(a[i]))
      versAns.push_back(VerSeg(a[i].first, a[i].second, a[i].second));
  was.clear();
  for (int i = 0; (i) < (m); ++i) {
    if (maxIndependent[n + i]) {
      int ind = m;
      for (int j = (i); (j) < (m); ++j) {
        if (!maxIndependent[n + j] || hor[j].y != hor[i].y) {
          ind = j;
          break;
        }
        was.insert(make_pair(hor[j].x_1, hor[j].y));
        was.insert(make_pair(hor[j].x_2, hor[j].y));
      }
      horsAns.push_back(HorSeg(hor[i].y, hor[i].x_1, hor[ind - 1].x_2));
      i = ind - 1;
    }
  }
  for (int i = 0; (i) < (k); ++i)
    if (!was.count(a[i]))
      horsAns.push_back(HorSeg(a[i].second, a[i].first, a[i].first));
  printf("%d\n", (int)((horsAns).size()));
  for (auto seg : horsAns)
    printf("%d %d %d %d\n", seg.x_1, seg.y, seg.x_2, seg.y);
  printf("%d\n", (int)((versAns).size()));
  for (auto seg : versAns)
    printf("%d %d %d %d\n", seg.x, seg.y_1, seg.x, seg.y_2);
  return 0;
}


Example question 3:
Name: dipu-and-interesting-numbers-2
Tags: []
Description: Little Dipu is a small kid and like all the other kids, he likes to play, but he plays with numbers (He is extraordinary you know). Now-a-days Dipu has some extra interest in odd numbers. So, he says that a number N is interesting if it has odd number of divisors. Now Dipu turns to you and asks you to tell him how many interesting numbers are there between two given numbers, L and R (both inclusive).
 Input 
First line of input contains the number of test cases T. Each of the next T lines contains two space separated integers L and R.

 Output 
For each test case, output an integer, denoting the count of interesting numbers between L and R (both inclusive).

 Constraints 
1 ≤ T ≤ 100000

1 ≤ L ≤ R ≤ 10^18

SAMPLE INPUT
2
1 3
6 10

SAMPLE OUTPUT
1
1

Explanation

In 1st test case, 1 has 1 divisor, 2 has 2 divisors and 3 also has 2 divisors. So only 1 has odd number of divisors. Hence count of interesting numbers is 1.

In 2nd test case, 9 is the only number to have odd number of divisors. So answer is again 1.
Difficulty: 0
Solutions: import math
import decimal

'''
Created by anirudhmenon on 12/03/16
https://www.hackerearth.com/problem/algorithm/dipu-and-interesting-numbers-2/
'''

# number of test cases
t = int(raw_input())

while t > 0:

    # Enter values for l and r
    l, r = raw_input().split()
    l, r = long(l), long(r)

    print int(decimal.Decimal(r).sqrt())-int(decimal.Decimal(l-1).sqrt())

    t -= 1


INSTRUCTIONS:
Solve the current question.
Provide:
1. A complete and efficient code solution, optimized for both time and space complexity.
2. A detailed explanation of the solution, including:
   - The intuition behind the approach;
   - Time and space complexity;
   - Important considerations about the algorithm.
3. If the language has classes, implement in 'Solution' class. Any language is accepted.
4. You can use the example questions as general references for coding patterns and structure, but solve the current problem independently.
5. Don't use any external libraries. Don't need to import any libraries.
