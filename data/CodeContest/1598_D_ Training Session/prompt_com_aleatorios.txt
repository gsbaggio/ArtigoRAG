CURRENT QUESTION:
Monocarp is the coach of the Berland State University programming teams. He decided to compose a problemset for a training session for his teams.

Monocarp has n problems that none of his students have seen yet. The i-th problem has a topic a_i (an integer from 1 to n) and a difficulty b_i (an integer from 1 to n). All problems are different, that is, there are no two tasks that have the same topic and difficulty at the same time.

Monocarp decided to select exactly 3 problems from n problems for the problemset. The problems should satisfy at least one of two conditions (possibly, both):

  * the topics of all three selected problems are different; 
  * the difficulties of all three selected problems are different. 



Your task is to determine the number of ways to select three problems for the problemset.

Input

The first line contains a single integer t (1 ≤ t ≤ 50000) — the number of testcases.

The first line of each testcase contains an integer n (3 ≤ n ≤ 2 ⋅ 10^5) — the number of problems that Monocarp have.

In the i-th of the following n lines, there are two integers a_i and b_i (1 ≤ a_i, b_i ≤ n) — the topic and the difficulty of the i-th problem.

It is guaranteed that there are no two problems that have the same topic and difficulty at the same time.

The sum of n over all testcases doesn't exceed 2 ⋅ 10^5.

Output

Print the number of ways to select three training problems that meet either of the requirements described in the statement.

Example

Input


2
4
2 4
3 4
2 1
1 3
5
1 5
2 4
3 3
4 2
5 1


Output


3
10

Note

In the first example, you can take the following sets of three problems:

  * problems 1, 2, 4; 
  * problems 1, 3, 4; 
  * problems 2, 3, 4. 



Thus, the number of ways is equal to three.

EXAMPLE QUESTIONS:
Example question 1:
Name: p03710 AtCoder Grand Contest 015 - Kenus the Ancient Greek
Tags: ['']
Description: Kenus, the organizer of International Euclidean Olympiad, is seeking a pair of two integers that requires many steps to find its greatest common divisor using the Euclidean algorithm.

You are given Q queries. The i-th query is represented as a pair of two integers X_i and Y_i, and asks you the following: among all pairs of two integers (x,y) such that 1 ≤ x ≤ X_i and 1 ≤ y ≤ Y_i, find the maximum Euclidean step count (defined below), and how many pairs have the maximum step count, modulo 10^9+7.

Process all the queries. Here, the Euclidean step count of a pair of two non-negative integers (a,b) is defined as follows:

* (a,b) and (b,a) have the same Euclidean step count.
* (0,a) has a Euclidean step count of 0.
* If a > 0 and a ≤ b, let p and q be a unique pair of integers such that b=pa+q and 0 ≤ q < a. Then, the Euclidean step count of (a,b) is the Euclidean step count of (q,a) plus 1.

Constraints

* 1 ≤ Q ≤ 3 × 10^5
* 1 ≤ X_i,Y_i ≤ 10^{18}(1 ≤ i ≤ Q)

Input

The input is given from Standard Input in the following format:


Q
X_1 Y_1
:
X_Q Y_Q


Output

For each query, print the maximum Euclidean step count, and the number of the pairs that have the maximum step count, modulo 10^9+7, with a space in between.

Examples

Input

3
4 4
6 10
12 11


Output

2 4
4 1
4 7


Input

10
1 1
2 2
5 1000000000000000000
7 3
1 334334334334334334
23847657 23458792534
111111111 111111111
7 7
4 19
9 10


Output

1 1
1 4
4 600000013
3 1
1 993994017
35 37447
38 2
3 6
3 9
4 2
Difficulty: 0
Solutions: #include <cstdio>
#include <vector>
#include <cassert>
#include <algorithm>
using namespace std;

#define iter(i, n) for (int i = 1; i <= n; ++i)

const int mod = 1e9 + 7;

typedef long long i64;
typedef pair<i64, i64> pii;

#define fi first
#define se second

vector<pii> vec[100];
i64 f[100];

int F(i64 a, i64 b) {
	if (a < b) swap(a, b);
	return !b ? 0 : F(b, a % b) + 1;
}

int main() {
	f[0] = 1, f[1] = 1;
	int n = 1;

	
	while (f[n] <= 1e18) {
		++n;
		f[n] = f[n - 1] + f[n - 2];
	}
	f[n + 1] = f[n];
	--n;

	vec[0].push_back(pii(0, 1));
	vec[0].push_back(pii(0, 2));
	iter(i, n) {
		for (pii p : vec[i - 1]) {
			i64 a = p.fi, b = p.se;
		//	if (i == 4) printf("[%lld %lld] %d %d %lld\n", a, b, i-1, F(a, b), f[i+1]);
			assert(F(a, b) == i - 1);

//			printf("%d [%lld %lld]", i, a, b);
			for (; a + b <= f[i + 2]; a += b) {
				//gcd(f[i+2],f
				if (F(b, a + b) == i) vec[i].push_back(pii(b, a + b));
			}
		}
	}
	int q;
	scanf("%d", &q);
	iter(id, q) {
		i64 a, b;
		scanf("%lld%lld", &a, &b);
		if (a > b) swap(a, b);
		int ans = 1; i64 cnt = 0;
		iter(i, n) {
			if (a >= f[i] && b >= f[i + 1]) ans = i;
			else break;
		}
		printf("%d ", ans);
		for (pii p : vec[ans - 1]) {
			if (p.se <= a && p.fi + p.se <= b && p.fi != p.se) cnt = (cnt + (b - p.fi) / p.se) % mod;
			swap(a, b);
			if (p.se <= a && p.fi + p.se <= b && p.fi != p.se) cnt = (cnt + (b - p.fi) / p.se) % mod;
			swap(a, b);
			
		}
		printf("%lld\n", ans != 1 ? cnt : a * b % mod);
	}
	//
	return 0;
}


Example question 2:
Name: 470_F. Pairwise Sums
Tags: ['*special']
Description: You are given an array of n integers. For each element output the sum of itself and the previous element. For the first element, output the sum of the first and the last elements of the array.

Input

The input consists of a single line of space-separated integers. The first number is n (2 ≤ n ≤ 50) — the size of the array. The following n numbers are the elements of the array (1 ≤ ai ≤ 1000).

Output

Output the sums a1 + an, a2 + a1, ..., an + an - 1, separated with spaces.

Examples

Input

4 1 2 3 4


Output

5 3 5 7 

Input

5 5 46 372 81 9


Output

14 51 418 453 90 
Difficulty: 12
Solutions: 


INSTRUCTIONS:
Solve the current question.
Provide:
1. A complete and efficient code solution, optimized for both time and space complexity.
2. A detailed explanation of the solution, including:
   - The intuition behind the approach;
   - Time and space complexity;
   - Important considerations about the algorithm.
3. You can use the example questions as general references for coding patterns and structure, but solve the current problem independently.
4. Don't use any external libraries. Any language is accepted.