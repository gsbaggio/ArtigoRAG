CURRENT QUESTION:
Alice has an integer sequence a of length n and all elements are different. She will choose a subsequence of a of length m, and defines the value of a subsequence a_{b_1},a_{b_2},…,a_{b_m} as $$$∑_{i = 1}^m (m ⋅ a_{b_i}) - ∑_{i = 1}^m ∑_{j = 1}^m f(min(b_i, b_j), max(b_i, b_j)), where f(i, j) denotes \min(a_i, a_{i + 1}, \ldots, a_j)$$$.

Alice wants you to help her to maximize the value of the subsequence she choose.

A sequence s is a subsequence of a sequence t if s can be obtained from t by deletion of several (possibly, zero or all) elements.

Input

The first line contains two integers n and m (1 ≤ m ≤ n ≤ 4000).

The second line contains n distinct integers a_1, a_2, …, a_n (1 ≤ a_i < 2^{31}).

Output

Print the maximal value Alice can get.

Examples

Input


6 4
15 2 18 12 13 4


Output


100


Input


11 5
9 3 7 1 8 12 10 20 15 18 5


Output


176


Input


1 1
114514


Output


0


Input


2 1
666 888


Output


0

Note

In the first example, Alice can choose the subsequence [15, 2, 18, 13], which has the value 4 ⋅ (15 + 2 + 18 + 13) - (15 + 2 + 2 + 2) - (2 + 2 + 2 + 2) - (2 + 2 + 18 + 12) - (2 + 2 + 12 + 13) = 100. In the second example, there are a variety of subsequences with value 176, and one of them is [9, 7, 12, 20, 18].

EXAMPLE QUESTIONS:
Example question 1:
Name: 555_D. Case of a Top Secret
Tags: ['binary search', 'implementation', 'math']
Description: Andrewid the Android is a galaxy-famous detective. Now he is busy with a top secret case, the details of which are not subject to disclosure.

However, he needs help conducting one of the investigative experiment. There are n pegs put on a plane, they are numbered from 1 to n, the coordinates of the i-th of them are (xi, 0). Then, we tie to the bottom of one of the pegs a weight on a tight rope of length l (thus, its coordinates will be equal to (xi, - l), where i is the number of the used peg). Then the weight is pushed to the right, so that it starts to rotate counterclockwise. At the same time, if the weight during rotation touches some of the other pegs, it then begins to rotate around that peg. Suppose that each peg itself is very thin and does not affect the rope length while weight is rotating around it.

<image>

More formally, if at some moment the segment of the rope contains one or more pegs in addition to the peg around which the weight is rotating, the weight will then rotate around the farthermost one of them on a shorter segment of a rope. In particular, if the segment of the rope touches some peg by its endpoint, it is considered that the weight starts to rotate around that peg on a segment of the rope of length 0.

At some moment the weight will begin to rotate around some peg, without affecting the rest of the pegs. Andrewid interested in determining the number of this peg.

Andrewid prepared m queries containing initial conditions for pushing the weight, help him to determine for each of them, around what peg the weight will eventually rotate.

Input

The first line contains integers n and m (1 ≤ n, m ≤ 2·105) — the number of pegs and queries.

The next line contains n integers x1, x2, ..., xn ( - 109 ≤ xi ≤ 109) — the coordinates of the pegs. It is guaranteed that the coordinates of all the pegs are distinct integers.

Next m lines contain the descriptions of the queries of pushing the weight, each consists of two integers ai (1 ≤ ai ≤ n) and li (1 ≤ li ≤ 109) — the number of the starting peg and the length of the rope.

Output

Print m lines, the i-th line should contain the number of the peg around which the weight will eventually rotate after the i-th push.

Examples

Input

3 2
0 3 5
2 3
1 8


Output

3
2


Input

4 4
1 5 7 15
1 4
2 15
3 16
1 28


Output

2
4
3
1

Note

Picture to the first sample test:

<image>

Picture to the second sample test:

<image>

Note that in the last query weight starts to rotate around the peg 1 attached to a rope segment of length 0.
Difficulty: 10
Solutions: #include <bits/stdc++.h>
using namespace std;
const int maxn = 200003;
long long INF = 0x3f3f3f3f3f3f3f3fll;
int n, Q, pos[maxn];
pair<long long, int> a[maxn];
int main() {
  scanf("%d%d", &n, &Q);
  for (int i = 1; i <= n; i++) scanf("%lld", &a[i].first), a[i].second = i;
  sort(a + 1, a + n + 1);
  a[0].first = -INF, a[n + 1].first = INF;
  for (int i = 1; i <= n; i++) pos[a[i].second] = i;
  while (Q--) {
    int y, p;
    long long l;
    scanf("%d%lld", &y, &l);
    y = pos[y];
    bool dir = 1;
    int flag = 0;
    while (1) {
      if (flag == 2) {
        printf("%d\n", a[p].second);
        break;
      }
      if (dir) {
        p = upper_bound(a + 1, a + n + 1,
                        pair<long long, int>(a[y].first + l, maxn)) -
            a - 1;
        long long len = a[p].first - a[y].first;
        if (p == y) {
          flag++;
          dir = 0;
          continue;
        }
        flag = 0;
        if (l < a[p + 1].first - a[y].first &&
            a[y].first + len - l > a[y - 1].first) {
          if (l / len % 2) dir = 0, y = p;
          l %= len;
        } else {
          l -= len;
          y = p;
          dir = 0;
        }
      } else {
        p = lower_bound(a + 1, a + n + 1,
                        pair<long long, int>(a[y].first - l, 0)) -
            a;
        long long len = a[y].first - a[p].first;
        if (p == y) {
          flag++;
          dir = 1;
          continue;
        }
        flag = 0;
        if (l > a[p - 1].first && a[y].first - len + l < a[y + 1].first) {
          if (l / len % 2) dir = 0, y = p;
          l %= len;
        } else {
          l -= len;
          y = p;
          dir = 1;
        }
      }
    }
  }
  return 0;
}



INSTRUCTIONS:
Solve the current question.
Provide:
1. A complete and efficient code solution, optimized for both time and space complexity.
2. A detailed explanation of the solution, including:
   - The intuition behind the approach;
   - Time and space complexity;
   - Important considerations about the algorithm.
3. If the language has classes, implement in 'Solution' class. Any language is accepted.
4. You can use the example questions as general references for coding patterns and structure, but solve the current problem independently.
5. Don't use any external libraries. Don't need to import any libraries.
