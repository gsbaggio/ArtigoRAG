CURRENT QUESTION:
Alice has an integer sequence a of length n and all elements are different. She will choose a subsequence of a of length m, and defines the value of a subsequence a_{b_1},a_{b_2},…,a_{b_m} as $$$∑_{i = 1}^m (m ⋅ a_{b_i}) - ∑_{i = 1}^m ∑_{j = 1}^m f(min(b_i, b_j), max(b_i, b_j)), where f(i, j) denotes \min(a_i, a_{i + 1}, \ldots, a_j)$$$.

Alice wants you to help her to maximize the value of the subsequence she choose.

A sequence s is a subsequence of a sequence t if s can be obtained from t by deletion of several (possibly, zero or all) elements.

Input

The first line contains two integers n and m (1 ≤ m ≤ n ≤ 4000).

The second line contains n distinct integers a_1, a_2, …, a_n (1 ≤ a_i < 2^{31}).

Output

Print the maximal value Alice can get.

Examples

Input


6 4
15 2 18 12 13 4


Output


100


Input


11 5
9 3 7 1 8 12 10 20 15 18 5


Output


176


Input


1 1
114514


Output


0


Input


2 1
666 888


Output


0

Note

In the first example, Alice can choose the subsequence [15, 2, 18, 13], which has the value 4 ⋅ (15 + 2 + 18 + 13) - (15 + 2 + 2 + 2) - (2 + 2 + 2 + 2) - (2 + 2 + 18 + 12) - (2 + 2 + 12 + 13) = 100. In the second example, there are a variety of subsequences with value 176, and one of them is [9, 7, 12, 20, 18].

EXAMPLE QUESTIONS:
Example question 1:
Name: atom
Tags: []
Description: Mr. Yagami is a scientist in the Bhabha Atomic Research Centre. They are
  conducting a lab experiment on nuclear fission. In nuclear fission, one atom
  breaks into more than one atom of the same type.

  Initially, there are N atoms in the lab. Starting from now (t=0), after each
  second, every atom will break into K atoms of the same type. They don’t want
  the number of atoms to exceed M, so they have to stop the reaction at some
  time t=T. Can you find this value T for Mr. Yagami.
  

Input Format:

  First line contains P, the number of test cases. Next P lines contain three
  integers each. These three integers represent the values of N, K and M
  respectively.
  

Output Format:

  For each test case print the time at which the reaction will have to be
  stopped.
  

Constraints:


  1 ≤ P ≤ 10^4
  2 ≤ N, K, M ≤ 10^18



Sample Input:

2
2 2 7
2 2 8
Sample Output:

1
2
Explanation:

  1st test case: 
  at t=1, number of atoms=4
  at t=2, number of atoms will be 8.
  So reaction has to be stopped at t=1.
  2nd test case:
  at t=1, number of atoms=4
  at t=2, number of atoms will be 8.
  at t=3, number of atoms will be 16.
  

Problem Setter: Lalit Kundu
Difficulty: 6
Solutions: import math
t=input("")
while(t):
	inp=raw_input("")
	inp=inp.split()
	n=int(inp[0]);k=int(inp[1]);m=int(inp[2])
	m=m/n;
	if(m>0):
		print int(math.log(m,k))
	else:
		print 0
	t=t-1

Example question 2:
Name: 1110_G. Tree-Tac-Toe 
Tags: ['constructive algorithms', 'games', 'trees']
Description: The tic-tac-toe game is starting on a tree of n vertices. Some vertices are already colored in white while the remaining are uncolored.

There are two players — white and black. The players make moves alternatively. The white player starts the game. In his turn, a player must select one uncolored vertex and paint it in his color.

The player wins if he paints some path of three vertices in his color. In case all vertices are colored and neither player won, the game ends in a draw.

Could you please find who will win the game or whether it ends as a draw, assuming both players play optimally? 

Input

The first line contains a single integer T (1 ≤ T ≤ 50 000) — the number of test cases. Then descriptions of T test cases follow.

The first line of each test contains a single integer n (1 ≤ n ≤ 5 ⋅ 10^5) — the number of vertices in the tree.

Each of the following n - 1 lines contains integers v, u (1 ≤ v, u ≤ n) denoting an edge of the tree connecting vertices v and u.

The last line of a test case contains a string of letters 'W' (for white) and 'N' (for not colored) of length n denoting already colored vertices. Vertexes already colored in white are denoted as 'W'.

It's guaranteed that the given edges form a tree, that there is at least one uncolored vertex and that there is no path of three white vertices.

It's guaranteed that sum of all n among all test cases is at most 5 ⋅ 10^5.

Output

For every test case, print either "White", "Draw" or "Black", depending on the result of the game.

Example

Input


2
4
1 2
1 3
1 4
NNNW
5
1 2
2 3
3 4
4 5
NNNNN


Output


White
Draw

Note

In the first example, vertex 4 is already colored in white. The white player can win by coloring the vertex 1 in white first and the remaining vertex on his second turn. The process is illustrated with the pictures below.

<image>

In the second example, we can show that no player can enforce their victory.
Difficulty: 13
Solutions: #include <bits/stdc++.h>
using namespace std;
vector<int> adjList[2000000];
int main() {
  int i, j;
  int T, t;
  int n, u, v;
  char c;
  scanf("%d", &T);
  for (t = 0; t < T; t++) {
    scanf("%d", &n);
    for (i = 0; i < n - 1; i++) {
      scanf("%d %d", &u, &v);
      u--, v--;
      adjList[u].push_back(v);
      adjList[v].push_back(u);
    }
    int nn = n;
    for (i = 0; i < nn; i++) {
      scanf(" %c", &c);
      if (c == 'W') {
        adjList[i].push_back(n), adjList[n].push_back(i);
        adjList[n].push_back(n + 1), adjList[n + 1].push_back(n);
        adjList[n].push_back(n + 2), adjList[n + 2].push_back(n);
        n += 3;
      }
    }
    int c = 0;
    for (i = 0; i < n; i++) {
      if (adjList[i].size() >= 4)
        break;
      else if (adjList[i].size() >= 3) {
        c++;
        int c2 = 0;
        for (j = 0; j < adjList[i].size(); j++) {
          v = adjList[i][j];
          if (adjList[v].size() >= 2) c2++;
        }
        if (c2 >= 2) break;
      }
    }
    if ((i < n) || ((c == 2) && (n & 1)))
      printf("White\n");
    else
      printf("Draw\n");
    for (i = 0; i < n; i++) adjList[i].clear();
  }
  return 0;
}



INSTRUCTIONS:
Solve the current question.
Provide:
1. A complete and efficient code solution, optimized for both time and space complexity.
2. A detailed explanation of the solution, including:
   - The intuition behind the approach;
   - Time and space complexity;
   - Important considerations about the algorithm.
3. You can use the example questions as general references for coding patterns and structure, but solve the current problem independently.
4. Don't use any external libraries. Any language is accepted.