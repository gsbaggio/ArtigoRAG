def maximize_subsequence_value(n, m, a):
    import sys
    import math
    input = sys.stdin.read
    data = input().split()
    
    # Precompute Sparse Table for range minimum queries
    def build_sparse_table(arr):
        n = len(arr)
        log = [0] * (n + 1)
        for i in range(2, n + 1):
            log[i] = log[i // 2] + 1
        
        k = log[n] + 1
        st = [[0] * k for _ in range(n)]
        
        for i in range(n):
            st[i][0] = arr[i]
        
        j = 1
        while (1 << j) <= n:
            i = 0
            while (i + (1 << j) - 1) < n:
                st[i][j] = min(st[i][j - 1], st[i + (1 << (j - 1))][j - 1])
                i += 1
            j += 1
        
        return st, log
    
    def query_sparse_table(st, log, l, r):
        j = log[r - l + 1]
        return min(st[l][j], st[r - (1 << j) + 1][j])
    
    # Build Sparse Table for the array
    sparse_table, log = build_sparse_table(a)
    
    # DP array
    dp = [[-float('inf')] * (m + 1) for _ in range(n + 1)]
    dp[0][0] = 0  # Base case: no elements, no subsequence
    
    # Fill DP table
    for i in range(1, n + 1):
        for k in range(1, m + 1):
            for j in range(i):
                # Calculate penalty using Sparse Table
                penalty = query_sparse_table(sparse_table, log, j, i - 1)
                dp[i][k] = max(dp[i][k], dp[j][k - 1] + m * a[i - 1] - penalty)
    
    # The result is the maximum value for dp[n][m]
    return max(dp[n])

# Input reading
if __name__ == "__main__":
    import sys
    input = sys.stdin.read
    data = input().split()
    
    n, m = int(data[0]), int(data[1])
    a = list(map(int, data[2:]))
    
    print(maximize_subsequence_value(n, m, a))