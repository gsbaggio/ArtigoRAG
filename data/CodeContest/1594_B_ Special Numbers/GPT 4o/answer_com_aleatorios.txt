MOD = 10**9 + 7

# Function to calculate (base^exp) % MOD using modular exponentiation
def modular_exponentiation(base, exp, mod):
    result = 1
    while exp > 0:
        if exp % 2 == 1:  # If the current bit is 1
            result = (result * base) % mod
        base = (base * base) % mod  # Square the base
        exp //= 2
    return result

# Function to find the k-th special number modulo MOD
def find_kth_special_number(n, k):
    k -= 1  # Convert to 0-based index
    result = 0
    power = 0
    
    # Process each bit of k
    while k > 0:
        if k % 2 == 1:  # If the current bit is 1
            result = (result + modular_exponentiation(n, power, MOD)) % MOD
        k //= 2
        power += 1
    
    return result

# Main function to process all test cases
def main():
    import sys
    input = sys.stdin.read
    data = input().split()
    
    t = int(data[0])  # Number of test cases
    results = []
    index = 1
    for _ in range(t):
        n, k = map(int, data[index:index + 2])
        index += 2
        results.append(find_kth_special_number(n, k))
    
    # Print all results
    sys.stdout.write("\n".join(map(str, results)) + "\n")