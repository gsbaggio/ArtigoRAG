CURRENT QUESTION:
Theofanis really likes sequences of positive integers, thus his teacher (Yeltsa Kcir) gave him a problem about a sequence that consists of only special numbers.

Let's call a positive number special if it can be written as a sum of different non-negative powers of n. For example, for n = 4 number 17 is special, because it can be written as 4^0 + 4^2 = 1 + 16 = 17, but 9 is not.

Theofanis asks you to help him find the k-th special number if they are sorted in increasing order. Since this number may be too large, output it modulo 10^9+7.

Input

The first line contains a single integer t (1 ≤ t ≤ 10^4) — the number of test cases.

The first and only line of each test case contains two integers n and k (2 ≤ n ≤ 10^9; 1 ≤ k ≤ 10^9).

Output

For each test case, print one integer — the k-th special number in increasing order modulo 10^9+7.

Example

Input


3
3 4
2 12
105 564


Output


9
12
3595374

Note

For n = 3 the sequence is [1,3,4,9...]

EXAMPLE QUESTIONS:
Example question 1:
Name: 768_C. Jon Snow and his Favourite Number
Tags: ['brute force', 'dp', 'implementation', 'sortings']
Description: Jon Snow now has to fight with White Walkers. He has n rangers, each of which has his own strength. Also Jon Snow has his favourite number x. Each ranger can fight with a white walker only if the strength of the white walker equals his strength. He however thinks that his rangers are weak and need to improve. Jon now thinks that if he takes the bitwise XOR of strengths of some of rangers with his favourite number x, he might get soldiers of high strength. So, he decided to do the following operation k times: 

  1. Arrange all the rangers in a straight line in the order of increasing strengths.
  2. Take the bitwise XOR (is written as <image>) of the strength of each alternate ranger with x and update it's strength.

Suppose, Jon has 5 rangers with strengths [9, 7, 11, 15, 5] and he performs the operation 1 time with x = 2. He first arranges them in the order of their strengths, [5, 7, 9, 11, 15]. Then he does the following: 

  1. The strength of first ranger is updated to <image>, i.e. 7.
  2. The strength of second ranger remains the same, i.e. 7.
  3. The strength of third ranger is updated to <image>, i.e. 11.
  4. The strength of fourth ranger remains the same, i.e. 11.
  5. The strength of fifth ranger is updated to <image>, i.e. 13.

The new strengths of the 5 rangers are [7, 7, 11, 11, 13]

Now, Jon wants to know the maximum and minimum strength of the rangers after performing the above operations k times. He wants your help for this task. Can you help him?

Input

First line consists of three integers n, k, x (1 ≤ n ≤ 105, 0 ≤ k ≤ 105, 0 ≤ x ≤ 103) — number of rangers Jon has, the number of times Jon will carry out the operation and Jon's favourite number respectively.

Second line consists of n integers representing the strengths of the rangers a1, a2, ..., an (0 ≤ ai ≤ 103).

Output

Output two integers, the maximum and the minimum strength of the rangers after performing the operation k times.

Examples

Input

5 1 2
9 7 11 15 5


Output

13 7

Input

2 100000 569
605 986


Output

986 605
Difficulty: 9
Solutions: import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.util.Arrays;
import java.util.StringTokenizer;

public class C399 {
	public static void main(String[] args) {
		FS scan = new FS(System.in);
		int N = scan.nextInt(), K = scan.nextInt(), X = scan.nextInt();
		int[] compress = new int[1<<10];
		for(int i=0;i<N;i++){
			compress[scan.nextInt()]++;
		}
		int[] next = new int[1<<10];
		for(int i=0;i<K;i++){
			Arrays.fill(next, 0);
			int parity = 0;
			for(int j=0;j<1<<10;j++){
				if(compress[j]==0)continue;
				if(parity==0){
					next[j] += compress[j]>>1;
					next[j^X]+=(compress[j]+1)>>1;
				}else{
					next[j^X] += compress[j]>>1;
					next[j]+=(compress[j]+1)>>1;
				}
				parity+=compress[j];
				parity&=1;
			}
			compress = Arrays.copyOf(next, next.length);
		}
		
		int min = 10000, max = -1;
		for(int i=0;i<1<<10;i++){
			if(compress[i]==0)continue;
			if(i<min)min = i;
			if(i>max)max = i;
		}
		System.out.println(max+" "+min);
	}
	private static class FS {
		BufferedReader br;
		StringTokenizer st;
		public FS(InputStream in) {
			br = new BufferedReader(new InputStreamReader(in));
		}
		String next(){
			while(st==null||!st.hasMoreElements()){
				try{st = new StringTokenizer(br.readLine());}
				catch(IOException e){e.printStackTrace();}
			}
			return st.nextToken();
		}
		int nextInt() {return Integer.parseInt(next());}
		long nextLong() {return Long.parseLong(next());}
		double nextDouble() { return Double.parseDouble(next());}
	}
}



INSTRUCTIONS:
Solve the current question.
Provide:
1. A complete and efficient code solution, optimized for both time and space complexity.
2. A detailed explanation of the solution, including:
   - The intuition behind the approach;
   - Time and space complexity;
   - Important considerations about the algorithm.
3. You can use the example questions as general references for coding patterns and structure, but solve the current problem independently.
4. Don't use any external libraries. Any language is accepted.