#include <iostream>
#include <vector>
#include <cmath>
#include <algorithm>
#include <iomanip>

using namespace std;

struct Point {
    int x, y;
};

// Calculate Euclidean distance between two points
double distance(Point a, Point b) {
    return sqrt(pow(a.x - b.x, 2) + pow(a.y - b.y, 2));
}

// Check if three points are collinear
bool areCollinear(Point a, Point b, Point c) {
    // Using cross product: (b-a) Ã— (c-a) = 0 for collinear points
    return (b.x - a.x) * (c.y - a.y) == (b.y - a.y) * (c.x - a.x);
}

// Find the non-collinear point
int findNonCollinearPoint(vector<Point>& points) {
    int n = points.size();
    if (n <= 2) return -1; // Need at least 3 points
    
    // Try to establish a line with first 3 points
    for (int i = 0; i < n; i++) {
        for (int j = i+1; j < n; j++) {
            int count = 0;
            int outlier = -1;
            
            for (int k = 0; k < n; k++) {
                if (!areCollinear(points[i], points[j], points[k])) {
                    count++;
                    outlier = k;
                }
            }
            
            if (count == 1) return outlier; // Found the outlier
        }
    }
    return -1; // Should not reach here based on problem constraints
}

int main() {
    int n, k;
    cin >> n >> k;
    
    vector<Point> points(n);
    for (int i = 0; i < n; i++) {
        cin >> points[i].x >> points[i].y;
    }
    
    // Adjust for 0-indexed
    k--;
    
    // Find the non-collinear point
    int outlierIdx = findNonCollinearPoint(points);
    
    // Find the collinear points
    vector<int> collinearIndices;
    for (int i = 0; i < n; i++) {
        if (i != outlierIdx) {
            collinearIndices.push_back(i);
        }
    }
    
    // Sort collinear points to ensure we're visiting them in order along the line
    if (collinearIndices.size() >= 2) {
        sort(collinearIndices.begin(), collinearIndices.end(), [&](int a, int b) {
            Point& pa = points[a];
            Point& pb = points[b];
            
            // Compare based on x coordinate first, then y if x is equal
            if (pa.x != pb.x) return pa.x < pb.x;
            return pa.y < pb.y;
        });
    }
    
    double minDist = 1e18;
    
    // Try visiting all collinear points first, then the outlier
    for (bool reverse : {false, true}) {
        vector<int> path = collinearIndices;
        if (reverse) {
            std::reverse(path.begin(), path.end());
        }
        path.push_back(outlierIdx);
        
        // Check if we start from outlier
        if (k == outlierIdx) {
            double dist = 0;
            int curr = k;
            for (int next : collinearIndices) {
                dist += distance(points[curr], points[next]);
                curr = next;
            }
            minDist = min(minDist, dist);
            continue;
        }
        
        // Check both directions for visiting collinear points
        for (int direction = 0; direction < 2; direction++) {
            double dist = 0;
            int curr = k;
            
            if (direction == 0) {
                // Find where K is in the sorted array
                auto it = find(path.begin(), path.end() - 1, k);
                int kPos = distance(path.begin(), it);
                
                // Visit collinear points to the right
                for (int i = kPos + 1; i < (int)path.size() - 1; i++) {
                    dist += distance(points[curr], points[path[i]]);
                    curr = path[i];
                }
                
                // Visit collinear points to the left
                for (int i = kPos - 1; i >= 0; i--) {
                    dist += distance(points[curr], points[path[i]]);
                    curr = path[i];
                }
            } else {
                // Find where K is in the sorted array
                auto it = find(path.begin(), path.end() - 1, k);
                int kPos = distance(path.begin(), it);
                
                // Visit collinear points to the left
                for (int i = kPos - 1; i >= 0; i--) {
                    dist += distance(points[curr], points[path[i]]);
                    curr = path[i];
                }
                
                // Visit collinear points to the right
                for (int i = kPos + 1; i < (int)path.size() - 1; i++) {
                    dist += distance(points[curr], points[path[i]]);
                    curr = path[i];
                }
            }
            
            // Visit the outlier last
            dist += distance(points[curr], points[outlierIdx]);
            minDist = min(minDist, dist);
        }
    }
    
    cout << fixed << setprecision(6) << minDist << endl;
    
    return 0;
}