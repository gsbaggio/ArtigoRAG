def min_deletions_to_nonzero_and(t, test_cases):
    results = []
    
    for l, r in test_cases:
        # Total number of elements in the range [l, r]
        total_elements = r - l + 1
        
        # Count the number of 1s for each bit position (0 to 19)
        bit_count = [0] * 20
        for num in range(l, r + 1):
            for bit in range(20):
                if num & (1 << bit):
                    bit_count[bit] += 1
        
        # Maximum count of 1s in any bit position
        max_ones = max(bit_count)
        
        # Minimum deletions = total elements - max_ones
        results.append(total_elements - max_ones)
    
    return results


# Input reading
if __name__ == "__main__":
    import sys
    input = sys.stdin.read
    data = input().split()
    
    t = int(data[0])
    test_cases = []
    index = 1
    for _ in range(t):
        l, r = map(int, data[index:index+2])
        test_cases.append((l, r))
        index += 2
    
    # Solve the problem
    results = min_deletions_to_nonzero_and(t, test_cases)
    
    # Output the results
    sys.stdout.write("\n".join(map(str, results)) + "\n")