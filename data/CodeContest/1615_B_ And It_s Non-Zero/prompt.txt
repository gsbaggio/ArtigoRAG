CURRENT QUESTION:
You are given an array consisting of all integers from [l, r] inclusive. For example, if l = 2 and r = 5, the array would be [2, 3, 4, 5]. What's the minimum number of elements you can delete to make the [bitwise AND](https://en.wikipedia.org/wiki/Bitwise_operation#AND) of the array non-zero?

A bitwise AND is a binary operation that takes two equal-length binary representations and performs the AND operation on each pair of the corresponding bits.

Input

The first line contains one integer t (1 ≤ t ≤ 10^4) — the number of test cases. Then t cases follow.

The first line of each test case contains two integers l and r (1 ≤ l ≤ r ≤ 2 ⋅ 10^5) — the description of the array.

Output

For each test case, output a single integer — the answer to the problem.

Example

Input


5
1 2
2 8
4 5
1 5
100000 200000


Output


1
3
0
2
31072

Note

In the first test case, the array is [1, 2]. Currently, the bitwise AND is 0, as 1\ \& \ 2 = 0. However, after deleting 1 (or 2), the array becomes [2] (or [1]), and the bitwise AND becomes 2 (or 1). This can be proven to be the optimal, so the answer is 1.

In the second test case, the array is [2, 3, 4, 5, 6, 7, 8]. Currently, the bitwise AND is 0. However, after deleting 4, 5, and 8, the array becomes [2, 3, 6, 7], and the bitwise AND becomes 2. This can be proven to be the optimal, so the answer is 3. Note that there may be other ways to delete 3 elements.

SIMILAR QUESTIONS:
Similar question 1 (Similarity score: 0.76):
Name: 1506_D. Epic Transformation
Tags: ['constructive algorithms', 'data structures', 'greedy']
Description: You are given an array a of length n consisting of integers. You can apply the following operation, consisting of several steps, on the array a zero or more times: 

  * you select two different numbers in the array a_i and a_j; 
  * you remove i-th and j-th elements from the array. 



For example, if n=6 and a=[1, 6, 1, 1, 4, 4], then you can perform the following sequence of operations: 

  * select i=1, j=5. The array a becomes equal to [6, 1, 1, 4]; 
  * select i=1, j=2. The array a becomes equal to [1, 4]. 



What can be the minimum size of the array after applying some sequence of operations to it?

Input

The first line contains a single integer t (1 ≤ t ≤ 10^4). Then t test cases follow.

The first line of each test case contains a single integer n (1 ≤ n ≤ 2 ⋅ 10^5) is length of the array a.

The second line of each test case contains n integers a_1, a_2, …, a_n (1 ≤ a_i ≤ 10^9).

It is guaranteed that the sum of n over all test cases does not exceed 2 ⋅ 10^5.

Output

For each test case, output the minimum possible size of the array after applying some sequence of operations to it.

Example

Input


5
6
1 6 1 1 4 4
2
1 2
2
1 1
5
4 5 4 5 4
6
2 3 2 1 3 1


Output


0
0
2
1
0
Difficulty: 10
Solutions: import sys
input=sys.stdin.readline

t = int(input())
 
for i in range(t):
    n=int(input())
    a=[int(x) for x in input().split()]
    a.sort()
    temp=1

    if n==1:
        print(1)
        continue

    count=[]

    for i in range(1,n):
        if a[i]==a[i-1]:
            temp+=1
            if i==n-1:
                count.append(temp)
        else:
            count.append(temp)
            temp=1
            if i==n-1:
                count.append(temp)

    count.sort()

    if len(count)==1:
        print(count[0])
        continue

    if count[-1]<=sum(count[:len(count)-1]):
        print(n%2)
    else:
        print(count[-1]-sum(count[:len(count)-1]))


Similar question 2 (Similarity score: 0.75):
Name: 1514_B. AND 0, Sum Big
Tags: ['bitmasks', 'combinatorics', 'math']
Description: Baby Badawy's first words were "AND 0 SUM BIG", so he decided to solve the following problem. Given two integers n and k, count the number of arrays of length n such that:

  * all its elements are integers between 0 and 2^k-1 (inclusive); 
  * the [bitwise AND](https://en.wikipedia.org/wiki/Bitwise_operation#AND) of all its elements is 0; 
  * the sum of its elements is as large as possible. 



Since the answer can be very large, print its remainder when divided by 10^9+7.

Input

The first line contains an integer t (1 ≤ t ≤ 10) — the number of test cases you need to solve.

Each test case consists of a line containing two integers n and k (1 ≤ n ≤ 10^{5}, 1 ≤ k ≤ 20).

Output

For each test case, print the number of arrays satisfying the conditions. Since the answer can be very large, print its remainder when divided by 10^9+7.

Example

Input


2
2 2
100000 20


Output


4
226732710

Note

In the first example, the 4 arrays are:

  * [3,0], 
  * [0,3], 
  * [1,2], 
  * [2,1]. 
Difficulty: 8
Solutions: #include<bits/stdc++.h>
using namespace std;
#define ll long long int
const ll mod = 1e9 + 7;
#define inf 1e18 + 3
#define pb push_back
#define mp make_pair

void solve() {
	int n, k;
	cin >> n >> k;
	ll ans = 1;
	while (k > 0) {
		ans = (ans * n) % mod;
		k--;
	}
	cout << ans << '\n';
}

signed main() {
#ifndef ONLINE_JUDGE
	freopen("input.txt", "r", stdin);
	freopen("output.txt", "w", stdout);
#endif
	int t;
	cin >> t;
	while (t--)solve();
	return 0;
}

Similar question 3 (Similarity score: 0.74):
Name: 1527_A. And Then There Were K
Tags: ['bitmasks']
Description: Given an integer n, find the maximum value of integer k such that the following condition holds: 

n & (n-1) & (n-2) & (n-3) & ... (k) = 0  where & denotes the [bitwise AND operation.](https://en.wikipedia.org/wiki/Bitwise_operation#AND)

Input

The first line contains a single integer t (1 ≤ t ≤ 3 ⋅ 10^4). Then t test cases follow.

The first line of each test case contains a single integer n (1 ≤ n ≤ 10^9).

Output

For each test case, output a single integer — the required integer k.

Example

Input


3
2
5
17


Output


1
3
15

Note

In the first testcase, the maximum value for which the continuous & operation gives 0 value, is 1.

In the second testcase, the maximum value for which the continuous & operation gives 0 value, is 3. No value greater then 3, say for example 4, will give the & sum 0. 

  * 5   \&   4 ≠ 0, 
  * 5   \&   4   \&   3 = 0. 



Hence, 3 is the answer.
Difficulty: 7
Solutions: from math import log
from math import floor
t = int(input())

for i in range(t):
    n = int(input())
    #print(n)
    k = 2**(floor(log(n,2)))-1
    print(k)




INSTRUCTIONS:
Solve the current question.
Provide:
1. A complete and efficient code solution, optimized for both time and space complexity.
2. A detailed explanation of the solution, including:
   - The intuition behind the approach;
   - Time and space complexity;
   - Important considerations about the algorithm.
3. If the language has classes, implement in 'Solution' class. Any language is accepted.
4. Use the similar questions as references to improve the solution, but only if they are relevant.
5. Don't use any external libraries. Don't need to import any libraries.
