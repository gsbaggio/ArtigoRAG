CURRENT QUESTION:
You are given a tree consisting of n vertices. Recall that a tree is an undirected connected acyclic graph. The given tree is rooted at the vertex 1.

You have to process q queries. In each query, you are given a vertex of the tree v and an integer k.

To process a query, you may delete any vertices from the tree in any order, except for the root and the vertex v. When a vertex is deleted, its children become the children of its parent. You have to process a query in such a way that maximizes the value of c(v) - m ⋅ k (where c(v) is the resulting number of children of the vertex v, and m is the number of vertices you have deleted). Print the maximum possible value you can obtain.

The queries are independent: the changes you make to the tree while processing a query don't affect the tree in other queries.

Input

The first line contains one integer n (1 ≤ n ≤ 2 ⋅ 10^5) — the number of vertices in the tree.

Then n-1 lines follow, the i-th of them contains two integers x_i and y_i (1 ≤ x_i, y_i ≤ n; x_i ≠ y_i) — the endpoints of the i-th edge. These edges form a tree.

The next line contains one integer q (1 ≤ q ≤ 2 ⋅ 10^5) — the number of queries.

Then q lines follow, the j-th of them contains two integers v_j and k_j (1 ≤ v_j ≤ n; 0 ≤ k_j ≤ 2 ⋅ 10^5) — the parameters of the j-th query.

Output

For each query, print one integer — the maximum value of c(v) - m ⋅ k you can achieve.

Example

Input


8
6 7
3 2
8 3
5 7
7 4
7 1
7 3
6
1 0
1 2
1 3
7 1
5 0
7 200000


Output


5
2
1
4
0
4

Note

The tree in the first example is shown in the following picture:

<image>

Answers to the queries are obtained as follows:

  1. v=1,k=0: you can delete vertices 7 and 3, so the vertex 1 has 5 children (vertices 2, 4, 5, 6, and 8), and the score is 5 - 2 ⋅ 0 = 5; 
  2. v=1,k=2: you can delete the vertex 7, so the vertex 1 has 4 children (vertices 3, 4, 5, and 6), and the score is 4 - 1 ⋅ 2 = 2. 
  3. v=1,k=3: you shouldn't delete any vertices, so the vertex 1 has only one child (vertex 7), and the score is 1 - 0 ⋅ 3 = 1; 
  4. v=7,k=1: you can delete the vertex 3, so the vertex 7 has 5 children (vertices 2, 4, 5, 6, and 8), and the score is 5 - 1 ⋅ 1 = 4; 
  5. v=5,k=0: no matter what you do, the vertex 5 will have no children, so the score is 0; 
  6. v=7,k=200000: you shouldn't delete any vertices, so the vertex 7 has 4 children (vertices 3, 4, 5, and 6), and the score is 4 - 0 ⋅ 200000 = 4. 

EXAMPLE QUESTIONS:
Example question 1:
Name: 1431_F. Neural Network Problem
Tags: ['*special', 'binary search', 'greedy']
Description: You want to train a neural network model for your graduation work. There are n images in the dataset, the i-th image's size is a_i bytes.

You don't have any powerful remote servers to train this model so you have to do it on your local machine. But there is a problem: the total size of the dataset is too big for your machine, so you decided to remove some images — though you don't want to make the dataset too weak so you can remove no more than k images from it. Note that you can only remove images, you can't change their order.

You want to remove these images optimally so you came up with a metric (you're a data scientist after all) that allows to measure the result of removals. Consider the array b_1, b_2, …, b_m after removing at most k images (n - k ≤ m ≤ n). The data from this array will be uploaded to the machine in blocks of x consecutive elements each. More precisely:

  * elements with indices from 1 to x (b_1, b_2, …, b_x) belong to the first block; 
  * elements with indices from x + 1 to 2x (b_{x + 1}, b_{x + 2}, …, b_{2x}) belong to the second block; 
  * elements with indices from 2x + 1 to 3x (b_{2x + 1}, b_{2x + 2}, …, b_{3x}) belong to the third block; 
  * and so on. 



There will be cnt = \left⌈m/x\right⌉ blocks in total. Note that if m is not divisible by x then the last block contains less than x elements, and it's okay.

Let w(i) be the total size of the i-th block — that is, the sum of sizes of images inside this block. For example, the size of the first block w(1) is b_1 + b_2 + … + b_x, the size of the second block w(2) is b_{x + 1} + b_{x + 2} + … + b_{2x}.

The value of the metric you came up with is the maximum block size over the blocks of the resulting dataset. In other words, the value of the metric is max_{i=1}^{cnt} w(i).

You don't want to overload your machine too much, so you have to remove at most k images in a way that minimizes the value of the metric described above.

Input

The first line of the input contains three integers n, k and x (1 ≤ n ≤ 10^5; 1 ≤ k, x ≤ n) — the number of images in the dataset, the maximum number of images you can remove and the length of each block (except maybe for the last one), respectively.

The second line of the input contains n integers a_1, a_2, …, a_n (1 ≤ a_i ≤ 10^5), where a_i is the size of the i-th image.

Output

Print one integer: the minimum possible value of the metric described in the problem statement after removing no more than k images from the dataset.

Examples

Input


5 5 4
1 1 5 4 5


Output


0


Input


5 2 4
6 1 5 5 6


Output


11


Input


6 1 4
3 3 1 3 1 2


Output


8


Input


6 1 3
2 2 1 2 2 1


Output


5

Note

In the first example, you can remove the whole array so the answer is 0.

In the second example, you can remove the first and the last elements of a and obtain b = [1, 5, 5]. The size of the first (and the only) block is 11. So the answer is 11.

In the third example, you can remove the second element of a and obtain b = [3, 1, 3, 1, 2]. The size of the first block is 8 and the size of the second block is 2. So the answer is 8.

In the fourth example, you can keep the array a unchanged and obtain b = [2, 2, 1, 2, 2, 1]. The size of the first block is 5 as well as the size of the second block. So the answer is 5.
Difficulty: 12
Solutions: 

Example question 2:
Name: 405_E. Graph Cutting
Tags: ['dfs and similar', 'graphs']
Description: Little Chris is participating in a graph cutting contest. He's a pro. The time has come to test his skills to the fullest.

Chris is given a simple undirected connected graph with n vertices (numbered from 1 to n) and m edges. The problem is to cut it into edge-distinct paths of length 2. Formally, Chris has to partition all edges of the graph into pairs in such a way that the edges in a single pair are adjacent and each edge must be contained in exactly one pair.

For example, the figure shows a way Chris can cut a graph. The first sample test contains the description of this graph.

<image>

You are given a chance to compete with Chris. Find a way to cut the given graph or determine that it is impossible!

Input

The first line of input contains two space-separated integers n and m (1 ≤ n, m ≤ 105), the number of vertices and the number of edges in the graph. The next m lines contain the description of the graph's edges. The i-th line contains two space-separated integers ai and bi (1 ≤ ai, bi ≤ n; ai ≠ bi), the numbers of the vertices connected by the i-th edge. It is guaranteed that the given graph is simple (without self-loops and multi-edges) and connected.

Note: since the size of the input and output could be very large, don't use slow output techniques in your language. For example, do not use input and output streams (cin, cout) in C++.

Output

If it is possible to cut the given graph into edge-distinct paths of length 2, output <image> lines. In the i-th line print three space-separated integers xi, yi and zi, the description of the i-th path. The graph should contain this path, i.e., the graph should contain edges (xi, yi) and (yi, zi). Each edge should appear in exactly one path of length 2. If there are multiple solutions, output any of them.

If it is impossible to cut the given graph, print "No solution" (without quotes).

Examples

Input

8 12
1 2
2 3
3 4
4 1
1 3
2 4
3 5
3 6
5 6
6 7
6 8
7 8


Output

1 2 4
1 3 2
1 4 3
5 3 6
5 6 8
6 7 8

Input

3 3
1 2
2 3
3 1


Output

No solution


Input

3 2
1 2
2 3


Output

1 2 3
Difficulty: 11
Solutions: #include <bits/stdc++.h>
using namespace std;
int n, m;
int visit[111111];
vector<int> v[111111], mark[111111];
int dfs(int t) {
  vector<int> v1;
  int i;
  for (i = 0; i < v[t].size(); i++) {
    int u = v[t][i];
    if (visit[mark[t][i]] == 0) {
      visit[mark[t][i]] = 1;
      int w = dfs(u);
      if (w == 0)
        v1.push_back(u);
      else
        printf("%d %d %d\n", t, u, w);
    }
  }
  while (v1.size() > 1) {
    printf("%d %d %d\n", v1[v1.size() - 1], t, v1[v1.size() - 2]);
    v1.pop_back();
    v1.pop_back();
  }
  if (v1.size() == 1)
    return v1[0];
  else
    return 0;
}
int main() {
  memset(visit, 0, sizeof(visit));
  scanf("%d%d", &n, &m);
  int i;
  for (i = 0; i < m; i++) {
    int a, b;
    scanf("%d%d", &a, &b);
    v[a].push_back(b);
    v[b].push_back(a);
    mark[a].push_back(i);
    mark[b].push_back(i);
  }
  if (m % 2)
    printf("No solution\n");
  else {
    for (i = 1; i <= n; i++) dfs(i);
  }
}


Example question 3:
Name: 1167_D. Bicolored RBS
Tags: ['constructive algorithms', 'greedy']
Description: A string is called bracket sequence if it does not contain any characters other than "(" and ")". A bracket sequence is called regular (shortly, RBS) if it is possible to obtain correct arithmetic expression by inserting characters "+" and "1" into this sequence. For example, "", "(())" and "()()" are RBS and ")(" and "(()" are not.

We can see that each opening bracket in RBS is paired with some closing bracket, and, using this fact, we can define nesting depth of the RBS as maximum number of bracket pairs, such that the 2-nd pair lies inside the 1-st one, the 3-rd one — inside the 2-nd one and so on. For example, nesting depth of "" is 0, "()()()" is 1 and "()((())())" is 3.

Now, you are given RBS s of even length n. You should color each bracket of s into one of two colors: red or blue. Bracket sequence r, consisting only of red brackets, should be RBS, and bracket sequence, consisting only of blue brackets b, should be RBS. Any of them can be empty. You are not allowed to reorder characters in s, r or b. No brackets can be left uncolored.

Among all possible variants you should choose one that minimizes maximum of r's and b's nesting depth. If there are multiple solutions you can print any of them.

Input

The first line contains an even integer n (2 ≤ n ≤ 2 ⋅ 10^5) — the length of RBS s.

The second line contains regular bracket sequence s (|s| = n, s_i ∈ \{"(", ")"\}).

Output

Print single string t of length n consisting of "0"-s and "1"-s. If t_i is equal to 0 then character s_i belongs to RBS r, otherwise s_i belongs to b.

Examples

Input


2
()


Output


11


Input


4
(())


Output


0101


Input


10
((()())())


Output


0110001111

Note

In the first example one of optimal solutions is s =  "\color{blue}{()}". r is empty and b =  "()". The answer is max(0, 1) = 1.

In the second example it's optimal to make s =  "\color{red}{(}\color{blue}{(}\color{red}{)}\color{blue}{)}". r = b =  "()" and the answer is 1.

In the third example we can make s =  "\color{red}{(}\color{blue}{((}\color{red}{)()}\color{blue}{)())}". r =  "()()" and b =  "(()())" and the answer is 2.
Difficulty: 10
Solutions: #include <bits/stdc++.h>
using namespace std;
int main() {
  ios_base::sync_with_stdio(false);
  cin.tie(0);
  cout.tie(0);
  int n;
  cin >> n;
  int d = 0;
  while (n--) {
    char e;
    cin >> e;
    if (e == '(') {
      cout << d % 2;
      d++;
    } else {
      d--;
      cout << d % 2;
    }
  }
  cout << endl;
}



INSTRUCTIONS:
Solve the current question.
Provide:
1. A complete and efficient code solution, optimized for both time and space complexity.
2. A detailed explanation of the solution, including:
   - The intuition behind the approach;
   - Time and space complexity;
   - Important considerations about the algorithm.
3. You can use the example questions as general references for coding patterns and structure, but solve the current problem independently.
4. Don't use any external libraries. Any language is accepted.