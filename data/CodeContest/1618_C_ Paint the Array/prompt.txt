CURRENT QUESTION:
You are given an array a consisting of n positive integers. You have to choose a positive integer d and paint all elements into two colors. All elements which are divisible by d will be painted red, and all other elements will be painted blue.

The coloring is called beautiful if there are no pairs of adjacent elements with the same color in the array. Your task is to find any value of d which yields a beautiful coloring, or report that it is impossible.

Input

The first line contains a single integer t (1 ≤ t ≤ 1000) — the number of testcases.

The first line of each testcase contains one integer n (2 ≤ n ≤ 100) — the number of elements of the array.

The second line of each testcase contains n integers a_1, a_2, ..., a_n (1 ≤ a_i ≤ 10^{18}).

Output

For each testcase print a single integer. If there is no such value of d that yields a beautiful coloring, print 0. Otherwise, print any suitable value of d (1 ≤ d ≤ 10^{18}).

Example

Input


5
5
1 2 3 4 5
3
10 5 15
3
100 10 200
10
9 8 2 6 6 2 8 6 5 4
2
1 3


Output


2
0
100
0
3

SIMILAR QUESTIONS:
Similar question 1 (Similarity score: 0.77):
Name: 1102_B. Array K-Coloring
Tags: ['greedy', 'sortings']
Description: You are given an array a consisting of n integer numbers.

You have to color this array in k colors in such a way that: 

  * Each element of the array should be colored in some color; 
  * For each i from 1 to k there should be at least one element colored in the i-th color in the array; 
  * For each i from 1 to k all elements colored in the i-th color should be distinct. 



Obviously, such coloring might be impossible. In this case, print "NO". Otherwise print "YES" and any coloring (i.e. numbers c_1, c_2, ... c_n, where 1 ≤ c_i ≤ k and c_i is the color of the i-th element of the given array) satisfying the conditions above. If there are multiple answers, you can print any.

Input

The first line of the input contains two integers n and k (1 ≤ k ≤ n ≤ 5000) — the length of the array a and the number of colors, respectively.

The second line of the input contains n integers a_1, a_2, ..., a_n (1 ≤ a_i ≤ 5000) — elements of the array a.

Output

If there is no answer, print "NO". Otherwise print "YES" and any coloring (i.e. numbers c_1, c_2, ... c_n, where 1 ≤ c_i ≤ k and c_i is the color of the i-th element of the given array) satisfying the conditions described in the problem statement. If there are multiple answers, you can print any.

Examples

Input


4 2
1 2 2 3


Output


YES
1 1 2 2


Input


5 2
3 2 1 2 3


Output


YES
2 1 1 2 1


Input


5 2
2 1 1 2 1


Output


NO

Note

In the first example the answer 2~ 1~ 2~ 1 is also acceptable.

In the second example the answer 1~ 1~ 1~ 2~ 2 is also acceptable.

There exist other acceptable answers for both examples.
Difficulty: 8
Solutions: import java.io.*;
import java.util.*;
public class div531B
{
	BufferedReader in;
	PrintWriter ob;
	StringTokenizer st;

	public static void main(String[] args) throws IOException {
		new div531B().run();
	}
	void run() throws IOException {
		in=new BufferedReader(new InputStreamReader(System.in));
		ob=new PrintWriter(System.out);
		solve();
		ob.flush();
	}
	void solve() throws IOException {
		int n = ni();
		int k = ni();
		int a[] = new int[n+1];
		int cnt[] = new int[5002];
		int max = 0;
		for(int i=1 ; i<=n ; i++) {
			a[i] = ni();
			++cnt[a[i]];
			max = Math.max( max , cnt[a[i]] );
		}
		if( max > k )
			ob.println("NO");
		else {
			boolean good = true;
			int color = 1;
			int res[] = new int[n+1];
			Arrays.fill( res , -1 );
			for(int i=1 ; i<=n ; i++) {
				if( res[i] == -1 ) {
					for(int j=1 ; j<=n ; j++) {
						if( res[j] == -1 && a[j] == a[i] )
							{
								res[j] = color++;
								if( color == k+1 ) {
									color = 1;
									good = true;
								}
							}
					}
				}
			}
			if( good ){
				ob.println("YES");
				for(int i=1; i<=n ; i++)
				ob.print(res[i]+" ");
			} else {
				ob.println("NO");
			}
			
		}
	}
	String ns() throws IOException {
		return nextToken();
	}
	long nl() throws IOException {
		return Long.parseLong(nextToken());
	}
	int ni() throws IOException {
		return Integer.parseInt(nextToken());
	}
	double nd() throws IOException {
		return Double.parseDouble(nextToken());
	} 
	String nextToken() throws IOException {
		if(st==null || !st.hasMoreTokens())
			st=new StringTokenizer(in.readLine());
		return st.nextToken();
	}
	int[] nia(int start,int b) throws IOException {
		int a[]=new int[b];
		for(int i=start;i<b;i++)
			a[i]=ni();
		return a;
	}
	long[] nla(int start,int n) throws IOException {
		long a[]=new long[n];
		for (int i=start; i<n ;i++ ) {
			a[i]=nl();
		}
		return a;
	}
}

Similar question 2 (Similarity score: 0.73):
Name: 1209_A. Paint the Numbers
Tags: ['greedy', 'implementation', 'math']
Description: You are given a sequence of integers a_1, a_2, ..., a_n. You need to paint elements in colors, so that: 

  * If we consider any color, all elements of this color must be divisible by the minimal element of this color. 
  * The number of used colors must be minimized. 



For example, it's fine to paint elements [40, 10, 60] in a single color, because they are all divisible by 10. You can use any color an arbitrary amount of times (in particular, it is allowed to use a color only once). The elements painted in one color do not need to be consecutive.

For example, if a=[6, 2, 3, 4, 12] then two colors are required: let's paint 6, 3 and 12 in the first color (6, 3 and 12 are divisible by 3) and paint 2 and 4 in the second color (2 and 4 are divisible by 2). For example, if a=[10, 7, 15] then 3 colors are required (we can simply paint each element in an unique color).

Input

The first line contains an integer n (1 ≤ n ≤ 100), where n is the length of the given sequence.

The second line contains n integers a_1, a_2, ..., a_n (1 ≤ a_i ≤ 100). These numbers can contain duplicates.

Output

Print the minimal number of colors to paint all the given numbers in a valid way.

Examples

Input


6
10 2 3 5 4 2


Output


3


Input


4
100 100 100 100


Output


1


Input


8
7 6 5 4 3 2 2 3


Output


4

Note

In the first example, one possible way to paint the elements in 3 colors is:

  * paint in the first color the elements: a_1=10 and a_4=5, 
  * paint in the second color the element a_3=3, 
  * paint in the third color the elements: a_2=2, a_5=4 and a_6=2. 



In the second example, you can use one color to paint all the elements.

In the third example, one possible way to paint the elements in 4 colors is:

  * paint in the first color the elements: a_4=4, a_6=2 and a_7=2, 
  * paint in the second color the elements: a_2=6, a_5=3 and a_8=3, 
  * paint in the third color the element a_3=5, 
  * paint in the fourth color the element a_1=7. 
Difficulty: 7
Solutions: n=int(input())
arr = list(map(int,input().split()))
elem = {}
arr.sort()
for i in arr:
  f=0
  for k in elem:
    if i%k == 0:
      elem[k]+=1
      f=1
      break
  if not f:
    elem[i] = 1
print(len(elem))

Similar question 3 (Similarity score: 0.72):
Name: p02973 AtCoder Beginner Contest 134 - Sequence Decomposing
Tags: ['']
Description: You are given a sequence with N integers: A = \\{ A_1, A_2, \cdots, A_N \\}. For each of these N integers, we will choose a color and paint the integer with that color. Here the following condition must be satisfied:

* If A_i and A_j (i < j) are painted with the same color, A_i < A_j.



Find the minimum number of colors required to satisfy the condition.

Constraints

* 1 \leq N \leq 10^5
* 0 \leq A_i \leq 10^9

Input

Input is given from Standard Input in the following format:


N
A_1
:
A_N


Output

Print the minimum number of colors required to satisfy the condition.

Examples

Input

5
2
1
4
5
3


Output

2


Input

4
0
0
0
0


Output

4
Difficulty: 0
Solutions: 
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.List;
import java.util.Scanner;

public class Main {
    public static void main(String [] args) {
        Scanner scanner = new Scanner(System.in);
        int n = scanner.nextInt();
        long[] a = new long[n];
        for (int i = 0; i < n; ++i) {
            long current = scanner.nextLong();
            a[i] = current;
        }

        List<Long> numbers = new ArrayList<>();
        for (long num : a) {
            int value = Collections.binarySearch(
                    numbers, num
            );
            if (value >= 0 && value < numbers.size()) {
                int lessValue = Collections.binarySearch(
                        numbers, num - 1
                );
                if (lessValue >= 0 && lessValue < numbers.size()) {
                    numbers.set(lessValue, num);
                } else {
                    int lessPos = -1 * (lessValue + 1);
                    if (lessPos - 1 >= 0 && numbers.get(lessPos - 1) < num) {
                        numbers.set(lessPos - 1, num);
                    } else {
                        numbers.add(value, num);
                    }
                }
                continue;
            }

            int pos = -1 * (value + 1);
            if (pos - 1 >= 0 && numbers.get(pos - 1) < num) {
                numbers.set(pos - 1, num);
            } else {
                numbers.add(pos, num);
            }


        }
        System.out.println(numbers.size());

    }
}



INSTRUCTIONS:
Solve the current question.
Provide:
1. A complete and efficient code solution, optimized for both time and space complexity.
2. A detailed explanation of the solution, including:
   - The intuition behind the approach;
   - Time and space complexity;
   - Important considerations about the algorithm.
3. Use the similar questions as references to improve the solution, but only if they are relevant.
4. Don't use any external libraries. Any language is accepted.