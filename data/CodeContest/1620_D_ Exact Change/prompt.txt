CURRENT QUESTION:
One day, early in the morning, you decided to buy yourself a bag of chips in the nearby store. The store has chips of n different flavors. A bag of the i-th flavor costs a_i burles.

The store may run out of some flavors, so you'll decide which one to buy after arriving there. But there are two major flaws in this plan: 

  1. you have only coins of 1, 2 and 3 burles; 
  2. since it's morning, the store will ask you to pay in exact change, i. e. if you choose the i-th flavor, you'll have to pay exactly a_i burles. 



Coins are heavy, so you'd like to take the least possible number of coins in total. That's why you are wondering: what is the minimum total number of coins you should take with you, so you can buy a bag of chips of any flavor in exact change?

Input

The first line contains a single integer t (1 ≤ t ≤ 1000) — the number of test cases.

The first line of each test case contains the single integer n (1 ≤ n ≤ 100) — the number of flavors in the store.

The second line of each test case contains n integers a_1, a_2, ..., a_n (1 ≤ a_i ≤ 10^9) — the cost of one bag of each flavor.

Output

For each test case, print one integer — the minimum number of coins you need to buy one bag of any flavor you'll choose in exact change.

Example

Input


4
1
1337
3
10 8 10
5
1 2 3 4 5
3
7 77 777


Output


446
4
3
260

Note

In the first test case, you should, for example, take with you 445 coins of value 3 and 1 coin of value 2. So, 1337 = 445 ⋅ 3 + 1 ⋅ 2.

In the second test case, you should, for example, take 2 coins of value 3 and 2 coins of value 2. So you can pay either exactly 8 = 2 ⋅ 3 + 1 ⋅ 2 or 10 = 2 ⋅ 3 + 2 ⋅ 2.

In the third test case, it's enough to take 1 coin of value 3 and 2 coins of value 1.

SIMILAR QUESTIONS:
Similar question 1 (Similarity score: 0.73):
Name: 1132_B. Discounts
Tags: ['greedy', 'sortings']
Description: You came to a local shop and want to buy some chocolate bars. There are n bars in the shop, i-th of them costs a_i coins (and you want to buy all of them).

You have m different coupons that allow you to buy chocolate bars. i-th coupon allows you to buy q_i chocolate bars while you have to pay only for the q_i - 1 most expensive ones (so, the cheapest bar of those q_i bars is for free).

You can use only one coupon; if you use coupon i, you have to choose q_i bars and buy them using the coupon, and buy all the remaining n - q_i bars without any discounts.

To decide which coupon to choose, you want to know what will be the minimum total amount of money you have to pay if you use one of the coupons optimally.

Input

The first line contains one integer n (2 ≤ n ≤ 3 ⋅ 10^5) — the number of chocolate bars in the shop.

The second line contains n integers a_1, a_2, ..., a_n (1 ≤ a_i ≤ 10^9), where a_i is the cost of i-th chocolate bar.

The third line contains one integer m (1 ≤ m ≤ n - 1) — the number of coupons you have.

The fourth line contains m integers q_1, q_2, ..., q_m (2 ≤ q_i ≤ n), where q_i is the number of chocolate bars you have to buy using i-th coupon so that the least expensive of them will be for free. All values of q_i are pairwise distinct.

Output

Print m integers, i-th of them should be the minimum amount of money you have to pay if you buy q_i bars with i-th coupon, and all the remaining bars one by one for their full price.

Example

Input


7
7 1 3 1 4 10 8
2
3 4


Output


27
30

Note

Consider the first example.

If we use the first coupon, we may choose chocolate bars having indices 1, 6 and 7, and we pay 18 coins for them and 9 coins for all other bars.

If we use the second coupon, we may choose chocolate bars having indices 1, 5, 6 and 7, and we pay 25 coins for them and 5 coins for all other bars.
Difficulty: 8
Solutions: #include <bits/stdc++.h>
namespace FASTIO {
char buf[1 << 21];
char *p1, *p2;
template <typename T>
inline void wt(T x, char c = '\n') {
  if (x < 0) {
    x = -x;
    putchar('-');
  }
  static char sta[sizeof(T) * 8];
  T top = 0;
  do {
    sta[top++] = x % 10;
    x /= 10;
  } while (x);
  while (top) putchar(sta[--top] + '0');
  putchar(c);
}
template <typename T>
inline T rd() {
  T sum = 0, fl = 1;
  char ch =
      (p1 == p2 && (p2 = (p1 = buf) + fread(buf, 1, 1 << 21, stdin), p1 == p2)
           ? EOF
           : *p1++);
  for (; ch < '0' || ch > '9';
       ch = (p1 == p2 &&
                     (p2 = (p1 = buf) + fread(buf, 1, 1 << 21, stdin), p1 == p2)
                 ? EOF
                 : *p1++))
    if (ch == '-')
      fl = -1;
    else if (ch == EOF)
      exit(0);
  for (; '0' <= ch && ch <= '9';
       ch = (p1 == p2 &&
                     (p2 = (p1 = buf) + fread(buf, 1, 1 << 21, stdin), p1 == p2)
                 ? EOF
                 : *p1++))
    sum = sum * 10 + ch - '0';
  return sum * fl;
}
}  // namespace FASTIO
using namespace FASTIO;
int main() {
  int n = rd<int>(), *a;
  uint64_t sum = 0;
  a = new int[n];
  for (int i = 0; i < n; i++) sum += a[i] = rd<int>();
  std::sort(a, a + n, std::greater<int>());
  for (int m = rd<int>(); m--;) wt(sum - a[rd<int>() - 1]);
  delete a;
  return 0;
}


Similar question 2 (Similarity score: 0.70):
Name: 1234_A. Equalize Prices Again
Tags: ['math']
Description: You are both a shop keeper and a shop assistant at a small nearby shop. You have n goods, the i-th good costs a_i coins.

You got tired of remembering the price of each product when customers ask for it, thus you decided to simplify your life. More precisely you decided to set the same price for all n goods you have.

However, you don't want to lose any money so you want to choose the price in such a way that the sum of new prices is not less than the sum of the initial prices. It means that if you sell all n goods for the new price, you will receive at least the same (or greater) amount of money as if you sell them for their initial prices.

On the other hand, you don't want to lose customers because of big prices so among all prices you can choose you need to choose the minimum one.

So you need to find the minimum possible equal price of all n goods so if you sell them for this price, you will receive at least the same (or greater) amount of money as if you sell them for their initial prices.

You have to answer q independent queries.

Input

The first line of the input contains one integer q (1 ≤ q ≤ 100) — the number of queries. Then q queries follow.

The first line of the query contains one integer n (1 ≤ n ≤ 100) — the number of goods. The second line of the query contains n integers a_1, a_2, ..., a_n (1 ≤ a_i ≤ 10^7), where a_i is the price of the i-th good.

Output

For each query, print the answer for it — the minimum possible equal price of all n goods so if you sell them for this price, you will receive at least the same (or greater) amount of money as if you sell them for their initial prices.

Example

Input


3
5
1 2 3 4 5
3
1 2 2
4
1 1 1 1


Output


3
2
1
Difficulty: 7
Solutions: import math
for _  in range(int(input())):
    k=int(input())
    l=list(map(int,input().split()))
    k=sum(l)/k
    print(math.ceil(k))


INSTRUCTIONS:
Solve the current question.
Provide:
1. A complete and efficient code solution, optimized for both time and space complexity.
2. A detailed explanation of the solution, including:
   - The intuition behind the approach;
   - Time and space complexity;
   - Important considerations about the algorithm.
3. Use the similar questions as references to improve the solution, but only if they are relevant.
4. Don't use any external libraries. Any language is accepted.