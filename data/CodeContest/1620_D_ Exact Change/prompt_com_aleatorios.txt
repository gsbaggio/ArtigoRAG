CURRENT QUESTION:
One day, early in the morning, you decided to buy yourself a bag of chips in the nearby store. The store has chips of n different flavors. A bag of the i-th flavor costs a_i burles.

The store may run out of some flavors, so you'll decide which one to buy after arriving there. But there are two major flaws in this plan: 

  1. you have only coins of 1, 2 and 3 burles; 
  2. since it's morning, the store will ask you to pay in exact change, i. e. if you choose the i-th flavor, you'll have to pay exactly a_i burles. 



Coins are heavy, so you'd like to take the least possible number of coins in total. That's why you are wondering: what is the minimum total number of coins you should take with you, so you can buy a bag of chips of any flavor in exact change?

Input

The first line contains a single integer t (1 ≤ t ≤ 1000) — the number of test cases.

The first line of each test case contains the single integer n (1 ≤ n ≤ 100) — the number of flavors in the store.

The second line of each test case contains n integers a_1, a_2, ..., a_n (1 ≤ a_i ≤ 10^9) — the cost of one bag of each flavor.

Output

For each test case, print one integer — the minimum number of coins you need to buy one bag of any flavor you'll choose in exact change.

Example

Input


4
1
1337
3
10 8 10
5
1 2 3 4 5
3
7 77 777


Output


446
4
3
260

Note

In the first test case, you should, for example, take with you 445 coins of value 3 and 1 coin of value 2. So, 1337 = 445 ⋅ 3 + 1 ⋅ 2.

In the second test case, you should, for example, take 2 coins of value 3 and 2 coins of value 2. So you can pay either exactly 8 = 2 ⋅ 3 + 1 ⋅ 2 or 10 = 2 ⋅ 3 + 2 ⋅ 2.

In the third test case, it's enough to take 1 coin of value 3 and 2 coins of value 1.

EXAMPLE QUESTIONS:
Example question 1:
Name: 311_D. Interval Cubing
Tags: ['data structures', 'math']
Description: While learning Computational Geometry, Tiny is simultaneously learning a useful data structure called segment tree or interval tree. He has scarcely grasped it when comes out a strange problem:

Given an integer sequence a1, a2, ..., an. You should run q queries of two types:

  1. Given two integers l and r (1 ≤ l ≤ r ≤ n), ask the sum of all elements in the sequence al, al + 1, ..., ar. 
  2. Given two integers l and r (1 ≤ l ≤ r ≤ n), let each element x in the sequence al, al + 1, ..., ar becomes x3. In other words, apply an assignments al = al3, al + 1 = al + 13, ..., ar = ar3. 



For every query of type 1, output the answer to it.

Tiny himself surely cannot work it out, so he asks you for help. In addition, Tiny is a prime lover. He tells you that because the answer may be too huge, you should only output it modulo 95542721 (this number is a prime number).

Input

The first line contains an integer n (1 ≤ n ≤ 105), representing the length of the sequence. The second line contains n space-separated integers a1, a2, ..., an (0 ≤ ai ≤ 109).

The third line contains an integer q (1 ≤ q ≤ 105), representing the number of queries. Then follow q lines. Each line contains three integers ti (1 ≤ ti ≤ 2), li, ri (1 ≤ li ≤ ri ≤ n), where ti stands for the type of the query while li and ri is the parameters of the query, correspondingly.

Output

For each 1-type query, print the answer to it per line.

You should notice that each printed number should be non-negative and less than 95542721.

Examples

Input

8
1 2 3 4 5 6 7 8
5
1 2 5
2 2 5
1 2 5
2 3 6
1 4 7


Output

14
224
2215492
Difficulty: 10
Solutions: #include <bits/stdc++.h>
using namespace std;
const int MOD = 95542721;
const int MAX = 100005;
int seg[4 * MAX][48], mark[4 * MAX], tmp[48], a[MAX];
int n, q;
int next(int x) { return 1ll * x * x % MOD * x % MOD; }
void fix(int& x) {
  while (x >= MOD) x -= MOD;
  while (x < 0) x += MOD;
}
void merge(int v) {
  for (int i = 0; i < 48; i++) {
    seg[v][i] = seg[2 * v][i] + seg[2 * v + 1][i];
    fix(seg[v][i]);
  }
}
void rotate(int v, int k) {
  for (int i = 0; i < 48; i++) tmp[i] = seg[v][(i + k) % 48];
  for (int i = 0; i < 48; i++) seg[v][i] = tmp[i];
}
void shift(int v) {
  mark[v] %= 48;
  if (mark[v]) {
    rotate(2 * v, mark[v]);
    rotate(2 * v + 1, mark[v]);
    mark[2 * v] += mark[v];
    mark[2 * v + 1] += mark[v];
    mark[v] = 0;
  }
}
void build(int v = 1, int s = 0, int e = n) {
  if (e - s < 2) {
    seg[v][0] = a[s];
    for (int i = 1; i < 48; i++) seg[v][i] = next(seg[v][i - 1]);
    return;
  }
  int mid = (s + e) / 2;
  build(2 * v, s, mid);
  build(2 * v + 1, mid, e);
  merge(v);
}
void upd(int l, int r, int v = 1, int s = 0, int e = n) {
  if (l <= s && e <= r) {
    mark[v]++;
    rotate(v, 1);
    return;
  }
  if (e <= l || r <= s) return;
  shift(v);
  int mid = (s + e) / 2;
  upd(l, r, 2 * v, s, mid);
  upd(l, r, 2 * v + 1, mid, e);
  merge(v);
}
int get(int l, int r, int v = 1, int s = 0, int e = n) {
  if (l <= s && e <= r) return seg[v][0];
  if (e <= l || r <= s) return 0;
  shift(v);
  int mid = (s + e) / 2;
  int ans = get(l, r, 2 * v, s, mid) + get(l, r, 2 * v + 1, mid, e);
  fix(ans);
  return ans;
}
int main() {
  ios::sync_with_stdio(false);
  cin >> n;
  for (int i = 0; i < n; i++) {
    cin >> a[i];
    a[i] %= MOD;
  }
  build();
  cin >> q;
  while (q--) {
    int t, l, r;
    cin >> t >> l >> r;
    l--;
    if (t == 2)
      upd(l, r);
    else
      cout << get(l, r) << endl;
  }
  return 0;
}



INSTRUCTIONS:
Solve the current question.
Provide:
1. A complete and efficient code solution, optimized for both time and space complexity.
2. A detailed explanation of the solution, including:
   - The intuition behind the approach;
   - Time and space complexity;
   - Important considerations about the algorithm.
3. You can use the example questions as general references for coding patterns and structure, but solve the current problem independently.
4. Don't use any external libraries. Any language is accepted.