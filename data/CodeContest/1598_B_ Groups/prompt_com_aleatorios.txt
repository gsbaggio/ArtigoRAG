CURRENT QUESTION:
n students attended the first meeting of the Berland SU programming course (n is even). All students will be divided into two groups. Each group will be attending exactly one lesson each week during one of the five working days (Monday, Tuesday, Wednesday, Thursday and Friday), and the days chosen for the groups must be different. Furthermore, both groups should contain the same number of students.

Each student has filled a survey in which they told which days of the week are convenient for them to attend a lesson, and which are not. 

Your task is to determine if it is possible to choose two different week days to schedule the lessons for the group (the first group will attend the lesson on the first chosen day, the second group will attend the lesson on the second chosen day), and divide the students into two groups, so the groups have equal sizes, and for each student, the chosen lesson day for their group is convenient.

Input

The first line contains a single integer t (1 ≤ t ≤ 10^4) — the number of testcases.

Then the descriptions of t testcases follow.

The first line of each testcase contains one integer n (2 ≤ n ≤ 1 000) — the number of students.

The i-th of the next n lines contains 5 integers, each of them is 0 or 1. If the j-th integer is 1, then the i-th student can attend the lessons on the j-th day of the week. If the j-th integer is 0, then the i-th student cannot attend the lessons on the j-th day of the week. 

Additional constraints on the input: for each student, at least one of the days of the week is convenient, the total number of students over all testcases doesn't exceed 10^5.

Output

For each testcase print an answer. If it's possible to divide the students into two groups of equal sizes and choose different days for the groups so each student can attend the lesson in the chosen day of their group, print "YES" (without quotes). Otherwise, print "NO" (without quotes). 

Example

Input


2
4
1 0 0 1 0
0 1 0 0 1
0 0 0 1 0
0 1 0 1 0
2
0 0 0 1 0
0 0 0 1 0


Output


YES
NO

Note

In the first testcase, there is a way to meet all the constraints. For example, the first group can consist of the first and the third students, they will attend the lessons on Thursday (the fourth day); the second group can consist of the second and the fourth students, and they will attend the lessons on Tuesday (the second day).

In the second testcase, it is impossible to divide the students into groups so they attend the lessons on different days.

EXAMPLE QUESTIONS:
Example question 1:
Name: 112_B. Petya and Square
Tags: ['implementation', 'math']
Description: Little Petya loves playing with squares. Mum bought him a square 2n × 2n in size. Petya marked a cell inside the square and now he is solving the following task.

The task is to draw a broken line that would go along the grid lines and that would cut the square into two equal parts. The cutting line should not have any common points with the marked cell and the resulting two parts should be equal up to rotation.

Petya wants to determine whether it is possible to cut the square in the required manner given the sizes of the square side and the coordinates of the marked cell. Help him.

Input

The first line contains three space-separated integers 2n, x and y (2 ≤ 2n ≤ 100, 1 ≤ x, y ≤ 2n), representing the length of a square's side and the coordinates of the marked cell. It is guaranteed that 2n is even.

The coordinates of the marked cell are represented by a pair of numbers x y, where x represents the number of the row and y represents the number of the column. The rows and columns are numbered by consecutive integers from 1 to 2n. The rows are numbered from top to bottom and the columns are numbered from the left to the right.

Output

If the square is possible to cut, print "YES", otherwise print "NO" (without the quotes).

Examples

Input

4 1 1


Output

YES


Input

2 2 2


Output

NO

Note

A sample test from the statement and one of the possible ways of cutting the square are shown in the picture: 

<image>
Difficulty: 8
Solutions: #include <bits/stdc++.h>
using namespace std;
const int N = 1000010;
const long long MOD = 1e9 + 7;
void solve() {
  int a, x, y;
  cin >> a >> x >> y;
  int k = a / 2;
  if (x == k && y == k) {
    cout << "NO"
         << "\n";
    return;
  }
  if (x == k + 1 && y == k) {
    cout << "NO"
         << "\n";
    return;
  }
  if (x == k && y == k + 1) {
    cout << "NO"
         << "\n";
    return;
  }
  if (x == k + 1 && y == k + 1) {
    cout << "NO"
         << "\n";
    return;
  }
  cout << "YES"
       << "\n";
}
int main() { solve(); }


Example question 2:
Name: 1121_D. Diana and Liana
Tags: ['greedy', 'implementation', 'two pointers']
Description: At the first holiday in spring, the town Shortriver traditionally conducts a flower festival. Townsfolk wear traditional wreaths during these festivals. Each wreath contains exactly k flowers.

The work material for the wreaths for all n citizens of Shortriver is cut from the longest flowered liana that grew in the town that year. Liana is a sequence a_1, a_2, ..., a_m, where a_i is an integer that denotes the type of flower at the position i. This year the liana is very long (m ≥ n ⋅ k), and that means every citizen will get a wreath.

Very soon the liana will be inserted into a special cutting machine in order to make work material for wreaths. The machine works in a simple manner: it cuts k flowers from the beginning of the liana, then another k flowers and so on. Each such piece of k flowers is called a workpiece. The machine works until there are less than k flowers on the liana.

Diana has found a weaving schematic for the most beautiful wreath imaginable. In order to weave it, k flowers must contain flowers of types b_1, b_2, ..., b_s, while other can be of any type. If a type appears in this sequence several times, there should be at least that many flowers of that type as the number of occurrences of this flower in the sequence. The order of the flowers in a workpiece does not matter.

Diana has a chance to remove some flowers from the liana before it is inserted into the cutting machine. She can remove flowers from any part of the liana without breaking liana into pieces. If Diana removes too many flowers, it may happen so that some of the citizens do not get a wreath. Could some flowers be removed from the liana so that at least one workpiece would conform to the schematic and machine would still be able to create at least n workpieces?

Input

The first line contains four integers m, k, n and s (1 ≤ n, k, m ≤ 5 ⋅ 10^5, k ⋅ n ≤ m, 1 ≤ s ≤ k): the number of flowers on the liana, the number of flowers in one wreath, the amount of citizens and the length of Diana's flower sequence respectively.

The second line contains m integers a_1, a_2, ..., a_m (1 ≤ a_i ≤ 5 ⋅ 10^5) — types of flowers on the liana.

The third line contains s integers b_1, b_2, ..., b_s (1 ≤ b_i ≤ 5 ⋅ 10^5) — the sequence in Diana's schematic.

Output

If it's impossible to remove some of the flowers so that there would be at least n workpieces and at least one of them fullfills Diana's schematic requirements, output -1.

Otherwise in the first line output one integer d — the number of flowers to be removed by Diana.

In the next line output d different integers — the positions of the flowers to be removed.

If there are multiple answers, print any.

Examples

Input


7 3 2 2
1 2 3 3 2 1 2
2 2


Output


1
4 


Input


13 4 3 3
3 2 6 4 1 4 4 7 1 3 3 2 4
4 3 4


Output


-1


Input


13 4 1 3
3 2 6 4 1 4 4 7 1 3 3 2 4
4 3 4


Output


9
1 2 3 4 5 9 11 12 13

Note

In the first example, if you don't remove any flowers, the machine would put out two workpieces with flower types [1, 2, 3] and [3, 2, 1]. Those workpieces don't fit Diana's schematic. But if you remove flower on 4-th place, the machine would output workpieces [1, 2, 3] and [2, 1, 2]. The second workpiece fits Diana's schematic.

In the second example there is no way to remove flowers so that every citizen gets a wreath and Diana gets a workpiece that fits here schematic.

In the third example Diana is the only citizen of the town and that means she can, for example, just remove all flowers except the ones she needs.
Difficulty: 10
Solutions: def main():
    m, k, n, s = map(int, input().split())
    a = list(map(int, input().split()))  # prevbug: input in a line!
    b = list(map(int, input().split()))  # prevbug: convert to list
    b_dict = {}
    for x in b:
        b_dict.setdefault(x, 0)
        b_dict[x] += 1  # prevbug: b or b_dict

    left = 0
    right = 0
    max_cut = m - n * k
    condition_not_met = len(b_dict)
    a_dict = {}
    while right < m and condition_not_met > 0:
        x = a[right]
        a_dict.setdefault(x, 0)
        a_dict[x] += 1
        if x in b_dict and a_dict[x] == b_dict[x]:
            condition_not_met -= 1
        right += 1  # prevbug: ftl
    if condition_not_met > 0:
        print(-1)
        return

    def num_to_remove(lft, rgt):
        lft = lft // k * k
        num_in_seq = rgt - lft
        if num_in_seq < k:
            return 0  # prevbug: if sequence is shorter than k, then no need to remove flowers
        return num_in_seq - k

    def test_plan():
        nonlocal left
        if num_to_remove(left, right) <= max_cut:
            tot = num_to_remove(left, right)
            print(tot)
            left = left // k * k
            while tot > 0:
                x = a[left]
                if x in b_dict:
                    b_dict[x] -= 1
                    if b_dict[x] == 0:
                        del b_dict[x]
                else:
                    print(left + 1, end=' ')
                    tot -= 1  # prevbug: ftl
                left += 1
            return True
        return False

    while True:
        while left < right:  # prevbug: should shift left before shifting right
            x = a[left]
            if x in b_dict and a_dict[x] - 1 < b_dict[x]:
                break
            else:
                a_dict[x] -= 1
                if a_dict[x] == 0:
                    del a_dict[x]  # prevbug: ftl
                left += 1
        if test_plan():
            return
        if right < m:
            a_dict.setdefault(a[right], 0)
            a_dict[a[right]] += 1
            right += 1
        else:
            break

    print(-1)


if __name__ == '__main__':
    main()



INSTRUCTIONS:
Solve the current question.
Provide:
1. A complete and efficient code solution, optimized for both time and space complexity.
2. A detailed explanation of the solution, including:
   - The intuition behind the approach;
   - Time and space complexity;
   - Important considerations about the algorithm.
3. You can use the example questions as general references for coding patterns and structure, but solve the current problem independently.
4. Don't use any external libraries. Any language is accepted.