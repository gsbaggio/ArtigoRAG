from collections import defaultdict

def dfs(node, parent, path, edge_strings, tree, paths):
    if parent is not None:
        path += edge_strings[(parent, node)]
    
    paths[node] = path
    
    for child in tree[node]:
        if child != parent:
            dfs(child, node, path, edge_strings, tree, paths)

def lcp(s1, s2):
    i = 0
    while i < len(s1) and i < len(s2) and s1[i] == s2[i]:
        i += 1
    return s1[:i]

n, m, q = map(int, input().split())
tree = defaultdict(list)
edge_strings = {}
paths = {}

for _ in range(n-1):
    u, v, c = input().split()
    u, v = int(u), int(v)
    tree[u].append(v)
    tree[v].append(u)
    edge_strings[(u, v)] = c
    edge_strings[(v, u)] = c

for i in range(1, n+1):
    dfs(i, None, "", edge_strings, tree, paths)

strings = [input().strip() for _ in range(m)]

for _ in range(q):
    u, v, l, r = map(int, input().split())
    common_substr = paths[u][:len(paths[v])] if len(paths[u]) < len(paths[v]) else paths[v]
    count = sum(1 for s in strings[l-1:r] if common_substr in s)
    print(count)