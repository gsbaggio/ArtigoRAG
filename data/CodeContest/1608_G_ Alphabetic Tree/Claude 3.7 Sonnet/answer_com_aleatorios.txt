#include <iostream>
#include <vector>
#include <string>
#include <unordered_map>
using namespace std;

const int MAXN = 1e5 + 5;

// Graph representation
vector<pair<int, char>> adj[MAXN];
vector<string> strings;
int n, m, q;

// Used for path finding
string path;
unordered_map<string, int> count_map;

void dfs(int node, int parent) {
    for (auto [neighbor, letter] : adj[node]) {
        if (neighbor == parent) continue;
        path.push_back(letter);
        dfs(neighbor, node);
        path.pop_back();
    }
}

// Find the path between two nodes
string find_path(int start, int end) {
    vector<int> parent(n+1, -1);
    vector<char> edge_letter(n+1, ' ');
    vector<bool> visited(n+1, false);
    
    // BFS to find the shortest path
    vector<int> queue;
    queue.push_back(start);
    visited[start] = true;
    
    while (!queue.empty()) {
        int current = queue.front();
        queue.erase(queue.begin());
        
        if (current == end) break;
        
        for (auto [neighbor, letter] : adj[current]) {
            if (!visited[neighbor]) {
                visited[neighbor] = true;
                parent[neighbor] = current;
                edge_letter[neighbor] = letter;
                queue.push_back(neighbor);
            }
        }
    }
    
    // Reconstruct the path
    string result = "";
    int current = end;
    while (current != start) {
        result = edge_letter[current] + result;
        current = parent[current];
    }
    
    return result;
}

// Count occurrences of pattern in string
int count_occurrences(const string& str, const string& pattern) {
    if (pattern.empty()) return 0;
    if (pattern.length() > str.length()) return 0;
    
    int count = 0;
    for (int i = 0; i <= str.length() - pattern.length(); i++) {
        bool match = true;
        for (int j = 0; j < pattern.length(); j++) {
            if (str[i + j] != pattern[j]) {
                match = false;
                break;
            }
        }
        if (match) count++;
    }
    return count;
}

int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(NULL);
    
    cin >> n >> m >> q;
    
    // Reading the tree
    for (int i = 0; i < n-1; i++) {
        int u, v;
        char c;
        cin >> u >> v >> c;
        adj[u].push_back({v, c});
        adj[v].push_back({u, c});
    }
    
    // Reading the strings
    strings.resize(m+1); // 1-indexed
    for (int i = 1; i <= m; i++) {
        cin >> strings[i];
    }
    
    // Process queries
    for (int i = 0; i < q; i++) {
        int u, v, l, r;
        cin >> u >> v >> l >> r;
        
        string pattern = find_path(u, v);
        int total = 0;
        
        // Count occurrences in strings l to r
        for (int j = l; j <= r; j++) {
            total += count_occurrences(strings[j], pattern);
        }
        
        cout << total << endl;
    }
    
    return 0;
}