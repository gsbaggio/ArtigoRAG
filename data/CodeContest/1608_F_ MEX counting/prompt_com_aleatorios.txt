CURRENT QUESTION:
For an array c of nonnegative integers, MEX(c) denotes the smallest nonnegative integer that doesn't appear in it. For example, MEX([0, 1, 3]) = 2, MEX([42]) = 0.

You are given integers n, k, and an array [b_1, b_2, …, b_n].

Find the number of arrays [a_1, a_2, …, a_n], for which the following conditions hold:

  * 0 ≤ a_i ≤ n for each i for each i from 1 to n.

  * |MEX([a_1, a_2, …, a_i]) - b_i| ≤ k for each i from 1 to n.




As this number can be very big, output it modulo 998 244 353.

Input

The first line of the input contains two integers n, k (1 ≤ n ≤ 2000, 0 ≤ k ≤ 50).

The second line of the input contains n integers b_1, b_2, …, b_n (-k ≤ b_i ≤ n+k) — elements of the array b.

Output

Output a single integer — the number of arrays which satisfy the conditions from the statement, modulo 998 244 353.

Examples

Input


4 0
0 0 0 0


Output


256


Input


4 1
0 0 0 0


Output


431


Input


4 1
0 0 1 1


Output


509


Input


5 2
0 0 2 2 0


Output


6546


Input


3 2
-2 0 4


Output


11

EXAMPLE QUESTIONS:
Example question 1:
Name: 1422_F. Boring Queries
Tags: ['data structures', 'math', 'number theory']
Description: Yura owns a quite ordinary and boring array a of length n. You think there is nothing more boring than that, but Vladik doesn't agree!

In order to make Yura's array even more boring, Vladik makes q boring queries. Each query consists of two integers x and y. Before answering a query, the bounds l and r for this query are calculated: l = (last + x) mod n + 1, r = (last + y) mod n + 1, where last is the answer on the previous query (zero initially), and mod is the remainder operation. Whenever l > r, they are swapped.

After Vladik computes l and r for a query, he is to compute the least common multiple (LCM) on the segment [l; r] of the initial array a modulo 10^9 + 7. LCM of a multiset of integers is the smallest positive integer that is divisible by all the elements of the multiset. The obtained LCM is the answer for this query.

Help Vladik and compute the answer for each query!

Input

The first line contains a single integer n (1 ≤ n ≤ 10^5) — the length of the array.

The second line contains n integers a_i (1 ≤ a_i ≤ 2 ⋅ 10^5) — the elements of the array.

The third line contains a single integer q (1 ≤ q ≤ 10^5) — the number of queries.

The next q lines contain two integers x and y each (1 ≤ x, y ≤ n) — the description of the corresponding query.

Output

Print q integers — the answers for the queries.

Example

Input


3
2 3 5
4
1 3
3 3
2 3
2 3


Output


6
2
15
30

Note

Consider the example:

  * boundaries for first query are (0 + 1) mod 3 + 1 = 2 and (0 + 3) mod 3 + 1 = 1. LCM for segment [1, 2] is equal to 6; 
  * boundaries for second query are (6 + 3) mod 3 + 1 = 1 and (6 + 3) mod 3 + 1 = 1. LCM for segment [1, 1] is equal to 2; 
  * boundaries for third query are (2 + 2) mod 3 + 1 = 2 and (2 + 3) mod 3 + 1 = 3. LCM for segment [2, 3] is equal to 15; 
  * boundaries for fourth query are (15 + 2) mod 3 + 1 = 3 and (15 + 3) mod 3 + 1 = 1. LCM for segment [1, 3] is equal to 30. 
Difficulty: 12
Solutions: #include <bits/stdc++.h>
template <class T>
inline void readInt(T &w) {
  char c, p = 0;
  while (!isdigit(c = getchar())) p = c == '-';
  for (w = c & 15; isdigit(c = getchar()); w = w * 10 + (c & 15))
    ;
  if (p) w = -w;
}
template <class T, class... Args>
inline void readInt(T &w, Args &...args) {
  readInt(w), readInt(args...);
}
template <class T, class U>
inline bool smin(T &x, const U &y) {
  return y < x ? x = y, 1 : 0;
}
template <class T, class U>
inline bool smax(T &x, const U &y) {
  return x < y ? x = y, 1 : 0;
}
constexpr int N(1e5 + 5), P(1e9 + 7);
inline int fpow(int x, int k = P - 2) {
  assert(k >= 0);
  int r = 1;
  for (; k; k >>= 1, x = 1LL * x * x % P)
    if (k & 1) r = 1LL * r * x % P;
  return r;
}
constexpr std::array<int, 87> pr{
    2,   3,   5,   7,   11,  13,  17,  19,  23,  29,  31,  37,  41,  43,  47,
    53,  59,  61,  67,  71,  73,  79,  83,  89,  97,  101, 103, 107, 109, 113,
    127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197,
    199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281,
    283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379,
    383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449};
int n, m, a[N];
struct Node {
  Node *ls, *rs;
  int w;
  Node() {}
} buf[N * 100], *ptr = buf;
class SegmentTree {
 private:
  Node *rt;
  void ins(Node *&o, int l, int r, int x, int y) {
    if (!o) o = ptr++;
    smax(o->w, y);
    if (l == r) return;
    int mid = l + r >> 1;
    x <= mid ? ins(o->ls, l, mid, x, y) : ins(o->rs, mid + 1, r, x, y);
  }
  int ask(Node *o, int l, int r, int x, int y) {
    if (!o) return 0;
    if (x <= l && r <= y) return o->w;
    int mid = l + r >> 1;
    if (y <= mid) return ask(o->ls, l, mid, x, y);
    if (x > mid) return ask(o->rs, mid + 1, r, x, y);
    return std::max(ask(o->ls, l, mid, x, y), ask(o->rs, mid + 1, r, x, y));
  }

 public:
  inline void ins(int x, int y) { ins(rt, 1, n, x, y); }
  inline int ask(int l, int r) { return ask(rt, 1, n, l, r); }
} t[87];
Node *rt[N], *null = new Node();
void ins(Node *&o, int l, int r, int x, int y) {
  *ptr = *o, o = ptr++;
  o->w = 1LL * o->w * y % P;
  if (l == r) return;
  int mid = l + r >> 1;
  x <= mid ? ins(o->ls, l, mid, x, y) : ins(o->rs, mid + 1, r, x, y);
}
int ask(Node *x, Node *y, int l, int r, int z) {
  if (r <= z) return 1LL * fpow(x->w) * y->w % P;
  int mid = l + r >> 1;
  if (z <= mid) return ask(x->ls, y->ls, l, mid, z);
  return 1LL * ask(x->ls, y->ls, l, mid, z) * ask(x->rs, y->rs, mid + 1, r, z) %
         P;
}
std::map<int, int> pos;
std::mt19937_64 ha(
    std::chrono::high_resolution_clock::now().time_since_epoch().count());
void gen() {
  n = 1e5;
  for (int i = 1; i <= n; i++) a[i] = ha() % 200000 + 1;
}
int main() {
  readInt(n);
  for (int i = 1; i <= n; i++) readInt(a[i]);
  null->ls = null->rs = null, null->w = 1;
  rt[0] = null;
  for (int i = 1; i <= n; i++) {
    for (int j = 0; j < 87; j++) {
      if (pr[j] > a[i]) break;
      int c = 0;
      while (a[i] % pr[j] == 0) a[i] /= pr[j], c++;
      if (c) t[j].ins(i, c);
    }
    int &u = pos[a[i]];
    ins(rt[i] = rt[i - 1], 0, n - 1, u, a[i]);
    u = i;
  }
  int ans = 0;
  readInt(m);
  while (m--) {
    int l, r;
    readInt(l, r);
    l = (ans + l) % n + 1, r = (ans + r) % n + 1;
    if (l > r) std::swap(l, r);
    ans = ask(rt[l - 1], rt[r], 0, n - 1, l - 1);
    for (int i = 0; i < 87; i++) {
      ans = 1LL * ans * fpow(pr[i], t[i].ask(l, r)) % P;
    }
    printf("%d\n", ans);
  }
  return 0;
}


Example question 2:
Name: p00239 Calorie Counting
Tags: ['']
Description: Food contains three nutrients called "protein", "fat" and "carbohydrate", which are called three major nutrients. It is calculated that protein and carbohydrate are 4 kcal (kilocalories) and fat is 9 kcal per 1 g (gram). For example, according to the table below, the number 1 cake contains 7 g of protein, 14 g of fat and 47 g of carbohydrates. If you calculate the calories contained based on this, it will be 4 x 7 + 9 x 14 + 4 x 47 = 342 kcal. Others are calculated in the same way.

Number | Name | Protein (g) | Lipids (g) | Carbohydrates (g) | Calories (kcal)
--- | --- | --- | --- | --- | ---
1 | Cake | 7 | 14 | 47 | 342
2 | Potato Chips | 5 | 35 | 55 | 555
3 | Dorayaki | 6 | 3 | 59 | 287
4 | Pudding | 6 | 5 | 15 | 129



Input the number of sweets to be classified n, the information of each sweet, and the limit information, and output a list of sweets that do not exceed the limit (may be eaten) if only one sweet is used. Create a program.

The candy information consists of the candy number s, the weight p of the protein contained in the candy, the weight q of the lipid, and the weight r of the carbohydrate. The limit information consists of the maximum protein weight P that can be included, the fat weight Q, the carbohydrate weight R, and the maximum calorie C that can be consumed, of protein, fat, carbohydrate, and calories. If any one of them is exceeded, the restriction will be violated and it will be judged as "sweets that should not be eaten".

For a list of sweets that you can eat, output the numbers of sweets that you can eat in the order in which you entered them. If there are no sweets you can eat, please output "NA". For the four sweets in the table above, if the limit is P = 10, Q = 15, R = 50, C = 400, cake and pudding may be eaten as their respective nutrients and calories are below the limit. Although it is classified as sweets, potato chips are classified as sweets that should not be eaten because the amount of carbohydrates exceeds the limit value.



input

Given a sequence of multiple datasets. The end of the input is indicated by a single line of zeros. Each dataset is given in the following format:


n
s1 p1 q1 r1
s2 p2 q2 r2
::
sn pn qn rn
P Q R C


The first line gives the number of sweets n (1 ≤ n ≤ 1000). The next n lines are given the number si (1 ≤ si ≤ 1000) of the i-th candy and the integers pi, qi, ri (0 ≤ pi, qi, ri ≤ 100) representing the weight of each nutrient.

The following lines are given the integers P, Q, R (0 ≤ P, Q, R ≤ 100), C (0 ≤ C ≤ 1700) representing the limits for each nutrient and calorie.

The number of datasets does not exceed 100.

output

For each dataset, it outputs the number of sweets you can eat or "NA".

Example

Input

4
1 7 14 47
2 5 35 55
3 6 3 59
4 6 5 15
10 15 50 400
2
1 8 10 78
2 4 18 33
10 10 50 300
0


Output

1
4
NA
Difficulty: 0
Solutions: import java.util.Arrays;
import java.util.PriorityQueue;
import java.util.Scanner;

public class Main {
	
	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);

		while(true){
			final int n = sc.nextInt();
			
			if(n == 0){
				break;
			}
			
			int[][] items = new int[n][4];
			
			for(int i = 0; i < n; i++){
				for(int j = 0; j < 4; j++){
					items[i][j] = sc.nextInt();
				}
			}
			
			int[] limits = new int[4]; 
			for(int i = 0; i < 4; i++){
				limits[i] = sc.nextInt();
			}
			
			boolean found = false;
			START:for(int i = 0; i < n; i++){
				for(int j = 1; j < 4; j++){
					if(items[i][j] > limits[j-1]){
						continue START;
					}
				}
				
				if(items[i][1]*4 + items[i][2]*9 + items[i][3]*4 > limits[3]){
					continue START;
				}
				
				found = true;
				System.out.println(items[i][0]);
			}
			
			if(!found){
				System.out.println("NA");
			}
		}
	}
}

Example question 3:
Name: 784_F. Crunching Numbers Just for You
Tags: ['*special', 'implementation']
Description: You are developing a new feature for the website which sells airline tickets: being able to sort tickets by price! You have already extracted the tickets' prices, so there's just the last step to be done...

You are given an array of integers. Sort it in non-descending order.

Input

The input consists of a single line of space-separated integers. The first number is n (1 ≤ n ≤ 10) — the size of the array. The following n numbers are the elements of the array (1 ≤ ai ≤ 100).

Output

Output space-separated elements of the sorted array.

Example

Input

3 3 1 2


Output

1 2 3 

Note

Remember, this is a very important feature, and you have to make sure the customers appreciate it!
Difficulty: 12
Solutions: a = input()[2:]
n = [0 for i in range(1000000)]
g = 123
for i in range(130000):
    g *= 3
a = list(map(int, a.split()))
x = [0 for _ in range(len(a))]
for i in range(len(x)):
    x[i] = min(a)
    a.remove(x[i])
for o in x:
    print(o, end=' ')
    


INSTRUCTIONS:
Solve the current question.
Provide:
1. A complete and efficient code solution, optimized for both time and space complexity.
2. A detailed explanation of the solution, including:
   - The intuition behind the approach;
   - Time and space complexity;
   - Important considerations about the algorithm.
3. If the language has classes, implement in 'Solution' class. Any language is accepted.
4. You can use the example questions as general references for coding patterns and structure, but solve the current problem independently.
5. Don't use any external libraries. Don't need to import any libraries.
