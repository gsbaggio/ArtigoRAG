CURRENT QUESTION:
Denote a cyclic sequence of size n as an array s such that s_n is adjacent to s_1. The segment s[r, l] where l < r is the concatenation of s[r, n] and s[1, l].

You are given an array a consisting of n integers. Define b as the cyclic sequence obtained from concatenating m copies of a. Note that b has size n ⋅ m.

You are given an integer k where k = 1 or k is a prime number. Find the number of different segments in b where the sum of elements in the segment is divisible by k.

Two segments are considered different if the set of indices of the segments are different. For example, when n = 3 and m = 2, the set of indices for segment s[2, 5] is \{2, 3, 4, 5\}, and for segment s[5, 2] is \{5, 6, 1, 2\}. In particular, the segments s[1, 6], s[2,1], …, s[6, 5] are considered as the same segment.

Output the answer modulo 10^9 + 7.

Input

The first line contains three integers n, m, and k (1 ≤ n, m, k ≤ 2 ⋅ 10^5, k = 1 or k is a prime number).

The second line contains n integers a_1, a_2, …, a_n (0 ≤ a_i ≤ 2 ⋅ 10^5).

Output

Output an integer denoting the number of different segments in b where the sum of elements in the segment is divisible by k, modulo 10^9 + 7.

Examples

Input


5 1 5
1 2 3 4 3


Output


4


Input


5 1 5
1 2 3 4 5


Output


5


Input


5 4 5
1 2 3 4 5


Output


125

Note

In the first example, all valid segments are [1,4], [2, 3], [3, 5], and [4, 2].

In the second example, one of the valid segments is [1, 5].

EXAMPLE QUESTIONS:
Example question 1:
Name: cheflr
Tags: []
Description: Chef has a nice complete binary tree in his garden. Complete means that each node has exactly two sons, so the tree is infinite. Yesterday he had enumerated the nodes of the tree in such a way: 

Let's call the nodes' level a number of nodes that occur on the way to this node from the root, including this node. This way, only the root has the level equal to 1, while only its two sons has the level equal to 2.
Then, let's take all the nodes with the odd level and enumerate them with consecutive odd numbers, starting from the smallest levels and the leftmost nodes, going to the rightmost nodes and the highest levels.
Then, let's take all the nodes with the even level and enumerate them with consecutive even numbers, starting from the smallest levels and the leftmost nodes, going to the rightmost nodes and the highest levels.
For the better understanding there is an example: 


                             1
                        /           \
                  2                   4
                /   \                /       \
             3       5           7        9
            / \      /  \          /  \       /  \
           6  8 10 12      14 16   18 20 
Here you can see the visualization of the process. For example, in odd levels, the root was enumerated first, then, there were enumerated roots' left sons' sons and roots' right sons' sons.
You are given the string of symbols, let's call it S. Each symbol is either l or r. Naturally, this sequence denotes some path from the root, where l means going to the left son and r means going to the right son.
Please, help Chef to determine the number of the last node in this path.

Input
The first line contains single integer T number of test cases.
Each of next T lines contain a string S consisting only of the symbols l and r.


Output
Per each line output the number of the last node in the path, described by S, modulo 10^9+7.

Constraints

1 ≤ |T| ≤ 5
1 ≤ |S| ≤ 10^5
Remember that the tree is infinite, so each path described by appropriate S is a correct one.


Example
Input:
4
lrl
rll
r
lllr
Output:
10
14
4
13



Explanation
See the example in the statement for better understanding the samples.
Difficulty: 2
Solutions: import sys
 
 
def update_odd( direction , value ) :
    if direction == 'l' :
       value = (value * 2) 
    else :
       value  = (2 *value + 2) 
    return value
 
def update_even(direction , value) :
    if direction == 'l' :
       value = (2*value - 1)
    else :
       value = (2*value + 1) 
    return value 
 
t = int(raw_input())
for i in range(0,t) :
    list = raw_input()
    value = 1
    flag = True
    for character in list :
        if character in ('l','r'):
            value = update_odd(character,value) if ( flag ) else update_even(character,value)
            flag = not (flag) 
    print value  % (10**9 + 7)


INSTRUCTIONS:
Solve the current question.
Provide:
1. A complete and efficient code solution, optimized for both time and space complexity.
2. A detailed explanation of the solution, including:
   - The intuition behind the approach;
   - Time and space complexity;
   - Important considerations about the algorithm.
3. If the language has classes, implement in 'Solution' class. Any language is accepted.
4. You can use the example questions as general references for coding patterns and structure, but solve the current problem independently.
5. Don't use any external libraries. Don't need to import any libraries.
