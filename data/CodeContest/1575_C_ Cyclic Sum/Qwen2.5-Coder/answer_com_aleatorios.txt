MOD = 10**9 + 7

def count_segments(n, m, k, a):
    # Step 1: Calculate prefix sums modulo k
    prefix_mod = [0] * (n + 1)
    for i in range(1, n + 1):
        prefix_mod[i] = (prefix_mod[i - 1] + a[i - 1]) % k
    
    # Step 2: Count occurrences of each prefix sum modulo k in one copy of a
    count = [0] * k
    for i in range(n + 1):
        count[prefix_mod[i]] += 1
    
    # Step 3: Calculate the total number of valid segments
    total_segments = 0
    
    # Segments within one copy of a
    for i in range(n + 1):
        for j in range(i + 1, n + 1):
            if (prefix_mod[j] - prefix_mod[i]) % k == 0:
                total_segments += 1
    
    # Segments that wrap around the end of b to the beginning
    # Extend the prefix_mod array by another copy of a
    extended_prefix_mod = prefix_mod + [(prefix_mod[-1] + x) % k for x in a]
    
    # Count the occurrences of each prefix sum in the extended sequence
    extended_count = [0] * k
    for i in range(n + 1):
        extended_count[prefix_mod[i]] += 1
    
    for i in range(n + 1, 2 * n + 1):
        extended_count[extended_prefix_mod[i]] += 1
    
    # Calculate the number of valid segments in the extended sequence
    for i in range(n + 1, 2 * n + 1):
        for j in range(i - n, i):
            if (extended_prefix_mod[i] - extended_prefix_mod[j]) % k == 0:
                total_segments += 1
    
    # Multiply the counts by m for segments within one copy of a
    total_segments *= m
    
    # Adjust for the wrap-around segments
    # We counted each wrap-around segment m times, but they should be counted only once
    for i in range(n + 1, 2 * n + 1):
        for j in range(i - n, i):
            if (extended_prefix_mod[i] - extended_prefix_mod[j]) % k == 0:
                total_segments -= (m - 1)
    
    return total_segments % MOD

# Read input
import sys
input = sys.stdin.read().split()
n = int(input[0])
m = int(input[1])
k = int(input[2])
a = list(map(int, input[3:]))

# Output the result
print(count_segments(n, m, k, a))