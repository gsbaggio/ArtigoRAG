#include <iostream>
#include <vector>

using namespace std;

const int MOD = 998244353;

int main() {
    int n;
    cin >> n;
    
    vector<vector<int>> adj(n+1);
    for (int i = 0; i < n-1; i++) {
        int x, y;
        cin >> x >> y;
        adj[x].push_back(y);
        adj[y].push_back(x);
    }
    
    // dp[node][color] = number of ways to color the subtree rooted at 'node'
    // when 'node' has color 'color'
    vector<vector<long long>> dp(n+1, vector<long long>(n+1, 0));
    
    function<void(int, int)> dfs = [&](int node, int parent) {
        // Initialize dp values for leaf nodes
        for (int color = 1; color <= n; color++) {
            dp[node][color] = 1;
        }
        
        for (int child : adj[node]) {
            if (child == parent) continue;
            
            dfs(child, node);
            
            // Create a temporary dp array
            vector<long long> new_dp(n+1, 0);
            
            for (int node_color = 1; node_color <= n; node_color++) {
                long long total = 0;
                
                // Calculate total ways for all valid child colors
                for (int child_color = 1; child_color <= n; child_color++) {
                    if (child_color != node_color - 1) {
                        total = (total + dp[child][child_color]) % MOD;
                    }
                }
                
                new_dp[node_color] = (dp[node][node_color] * total) % MOD;
            }
            
            // Update dp values
            for (int color = 1; color <= n; color++) {
                dp[node][color] = new_dp[color];
            }
        }
    };
    
    dfs(1, 0); // Start from root
    
    // Sum up all possible colorings
    long long result = 0;
    for (int color = 1; color <= n; color++) {
        result = (result + dp[1][color]) % MOD;
    }
    
    cout << result << endl;
    
    return 0;
}