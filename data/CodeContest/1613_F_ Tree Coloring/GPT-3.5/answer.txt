import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.PrintWriter;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Comparator;
import java.util.StringTokenizer;

public class TreeAndQueries {

    static class Query {
        int L, R, k, idx;

        Query(int l, int r, int k, int i) {
            L = l;
            R = r;
            this.k = k;
            idx = i;
        }
    }

    static final int MAX = (int) 1e5 + 1;
    static ArrayList<Integer>[] graph;
    static int[] color, tin, tout, euler, ans, count;
    static int idx;

    static void dfs(int u, int p) {
        euler[idx] = color[u];
        tin[u] = idx++;
        for (int v : graph[u]) {
            if (p != v)
                dfs(v, u);
        }
        tout[u] = idx - 1;
    }

    static void add(int val) {
        ans[++count[val]]++;
    }

    static void remove(int val) {
        ans[count[val]--]--;
    }

    public static void main(String[] args) throws IOException {
        MyScanner sc = new MyScanner(System.in);
        PrintWriter out = new PrintWriter(System.out);
        int n = sc.nextInt(), m = sc.nextInt();
        color = new int[n];
        for (int i = 0; i < n; i++)
            color[i] = sc.nextInt();
        graph = new ArrayList[n];
        for (int i = 0; i < n; i++)
            graph[i] = new ArrayList<>();
        for (int i = 1; i < n; i++) {
            int u = sc.nextInt() - 1, v = sc.nextInt() - 1;
            graph[u].add(v);
            graph[v].add(u);
        }
        idx = 0;
        euler = new int[n];
        tin = new int[n];
        tout = new int[n];
        dfs(0, -1);
        final int BLOCK_SIZE = (int) Math.sqrt(n);
        Query[] queries = new Query[m];
        for (int i = 0; i < m; i++) {
            int u = sc.nextInt();
            queries[i] = new Query(tin[u - 1], tout[u - 1], sc.nextInt(), i);
        }
        Arrays.sort(queries, new Comparator<Query>() {
            @Override
            public int compare(Query q1, Query q2) {
                int x = q1.L / BLOCK_SIZE, y = q2.L / BLOCK_SIZE;
                if (x != y)
                    return x - y;
                else
                    return q1.R - q2.R;
            }
        });
        count = new int[MAX];
        ans = new int[MAX];
        int[] answer = new int[m];
        int MOL = 0, MOR = -1;
        for (int i = 0; i < m; i++) {
            Query q = queries[i];
            int L = q.L, R = q.R, k = q.k;
            while (MOR < R) {
                MOR++;
                add(euler[MOR]);
            }
            while (MOR > R) {
                remove(euler[MOR]);
                MOR--;
            }
            while (MOL < L) {
                remove(euler[MOL]);
                MOL++;
            }
            while (MOL > L) {
                MOL--;
                add(euler[MOL]);
            }
            answer[q.idx] = ans[q.k];
        }
        for (int x : answer)
            out.println(x);
        out.close();
    }

    static class MyScanner {
        BufferedReader br;
        StringTokenizer st;

        public MyScanner(InputStream is) {
            br = new BufferedReader(new InputStreamReader(is));
        }

        public String next() throws IOException {
            while (st == null || !st.hasMoreTokens())
                st = new StringTokenizer(br.readLine());
            return st.nextToken();
        }

        public boolean ready() throws IOException {
            return br.ready();
        }

        public int nextInt() throws IOException {
            return Integer.parseInt(next());
        }
    }
}