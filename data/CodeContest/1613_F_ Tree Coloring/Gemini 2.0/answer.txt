def solve():
    n = int(input())
    edges = []
    for _ in range(n - 1):
        u, v = map(int, input().split())
        edges.append((u - 1, v - 1))

    adj = [[] for _ in range(n)]
    for u, v in edges:
        adj[u].append(v)
        adj[v].append(u)

    def count_beautiful_colorings(n, adj):
        MOD = 998244353

        def is_beautiful(coloring, adj):
            for u in range(1, n):
                parent = -1
                for v in range(n):
                    if u in adj[v]:
                        # Check if v is parent of u in a possible rooted tree
                        is_parent = True
                        q = [(v, -1)]
                        visited = [False] * n
                        visited[v] = True
                        found = False
                        while q:
                            curr, par = q.pop(0)
                            if curr == u:
                                parent = par
                                found = True
                                break
                            for neighbor in adj[curr]:
                                if not visited[neighbor]:
                                    visited[neighbor] = True
                                    q.append((neighbor, curr))
                        if found and parent != -1:
                            if coloring[u] == coloring[parent] - 1:
                                return False
            return True

        import itertools
        count = 0
        for coloring in itertools.permutations(range(1, n + 1)):
            coloring_dict = {}
            for i in range(n):
                coloring_dict[i] = coloring[i]
            
            if is_beautiful(coloring_dict, adj):
                count = (count + 1) % MOD
        return count

    result = count_beautiful_colorings(n, adj)
    print(result)

solve()