CURRENT QUESTION:
You are given a rooted tree consisting of n vertices numbered from 1 to n. The root of the tree is the vertex 1.

You have to color all vertices of the tree into n colors (also numbered from 1 to n) so that there is exactly one vertex for each color. Let c_i be the color of vertex i, and p_i be the parent of vertex i in the rooted tree. The coloring is considered beautiful if there is no vertex k (k > 1) such that c_k = c_{p_k} - 1, i. e. no vertex such that its color is less than the color of its parent by exactly 1.

Calculate the number of beautiful colorings, and print it modulo 998244353.

Input

The first line contains one integer n (2 ≤ n ≤ 250000) — the number of vertices in the tree.

Then n-1 lines follow, the i-th line contains two integers x_i and y_i (1 ≤ x_i, y_i ≤ n; x_i ≠ y_i) denoting an edge between the vertex x_i and the vertex y_i. These edges form a tree.

Output

Print one integer — the number of beautiful colorings, taken modulo 998244353.

Examples

Input


5
1 2
3 2
4 2
2 5


Output


42


Input


5
1 2
2 3
3 4
4 5


Output


53


Input


20
20 19
20 4
12 4
5 8
1 2
20 7
3 10
7 18
11 8
9 10
17 10
1 15
11 16
14 11
18 10
10 1
14 2
13 17
20 6


Output


955085064

EXAMPLE QUESTIONS:
Example question 1:
Name: 1400_G. Mercenaries
Tags: ['bitmasks', 'brute force', 'combinatorics', 'dp', 'dsu', 'math', 'two pointers']
Description: Polycarp plays a (yet another!) strategic computer game. In this game, he leads an army of mercenaries.

Polycarp wants to gather his army for a quest. There are n mercenaries for hire, and the army should consist of some subset of them.

The i-th mercenary can be chosen if the resulting number of chosen mercenaries is not less than l_i (otherwise he deems the quest to be doomed) and not greater than r_i (he doesn't want to share the trophies with too many other mercenaries). Furthermore, m pairs of mercenaries hate each other and cannot be chosen for the same quest. 

How many non-empty subsets does Polycarp need to consider? In other words, calculate the number of non-empty subsets of mercenaries such that the size of this subset belongs to [l_i, r_i] for each chosen mercenary, and there are no two mercenaries in the subset that hate each other.

The answer may be large, so calculate it modulo 998244353.

Input

The first line contains two integers n and m (1 ≤ n ≤ 3 ⋅ 10^5, 0 ≤ m ≤ min(20, (n(n-1))/(2))) — the number of mercenaries and the number of pairs of mercenaries that hate each other.

Then n lines follow, the i-th of them contains two integers l_i and r_i (1 ≤ l_i ≤ r_i ≤ n).

Then m lines follow, the i-th of them contains two integers a_i and b_i (1 ≤ a_i < b_i ≤ n) denoting that the mercenaries a_i and b_i hate each other. There are no two equal pairs in this list.

Output

Print one integer — the number of non-empty subsets meeting the constraints, taken modulo 998244353.

Examples

Input


3 0
1 1
2 3
1 3


Output


3


Input


3 1
1 1
2 3
1 3
2 3


Output


2
Difficulty: 13
Solutions: #include <bits/stdc++.h>
using namespace std;
const int Inf = 0x3f3f3f3f;
const long long INF = 0x3f3f3f3f3f3f3f3fll;
const int jt = 998244353;
int n, m;
int jc[1 << 19], fjc[1 << 19];
int l[1 << 19], r[1 << 19];
int a[44], b[44];
int xf[1 << 19], cs[1 << 19][44];
int lgl[1 << 19];
int ksmii(int a, int b) {
  if (!b) return 1;
  int x = ksmii(a, b >> 1);
  x = 1ll * x * x % jt;
  if (b & 1) x = 1ll * x * a % jt;
  return x;
}
int inline C(int a, int b) {
  if (b < 0 || a < b) return 0;
  return 1ll * jc[a] * fjc[b] % jt * fjc[a - b] % jt;
}
int main() {
  jc[0] = 1;
  for (int i = 1; i <= (500000); i++) jc[i] = 1ll * jc[i - 1] * i % jt;
  fjc[500000] = ksmii(jc[500000], jt - 2);
  for (int i = (500000); ((-1) > 0 ? i <= (1) : i >= (1)); i += (-1))
    fjc[i - 1] = 1ll * fjc[i] * i % jt;
  scanf("%d%d", &n, &m);
  for (int i = 1; i <= (n); i++) {
    scanf("%d%d", l + i, r + i);
    xf[l[i]]++;
    xf[r[i] + 1]--;
  }
  for (int i = 1; i <= (n); i++) {
    xf[i] += xf[i - 1];
    for (int j = 0; j < (m << 1 | 1); j++) {
      cs[i][j] = (cs[i - 1][j] + C(xf[i] - j, i - j)) % jt;
    }
  }
  for (int i = 0; i < (m); i++) scanf("%d%d", a + i, b + i);
  int ans = 0;
  for (int i = 0; i < (1 << m); i++) {
    int ls = 1, rs = n, ts = 0;
    for (int j = 0; j < (m); j++) {
      if (!((i >> j) & 1)) continue;
      if (lgl[a[j]] != i) {
        lgl[a[j]] = i;
        ts++;
      }
      if (lgl[b[j]] != i) {
        lgl[b[j]] = i;
        ts++;
      }
      ls = max(ls, max(l[a[j]], l[b[j]]));
      rs = min(rs, min(r[a[j]], r[b[j]]));
    }
    if (ls > rs) continue;
    int res = (cs[rs][ts] - cs[ls - 1][ts] + jt) % jt;
    if (__builtin_popcount(i) % 2)
      ans = (ans - res + jt) % jt;
    else
      ans = (ans + res) % jt;
  }
  printf("%d\n", ans);
  return 0;
}


Example question 2:
Name: 739_C. Alyona and towers
Tags: ['data structures']
Description: Alyona has built n towers by putting small cubes some on the top of others. Each cube has size 1 × 1 × 1. A tower is a non-zero amount of cubes standing on the top of each other. The towers are next to each other, forming a row.

Sometimes Alyona chooses some segment towers, and put on the top of each tower several cubes. Formally, Alyouna chooses some segment of towers from li to ri and adds di cubes on the top of them.

Let the sequence a1, a2, ..., an be the heights of the towers from left to right. Let's call as a segment of towers al, al + 1, ..., ar a hill if the following condition holds: there is integer k (l ≤ k ≤ r) such that al < al + 1 < al + 2 < ... < ak > ak + 1 > ak + 2 > ... > ar.

After each addition of di cubes on the top of the towers from li to ri, Alyona wants to know the maximum width among all hills. The width of a hill is the number of towers in it.

Input

The first line contain single integer n (1 ≤ n ≤ 3·105) — the number of towers.

The second line contain n integers a1, a2, ..., an (1 ≤ ai ≤ 109) — the number of cubes in each tower. 

The third line contain single integer m (1 ≤ m ≤ 3·105) — the number of additions.

The next m lines contain 3 integers each. The i-th of these lines contains integers li, ri and di (1 ≤ l ≤ r ≤ n, 1 ≤ di ≤ 109), that mean that Alyona puts di cubes on the tio of each of the towers from li to ri.

Output

Print m lines. In i-th line print the maximum width of the hills after the i-th addition.

Example

Input

5
5 5 5 5 5
3
1 3 2
2 2 1
4 4 1


Output

2
4
5

Note

The first sample is as follows:

After addition of 2 cubes on the top of each towers from the first to the third, the number of cubes in the towers become equal to [7, 7, 7, 5, 5]. The hill with maximum width is [7, 5], thus the maximum width is 2.

After addition of 1 cube on the second tower, the number of cubes in the towers become equal to [7, 8, 7, 5, 5]. The hill with maximum width is now [7, 8, 7, 5], thus the maximum width is 4.

After addition of 1 cube on the fourth tower, the number of cubes in the towers become equal to [7, 8, 7, 6, 5]. The hill with maximum width is now [7, 8, 7, 6, 5], thus the maximum width is 5.
Difficulty: 9
Solutions: #include <bits/stdc++.h>
using namespace std;
const int N = 300005;
struct ban {
  long long laz;
  int e;
  int maxs, maxl, maxr;
  int nl, nr;
  long long l, r;
  void nor(long long x) {
    laz = 0;
    e = 1;
    maxs = maxl = maxr = 1;
    nl = nr = 1;
    l = r = x;
  }
  void mer(const ban& ll, const ban& rr) {
    e = ll.e + rr.e;
    maxs = max(ll.maxs, rr.maxs);
    maxl = ll.maxl;
    maxr = rr.maxr;
    nl = ll.nl;
    nr = rr.nr;
    l = ll.l;
    r = rr.r;
    if (ll.r > rr.l) {
      maxs = max(maxs, ll.maxr + rr.nl);
      if (ll.maxr == ll.e) maxl = ll.maxr + rr.nl;
      if (rr.nl == rr.e) maxr = ll.maxr + rr.nl;
    }
    if (rr.l > ll.r) {
      maxs = max(maxs, rr.maxl + ll.nr);
      if (rr.maxl == rr.e) maxr = rr.maxl + ll.nr;
      if (ll.nr == ll.e) maxl = rr.maxl + ll.nr;
    }
    if (ll.nl == ll.e && ll.r > rr.l) nl = ll.nl + rr.nl;
    if (rr.nr == rr.e && rr.l > ll.r) nr = rr.nr + ll.nr;
  }
};
int n;
long long a[N];
ban t[N * 4];
void shi(int pos) {
  if (t[pos].laz == 0) return;
  t[pos].l += t[pos].laz;
  t[pos].r += t[pos].laz;
  if (t[pos].e > 1) {
    t[pos * 2].laz += t[pos].laz;
    t[pos * 2 + 1].laz += t[pos].laz;
  }
  t[pos].laz = 0;
}
ban crt(ban u) {
  u.l += u.laz;
  u.r += u.laz;
  return u;
}
void bil(int tl, int tr, int pos) {
  if (tl == tr) {
    t[pos].nor(a[tl]);
    return;
  }
  int m = (tl + tr) / 2;
  bil(tl, m, pos * 2);
  bil(m + 1, tr, pos * 2 + 1);
  t[pos].mer(crt(t[pos * 2]), crt(t[pos * 2 + 1]));
}
void ubd(int tl, int tr, int l, int r, long long g, int pos) {
  if (tl == l && tr == r) {
    t[pos].laz += g;
    return;
  }
  shi(pos);
  int m = (tl + tr) / 2;
  if (r <= m)
    ubd(tl, m, l, r, g, pos * 2);
  else if (l > m)
    ubd(m + 1, tr, l, r, g, pos * 2 + 1);
  else {
    ubd(tl, m, l, m, g, pos * 2);
    ubd(m + 1, tr, m + 1, r, g, pos * 2 + 1);
  }
  t[pos].mer(crt(t[pos * 2]), crt(t[pos * 2 + 1]));
}
int32_t main() {
  ios_base::sync_with_stdio(false);
  cin >> n;
  for (int i = 1; i <= n; ++i) cin >> a[i];
  bil(1, n, 1);
  int q;
  cin >> q;
  while (q--) {
    int l, r, g;
    cin >> l >> r >> g;
    ubd(1, n, l, r, g, 1);
    cout << t[1].maxs << endl;
  }
  return 0;
}


Example question 3:
Name: 400_E. Inna and Binary Logic
Tags: ['binary search', 'bitmasks', 'data structures']
Description: Inna is fed up with jokes about female logic. So she started using binary logic instead.

Inna has an array of n elements a1[1], a1[2], ..., a1[n]. Girl likes to train in her binary logic, so she does an exercise consisting of n stages: on the first stage Inna writes out all numbers from array a1, on the i-th (i ≥ 2) stage girl writes all elements of array ai, which consists of n - i + 1 integers; the k-th integer of array ai is defined as follows: ai[k] = ai - 1[k] AND ai - 1[k + 1]. Here AND is bit-wise binary logical operation.

Dima decided to check Inna's skill. He asks Inna to change array, perform the exercise and say the sum of all <image> elements she wrote out during the current exercise.

Help Inna to answer the questions!

Input

The first line contains two integers n and m (1 ≤ n, m ≤ 105) — size of array a1 and number of Dima's questions. Next line contains n integers a1[1], a1[2], ..., a1[n] (0 ≤ ai ≤ 105) — initial array elements.

Each of next m lines contains two integers — Dima's question description. Each question consists of two integers pi, vi (1 ≤ pi ≤ n; 0 ≤ vi ≤ 105). For this question Inna should make a1[pi] equals vi, and then perform the exercise. Please, note that changes are saved from question to question.

Output

For each question print Inna's answer on a single line.

Examples

Input

3 4
1 1 1
1 1
2 2
3 2
1 2


Output

6
4
7
12
Difficulty: 11
Solutions: #include <bits/stdc++.h>
const int maxn = 100050, maxb = 20;
int n, m, d = 17, A[maxn];
long long ans = 0;
int main() {
  int d0, i, j, p, v;
  scanf("%d%d", &n, &m);
  for (i = 1; i <= n; i++) scanf("%d", &A[i]);
  for (d0 = 0; d0 < d; d0++)
    for (i = 1; i <= n; i++)
      if ((A[i] >> d0) & 1) {
        for (j = i + 1; j <= n && (A[j] >> d0) & 1; j++)
          ;
        ans += ((long long)(j - i) * (j - i + 1) / 2) << d0;
        i = j;
      }
  for (i = 0; i < m; i++) {
    scanf("%d%d", &p, &v);
    for (d0 = 0; d0 < d; d0++)
      if ((v >> d0 & 1) ^ (A[p] >> d0 & 1)) {
        int ls, rs;
        for (j = p + 1; j <= n && A[j] >> d0 & 1; j++)
          ;
        ls = j - p;
        for (j = p - 1; j && A[j] >> d0 & 1; j--)
          ;
        rs = p - j;
        if (A[p] >> d0 & 1)
          ans -= ((long long)ls * rs) << d0;
        else
          ans += ((long long)ls * rs) << d0;
      }
    A[p] = v;
    printf("%I64d\n", ans);
  }
  return 0;
}



INSTRUCTIONS:
Solve the current question.
Provide:
1. A complete and efficient code solution, optimized for both time and space complexity.
2. A detailed explanation of the solution, including:
   - The intuition behind the approach;
   - Time and space complexity;
   - Important considerations about the algorithm.
3. If the language has classes, implement in 'Solution' class. Any language is accepted.
4. You can use the example questions as general references for coding patterns and structure, but solve the current problem independently.
5. Don't use any external libraries. Don't need to import any libraries.
