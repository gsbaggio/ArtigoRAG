CURRENT QUESTION:
You are given a rooted tree consisting of n vertices numbered from 1 to n. The root of the tree is the vertex 1.

You have to color all vertices of the tree into n colors (also numbered from 1 to n) so that there is exactly one vertex for each color. Let c_i be the color of vertex i, and p_i be the parent of vertex i in the rooted tree. The coloring is considered beautiful if there is no vertex k (k > 1) such that c_k = c_{p_k} - 1, i. e. no vertex such that its color is less than the color of its parent by exactly 1.

Calculate the number of beautiful colorings, and print it modulo 998244353.

Input

The first line contains one integer n (2 ≤ n ≤ 250000) — the number of vertices in the tree.

Then n-1 lines follow, the i-th line contains two integers x_i and y_i (1 ≤ x_i, y_i ≤ n; x_i ≠ y_i) denoting an edge between the vertex x_i and the vertex y_i. These edges form a tree.

Output

Print one integer — the number of beautiful colorings, taken modulo 998244353.

Examples

Input


5
1 2
3 2
4 2
2 5


Output


42


Input


5
1 2
2 3
3 4
4 5


Output


53


Input


20
20 19
20 4
12 4
5 8
1 2
20 7
3 10
7 18
11 8
9 10
17 10
1 15
11 16
14 11
18 10
10 1
14 2
13 17
20 6


Output


955085064

EXAMPLE QUESTIONS:
Example question 1:
Name: bytesg
Tags: []
Description: Do you like Treasure Hunts? I like treasure hunts. Love ‘em. And TROIKA 2013 has the best one ever in ‘MIST’ (apps.facebook.com/mist_troika). 
Just like a normal treasure hunt, you are given several clues and you have to get the right answer to progress to the next level and so on, until you reach the ultimate prize! But the organizers have learnt that a lot of users are not progressing even after figuring out the correct answer; it seems ‘someone’ forgot to code in ‘possible variants of the correct answer’ for each level. For example, if “Sachin Tendulkar” happened to be the answer to a particular level, “Tendulkar” or “tendulkar” or “sachin tendulkar” wasn’t accepted as correct. This is what you have to rectify.
Given the expected answer ‘S’, your job is to modify the answer-verification-system to be able to allow acceptable variants of ‘S’.
If the user enters an acceptable variant ,terminate the program. You can assume that the user is intelligent enough so that he will enter the answer in an order specified by the string S i.e he will not enter anything like “Tendulkar Sachin” if the answer is “Sachin Tendulkar” however he can enter “Tendulkar”.

Input
The first line of the input contains a string S.
The next few lines contain the input string P entered by the user.

Output
For every line entered by the user output “Yes” if the string is acceptable and “No” if it is not. (quotes only for clarity).

Contraints
1 <= length of S and P <= 10000

Example

Input 1:
Sachin Ramesh Tendulkar
Sach
Ram
sAcH Tendul
sach Tendulkar
Sachin Ram Tendulkar
SAChin TENduLkaR

Output 1:
No
No
No
No
No
Yes

Input 2:
Sachin Ramesh Tendulkar
Sach
Ram
sAcH Tendul
sach Tendulkar
Sachin Ram Tendulkar
Ramesh TENduLkaR

Output 2:
No
No
No
No
No
Yes
Difficulty: 6
Solutions: import string
s = raw_input().split()
l = len(s)
for i in range(l):
    s[i] = string.lower(s[i])
while True:
    p = raw_input().split()
    l1 = len(p)
    a = 1
    for i in range(l1):
        if string.lower(p[i]) not in s:
            a = 0
            break
    if a:
        break
    else:
        print "No"
print "Yes"

Example question 2:
Name: 1107_C. Brutality
Tags: ['greedy', 'sortings', 'two pointers']
Description: You are playing a new famous fighting game: Kortal Mombat XII. You have to perform a brutality on your opponent's character.

You are playing the game on the new generation console so your gamepad have 26 buttons. Each button has a single lowercase Latin letter from 'a' to 'z' written on it. All the letters on buttons are pairwise distinct.

You are given a sequence of hits, the i-th hit deals a_i units of damage to the opponent's character. To perform the i-th hit you have to press the button s_i on your gamepad. Hits are numbered from 1 to n.

You know that if you press some button more than k times in a row then it'll break. You cherish your gamepad and don't want to break any of its buttons.

To perform a brutality you have to land some of the hits of the given sequence. You are allowed to skip any of them, however changing the initial order of the sequence is prohibited. The total damage dealt is the sum of a_i over all i for the hits which weren't skipped.

Note that if you skip the hit then the counter of consecutive presses the button won't reset.

Your task is to skip some hits to deal the maximum possible total damage to the opponent's character and not break your gamepad buttons.

Input

The first line of the input contains two integers n and k (1 ≤ k ≤ n ≤ 2 ⋅ 10^5) — the number of hits and the maximum number of times you can push the same button in a row.

The second line of the input contains n integers a_1, a_2, ..., a_n (1 ≤ a_i ≤ 10^9), where a_i is the damage of the i-th hit.

The third line of the input contains the string s consisting of exactly n lowercase Latin letters — the sequence of hits (each character is the letter on the button you need to press to perform the corresponding hit).

Output

Print one integer dmg — the maximum possible damage to the opponent's character you can deal without breaking your gamepad buttons.

Examples

Input


7 3
1 5 16 18 7 2 10
baaaaca


Output


54


Input


5 5
2 4 1 3 1000
aaaaa


Output


1010


Input


5 4
2 4 1 3 1000
aaaaa


Output


1009


Input


8 1
10 15 2 1 4 8 15 16
qqwweerr


Output


41


Input


6 3
14 18 9 19 2 15
cccccc


Output


52


Input


2 1
10 10
qq


Output


10

Note

In the first example you can choose hits with numbers [1, 3, 4, 5, 6, 7] with the total damage 1 + 16 + 18 + 7 + 2 + 10 = 54.

In the second example you can choose all hits so the total damage is 2 + 4 + 1 + 3 + 1000 = 1010.

In the third example you can choose all hits expect the third one so the total damage is 2 + 4 + 3 + 1000 = 1009.

In the fourth example you can choose hits with numbers [2, 3, 6, 8]. Only this way you can reach the maximum total damage 15 + 2 + 8 + 16 = 41.

In the fifth example you can choose only hits with numbers [2, 4, 6] with the total damage 18 + 19 + 15 = 52.

In the sixth example you can change either first hit or the second hit (it does not matter) with the total damage 10.
Difficulty: 9
Solutions: #include <bits/stdc++.h>
using namespace std;
int main() {
  ios::sync_with_stdio(false);
  cin.tie(0);
  vector<long long> tmp;
  int n, k;
  cin >> n >> k;
  long long mas[n], ans = 0;
  for (int i = 0; i < (int)(n); ++i) cin >> mas[i];
  vector<pair<long long, long long> > ext;
  string s;
  cin >> s;
  for (int i = 0; i < (int)(s.length()); ++i) {
    ext.push_back(make_pair(mas[i], s[i]));
  }
  for (long long i = 0; i < s.length(); i++) {
    long long start = i, loop = k;
    while (s[i] == s[i + 1] && i < s.length() - 1) i++;
    for (long long j = start; j <= i; j++) {
      tmp.push_back(ext[j].first);
    }
    sort(tmp.begin(), tmp.end());
    for (long long i = tmp.size() - 1; i >= 0; i--) {
      ans += tmp[i];
      loop--;
      if (loop <= 0) break;
    }
    tmp.clear();
  }
  cout << ans;
  return 0;
}


Example question 3:
Name: 92_E. Ski Base
Tags: ['combinatorics', 'dsu', 'graphs']
Description: A ski base is planned to be built in Walrusland. Recently, however, the project is still in the constructing phase. A large land lot was chosen for the construction. It contains n ski junctions, numbered from 1 to n. Initially the junctions aren't connected in any way.

In the constructing process m bidirectional ski roads will be built. The roads are built one after another: first the road number 1 will be built, then the road number 2, and so on. The i-th road connects the junctions with numbers ai and bi.

Track is the route with the following properties: 

  * The route is closed, that is, it begins and ends in one and the same junction.
  * The route contains at least one road. 
  * The route doesn't go on one road more than once, however it can visit any junction any number of times. 



Let's consider the ski base as a non-empty set of roads that can be divided into one or more tracks so that exactly one track went along each road of the chosen set. Besides, each track can consist only of roads from the chosen set. Ski base doesn't have to be connected.

Two ski bases are considered different if they consist of different road sets.

After building each new road the Walrusland government wants to know the number of variants of choosing a ski base based on some subset of the already built roads. The government asks you to help them solve the given problem.

Input

The first line contains two integers n and m (2 ≤ n ≤ 105, 1 ≤ m ≤ 105). They represent the number of junctions and the number of roads correspondingly. Then on m lines follows the description of the roads in the order in which they were built. Each road is described by a pair of integers ai and bi (1 ≤ ai, bi ≤ n, ai ≠ bi) — the numbers of the connected junctions. There could be more than one road between a pair of junctions.

Output

Print m lines: the i-th line should represent the number of ways to build a ski base after the end of construction of the road number i. The numbers should be printed modulo 1000000009 (109 + 9).

Examples

Input

3 4
1 3
2 3
1 2
1 2


Output

0
0
1
3

Note

Let us have 3 junctions and 4 roads between the junctions have already been built (as after building all the roads in the sample): 1 and 3, 2 and 3, 2 roads between junctions 1 and 2. The land lot for the construction will look like this:

<image>

The land lot for the construction will look in the following way:

<image>

We can choose a subset of roads in three ways:

<image>

In the first and the second ways you can choose one path, for example, 1 - 2 - 3 - 1. In the first case you can choose one path 1 - 2 - 1.
Difficulty: 11
Solutions: #include <bits/stdc++.h>
using namespace std;
const double pi = acos(-1.0);
int dx[] = {-1, 0, 1, 0, 1, 1, -1, -1};
int dy[] = {0, 1, 0, -1, 1, -1, 1, -1};
int n, m;
struct ufind {
  int p[100005], t;
  void init() { memset(p, 0, sizeof(p)); }
  void set_friend(int i, int j) {
    for (; p[t = i]; i = p[i], p[t] = (p[i] ? p[i] : i))
      ;
    for (; p[t = j]; j = p[j], p[t] = (p[j] ? p[j] : j))
      ;
    p[i] = (i == j ? 0 : j);
  }
  int is_friend(int i, int j) {
    for (; p[t = i]; i = p[i], p[t] = (p[i] ? p[i] : i))
      ;
    for (; p[t = j]; j = p[j], p[t] = (p[j] ? p[j] : j))
      ;
    return i == j && i;
  }
} U;
int main() {
  while (cin >> n >> m) {
    int a, b;
    U.init();
    long long ret = 0;
    for (int i = 0; i < m; ++i) {
      scanf("%d%d", &a, &b);
      if (U.is_friend(a, b)) {
        ret *= 2;
        ++ret;
        ret %= 1000000009;
      } else {
        U.set_friend(a, b);
      }
      cout << ret << endl;
    }
  }
  return 0;
}



INSTRUCTIONS:
Solve the current question.
Provide:
1. A complete and efficient code solution, optimized for both time and space complexity.
2. A detailed explanation of the solution, including:
   - The intuition behind the approach;
   - Time and space complexity;
   - Important considerations about the algorithm.
3. You can use the example questions as general references for coding patterns and structure, but solve the current problem independently.
4. Don't use any external libraries. Any language is accepted.