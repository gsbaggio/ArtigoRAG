CURRENT QUESTION:
Mr. Chanek has an array a of n integers. The prettiness value of a is denoted as:

$$$∑_{i=1}^{n} {∑_{j=1}^{n} {\gcd(a_i, a_j) ⋅ \gcd(i, j)}}$$$

where \gcd(x, y) denotes the greatest common divisor (GCD) of integers x and y.

In other words, the prettiness value of an array a is the total sum of \gcd(a_i, a_j) ⋅ \gcd(i, j) for all pairs (i, j).

Help Mr. Chanek find the prettiness value of a, and output the result modulo 10^9 + 7!

Input

The first line contains an integer n (2 ≤ n ≤ 10^5).

The second line contains n integers a_1, a_2, …, a_n (1 ≤ a_i ≤ 10^5).

Output

Output an integer denoting the prettiness value of a modulo 10^9 + 7.

Example

Input


5
3 6 2 1 4


Output


77

EXAMPLE QUESTIONS:
Example question 1:
Name: 331_E2. Deja Vu
Tags: ['constructive algorithms', 'dp']
Description: Everybody knows that we have been living in the Matrix for a long time. And in the new seventh Matrix the world is ruled by beavers.

So let's take beaver Neo. Neo has so-called "deja vu" outbursts when he gets visions of events in some places he's been at or is going to be at. Let's examine the phenomenon in more detail.

We can say that Neo's city is represented by a directed graph, consisting of n shops and m streets that connect the shops. No two streets connect the same pair of shops (besides, there can't be one street from A to B and one street from B to A). No street connects a shop with itself. As Neo passes some streets, he gets visions. No matter how many times he passes street k, every time he will get the same visions in the same order. A vision is a sequence of shops.

We know that Neo is going to get really shocked if he passes the way from some shop a to some shop b, possible coinciding with a, such that the list of visited shops in the real life and in the visions coincide.

Suggest beaver Neo such path of non-zero length. Or maybe you can even count the number of such paths modulo 1000000007 (109 + 7)?..

Input

The first line contains integers n and m — the number of shops and the number of streets, correspondingly, 1 ≤ n ≤ 50, <image>. Next m lines contain the descriptions of the streets in the following format: xi yi ki v1 v2 ... vk, where xi and yi (1 ≤ xi, yi ≤ n, xi ≠ yi) are numbers of shops connected by a street, ki (0 ≤ ki ≤ n) is the number of visions on the way from xi to yi; v1, v2, ..., vk (1 ≤ vi ≤ n) describe the visions: the numbers of the shops Neo saw. Note that the order of the visions matters.

It is guaranteed that the total number of visions on all streets doesn't exceed 105.

  * to get 50 points, you need to find any (not necessarily simple) path of length at most 2·n, that meets the attributes described above (subproblem E1); 
  * to get 50 more points, you need to count for each length from 1 to 2·n the number of paths that have the attribute described above (subproblem E2). 

Output

Subproblem E1. In the first line print an integer k (1 ≤ k ≤ 2·n) — the numbers of shops on Neo's path. In the next line print k integers — the number of shops in the order Neo passes them. If the graph doesn't have such paths or the length of the shortest path includes more than 2·n shops, print on a single line 0.

Subproblem E2. Print 2·n lines. The i-th line must contain a single integer — the number of required paths of length i modulo 1000000007 (109 + 7).

Examples

Input

6 6
1 2 2 1 2
2 3 1 3
3 4 2 4 5
4 5 0
5 3 1 3
6 1 1 6


Output

4
6 1 2 3


Input

6 6
1 2 2 1 2
2 3 1 3
3 4 2 4 5
4 5 0
5 3 1 3
6 1 1 6


Output

1
2
1
1
2
1
1
2
1
1
2
1

Note

The input in both samples are the same. The first sample contains the answer to the first subproblem, the second sample contains the answer to the second subproblem.
Difficulty: 11
Solutions: #include <bits/stdc++.h>
using namespace std;
const int MAX = 100 + 10;
const int Mod = (int)1e9 + 7;
int n, m;
int g[MAX][MAX], can[MAX][MAX];
vector<int> p[MAX][MAX];
int get(vector<int> &before, int kind, int could, int have) {
  int j;
  int now = 0, cc = have;
  for (; now < (int)before.size(); now++) {
    if (now + 1 == (int)before.size()) break;
    int a = before[now];
    int b = before[now + 1];
    if (g[a][b] != kind || (!could && can[a][b])) return 0;
    vector<int> &nL = p[a][b];
    for ((j) = (0); (j) != ((int)nL.size()); ++(j)) {
      if (cc < (int)before.size()) {
        if (nL[j] == before[cc])
          cc++;
        else
          return 0;
      } else {
        while (j < (int)nL.size()) {
          before.push_back(nL[j++]);
          if ((int)before.size() > 2 * n + 1) return 0;
        }
        cc = before.size();
        break;
      }
    }
  }
  return cc == (int)before.size();
}
int isCan(int a, int b) {
  int i;
  vector<int> &L = p[a][b];
  int len = L.size();
  for ((i) = (0); (i) <= (len - 2); ++(i))
    if (L[i] == a && L[i + 1] == b) return 1;
  return 0;
}
int f_Before[MAX][MAX][MAX], f_After[MAX][MAX][MAX], tmp[MAX][MAX][MAX];
int Before[MAX][MAX], After[MAX][MAX];
int ans[MAX];
void work(int u, int kind, int f[MAX][MAX][MAX]) {
  int v;
  for ((v) = (1); (v) <= (n); ++(v))
    if (g[u][v] == kind && !can[v][u]) {
      vector<int> after;
      after.push_back(u);
      after.push_back(v);
      if (!get(after, kind, kind != 2, 1)) continue;
      int Len = after.size();
      f[u][after[Len - 1]][Len - 1]++;
    }
}
void add(int &a, int b) {
  a += b;
  if (a >= Mod) a -= Mod;
}
void work2(int a, int b) {
  int i, j;
  vector<int> &L = p[a][b];
  int len = L.size();
  for ((i) = (0); (i) <= (len - 2); ++(i))
    if (L[i] == a && L[i + 1] == b) {
      vector<int> before, after;
      for (j = i; j >= 0; --j) before.push_back(L[j]);
      for (j = i + 1; j < len; ++j) after.push_back(L[j]);
      if (get(before, 2, 0, before.size()) && get(after, 1, 1, after.size())) {
        reverse(before.begin(), before.end());
        int A = before[0];
        int B = after[after.size() - 1];
        int Len = before.size() + after.size() - 1;
        int k, l, o;
        for ((l) = (1); (l) <= (n); ++(l))
          for ((o) = (0); (o) <= (2 * n); ++(o))
            if (tmp[A][l][o])
              for ((k) = (1); (k) <= (n); ++(k))
                if (g[k][l] == 1 && p[k][l].size() == 0 && Len + 1 + o <= 2 * n)
                  add(f_After[k][B][Len + 1 + o], tmp[A][l][o]);
      } else
        return;
    }
  return;
}
int tot = 0, First;
void Dp1(int f[MAX][MAX][MAX], int after[MAX][MAX]) {
  int i, j, k, l, o;
  memset(tmp, 0, sizeof tmp);
  for ((i) = (1); (i) <= (n); ++(i)) tmp[i][i][0] = 1;
  int up = 2 * n;
  for ((l) = (1); (l) <= (up); ++(l))
    for ((i) = (1); (i) <= (n); ++(i))
      for ((j) = (1); (j) <= (n); ++(j))
        for ((o) = (0); (o) <= (l); ++(o))
          if (f[i][j][o])
            for ((k) = (1); (k) <= (n); ++(k))
              if (tmp[j][k][l - o])
                add(tmp[i][k][l],
                    (long long)f[i][j][o] * tmp[j][k][l - o] % Mod);
  for ((i) = (1); (i) <= (n); ++(i))
    for ((j) = (1); (j) <= (n); ++(j))
      for ((l) = (0); (l) <= (2 * n); ++(l)) add(after[i][l], tmp[i][j][l]);
}
void Dp2(int f[MAX][MAX][MAX], int after[MAX][MAX]) {
  int i, j, k, l;
  for ((i) = (1); (i) <= (n); ++(i)) after[i][0] = 1;
  int up = 2 * n;
  for ((l) = (1); (l) <= (up); ++(l))
    for ((i) = (1); (i) <= (n); ++(i))
      for ((j) = (1); (j) <= (n); ++(j))
        for ((k) = (0); (k) != (l); ++(k))
          add(After[i][l], (long long)f[i][j][l - k] * After[j][k] % Mod);
}
void check(int a, int b) {
  int i, j;
  vector<int> &L = p[a][b];
  int len = L.size();
  for ((i) = (0); (i) <= (len - 2); ++(i))
    if (L[i] == a && L[i + 1] == b) {
      vector<int> before, after;
      for (j = i; j >= 0; --j) before.push_back(L[j]);
      for (j = i + 1; j < len; ++j) after.push_back(L[j]);
      if (get(before, 2, 0, before.size()) && get(after, 1, 1, after.size())) {
        reverse(before.begin(), before.end());
        int A = before[0];
        int B = after[after.size() - 1];
        int Len = before.size() + after.size() - 1;
        int l1, l2;
        for ((l1) = (0); (l1) <= (2 * n); ++(l1))
          for ((l2) = (0); (l2) <= (2 * n); ++(l2))
            if (l1 + l2 + Len <= 2 * n)
              add(ans[l1 + l2 + Len],
                  (long long)Before[A][l1] * After[B][l2] % Mod);
      } else
        return;
    }
  return;
}
int main() {
  int i, j;
  scanf("%d%d", &n, &m);
  for ((i) = (1); (i) <= (m); ++(i)) {
    int a, b;
    scanf("%d%d", &a, &b);
    if (!First) First = a;
    g[a][b] = 1;
    g[b][a] = 2;
    int k, first;
    scanf("%d", &k);
    while (k--) {
      scanf("%d", &first);
      p[a][b].push_back(first);
    }
    p[b][a] = p[a][b];
    reverse(p[b][a].begin(), p[b][a].end());
  }
  for ((i) = (1); (i) <= (n); ++(i))
    for ((j) = (1); (j) <= (n); ++(j))
      if (g[i][j] == 1 && isCan(i, j)) can[j][i] = can[i][j] = 1;
  for ((i) = (1); (i) <= (n); ++(i)) work(i, 1, f_After);
  for ((i) = (1); (i) <= (n); ++(i)) work(i, 2, f_Before);
  Dp1(f_Before, Before);
  for ((i) = (1); (i) <= (n); ++(i))
    for ((j) = (1); (j) <= (n); ++(j))
      if (g[i][j] == 1 && can[i][j] == 1) work2(i, j);
  Dp2(f_After, After);
  for ((i) = (1); (i) <= (n); ++(i))
    for ((j) = (1); (j) <= (n); ++(j))
      if (g[i][j] == 1 && can[i][j] == 1) check(i, j);
  for ((i) = (1); (i) <= (2 * n); ++(i)) cout << ans[i] << endl;
  return 0;
}


Example question 2:
Name: p02117 Picnic
Tags: ['']
Description: Problem

Tomorrow is finally the day of the excursion to Maizu Elementary School. Gatcho, who attends Maizu Elementary School, noticed that he had forgotten to buy tomorrow's sweets because he was so excited. Gaccho wants to stick to sweets so that he can enjoy the excursion to the fullest.


Gaccho gets a $ X $ yen allowance from his mother and goes to buy sweets. However, according to the rules of elementary school, the total amount of sweets to bring for an excursion is limited to $ Y $ yen, and if it exceeds $ Y $ yen, all sweets will be taken up by the teacher.

There are $ N $ towns in the school district where Gaccho lives, and each town has one candy store. Each town is assigned a number from 1 to $ N $, and Gaccho lives in town 1. Each candy store sells several sweets, and the price per one and the satisfaction level that you can get for each purchase are fixed. However, the number of sweets in stock is limited. Also, Gaccho uses public transportation to move between the two towns, so to move directly from town $ i $ to town $ j $, you only have to pay $ d_ {i, j} $ yen. It takes.

At first, Gaccho is in Town 1. Gaccho should make sure that the sum of the total cost of moving and the price of the sweets you bought is within $ X $ yen, and the total price of the sweets you bought is within $ Y $ yen. I'm going to buy sweets. You must have arrived at Town 1 at the end. Gaccho wants to maximize the total satisfaction of the sweets he bought. Find the total satisfaction when you do the best thing.

Constraints

The input satisfies the following conditions.

* $ 1 \ leq N \ leq 14 $
* $ 1 \ leq X \ leq 10000 $
* $ 1 \ leq Y \ leq min (1000, X) $
* $ 1 \ leq K \ leq 300 $
* $ 1 \ leq a_i \ leq 1000 $
* $ 1 \ leq b_i \ leq 1000 $
* $ 1 \ leq c_i \ leq 1000 $
* $ 0 \ leq d_ {i, j} \ leq 10000 $
* $ d_ {i, i} = 0 $

Input

All inputs are given as integers in the following format:

$ N $ $ X $ $ Y $
Information on candy stores in town 1
Information on candy stores in town 2
...
Information on candy stores in town $ N $
$ d_ {1,1} $ $ d_ {1,2} $ ... $ d_ {1, N} $
$ d_ {2,1} $ $ d_ {2,2} $ ... $ d_ {2, N} $
...
$ d_ {N, 1} $ $ d_ {N, 2} $ ... $ d_ {N, N} $


On the first line, the number of towns $ N $, the amount of money you have $ X $, and the maximum amount you can use to buy sweets $ Y $ are given, separated by blanks.
From the second line, information on each $ N $ candy store is given.
In the following $ N $ row and $ N $ column, the amount $ d_ {i, j} $ required to go back and forth between town $ i $ and town $ j $ is given, separated by blanks.


Information on candy stores in each town is given in the following format.

$ K $
$ a_1 $ $ b_1 $ $ c_1 $
$ a_2 $ $ b_2 $ $ c_2 $
...
$ a_K $ $ b_K $ $ c_K $


The first line gives $ K $, the number of types of sweets sold at the candy store. In the following $ K $ line, the price of one candy $ a_i $, the satisfaction level $ b_i $ per candy, and the number of stocks $ c_i $ are given, separated by blanks.

Output

Output the maximum value of the total satisfaction level on one line.

Examples

Input

1 10 10
3
1 10 1
2 20 2
3 30 3
0


Output

100


Input

2 10 10
3
1 10 1
2 20 2
3 30 3
1
5 200 1
0 2
3 0


Output

200


Input

3 10 10
1
1 1 1
1
3 3 3
1
5 5 5
0 1 0
1 0 0
0 1 0


Output

10


Input

4 59 40
1
7 6 3
1
10 3 9
2
9 8 5
7 6 10
4
8 2 9
1 7 1
7 7 9
1 2 3
0 28 7 26
14 0 10 24
9 6 0 21
9 24 14 0


Output

34
Difficulty: 0
Solutions: #include <bits/stdc++.h>
using namespace std;
#define F first
#define S second
typedef pair<int,int> P;
typedef pair<int,P> PP;
const int N=14;
int dp1[N][1001],c[N][N],dp2[1<<N][N],dp3[2][1<<(N/2+1)][1001],dp[1<<N][1001],ans;
vector<PP> a[N+1];
int main() {
  int A,B,n;
  cin >> n >> A >> B;
  for(int k=0; k<n; k++) {
    fill(dp1[k],dp1[k]+B+1,-(1<<30));
    dp1[k][0]=0;
    int m;
    cin >> m;
    for(int i=0; i<m; i++) {
      PP p;
      cin >> p.S.F >> p.F >> p.S.S;
      int t=1;
      while(p.S.S) {
        do {
          for(int j=B; j>=0; j--) {
            if(j+p.S.F*t<=B) dp1[k][j+p.S.F*t]=max(dp1[k][j+p.S.F*t],dp1[k][j]+p.F*t);
          }
          p.S.S-=t;
        } while(p.S.S%(t*2));
        t*=2;
      }
    }
    for(int i=0; i<B; i++) dp1[k][i+1]=max(dp1[k][i+1],dp1[k][i]);
  }
  for(int i=0; i<n; i++)for(int j=0; j<n; j++) cin >> c[i][j];
  for(int k=0;k<n;k++)for(int i=0;i<n;i++)for(int j=0;j<n;j++)c[i][j]=min(c[i][j],c[i][k]+c[k][j]);
  for(int t=0;t<(1<<n);t++)for(int i=0;i<n;i++) dp2[t][i]=1<<30;
  for(int i=0; i<n; i++) dp2[1<<i][i]=c[0][i];
  for(int t=1; t<(1<<n); t++) {
    for(int i=0; i<n; i++) {
      if(!(t&(1<<i))) continue;
      for(int j=0; j<n; j++) {
        if(t&(1<<j)) continue;
        dp2[t|(1<<j)][j]=min(dp2[t|(1<<j)][j],dp2[t][i]+c[i][j]);
      }
    }
  }
  for(int t=0;t<(1<<(n/2+n%2));t++)for(int i=0;i<=B;i++)dp3[0][t][i]=dp3[1][t][i]=-(1<<30);
  for(int l=0; l<2; l++) {
    dp3[l][0][0]=0;
    for(int t=0; t<(1<<(n/2+n%2*l)); t++) {
      for(int i=0; i<n/2+n%2*l; i++) {
        if(t&(1<<i)) continue;
        for(int j=B; j>=0; j--) {
          for(int k=B-j; k>=0; k--) {
            dp3[l][t|(1<<i)][j+k]=max(dp3[l][t|(1<<i)][j+k],dp3[l][t][j]+dp1[i+n/2*l][k]);
          }
        }
      }
      for(int i=0; i<B; i++) dp3[l][t][i+1]=max(dp3[l][t][i+1],dp3[l][t][i]);
    }
  }
  for(int t=0;t<(1<<n);t++)for(int i=0;i<=B;i++)dp[t][i]=-(1<<30);
  for(int t=0;t<(1<<(n/2));t++) {
    if(n>1&&t%2==0) continue;
    for(int s=0; s<(1<<(n/2+n%2)); s++) {
      int C=max(0,A-dp2[t|(s<<(n/2))][0]),D=min(B,C);
      for(int i=0; i<=D; i++)ans=max(ans,dp3[0][t][i]+dp3[1][s][D-i]);
    }
  }
  cout << ans << endl;
  return 0;
}


Example question 3:
Name: p01322 Lottery Checker
Tags: ['']
Description: You have successfully completed your studies and are preparing to move from near Komaba to near Hongo. As I was organizing my house, I found a lot of lottery tickets I bought last year. After confirming the exchange deadline, I have to cash in by tomorrow, but it is troublesome to go to the lottery counter for a small amount of money because I am not ready to move at all. So you decide to find out how much you can win.

The lottery consists of eight digits. The winning number is also composed of 8 digits and a number and'*', and if the lottery you have and the number part match, the winning money will be paid according to the winning number.

For example, if the lottery number you have is "12345678", you will win if the winning number is "******* 8" or "**** 5678", but the winning number is "**". If it is ** 4678 ", you will not win. There can be multiple winning numbers, and the winnings will be paid independently for each. However, the winning numbers are chosen so that one lottery does not win more than one winning number. For example, if there are two winning numbers, "******* 8" and "**** 5678", "12345678" will win both, so such a winning number will be selected. There is no one to be done.

Your job is to write a program that outputs how much winning money you will get for the lottery number you have and the lottery winning number given as input.

Notes on Test Cases

Multiple datasets are given in the above input format. Create a program that outputs each data set in the above output format.

When n is 0, it indicates the end of input.

<!-



Input

The input is given in the following format.


n m
N1 M1
...
Nn Mn
B1
...
Bm

In the first line, the number of winning numbers n (1 ≤ n ≤ 100) and the number of lottery tickets in possession m (1 ≤ m ≤ 1000) are given as integers.

In the next n lines, each line is given a winning number Ni and a winnings Mi (1 ≤ Mi ≤ 1000000). Winnings are integers. The format of the winning number is as described in the question text.

The next m lines will give you the number of the lottery you have.

Output

Output the total amount of winnings.

Examples

Input

3 3
*******1 100
******22 1000
11111112 1000000
01203291
02382022
11111111
10 10
****3228 149416
****3992 198635
****4286 77783
****4843 225244
***49835 231046
***59393 379996
*5763748 437345
*6726222 58054
*8117882 16375
*9244339 537727
77885716
96726222
26971031
66652868
89599648
37772338
64679621
65479161
92959393
57855682
0 0


Output

1200
438050


Input

3 3
*******1 100
******22 1000
11111112 1000000
01203291
02382022
11111111


Output

1200


Input

10 10
****3228 149416
****3992 198635
****4286 77783
****4843 225244
***49835 231046
***59393 379996
*5763748 437345
*6726222 58054
*8117882 16375
*9244339 537727
77885716
96726222
26971031
66652868
89599648
37772338
64679621
65479161
92959393
57855682


Output

438050
Difficulty: 0
Solutions: #include <iostream>
#include <string>
#include <algorithm>
using namespace std;
typedef long long ll;
ll n, m;
int main() {
    while (cin>>n>>m) {
        if (!n) break;
        string key[n];
        ll score[n];
        for (int i=0; i<n; i++) {
            string str; cin>>str>>score[i];
            key[i]=str;
        }
        ll sum=0;
        for (int i=0; i<m; i++) {
            string str; cin>>str;
            for (int j=0; j<n; j++) {
                int k=0;
                while ((key[j][k]=='*'||key[j][k]==str[k])&&k<8) k++;
                if (k==8) {
                    sum+=score[j];
                    break;
                }
            }
        }
        cout<<sum<<endl;
    }
}


INSTRUCTIONS:
Solve the current question.
Provide:
1. A complete and efficient code solution, optimized for both time and space complexity.
2. A detailed explanation of the solution, including:
   - The intuition behind the approach;
   - Time and space complexity;
   - Important considerations about the algorithm.
3. If the language has classes, implement in 'Solution' class. Any language is accepted.
4. You can use the example questions as general references for coding patterns and structure, but solve the current problem independently.
5. Don't use any external libraries. Don't need to import any libraries.
