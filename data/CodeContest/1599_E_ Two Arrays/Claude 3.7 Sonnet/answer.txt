#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

const int MOD = 1e9 + 7;

// Matrix structure for Fibonacci calculation using matrix exponentiation
struct Matrix {
    long long a[2][2];
    
    Matrix() {
        a[0][0] = a[0][1] = a[1][0] = 1;
        a[1][1] = 0;
    }
    
    Matrix(long long a00, long long a01, long long a10, long long a11) {
        a[0][0] = a00;
        a[0][1] = a01;
        a[1][0] = a10;
        a[1][1] = a11;
    }
    
    // Matrix multiplication
    Matrix operator * (const Matrix& other) const {
        Matrix res(0, 0, 0, 0);
        for (int i = 0; i < 2; i++) {
            for (int j = 0; j < 2; j++) {
                for (int k = 0; k < 2; k++) {
                    res.a[i][j] = (res.a[i][j] + a[i][k] * other.a[k][j]) % MOD;
                }
            }
        }
        return res;
    }
};

// Fast matrix exponentiation to calculate Fibonacci numbers
long long getFib(long long n) {
    if (n <= 0) return 0;
    if (n == 1) return 1;
    
    Matrix base;
    Matrix res(1, 0, 0, 1); // Identity matrix
    
    n--; // Adjust because F(1) = 1
    
    while (n > 0) {
        if (n & 1) {
            res = res * base;
        }
        base = base * base;
        n >>= 1;
    }
    
    return res.a[0][0];
}

// Segment Tree node structure
struct Node {
    long long min_val, max_val, sum;
    bool has_min, has_max, has_add;
    long long min_lazy, max_lazy, add_lazy;
    
    Node() {
        min_val = LLONG_MAX;
        max_val = 0;
        sum = 0;
        has_min = has_max = has_add = false;
        min_lazy = LLONG_MAX;
        max_lazy = 0;
        add_lazy = 0;
    }
};

class SegmentTree {
private:
    vector<Node> tree;
    vector<long long>& arr;
    int n;
    
    void build(int node, int start, int end, int k) {
        if (start == end) {
            tree[node].min_val = tree[node].max_val = tree[node].sum = arr[start + (k-1)*n];
            return;
        }
        
        int mid = start + (end - start) / 2;
        build(2*node, start, mid, k);
        build(2*node+1, mid+1, end, k);
        
        tree[node].min_val = min(tree[2*node].min_val, tree[2*node+1].min_val);
        tree[node].max_val = max(tree[2*node].max_val, tree[2*node+1].max_val);
        tree[node].sum = tree[2*node].sum + tree[2*node+1].sum;
    }
    
    void push_lazy(int node, int start, int end) {
        // Apply lazy values in correct order
        if (tree[node].has_min) {
            tree[node].min_val = min(tree[node].min_val, tree[node].min_lazy);
            tree[node].max_val = min(tree[node].max_val, tree[node].min_lazy);
            tree[node].sum = min(tree[node].sum, tree[node].min_lazy * (end - start + 1));
            
            if (start != end) {
                if (!tree[2*node].has_min || tree[2*node].min_lazy > tree[node].min_lazy) {
                    tree[2*node].min_lazy = tree[node].min_lazy;
                    tree[2*node].has_min = true;
                }
                if (!tree[2*node+1].has_min || tree[2*node+1].min_lazy > tree[node].min_lazy) {
                    tree[2*node+1].min_lazy = tree[node].min_lazy;
                    tree[2*node+1].has_min = true;
                }
            }
            tree[node].has_min = false;
        }
        
        if (tree[node].has_max) {
            tree[node].min_val = max(tree[node].min_val, tree[node].max_lazy);
            tree[node].max_val = max(tree[node].max_val, tree[node].max_lazy);
            tree[node].sum = max(tree[node].sum, tree[node].max_lazy * (end - start + 1));
            
            if (start != end) {
                if (!tree[2*node].has_max || tree[2*node].max_lazy < tree[node].max_lazy) {
                    tree[2*node].max_lazy = tree[node].max_lazy;
                    tree[2*node].has_max = true;
                }
                if (!tree[2*node+1].has_max || tree[2*node+1].max_lazy < tree[node].max_lazy) {
                    tree[2*node+1].max_lazy = tree[node].max_lazy;
                    tree[2*node+1].has_max = true;
                }
            }
            tree[node].has_max = false;
        }
        
        if (tree[node].has_add) {
            tree[node].min_val += tree[node].add_lazy;
            tree[node].max_val += tree[node].add_lazy;
            tree[node].sum += tree[node].add_lazy * (end - start + 1);
            
            if (start != end) {
                tree[2*node].add_lazy += tree[node].add_lazy;
                tree[2*node+1].add_lazy += tree[node].add_lazy;
                tree[2*node].has_add = true;
                tree[2*node+1].has_add = true;
            }
            tree[node].has_add = false;
            tree[node].add_lazy = 0;
        }
    }
    
    void update_min(int node, int start, int end, int l, int r, long long val) {
        push_lazy(node, start, end);
        
        if (start > r || end < l || tree[node].max_val <= val) return;
        
        if (start >= l && end <= r && tree[node].min_val > val) {
            tree[node].min_lazy = val;
            tree[node].has_min = true;
            push_lazy(node, start, end);
            return;
        }
        
        int mid = start + (end - start) / 2;
        update_min(2*node, start, mid, l, r, val);
        update_min(2*node+1, mid+1, end, l, r, val);
        
        tree[node].min_val = min(tree[2*node].min_val, tree[2*node+1].min_val);
        tree[node].max_val = max(tree[2*node].max_val, tree[2*node+1].max_val);
        tree[node].sum = tree[2*node].sum + tree[2*node+1].sum;
    }
    
    void update_max(int node, int start, int end, int l, int r, long long val) {
        push_lazy(node, start, end);
        
        if (start > r || end < l || tree[node].min_val >= val) return;
        
        if (start >= l && end <= r && tree[node].max_val < val) {
            tree[node].max_lazy = val;
            tree[node].has_max = true;
            push_lazy(node, start, end);
            return;
        }
        
        int mid = start + (end - start) / 2;
        update_max(2*node, start, mid, l, r, val);
        update_max(2*node+1, mid+1, end, l, r, val);
        
        tree[node].min_val = min(tree[2*node].min_val, tree[2*node+1].min_val);
        tree[node].max_val = max(tree[2*node].max_val, tree[2*node+1].max_val);
        tree[node].sum = tree[2*node].sum + tree[2*node+1].sum;
    }
    
    void update_add(int node, int start, int end, int l, int r, long long val) {
        push_lazy(node, start, end);
        
        if (start > r || end < l) return;
        
        if (start >= l && end <= r) {
            tree[node].add_lazy = val;
            tree[node].has_add = true;
            push_lazy(node, start, end);
            return;
        }
        
        int mid = start + (end - start) / 2;
        update_add(2*node, start, mid, l, r, val);
        update_add(2*node+1, mid+1, end, l, r, val);
        
        tree[node].min_val = min(tree[2*node].min_val, tree[2*node+1].min_val);
        tree[node].max_val = max(tree[2*node].max_val, tree[2*node+1].max_val);
        tree[node].sum = tree[2*node].sum + tree[2*node+1].sum;
    }
    
    vector<long long> query_range(int node, int start, int end, int l, int r) {
        if (start > r || end < l) {
            return {0}; // Return sum = 0 for non-overlapping segments
        }
        
        push_lazy(node, start, end);
        
        if (start >= l && end <= r) {
            vector<long long> result;
            for (int i = start; i <= end; i++) {
                result.push_back(i == start ? tree[node].sum : 0);
            }
            return result;
        }
        
        int mid = start + (end - start) / 2;
        vector<long long> left_vals = query_range(2*node, start, mid, l, r);
        vector<long long> right_vals = query_range(2*node+1, mid+1, end, l, r);
        
        vector<long long> result(left_vals.size() + right_vals.size() - 1);
        for (int i = 0; i < left_vals.size(); i++) {
            result[i] += left_vals[i];
        }
        for (int i = 0; i < right_vals.size(); i++) {
            result[i + left_vals.size() - 1] += right_vals[i];
        }
        
        return result;
    }

    long long query_sum(int node, int start, int end, int l, int r) {
        if (start > r || end < l) {
            return 0;
        }
        
        push_lazy(node, start, end);
        
        if (start >= l && end <= r) {
            return tree[node].sum;
        }
        
        int mid = start + (end - start) / 2;
        return query_sum(2*node, start, mid, l, r) + query_sum(2*node+1, mid+1, end, l, r);
    }

public:
    SegmentTree(vector<long long>& a, int size) : arr(a), n(size) {
        tree.resize(4*n);
    }
    
    void build(int k) {
        build(1, 0, n-1, k);
    }
    
    void update_min(int l, int r, long long val) {
        update_min(1, 0, n-1, l-1, r-1, val);
    }
    
    void update_max(int l, int r, long long val) {
        update_max(1, 0, n-1, l-1, r-1, val);
    }
    
    void update_add(int l, int r, long long val) {
        update_add(1, 0, n-1, l-1, r-1, val);
    }
    
    vector<long long> get_values(int l, int r) {
        return query_range(1, 0, n-1, l-1, r-1);
    }

    long long get_sum(int l, int r) {
        return query_sum(1, 0, n-1, l-1, r-1);
    }
};

int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(nullptr);
    
    int n, q;
    cin >> n >> q;
    
    vector<long long> a1(n), a2(n);
    
    for (int i = 0; i < n; i++) {
        cin >> a1[i];
    }
    for (int i = 0; i < n; i++) {
        cin >> a2[i];
    }
    
    SegmentTree st1(a1, n);
    SegmentTree st2(a2, n);
    
    st1.build(1);
    st2.build(2);
    
    while (q--) {
        int type;
        cin >> type;
        
        if (type == 1) {
            int k, l, r, x;
            cin >> k >> l >> r >> x;
            if (k == 1) {
                st1.update_min(l, r, x);
            } else {
                st2.update_min(l, r, x);
            }
        } else if (type == 2) {
            int k, l, r, x;
            cin >> k >> l >> r >> x;
            if (k == 1) {
                st1.update_max(l, r, x);
            } else {
                st2.update_max(l, r, x);
            }
        } else if (type == 3) {
            int k, l, r, x;
            cin >> k >> l >> r >> x;
            if (k == 1) {
                st1.update_add(l, r, x);
            } else {
                st2.update_add(l, r, x);
            }
        } else {
            int l, r;
            cin >> l >> r;
            
            long long result = 0;
            
            // For each position in range [l, r], calculate Fibonacci of sum
            for (int i = l; i <= r; i++) {
                long long val1 = st1.get_sum(i, i);
                long long val2 = st2.get_sum(i, i);
                long long fib_val = getFib(val1 + val2);
                result = (result + fib_val) % MOD;
            }
            
            cout << result << "\n";
        }
    }
    
    return 0;
}