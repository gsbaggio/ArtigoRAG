MOD = 10**9 + 7
MAX_FIB = 2 * 10**6

# Precompute Fibonacci numbers modulo MOD
fib = [0] * (MAX_FIB + 1)
fib[1] = 1
for i in range(2, MAX_FIB + 1):
    fib[i] = (fib[i - 1] + fib[i - 2]) % MOD

class SegmentTree:
    def __init__(self, n):
        self.n = n
        self.tree = [0] * (4 * n)
        self.lazy_add = [0] * (4 * n)
        self.lazy_min = [float('inf')] * (4 * n)
        self.lazy_max = [-float('inf')] * (4 * n)

    def _apply_lazy(self, node, start, end):
        if self.lazy_min[node] != float('inf'):
            self.tree[node] = min(self.tree[node], self.lazy_min[node])
            if start != end:
                self.lazy_min[node * 2] = min(self.lazy_min[node * 2], self.lazy_min[node])
                self.lazy_min[node * 2 + 1] = min(self.lazy_min[node * 2 + 1], self.lazy_min[node])
            self.lazy_min[node] = float('inf')

        if self.lazy_max[node] != -float('inf'):
            self.tree[node] = max(self.tree[node], self.lazy_max[node])
            if start != end:
                self.lazy_max[node * 2] = max(self.lazy_max[node * 2], self.lazy_max[node])
                self.lazy_max[node * 2 + 1] = max(self.lazy_max[node * 2 + 1], self.lazy_max[node])
            self.lazy_max[node] = -float('inf')

        if self.lazy_add[node] != 0:
            self.tree[node] += self.lazy_add[node]
            if start != end:
                self.lazy_add[node * 2] += self.lazy_add[node]
                self.lazy_add[node * 2 + 1] += self.lazy_add[node]
            self.lazy_add[node] = 0

    def _update(self, node, start, end, l, r, val, op):
        self._apply_lazy(node, start, end)
        if start > r or end < l:
            return
        if start >= l and end <= r:
            if op == "add":
                self.lazy_add[node] += val
            elif op == "min":
                self.lazy_min[node] = val
            elif op == "max":
                self.lazy_max[node] = val
            self._apply_lazy(node, start, end)
            return
        mid = (start + end) // 2
        self._update(node * 2, start, mid, l, r, val, op)
        self._update(node * 2 + 1, mid + 1, end, l, r, val, op)
        self.tree[node] = self.tree[node * 2] + self.tree[node * 2 + 1]

    def _query(self, node, start, end, l, r):
        self._apply_lazy(node, start, end)
        if start > r or end < l:
            return 0
        if start >= l and end <= r:
            return self.tree[node]
        mid = (start + end) // 2
        left_sum = self._query(node * 2, start, mid, l, r)
        right_sum = self._query(node * 2 + 1, mid + 1, end, l, r)
        return left_sum + right_sum

    def update(self, l, r, val, op):
        self._update(1, 0, self.n - 1, l, r, val, op)

    def query(self, l, r):
        return self._query(1, 0, self.n - 1, l, r)

# Main function to process queries
def process_queries(N, Q, A1, A2, queries):
    segtree1 = SegmentTree(N)
    segtree2 = SegmentTree(N)

    # Initialize segment trees
    for i in range(N):
        segtree1.update(i, i, A1[i], "add")
        segtree2.update(i, i, A2[i], "add")

    results = []
    for query in queries:
        if query[0] == 1:
            _, k, l, r, x = query
            if k == 1:
                segtree1.update(l - 1, r - 1, x, "min")
            else:
                segtree2.update(l - 1, r - 1, x, "min")
        elif query[0] == 2:
            _, k, l, r, x = query
            if k == 1:
                segtree1.update(l - 1, r - 1, x, "max")
            else:
                segtree2.update(l - 1, r - 1, x, "max")
        elif query[0] == 3:
            _, k, l, r, x = query
            if k == 1:
                segtree1.update(l - 1, r - 1, x, "add")
            else:
                segtree2.update(l - 1, r - 1, x, "add")
        elif query[0] == 4:
            _, l, r = query
            l, r = l - 1, r - 1
            sum_fib = 0
            for i in range(l, r + 1):
                val1 = segtree1.query(i, i)
                val2 = segtree2.query(i, i)
                sum_fib = (sum_fib + fib[val1 + val2]) % MOD
            results.append(sum_fib)

    return results

# Example usage
N, Q = 3, 4
A1 = [1, 0, 2]
A2 = [2, 1, 0]
queries = [
    [4, 1, 3],
    [3, 2, 2, 3],
    [1, 1, 1, 3, 0],
    [4, 1, 3]
]
print(process_queries(N, Q, A1, A2, queries))  # Output: [4, 4]