CURRENT QUESTION:
Mr. Chanek has an integer represented by a string s. Zero or more digits have been erased and are denoted by the character _. There are also zero or more digits marked by the character X, meaning they're the same digit.

Mr. Chanek wants to count the number of possible integer s, where s is divisible by 25. Of course, s must not contain any leading zero. He can replace the character _ with any digit. He can also replace the character X with any digit, but it must be the same for every character X.

As a note, a leading zero is any 0 digit that comes before the first nonzero digit in a number string in positional notation. For example, 0025 has two leading zeroes. An exception is the integer zero, (0 has no leading zero, but 0000 has three leading zeroes).

Input

One line containing the string s (1 ≤ |s| ≤ 8). The string s consists of the characters 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, _, and X.

Output

Output an integer denoting the number of possible integer s.

Examples

Input


25


Output


1


Input


_00


Output


9


Input


_XX


Output


9


Input


0


Output


1


Input


0_25


Output


0

Note

In the first example, the only possible s is 25.

In the second and third example, s ∈ \{100, 200,300,400,500,600,700,800,900\}.

In the fifth example, all possible s will have at least one leading zero.

EXAMPLE QUESTIONS:
Example question 1:
Name: p01884 Similarity of Subtrees
Tags: ['']
Description: Example

Input

5
1 2
1 3
1 4
1 5


Output

6
Difficulty: 0
Solutions: #include <cmath>
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>
#include <deque>
#include <queue>
#include <map>
#include <stack>
#include <vector>
using namespace std;
 
 
const int mod=1e9+7;
const int maxn=1e6+10;
#define _int64 unsigned long long
 
map<_int64,_int64> mp;
vector<int> g[maxn];
 
_int64 d[maxn];


_int64 ans;

int n; 

 
void dfs(int u,int fa){
    d[u]=1;
    for(int i=0;i<g[u].size();++i)
	{
        int v=g[u][i];
        if(v==fa)continue;
        dfs(v,u);
        d[u]+=d[v]*mod;
    }
    mp[d[u]]++;
}
 
 

int main()
{
	while(~scanf("%d",&n))
    {
    	
    	for(int i=0; i<=n; i++)
            g[i].clear();
        mp.clear();
        ans=0;
        for(int i=1;i<n;i++)
		{
            int u,v;
			scanf("%d%d",&u,&v);
            g[u].push_back(v);
			g[v].push_back(u);
        }
      
        dfs(1,0);
        for(map<_int64,_int64>::iterator it=mp.begin(); it!=mp.end(); it++)
            ans+=(_int64)it->second*(it->second-1)/2;
        cout<<ans<<endl;
    }
    return 0; 
}



INSTRUCTIONS:
Solve the current question.
Provide:
1. A complete and efficient code solution, optimized for both time and space complexity.
2. A detailed explanation of the solution, including:
   - The intuition behind the approach;
   - Time and space complexity;
   - Important considerations about the algorithm.
3. You can use the example questions as general references for coding patterns and structure, but solve the current problem independently.
4. Don't use any external libraries. Any language is accepted.