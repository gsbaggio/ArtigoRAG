CURRENT QUESTION:
Integers from 1 to n (inclusive) were sorted lexicographically (considering integers as strings). As a result, array a_1, a_2, ..., a_n was obtained.

Calculate value of (∑_{i = 1}^n ((i - a_i) mod 998244353)) mod 10^9 + 7.

x mod y here means the remainder after division x by y. This remainder is always non-negative and doesn't exceed y - 1. For example, 5 mod 3 = 2, (-1) mod 6 = 5. 

Input

The first line contains the single integer n (1 ≤ n ≤ 10^{12}).

Output

Print one integer — the required sum.

Examples

Input


3


Output


0


Input


12


Output


994733045


Input


21


Output


978932159


Input


1000000000000


Output


289817887

Note

A string a is lexicographically smaller than a string b if and only if one of the following holds:

  * a is a prefix of b, but a ≠ b; 
  * in the first position where a and b differ, the string a has a letter that appears earlier in the alphabet than the corresponding letter in b. 



For example, 42 is lexicographically smaller than 6, because they differ in the first digit, and 4 < 6; 42 < 420, because 42 is a prefix of 420.

Let's denote 998244353 as M.

In the first example, array a is equal to [1, 2, 3]. 

  * (1 - 1) mod M = 0 mod M = 0 
  * (2 - 2) mod M = 0 mod M = 0 
  * (3 - 3) mod M = 0 mod M = 0 



As a result, (0 + 0 + 0) mod 10^9 + 7 = 0

In the second example, array a is equal to [1, 10, 11, 12, 2, 3, 4, 5, 6, 7, 8, 9]. 

  * (1 - 1) mod M = 0 mod M = 0 
  * (2 - 10) mod M = (-8) mod M = 998244345 
  * (3 - 11) mod M = (-8) mod M = 998244345 
  * (4 - 12) mod M = (-8) mod M = 998244345 
  * (5 - 2) mod M = 3 mod M = 3 
  * (6 - 3) mod M = 3 mod M = 3 
  * (7 - 4) mod M = 3 mod M = 3 
  * (8 - 5) mod M = 3 mod M = 3 
  * (9 - 6) mod M = 3 mod M = 3 
  * (10 - 7) mod M = 3 mod M = 3 
  * (11 - 8) mod M = 3 mod M = 3 
  * (12 - 9) mod M = 3 mod M = 3 



As a result, (0 + 998244345 + 998244345 + 998244345 + 3 + 3 + 3 + 3 + 3 + 3 + 3 + 3) mod 10^9 + 7 = 2994733059 mod 10^9 + 7 = 994733045

EXAMPLE QUESTIONS:
Example question 1:
Name: 1368_D. AND, OR and square sum
Tags: ['bitmasks', 'greedy', 'math']
Description: Gottfried learned about binary number representation. He then came up with this task and presented it to you.

You are given a collection of n non-negative integers a_1, …, a_n. You are allowed to perform the following operation: choose two distinct indices 1 ≤ i, j ≤ n. If before the operation a_i = x, a_j = y, then after the operation a_i = x~AND~y, a_j = x~OR~y, where AND and OR are bitwise AND and OR respectively (refer to the Notes section for formal description). The operation may be performed any number of times (possibly zero).

After all operations are done, compute ∑_{i=1}^n a_i^2 — the sum of squares of all a_i. What is the largest sum of squares you can achieve?

Input

The first line contains a single integer n (1 ≤ n ≤ 2 ⋅ 10^5).

The second line contains n integers a_1, …, a_n (0 ≤ a_i < 2^{20}).

Output

Print a single integer — the largest possible sum of squares that can be achieved after several (possibly zero) operations.

Examples

Input


1
123


Output


15129


Input


3
1 3 5


Output


51


Input


2
349525 699050


Output


1099509530625

Note

In the first sample no operation can be made, thus the answer is 123^2.

In the second sample we can obtain the collection 1, 1, 7, and 1^2 + 1^2 + 7^2 = 51.

If x and y are represented in binary with equal number of bits (possibly with leading zeros), then each bit of x~AND~y is set to 1 if and only if both corresponding bits of x and y are set to 1. Similarly, each bit of x~OR~y is set to 1 if and only if at least one of the corresponding bits of x and y are set to 1. For example, x = 3 and y = 5 are represented as 011_2 and 101_2 (highest bit first). Then, x~AND~y = 001_2 = 1, and x~OR~y = 111_2 = 7.
Difficulty: 10
Solutions: from sys import stdin
input = stdin.readline
n = int(input())
a = [*map(lambda x: bin(int(x))[:1:-1], input().split())]
c1 = len(max(a, key=len))
a = [x + '0' * (c1 - len(x)) for x in a]
b = [sum(c[i] == '1' for c in a) for i in range(c1)]
c2 = max(b)
ans = 0
for i in range(c2):
	num = ''
	for i in range(c1):
		if b[i] != 0:
			b[i] -= 1
			num += '1'
		else:
			num += '0'
	ans += int(num[::-1], 2) ** 2
print(ans)


INSTRUCTIONS:
Solve the current question.
Provide:
1. A complete and efficient code solution, optimized for both time and space complexity.
2. A detailed explanation of the solution, including:
   - The intuition behind the approach;
   - Time and space complexity;
   - Important considerations about the algorithm.
3. If the language has classes, implement in 'Solution' class. Any language is accepted.
4. You can use the example questions as general references for coding patterns and structure, but solve the current problem independently.
5. Don't use any external libraries. Don't need to import any libraries.
