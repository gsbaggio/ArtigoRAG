CURRENT QUESTION:
Luntik came out for a morning stroll and found an array a of length n. He calculated the sum s of the elements of the array (s= ∑_{i=1}^{n} a_i). Luntik calls a subsequence of the array a nearly full if the sum of the numbers in that subsequence is equal to s-1.

Luntik really wants to know the number of nearly full subsequences of the array a. But he needs to come home so he asks you to solve that problem!

A sequence x is a subsequence of a sequence y if x can be obtained from y by deletion of several (possibly, zero or all) elements.

Input

The first line contains a single integer t (1 ≤ t ≤ 1000) — the number of test cases. The next 2 ⋅ t lines contain descriptions of test cases. The description of each test case consists of two lines.

The first line of each test case contains a single integer n (1 ≤ n ≤ 60) — the length of the array.

The second line contains n integers a_1, a_2, …, a_n (0 ≤ a_i ≤ 10^9) — the elements of the array a.

Output

For each test case print the number of nearly full subsequences of the array.

Example

Input


5
5
1 2 3 4 5
2
1000 1000
2
1 0
5
3 0 2 1 1
5
2 1 0 3 0


Output


1
0
2
4
4

Note

In the first test case, s=1+2+3+4+5=15, only (2,3,4,5) is a nearly full subsequence among all subsequences, the sum in it is equal to 2+3+4+5=14=15-1.

In the second test case, there are no nearly full subsequences.

In the third test case, s=1+0=1, the nearly full subsequences are (0) and () (the sum of an empty subsequence is 0).

EXAMPLE QUESTIONS:
Example question 1:
Name: 1312_G. Autocompletion
Tags: ['data structures', 'dfs and similar', 'dp']
Description: You are given a set of strings S. Each string consists of lowercase Latin letters.

For each string in this set, you want to calculate the minimum number of seconds required to type this string. To type a string, you have to start with an empty string and transform it into the string you want to type using the following actions:

  * if the current string is t, choose some lowercase Latin letter c and append it to the back of t, so the current string becomes t + c. This action takes 1 second; 
  * use autocompletion. When you try to autocomplete the current string t, a list of all strings s ∈ S such that t is a prefix of s is shown to you. This list includes t itself, if t is a string from S, and the strings are ordered lexicographically. You can transform t into the i-th string from this list in i seconds. Note that you may choose any string from this list you want, it is not necessarily the string you are trying to type. 



What is the minimum number of seconds that you have to spend to type each string from S?

Note that the strings from S are given in an unusual way.

Input

The first line contains one integer n (1 ≤ n ≤ 10^6).

Then n lines follow, the i-th line contains one integer p_i (0 ≤ p_i < i) and one lowercase Latin character c_i. These lines form some set of strings such that S is its subset as follows: there are n + 1 strings, numbered from 0 to n; the 0-th string is an empty string, and the i-th string (i ≥ 1) is the result of appending the character c_i to the string p_i. It is guaranteed that all these strings are distinct.

The next line contains one integer k (1 ≤ k ≤ n) — the number of strings in S.

The last line contains k integers a_1, a_2, ..., a_k (1 ≤ a_i ≤ n, all a_i are pairwise distinct) denoting the indices of the strings generated by above-mentioned process that form the set S — formally, if we denote the i-th generated string as s_i, then S = {s_{a_1}, s_{a_2}, ..., s_{a_k}}.

Output

Print k integers, the i-th of them should be equal to the minimum number of seconds required to type the string s_{a_i}.

Examples

Input


10
0 i
1 q
2 g
0 k
1 e
5 r
4 m
5 h
3 p
3 e
5
8 9 1 10 6


Output


2 4 1 3 3 


Input


8
0 a
1 b
2 a
2 b
4 a
4 b
5 c
6 d
5
2 3 4 7 8


Output


1 2 2 4 4 

Note

In the first example, S consists of the following strings: ieh, iqgp, i, iqge, ier.
Difficulty: 13
Solutions: #include <bits/stdc++.h>
using namespace std;
int n, k, a[1000001], f[1000001], g[1000001], sz[1000001], fa;
vector<pair<char, int>> d[1000001];
char ch;
void dfs(int x, int pre) {
  f[x] = f[pre] + 1;
  g[x] = min(f[x], g[pre] + sz[pre]);
  if (sz[x]) f[x] = min(f[x], g[x] + 1);
  sort(d[x].begin(), d[x].end());
  for (auto nxt : d[x]) dfs(nxt.second, x), sz[x] += sz[nxt.second];
}
int main() {
  scanf("%d", &n);
  for (int i = 1; i <= n; i++) {
    scanf("%d %c", &fa, &ch);
    d[fa].push_back(make_pair(ch, i));
  }
  scanf("%d", &k);
  for (int i = 1; i <= k; i++) scanf("%d", &a[i]), sz[a[i]] = 1;
  f[0] = -1, dfs(0, 0);
  for (int i = 1; i <= k; i++) printf("%d%c", f[a[i]], i < k ? ' ' : '\n');
  return 0;
}



INSTRUCTIONS:
Solve the current question.
Provide:
1. A complete and efficient code solution, optimized for both time and space complexity.
2. A detailed explanation of the solution, including:
   - The intuition behind the approach;
   - Time and space complexity;
   - Important considerations about the algorithm.
3. You can use the example questions as general references for coding patterns and structure, but solve the current problem independently.
4. Don't use any external libraries. Any language is accepted.