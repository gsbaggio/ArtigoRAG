def count_desert_pairs(n, m, edges):
    answer = 0
    
    for L in range(1, m + 1):
        # Initialize disjoint set data structure
        parent = list(range(n + 1))
        size = [1] * (n + 1)  # Size of each component
        edge_count = [0] * (n + 1)  # Number of edges in each component
        
        def find(x):
            if parent[x] != x:
                parent[x] = find(parent[x])
            return parent[x]
        
        def union(u, v):
            root_u = find(u)
            root_v = find(v)
            
            if root_u != root_v:
                # Ensure root_u is the larger component
                if size[root_u] < size[root_v]:
                    root_u, root_v = root_v, root_u
                
                # Merge components
                parent[root_v] = root_u
                size[root_u] += size[root_v]
                edge_count[root_u] += edge_count[root_v] + 1
                
                # Check if the merged component is still a cactus
                return edge_count[root_u] <= size[root_u]
            else:
                # Adding an edge within the same component creates a cycle
                edge_count[root_u] += 1
                return edge_count[root_u] <= size[root_u]
        
        is_desert = True
        
        for R in range(L, m + 1):
            u, v = edges[R-1]
            
            if not union(u, v):
                is_desert = False
                break
            
            if is_desert:
                answer += 1
    
    return answer

# Read input
n, m = map(int, input().split())
edges = []
for _ in range(m):
    u, v = map(int, input().split())
    edges.append((u, v))

print(count_desert_pairs(n, m, edges))