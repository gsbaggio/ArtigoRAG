CURRENT QUESTION:
Theofanis has a string s_1 s_2 ... s_n and a character c. He wants to make all characters of the string equal to c using the minimum number of operations.

In one operation he can choose a number x (1 ≤ x ≤ n) and for every position i, where i is not divisible by x, replace s_i with c. 

Find the minimum number of operations required to make all the characters equal to c and the x-s that he should use in his operations.

Input

The first line contains a single integer t (1 ≤ t ≤ 10^4) — the number of test cases.

The first line of each test case contains the integer n (3 ≤ n ≤ 3 ⋅ 10^5) and a lowercase Latin letter c — the length of the string s and the character the resulting string should consist of.

The second line of each test case contains a string s of lowercase Latin letters — the initial string.

It is guaranteed that the sum of n over all test cases does not exceed 3 ⋅ 10^5.

Output

For each test case, firstly print one integer m — the minimum number of operations required to make all the characters equal to c.

Next, print m integers x_1, x_2, ..., x_m (1 ≤ x_j ≤ n) — the x-s that should be used in the order they are given.

It can be proved that under given constraints, an answer always exists. If there are multiple answers, print any.

Example

Input


3
4 a
aaaa
4 a
baaa
4 b
bzyx


Output


0
1
2
2 
2 3

Note

Let's describe what happens in the third test case: 

  1. x_1 = 2: we choose all positions that are not divisible by 2 and replace them, i. e. bzyx → bzbx; 
  2. x_2 = 3: we choose all positions that are not divisible by 3 and replace them, i. e. bzbx → bbbb. 

EXAMPLE QUESTIONS:
Example question 1:
Name: cookfood
Tags: []
Description: As you might know, cooking is the process of taking a food item and subjecting it to various processes(like heating, roasting, baking etc).
A food item gets prepared after it has been subjected to exactly N processes.
The order in which the processes are applied matters(heating and then baking is different from baking and then heating). Also, the same processes cannot be aplied twice in succession. For example, heating → baking → heating is allowed, but heating → heating → baking is not allowed because 'heating' comes twice in succession.

Any given sequence A1, A2, A3, ... AN of N processes can be used to cook a food item if and only if Ai ≠ Ai+1 for all 1 ≤ i ≤ N-1.

The chefs kitchen has got K equipments for K different processes.

Chef has to cook two dishes in parallel.
This means that if the first dish is prepared by applying processes A1, A2, A3, ... AN in this order, and the second dish made by processes B1, B2, B3, ... BN, then Ai ≠ Bi for any 1 ≤ i ≤ N, because otherwise chef would need two equipments for the process Ai.

Needless to say, 1 ≤ Ai, Bi ≤ K, no two consecutive elements of A are same, and no two consecutive elements of B are same.

Given N, K your task is to find the number of ways in which in which he can prepare the two dishes. Since the number of ways can be very huge,  you have to report it modulo 1000000007.

 Input Description
The first line of the input contains an integer T denoting the number of test cases. The description of T test cases follows.
Each test case is described by line containing two space separated integers, N and K as per the problem description.

 Output Description 
For each Test case, output a separate line containing the answer modulo 1000000007.

Sample Input
3
2 2
2 3
1 3

Sample Output
2
18
6

Explanation
For first test case, there are two ways:
a) A = {1, 2} and B = {2, 1} and b) A = {2, 1} and B = {1,2}.

For third test case, A and B are of length 1. A0 can take three different values and for each value of A0, B0 can take any of the other two values.

Constraints

T ≤ 100 
1 ≤ N, K ≤ 10^9


Subtask 1 (30 points): 
N, K ≤ 5

Subtask 2 (20 points):
N, K ≤ 10000
the answer(without taking modulo 1000000007) will be at most 10^4.

Subtask 3 (25 points): 
N, K ≤ 10000

Subtask 4 (25 points): 
No special constraints
Difficulty: 3
Solutions: from sys import stdin
 
MOD = 1000000007
 
for trial in xrange(int(stdin.readline())):
    N,K = map(int,stdin.readline().split())
    Kmod = K%MOD
    K1mod=(K-1)%MOD
    K2mod=(K-2)%MOD
    if K==1: print 0
    elif K==2: print 2
    else:
        inner = ((Kmod*K1mod*K1mod)%MOD + (Kmod*K1mod*K2mod*K2mod)%MOD)%MOD
        if N==1: print (K*(K-1))%MOD
        elif N==2: print inner
        else: print ((inner)*pow(K**2-3*K+3,N-2,MOD))%MOD

Example question 2:
Name: p00109 Smart Calculator
Tags: ['']
Description: Your task is to write a program which reads an expression and evaluates it.

* The expression consists of numerical values, operators and parentheses, and the ends with '='.
* The operators includes +, - , *, / where respectively represents, addition, subtraction, multiplication and division.
* Precedence of the operators is based on usual laws. That is one should perform all multiplication and division first, then addition and subtraction. When two operators have the same precedence, they are applied from left to right.
* You may assume that there is no division by zero.
* All calculation is performed as integers, and after the decimal point should be truncated
* Length of the expression will not exceed 100.
* -1 × 109 ≤ intermediate results of computation ≤ 109



Input

The input is a sequence of datasets. The first line contains an integer n which represents the number of datasets. There will be n lines where each line contains an expression.

Output

For each datasets, prints the result of calculation.

Example

Input

2
4-2*3=
4*(8+4+3)=


Output

-2
60
Difficulty: 0
Solutions: #include <string>
#include <iostream>
using namespace std;

/*
  <expr>   ::= <term> [ ('+'|'-') <term> ]*
  <term>   ::= <factor> [ ('*'|'/') <factor> ]*
  <factor> ::= <number> | '(' <expr> ')'
  <number> :== 1?????\????????°???
*/

int expr(string& s, int& i);
int term(string& s, int& i);
int factor(string& s, int& i);
int number(string& s, int& i);

int expr(string& s, int& i) {
  int val = term(s, i);
  while (s[i] == '+' || s[i] == '-') {
    char op = s[i];
    i++;
    int val2 = term(s, i);
    if (op == '+')
      val += val2;
    else
      val -= val2;
  }
  return val;
}

int term(string& s, int& i) {
  int val = factor(s, i);
  while (s[i] == '*' || s[i] == '/') {
    char op = s[i];
    i++;
    int val2 = factor(s, i);
    if (op == '*')
      val *= val2;
    else
      val /= val2;
  }
  return val;
}

int factor(string& s, int& i) {
  int val;
  if (s[i] != '(') {
    val = number(s, i);
  } else {
    i++;
    val = expr(s, i);
    i++;
  }
  return val;
}

int number(string& s, int& i) {
  int val = 0;
  while(isdigit(s[i])) {
    val = val*10 + (s[i] - '0');
    i++;
  }
  return val;
}

int main() {
  int n;
  cin >> n;
  for (int j=0; j<n; j++) {
    int i = 0;
    string str;
    cin >> str;
    cout << expr(str, i) << endl;
  }
}


INSTRUCTIONS:
Solve the current question.
Provide:
1. A complete and efficient code solution, optimized for both time and space complexity.
2. A detailed explanation of the solution, including:
   - The intuition behind the approach;
   - Time and space complexity;
   - Important considerations about the algorithm.
3. You can use the example questions as general references for coding patterns and structure, but solve the current problem independently.
4. Don't use any external libraries. Any language is accepted.