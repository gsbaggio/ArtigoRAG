CURRENT QUESTION:
Theofanis has a string s_1 s_2 ... s_n and a character c. He wants to make all characters of the string equal to c using the minimum number of operations.

In one operation he can choose a number x (1 ≤ x ≤ n) and for every position i, where i is not divisible by x, replace s_i with c. 

Find the minimum number of operations required to make all the characters equal to c and the x-s that he should use in his operations.

Input

The first line contains a single integer t (1 ≤ t ≤ 10^4) — the number of test cases.

The first line of each test case contains the integer n (3 ≤ n ≤ 3 ⋅ 10^5) and a lowercase Latin letter c — the length of the string s and the character the resulting string should consist of.

The second line of each test case contains a string s of lowercase Latin letters — the initial string.

It is guaranteed that the sum of n over all test cases does not exceed 3 ⋅ 10^5.

Output

For each test case, firstly print one integer m — the minimum number of operations required to make all the characters equal to c.

Next, print m integers x_1, x_2, ..., x_m (1 ≤ x_j ≤ n) — the x-s that should be used in the order they are given.

It can be proved that under given constraints, an answer always exists. If there are multiple answers, print any.

Example

Input


3
4 a
aaaa
4 a
baaa
4 b
bzyx


Output


0
1
2
2 
2 3

Note

Let's describe what happens in the third test case: 

  1. x_1 = 2: we choose all positions that are not divisible by 2 and replace them, i. e. bzyx → bzbx; 
  2. x_2 = 3: we choose all positions that are not divisible by 3 and replace them, i. e. bzbx → bbbb. 

EXAMPLE QUESTIONS:
Example question 1:
Name: 1167_B. Lost Numbers
Tags: ['brute force', 'divide and conquer', 'interactive', 'math']
Description: This is an interactive problem. Remember to flush your output while communicating with the testing program. You may use fflush(stdout) in C++, system.out.flush() in Java, stdout.flush() in Python or flush(output) in Pascal to flush the output. If you use some other programming language, consult its documentation. You may also refer to the guide on interactive problems: <https://codeforces.com/blog/entry/45307>.

The jury guessed some array a consisting of 6 integers. There are 6 special numbers — 4, 8, 15, 16, 23, 42 — and each of these numbers occurs in a exactly once (so, a is some permutation of these numbers).

You don't know anything about their order, but you are allowed to ask up to 4 queries. In each query, you may choose two indices i and j (1 ≤ i, j ≤ 6, i and j are not necessarily distinct), and you will get the value of a_i ⋅ a_j in return.

Can you guess the array a?

The array a is fixed beforehand in each test, the interaction program doesn't try to adapt to your queries.

Interaction

Before submitting the answer, you may ask up to 4 queries. To ask a query, print one line in the following format: ? i j, where i and j should be two integers such that 1 ≤ i, j ≤ 6. The line should be ended with a line break character. After submitting a query, flush the output and read the answer to your query — one line containing one integer a_i ⋅ a_j. If you submit an incorrect query (or ask more than 4 queries), the answer to it will be one string 0. After receiving such an answer, your program should terminate immediately — otherwise you may receive verdict "Runtime error", "Time limit exceeded" or some other verdict instead of "Wrong answer".

To give the answer, your program should print one line ! a_1 a_2 a_3 a_4 a_5 a_6 with a line break in the end. After that, it should flush the output and terminate gracefully.

Example

Input


16
64
345
672

Output


? 1 1
? 2 2
? 3 5
? 4 6
! 4 8 15 16 23 42

Note

If you want to submit a hack for this problem, your test should contain exactly six space-separated integers a_1, a_2, ..., a_6. Each of 6 special numbers should occur exactly once in the test. The test should be ended with a line break character.
Difficulty: 8
Solutions: import java.util.*;
import java.io.*;
import java.text.*;

public class E1207 {

	public static void main(String[] args) throws IOException {
		Scanner sc = new Scanner(System.in);
		PrintWriter pw = new PrintWriter(System.out);
		int[] arr = new int[100];
		for (int i = 0; i < 100; i++) {
			arr[i] = (i + 1) << 7;
		}
		int[] arr2 = new int[100];
		for (int i = 0; i < arr2.length; i++) {
			arr2[i] = i;
		}
		pw.print("? ");
		for (int i = 0; i < arr2.length; i++) {
			pw.print(arr2[i] + " ");
		}
		pw.flush();
		int ans = sc.nextInt();
		if (ans == -1)
			return;

		pw.print("? ");
		for (int i = 0; i < arr.length; i++) {
			pw.print(arr[i] + " ");
		}
		pw.flush();
		int ans2 = sc.nextInt();
		if (ans2 == -1)
			return;
		int a = 0;
		for (int i = 0; i < 7; i++) {
			if ((ans2 & (1 << i)) != 0)
				a |= (1 << i);
		}
		for(int i = 7;i<15;i++) {
			if ((ans & (1 << i)) != 0)
				a |= (1 << i);
		}
		pw.print("! ");
		pw.println(a);
		pw.flush();
		
	}

	static class Scanner {
		StringTokenizer st;
		BufferedReader br;

		public Scanner(InputStream s) {
			br = new BufferedReader(new InputStreamReader(s));
		}

		public Scanner(FileReader r) {
			br = new BufferedReader(r);
		}

		public String next() throws IOException {
			while (st == null || !st.hasMoreTokens())
				st = new StringTokenizer(br.readLine());
			return st.nextToken();
		}

		public int nextInt() throws IOException {
			return Integer.parseInt(next());
		}

		public long nextLong() throws IOException {
			return Long.parseLong(next());
		}

		public String nextLine() throws IOException {
			return br.readLine();
		}

		public double nextDouble() throws IOException {
			String x = next();
			StringBuilder sb = new StringBuilder("0");
			double res = 0, f = 1;
			boolean dec = false, neg = false;
			int start = 0;
			if (x.charAt(0) == '-') {
				neg = true;
				start++;
			}
			for (int i = start; i < x.length(); i++)
				if (x.charAt(i) == '.') {
					res = Long.parseLong(sb.toString());
					sb = new StringBuilder("0");
					dec = true;
				} else {
					sb.append(x.charAt(i));
					if (dec)
						f *= 10;
				}
			res += Long.parseLong(sb.toString()) / f;
			return res * (neg ? -1 : 1);
		}

		public boolean ready() throws IOException {
			return br.ready();
		}

	}
}


Example question 2:
Name: 791_A. Bear and Big Brother
Tags: ['implementation']
Description: Bear Limak wants to become the largest of bears, or at least to become larger than his brother Bob.

Right now, Limak and Bob weigh a and b respectively. It's guaranteed that Limak's weight is smaller than or equal to his brother's weight.

Limak eats a lot and his weight is tripled after every year, while Bob's weight is doubled after every year.

After how many full years will Limak become strictly larger (strictly heavier) than Bob?

Input

The only line of the input contains two integers a and b (1 ≤ a ≤ b ≤ 10) — the weight of Limak and the weight of Bob respectively.

Output

Print one integer, denoting the integer number of years after which Limak will become strictly larger than Bob.

Examples

Input

4 7


Output

2


Input

4 9


Output

3


Input

1 1


Output

1

Note

In the first sample, Limak weighs 4 and Bob weighs 7 initially. After one year their weights are 4·3 = 12 and 7·2 = 14 respectively (one weight is tripled while the other one is doubled). Limak isn't larger than Bob yet. After the second year weights are 36 and 28, so the first weight is greater than the second one. Limak became larger than Bob after two years so you should print 2.

In the second sample, Limak's and Bob's weights in next years are: 12 and 18, then 36 and 36, and finally 108 and 72 (after three years). The answer is 3. Remember that Limak wants to be larger than Bob and he won't be satisfied with equal weights.

In the third sample, Limak becomes larger than Bob after the first year. Their weights will be 3 and 2 then.
Difficulty: 7
Solutions: #include <bits/stdc++.h>
using namespace std;
int a, b;
int y = 0;
int main() {
  cin >> a >> b;
  while (a <= b) {
    a = a * 3;
    b = b * 2;
    y++;
  }
  cout << y;
  return 0;
}



INSTRUCTIONS:
Solve the current question.
Provide:
1. A complete and efficient code solution, optimized for both time and space complexity.
2. A detailed explanation of the solution, including:
   - The intuition behind the approach;
   - Time and space complexity;
   - Important considerations about the algorithm.
3. If the language has classes, implement in 'Solution' class. Any language is accepted.
4. You can use the example questions as general references for coding patterns and structure, but solve the current problem independently.
5. Don't use any external libraries. Don't need to import any libraries.
