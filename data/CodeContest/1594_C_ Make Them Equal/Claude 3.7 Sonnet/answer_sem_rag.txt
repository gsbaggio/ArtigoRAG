def solve():
    t = int(input())
    
    for _ in range(t):
        n, c = input().split()
        n = int(n)
        s = input()
        
        # Check if all characters are already equal to c
        if all(char == c for char in s):
            print(0)
            continue
        
        # Find positions that need to be changed (1-indexed)
        need_change = [i+1 for i in range(n) if s[i] != c]
        
        operations = []
        while need_change:
            # Try to find an optimal x
            best_x = -1
            min_remaining = len(need_change)
            
            for x in range(1, n+1):
                # Count how many positions would still need changing after using x
                remaining = sum(1 for pos in need_change if pos % x == 0)
                
                # If this is better than our current best, update
                if remaining < min_remaining:
                    min_remaining = remaining
                    best_x = x
            
            # Add the best operation to our list
            operations.append(best_x)
            
            # Update positions that still need changing
            need_change = [pos for pos in need_change if pos % best_x == 0]
        
        # Output the result
        print(len(operations))
        if operations:
            print(*operations)

solve()