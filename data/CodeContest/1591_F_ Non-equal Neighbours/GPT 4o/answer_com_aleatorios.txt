MOD = 998244353

def solve(n, a):
    # Edge case: If any a[i] == 1, result is 0
    if any(x == 1 for x in a):
        return 0

    # Initialize DP arrays
    prev_dp = [0] * (max(a) + 1)
    curr_dp = [0] * (max(a) + 1)

    # Base case: dp[1][j] = 1 for all 1 <= j <= a[0]
    for j in range(1, a[0] + 1):
        prev_dp[j] = 1

    # Iterate over the array
    for i in range(1, n):
        # Compute prefix sums for prev_dp
        prefix_sum = [0] * (max(a) + 2)
        for j in range(1, max(a) + 1):
            prefix_sum[j] = (prefix_sum[j - 1] + prev_dp[j]) % MOD

        # Compute curr_dp for the current index
        for j in range(1, a[i] + 1):
            # Total sum of prev_dp minus prev_dp[j]
            total_sum = prefix_sum[a[i - 1]]
            curr_dp[j] = (total_sum - prev_dp[j] + MOD) % MOD

        # Swap DP arrays for the next iteration
        prev_dp, curr_dp = curr_dp, [0] * (max(a) + 1)

    # Final result: Sum of all dp[n][j] for 1 <= j <= a[n-1]
    result = sum(prev_dp[1:a[n - 1] + 1]) % MOD
    return result

# Input reading
n = int(input())
a = list(map(int, input().split()))

# Output the result
print(solve(n, a))