CURRENT QUESTION:
You are given an array of n positive integers a_1, a_2, …, a_n. Your task is to calculate the number of arrays of n positive integers b_1, b_2, …, b_n such that: 

  * 1 ≤ b_i ≤ a_i for every i (1 ≤ i ≤ n), and 
  * b_i ≠ b_{i+1} for every i (1 ≤ i ≤ n - 1). 



The number of such arrays can be very large, so print it modulo 998 244 353.

Input

The first line contains a single integer n (1 ≤ n ≤ 2 ⋅ 10^5) — the length of the array a.

The second line contains n integers a_1, a_2, …, a_n (1 ≤ a_i ≤ 10^9).

Output

Print the answer modulo 998 244 353 in a single line.

Examples

Input


3
2 2 2


Output


2

Input


2
2 3


Output


4

Input


3
1 1 1


Output


0

Note

In the first test case possible arrays are [1, 2, 1] and [2, 1, 2].

In the second test case possible arrays are [1, 2], [1, 3], [2, 1] and [2, 3].

SIMILAR QUESTIONS:
Similar question 1 (Similarity score: 0.83):
Name: 1312_D. Count the Arrays
Tags: ['combinatorics', 'math']
Description: Your task is to calculate the number of arrays such that:

  * each array contains n elements; 
  * each element is an integer from 1 to m; 
  * for each array, there is exactly one pair of equal elements; 
  * for each array a, there exists an index i such that the array is strictly ascending before the i-th element and strictly descending after it (formally, it means that a_j < a_{j + 1}, if j < i, and a_j > a_{j + 1}, if j ≥ i). 

Input

The first line contains two integers n and m (2 ≤ n ≤ m ≤ 2 ⋅ 10^5).

Output

Print one integer — the number of arrays that meet all of the aforementioned conditions, taken modulo 998244353.

Examples

Input


3 4


Output


6


Input


3 5


Output


10


Input


42 1337


Output


806066790


Input


100000 200000


Output


707899035

Note

The arrays in the first example are:

  * [1, 2, 1]; 
  * [1, 3, 1]; 
  * [1, 4, 1]; 
  * [2, 3, 2]; 
  * [2, 4, 2]; 
  * [3, 4, 3]. 
Difficulty: 10
Solutions: import java.io.*;
import java.util.*;
import java.math.*;

 
 public class S	{
		static class Pair  implements Comparable<Pair> {
   int a;
   int b;
   public Pair(int x,int y){a=x;b=y;}
   public Pair(){}
   public int compareTo(Pair p1){
      return a+b-p1.a-p1.b;
   }
@Override
public int hashCode() {
	final int prime = 31;
	int result = 1;
	result = prime * result + a;
	result = prime * result + b;
	return result;
}
@Override
public boolean equals(Object obj) {
	Pair p = (Pair)obj;
	if (this.a==p.a && this.b==p.b)
		return true;
	else return false;
	
}
     
   
 }
static class TrieNode{
  TrieNode[]child;
  int w;
  boolean term;
  TrieNode(){
    child = new TrieNode[26];  
  }
}
  public static int gcd(int a,int b)
  {
    if(a<b)

      return gcd(b,a);
    if(b==0)
      return a;
    return gcd(b,a%b);
    
  }
  //static long ans = 0;
  static long mod = 998244353;//(long)(1e9+7);
   
    public static void main(String[] args) throws Exception {
       new Thread(null, null, "Anshum Gupta", 99999999) {
            public void run() {
                try {
                    solve();
                } catch(Exception e) {
                    e.printStackTrace();
                    System.exit(1);
                }
            }
        }.start();
    }

static long pow(long x,long y){
    if(y == 0)return 1;
    if(y==1)return x;
    long a = pow(x,y/2);
    a = (a*a)%mod;
    if(y%2==0){
        return a;
    }
    return (a*x)%mod;
}
static long my_inv(long x) {
	return pow(x,mod-2);
}
static long bin(int n,int r) {
	return (((fact[n]*inv_fact[n-r])%mod)*inv_fact[r])%mod;
}
static long mxx;
static int mxN = (int)(1e5+5);
static long[]fact,inv_fact;
 public static void solve() throws Exception {
   // solve the problem here
   MyScanner s = new MyScanner();
        out = new PrintWriter(new BufferedOutputStream(System.out), true);
        int t = 1;//s.nextInt();
        mxx = (long)(1e18+5);
        while(t-->0){
        	int n = s.nextInt();
        	int m = s.nextInt();
        	if(n == 2) {
        		out.println("0");
        		break;
        	}
        	fact = new long[m+1];
        	inv_fact=new long[m+1];
        	fact[1] = inv_fact[1] = 1;
        	for(int i=2;i<=m;i++) {
        		fact[i] = (fact[i-1]*i)%mod;
        		inv_fact[i] = my_inv(fact[i]);
        	}
        	long ans = bin(m,n-1);
        	ans = (ans*(n-2))%mod;
        	ans = (ans * pow(2,n-3))%mod;
        	if(ans < 0)ans += mod;
        	out.println(ans);
        }
           
        out.flush();
}
 
     
 
 
 
    //-----------PrintWriter for faster output---------------------------------
    public static PrintWriter out;
 
    //-----------MyScanner class for faster input----------
    public static class MyScanner {
        BufferedReader br;
        StringTokenizer st;
 
        public MyScanner() {
            br = new BufferedReader(new InputStreamReader(System.in));
        }
 
        String next() {
            while (st == null || !st.hasMoreElements()) {
                try {
                    st = new StringTokenizer(br.readLine());
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
            return st.nextToken();
        }
 
        int nextInt() { return Integer.parseInt(next()); }
        long nextLong() { return Long.parseLong(next()); }
        double nextDouble() { return Double.parseDouble(next()); }
         
        String nextLine(){
            String str = "";
            try {
                str = br.readLine();
            } catch (IOException e) {
                e.printStackTrace();
            }
            return str;
        }
    }
    //--------------------------------------------------------
}


Similar question 2 (Similarity score: 0.79):
Name: 1327_F. AND Segments
Tags: ['bitmasks', 'combinatorics', 'data structures', 'dp', 'two pointers']
Description: You are given three integers n, k, m and m conditions (l_1, r_1, x_1), (l_2, r_2, x_2), ..., (l_m, r_m, x_m).

Calculate the number of distinct arrays a, consisting of n integers such that: 

  * 0 ≤ a_i < 2^k for each 1 ≤ i ≤ n; 
  * bitwise AND of numbers a[l_i] \& a[l_i + 1] \& ... \& a[r_i] = x_i for each 1 ≤ i ≤ m. 



Two arrays a and b are considered different if there exists such a position i that a_i ≠ b_i. 

The number can be pretty large so print it modulo 998244353.

Input

The first line contains three integers n, k and m (1 ≤ n ≤ 5 ⋅ 10^5, 1 ≤ k ≤ 30, 0 ≤ m ≤ 5 ⋅ 10^5) — the length of the array a, the value such that all numbers in a should be smaller than 2^k and the number of conditions, respectively.

Each of the next m lines contains the description of a condition l_i, r_i and x_i (1 ≤ l_i ≤ r_i ≤ n, 0 ≤ x_i < 2^k) — the borders of the condition segment and the required bitwise AND value on it.

Output

Print a single integer — the number of distinct arrays a that satisfy all the above conditions modulo 998244353.

Examples

Input


4 3 2
1 3 3
3 4 6


Output


3


Input


5 2 3
1 3 2
2 5 0
3 3 3


Output


33

Note

You can recall what is a bitwise AND operation [here](https://en.wikipedia.org/wiki/Bitwise_operation#AND).

In the first example, the answer is the following arrays: [3, 3, 7, 6], [3, 7, 7, 6] and [7, 3, 7, 6].
Difficulty: 12
Solutions: #include <bits/stdc++.h>
using namespace std;
const int MOD = (119 << 23) + 1;
const int MX = 5e5;
int l[MX], r[MX], x[MX], one[MX + 2], dp[MX + 2], zer[MX + 2], ps[MX + 2];
int main() {
  ios_base::sync_with_stdio(0);
  cin.tie(0);
  int n, k, m;
  cin >> n >> k >> m;
  for (int i = 0; i < m; ++i) {
    cin >> l[i] >> r[i] >> x[i];
  }
  long long ans = 1;
  for (int i = 1; i < (1 << k); i *= 2) {
    memset(ps, 0, sizeof ps);
    memset(dp, 0, sizeof dp);
    for (int j = 0; j < m; ++j) {
      if (x[j] & i) {
        ++one[l[j]];
        --one[r[j] + 1];
      } else {
        zer[r[j] + 1] = max(zer[r[j] + 1], l[j]);
      }
    }
    for (int i = 1; i <= n + 1; ++i) {
      one[i] += one[i - 1];
      zer[i] = max(zer[i], zer[i - 1]);
    }
    dp[0] = ps[0] = 1;
    for (int i = 1; i <= n + 1; ++i) {
      dp[i] = ps[i - 1];
      if (zer[i]) {
        ((dp[i] -= ps[zer[i] - 1]) += MOD) %= MOD;
        zer[i] = 0;
      }
      if (one[i]) {
        dp[i] = 0;
        one[i] = 0;
      }
      ps[i] = (dp[i] + ps[i - 1]) % MOD;
    }
    (ans *= dp[n + 1]) %= MOD;
  }
  cout << ans << '\n';
}


Similar question 3 (Similarity score: 0.78):
Name: 1102_E. Monotonic Renumeration
Tags: ['combinatorics', 'sortings']
Description: You are given an array a consisting of n integers. Let's denote monotonic renumeration of array a as an array b consisting of n integers such that all of the following conditions are met:

  * b_1 = 0; 
  * for every pair of indices i and j such that 1 ≤ i, j ≤ n, if a_i = a_j, then b_i = b_j (note that if a_i ≠ a_j, it is still possible that b_i = b_j); 
  * for every index i ∈ [1, n - 1] either b_i = b_{i + 1} or b_i + 1 = b_{i + 1}. 



For example, if a = [1, 2, 1, 2, 3], then two possible monotonic renumerations of a are b = [0, 0, 0, 0, 0] and b = [0, 0, 0, 0, 1].

Your task is to calculate the number of different monotonic renumerations of a. The answer may be large, so print it modulo 998244353.

Input

The first line contains one integer n (2 ≤ n ≤ 2 ⋅ 10^5) — the number of elements in a.

The second line contains n integers a_1, a_2, ..., a_n (1 ≤ a_i ≤ 10^9).

Output

Print one integer — the number of different monotonic renumerations of a, taken modulo 998244353.

Examples

Input


5
1 2 1 2 3


Output


2


Input


2
100 1


Output


2


Input


4
1 3 3 7


Output


4
Difficulty: 11
Solutions: import os
import sys
from io import BytesIO, IOBase
import math
from queue import Queue
import collections
import itertools
import bisect
import heapq
# sys.setrecursionlimit(100000)
# ^^^TAKE CARE FOR MEMORY LIMIT^^^
import random


def main():
    pass


BUFSIZE = 8192


class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = "x" in file.mode or "r" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b"\n") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)


class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode("ascii"))
        self.read = lambda: self.buffer.read().decode("ascii")
        self.readline = lambda: self.buffer.readline().decode("ascii")


sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip("\r\n")


def binary(n):
    return (bin(n).replace("0b", ""))


def decimal(s):
    return (int(s, 2))


def pow2(n):
    p = 0
    while (n > 1):
        n //= 2
        p += 1
    return (p)


def primeFactors(n):
    cnt = []
    while n % 2 == 0:
        cnt.append(2)
        n = n / 2
    for i in range(3, int(math.sqrt(n)) + 1, 2):
        while n % i == 0:
            cnt.append(i)
            n = n / i
    if n > 2:
        cnt.append(int(n))
    return (cnt)

def primeFactorsCount(n):
    cnt=0
    while n % 2 == 0:
        cnt+=1
        n = n // 2
    for i in range(3, int(math.sqrt(n)) + 1, 2):
        while n % i == 0:
            cnt+=1
            n = n // i
    if n > 2:
        cnt+=1
    return (cnt)

def isPrime(n):
    if (n == 1):
        return (False)
    else:
        root = int(n ** 0.5)
        root += 1
        for i in range(2, root):
            if (n % i == 0):
                return (False)
        return (True)


def maxPrimeFactors(n):
    maxPrime = -1
    while n % 2 == 0:
        maxPrime = 2
        n >>= 1
    for i in range(3, int(math.sqrt(n)) + 1, 2):
        while n % i == 0:
            maxPrime = i
            n = n / i
    if n > 2:
        maxPrime = n
    return int(maxPrime)


def countcon(s, i):
    c = 0
    ch = s[i]
    for i in range(i, len(s)):
        if (s[i] == ch):
            c += 1
        else:
            break
    return (c)


def lis(arr):
    n = len(arr)
    lis = [1] * n
    for i in range(1, n):
        for j in range(0, i):
            if arr[i] > arr[j] and lis[i] < lis[j] + 1:
                lis[i] = lis[j] + 1
    maximum = 0
    for i in range(n):
        maximum = max(maximum, lis[i])
    return maximum


def isSubSequence(str1, str2):
    m = len(str1)
    n = len(str2)
    j = 0
    i = 0
    while j < m and i < n:
        if str1[j] == str2[i]:
            j = j + 1
        i = i + 1
    return j == m


def maxfac(n):
    root = int(n ** 0.5)
    for i in range(2, root + 1):
        if (n % i == 0):
            return (n // i)
    return (n)


def p2(n):
    c = 0
    while (n % 2 == 0):
        n //= 2
        c += 1
    return c


def seive(n):
    primes = [True] * (n + 1)
    primes[1] = primes[0] = False
    i = 2
    while (i * i <= n):
        if (primes[i] == True):
            for j in range(i * i, n + 1, i):
                primes[j] = False
        i += 1
    pr = []
    for i in range(0, n + 1):
        if (primes[i]):
            pr.append(i)
    return pr


def ncr(n, r, p):
    num = den = 1
    for i in range(r):
        num = (num * (n - i)) % p
        den = (den * (i + 1)) % p
    return (num * pow(den,
                      p - 2, p)) % p


def denofactinverse(n, m):
    fac = 1
    for i in range(1, n + 1):
        fac = (fac * i) % m
    return (pow(fac, m - 2, m))


def numofact(n, m):
    fac = 1
    for i in range(1, n + 1):
        fac = (fac * i) % m
    return (fac)

def sod(n):
    s = 0
    while (n > 0):
        s += n % 10
        n //= 10
    return s
def defaultDictDefaultVal():
    return -1
n=int(input())
l=list(map(int,input().split()))
pos=collections.defaultdict(defaultDictDefaultVal)
for i in range(0,n):
    pos[l[i]]=max(pos[l[i]],i)
seg=0
lp=pos[l[0]]
for i in range(1,n):
    if(i>lp):
        seg+=1
    lp=max(lp,pos[l[i]])
print(pow(2,seg,998244353))


INSTRUCTIONS:
Solve the current question.
Provide:
1. A complete and efficient code solution, optimized for both time and space complexity.
2. A detailed explanation of the solution, including:
   - The intuition behind the approach;
   - Time and space complexity;
   - Important considerations about the algorithm.
3. Use the similar questions as references to improve the solution, but only if they are relevant.
4. Don't use any external libraries. Any language is accepted.