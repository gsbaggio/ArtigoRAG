CURRENT QUESTION:
You are given an array of n positive integers a_1, a_2, …, a_n. Your task is to calculate the number of arrays of n positive integers b_1, b_2, …, b_n such that: 

  * 1 ≤ b_i ≤ a_i for every i (1 ≤ i ≤ n), and 
  * b_i ≠ b_{i+1} for every i (1 ≤ i ≤ n - 1). 



The number of such arrays can be very large, so print it modulo 998 244 353.

Input

The first line contains a single integer n (1 ≤ n ≤ 2 ⋅ 10^5) — the length of the array a.

The second line contains n integers a_1, a_2, …, a_n (1 ≤ a_i ≤ 10^9).

Output

Print the answer modulo 998 244 353 in a single line.

Examples

Input


3
2 2 2


Output


2

Input


2
2 3


Output


4

Input


3
1 1 1


Output


0

Note

In the first test case possible arrays are [1, 2, 1] and [2, 1, 2].

In the second test case possible arrays are [1, 2], [1, 3], [2, 1] and [2, 3].

EXAMPLE QUESTIONS:
Example question 1:
Name: 612_F. Simba on the Circle
Tags: ['dp']
Description: You are given a circular array with n elements. The elements are numbered from some element with values from 1 to n in clockwise order. The i-th cell contains the value ai. The robot Simba is in cell s.

Each moment of time the robot is in some of the n cells (at the begin he is in s). In one turn the robot can write out the number written in current cell or move to the adjacent cell in clockwise or counterclockwise direction. To write out the number from the cell Simba doesn't spend any time, but to move to adjacent cell Simba spends one unit of time.

Simba wants to write the number from each cell one time, so the numbers will be written in a non decreasing order. Find the least number of time units to write out all numbers.

Input

The first line contains two integers n and s (1 ≤ s ≤ n ≤ 2000) — the number of cells in the circular array and the starting position of Simba.

The second line contains n integers ai ( - 109 ≤ ai ≤ 109) — the number written in the i-th cell. The numbers are given for cells in order from 1 to n. Some of numbers ai can be equal.

Output

In the first line print the number t — the least number of time units.

Each of the next n lines should contain the direction of robot movement and the number of cells to move in that direction. After that movement the robot writes out the number from the cell in which it turns out. The direction and the number of cells should be printed in the form of +x in case of clockwise movement and -x in case of counterclockwise movement to x cells (0 ≤ x ≤ n - 1).

Note that the sum of absolute values of x should be equal to t.

Examples

Input

9 1
0 1 2 2 2 1 0 1 1


Output

12
+0
-3
-1
+2
+1
+2
+1
+1
+1


Input

8 1
0 1 0 1 0 1 0 1


Output

13
+0
+2
+2
+2
-1
+2
+2
+2


Input

8 1
1 2 3 4 5 6 7 8


Output

7
+0
+1
+1
+1
+1
+1
+1
+1


Input

8 1
0 0 0 0 0 0 0 0


Output

7
+0
+1
+1
+1
+1
+1
+1
+1
Difficulty: 12
Solutions: #include <bits/stdc++.h>
using namespace std;
int a[2010], b[2010], bn, n;
vector<int> oc[2010];
int memo[2010];
int mn_dist(int a, int b) { return min(abs(a - b), n - abs(a - b)); }
int solve(int i);
int solve_aux(int i, int val) {
  int on = oc[val].size();
  if (on == 1) {
    return mn_dist(i, oc[val][0]) + solve(oc[val][0]);
  }
  int R = 999999999;
  for (int j = 0; j < on; j++) {
    int l = oc[val][(j + on - 1) % on], r = oc[val][(j + 1) % on];
    int cur = oc[val][j];
    int dis = l - r;
    if (dis < 0) {
      dis += n;
    }
    R = min(R, dis + mn_dist(i, l) + mn_dist(r, cur) + solve(cur));
    R = min(R, dis + mn_dist(i, r) + mn_dist(l, cur) + solve(cur));
    if (on == 3) {
      R = min(R, mn_dist(i, l) + mn_dist(l, cur) + 2 * mn_dist(r, cur) +
                     solve(cur));
      R = min(R, mn_dist(i, r) + mn_dist(r, cur) + 2 * mn_dist(l, cur) +
                     solve(cur));
    }
  }
  return R;
}
int solve(int i) {
  int &r = memo[i];
  if (r != -1) {
    return r;
  }
  if (a[i] == bn - 1) {
    return 0;
  }
  r = solve_aux(i, a[i] + 1);
  return r;
}
int int_dist(int a, int b) {
  int d = mn_dist(a, b);
  if (((a + d) % n) == b) {
    return d;
  } else {
    return -d;
  }
}
void prn(int x) {
  if (x >= 0) {
    cout << '+' << x << '\n';
  } else {
    cout << x << '\n';
  }
}
void deb_dist(int a, int b) { prn(int_dist(a, b)); }
void build(int i);
void build_aux(int i, int val, int ans) {
  int on = oc[val].size();
  if (on == 1) {
    deb_dist(i, oc[val][0]);
    build(oc[val][0]);
    return;
  }
  for (int j = 0; j < on; j++) {
    int aj = (j + on - 1) % on;
    int nj = (j + 1) % on;
    swap(nj, aj);
    int l = oc[val][nj], r = oc[val][aj];
    int cur = oc[val][j];
    int dis = l - r;
    if (dis < 0) {
      dis += n;
    }
    if (on == 3) {
      if (ans ==
          mn_dist(i, l) + mn_dist(l, cur) + 2 * mn_dist(r, cur) + solve(cur)) {
        deb_dist(i, l);
        deb_dist(l, r);
        deb_dist(r, cur);
        build(cur);
        return;
      }
      if (ans ==
          mn_dist(i, r) + mn_dist(r, cur) + 2 * mn_dist(l, cur) + solve(cur)) {
        deb_dist(i, r);
        deb_dist(r, l);
        deb_dist(l, cur);
        build(cur);
        return;
      }
    }
    if (ans == dis + mn_dist(i, l) + mn_dist(r, cur) + solve(cur)) {
      deb_dist(i, l);
      for (int k = nj; k != aj; k = (k - 1 + on) % on) {
        int d = oc[val][k] - oc[val][(k - 1 + on) % on];
        if (d < 0) {
          d += n;
        }
        cout << '-' << d << '\n';
      }
      deb_dist(r, cur);
      build(cur);
      return;
    }
    if (ans == dis + mn_dist(i, r) + mn_dist(l, cur) + solve(cur)) {
      deb_dist(i, r);
      for (int k = aj; k != nj; k = (k + 1) % on) {
        int d = oc[val][(k + 1) % on] - oc[val][k];
        if (d < 0) {
          d += n;
        }
        cout << '+' << d << '\n';
      }
      deb_dist(l, cur);
      build(cur);
      return;
    }
  }
}
void build(int i) {
  if (a[i] == bn - 1) {
    return;
  }
  build_aux(i, a[i] + 1, solve(i));
}
int main() {
  ios::sync_with_stdio(0);
  memset(memo, -1, sizeof(memo));
  int s;
  cin >> n >> s;
  s--;
  for (int i = 0; i < n; i++) {
    cin >> a[i];
    b[i] = a[i];
  }
  sort(b, b + n);
  bn = unique(b, b + n) - b;
  for (int i = 0; i < n; i++) {
    a[i] = lower_bound(b, b + bn, a[i]) - b;
    oc[a[i]].push_back(i);
  }
  int r = solve_aux(s, 0);
  cout << r << '\n';
  build_aux(s, 0, r);
  return 0;
}



INSTRUCTIONS:
Solve the current question.
Provide:
1. A complete and efficient code solution, optimized for both time and space complexity.
2. A detailed explanation of the solution, including:
   - The intuition behind the approach;
   - Time and space complexity;
   - Important considerations about the algorithm.
3. You can use the example questions as general references for coding patterns and structure, but solve the current problem independently.
4. Don't use any external libraries. Any language is accepted.