CURRENT QUESTION:
You are given an array a consisting of n non-negative integers.

You have to replace each 0 in a with an integer from 1 to n (different elements equal to 0 can be replaced by different integers).

The value of the array you obtain is the number of integers k from 1 to n such that the following condition holds: there exist a pair of adjacent elements equal to k (i. e. there exists some i ∈ [1, n - 1] such that a_i = a_{i + 1} = k). If there are multiple such pairs for some integer k, this integer is counted in the value only once.

Your task is to obtain the array with the maximum possible value.

Input

The first line contains one integer n (2 ≤ n ≤ 3 ⋅ 10^5) — the number of elements in the array.

The second line contains n integers a_1, a_2, ..., a_n (0 ≤ a_i ≤ min(n, 600)) — the elements of the array.

Output

Print n integers not less than 1 and not greater than n — the array with the maximum possible value you can obtain.

If there are multiple answers, print any of them.

Examples

Input


4
1 1 0 2


Output


1 1 2 2 


Input


5
0 0 0 0 0


Output


3 1 1 3 3


Input


5
1 2 3 4 5


Output


1 2 3 4 5 


Input


6
1 0 0 0 0 1


Output


1 2 3 3 1 1


Input


3
3 0 2


Output


3 2 2 


Input


5
1 0 2 0 1


Output


1 2 2 1 1 


Input


7
1 0 2 3 1 0 2


Output


1 2 2 3 1 1 2 

EXAMPLE QUESTIONS:
Example question 1:
Name: 645_G. Armistice Area Apportionment
Tags: ['binary search', 'geometry']
Description: After a drawn-out mooclear arms race, Farmer John and the Mischievous Mess Makers have finally agreed to establish peace. They plan to divide the territory of Bovinia with a line passing through at least two of the n outposts scattered throughout the land. These outposts, remnants of the conflict, are located at the points (x1, y1), (x2, y2), ..., (xn, yn).

In order to find the optimal dividing line, Farmer John and Elsie have plotted a map of Bovinia on the coordinate plane. Farmer John's farm and the Mischievous Mess Makers' base are located at the points P = (a, 0) and Q = ( - a, 0), respectively. Because they seek a lasting peace, Farmer John and Elsie would like to minimize the maximum difference between the distances from any point on the line to P and Q.

Formally, define the difference of a line <image> relative to two points P and Q as the smallest real number d so that for all points X on line <image>, |PX - QX| ≤ d. (It is guaranteed that d exists and is unique.) They wish to find the line <image> passing through two distinct outposts (xi, yi) and (xj, yj) such that the difference of <image> relative to P and Q is minimized.

Input

The first line of the input contains two integers n and a (2 ≤ n ≤ 100 000, 1 ≤ a ≤ 10 000) — the number of outposts and the coordinates of the farm and the base, respectively.

The following n lines describe the locations of the outposts as pairs of integers (xi, yi) (|xi|, |yi| ≤ 10 000). These points are distinct from each other as well as from P and Q.

Output

Print a single real number—the difference of the optimal dividing line. Your answer will be considered correct if its absolute or relative error does not exceed 10 - 6. 

Namely: let's assume that your answer is a, and the answer of the jury is b. The checker program will consider your answer correct, if <image>.

Examples

Input

2 5
1 0
2 1


Output

7.2111025509


Input

3 6
0 1
2 5
0 -3


Output

0.0000000000

Note

In the first sample case, the only possible line <image> is y = x - 1. It can be shown that the point X which maximizes |PX - QX| is (13, 12), with <image>, which is <image>.

In the second sample case, if we pick the points (0, 1) and (0, - 3), we get <image> as x = 0. Because PX = QX on this line, the minimum possible difference is 0.
Difficulty: 13
Solutions: #include <bits/stdc++.h>
using namespace std;
const int maxn = 200010;
const double eps = 1e-9;
const double pi = acos(-1);
int read() {
  int tot = 0, fh = 1;
  char c = getchar();
  while ((c < '0') || (c > '9')) {
    if (c == '-') fh = -1;
    c = getchar();
  }
  while ((c >= '0') && (c <= '9')) {
    tot = tot * 10 + c - '0';
    c = getchar();
  }
  return tot * fh;
}
int i, j, k;
int n, ll, rr;
double l, r, mid;
int d[maxn];
double ans, w;
struct node {
  double x, y;
  node(double xx = 0, double yy = 0) {
    x = xx;
    y = yy;
  }
} a[maxn];
node operator-(node a, node b) { return node(a.x - b.x, a.y - b.y); }
node operator/(node a, double b) { return node(a.x / b, a.y / b); }
node operator*(node a, long double b) { return node(a.x * b, a.y * b); }
node operator+(node a, node b) { return node(a.x + b.x, a.y + b.y); }
double cha(node a, node b) { return (a.x * b.y - a.y * b.x); }
double dian(node a, node b) { return (a.x * b.x + a.y * b.y); }
double len(node a) { return sqrt(dian(a, a)); }
node zhuan(node a, double w) {
  node b = node(cos(w), sin(w));
  return node(a.x * b.x - a.y * b.y, a.x * b.y + a.y * b.x);
}
struct CC {
  node a;
  double l;
  CC(node aa = node(0, 0), double ll = 0) {
    a = aa;
    l = ll;
  }
} b[maxn];
struct nodee {
  node a;
  int l;
  double ccc;
  nodee(node aa = node(0, 0), int ll = 0) {
    a = aa;
    l = ll;
  }
} c[maxn * 2];
void work(CC a, CC b, int fla) {
  if (a.l < b.l) swap(a, b);
  if (len(a.a - b.a) > a.l + b.l - eps) return;
  if (len(a.a - b.a) + b.l - eps < a.l) return;
  long double t1 = (long double)len(a.a - b.a) * (long double)len(a.a - b.a) +
                   (long double)a.l * a.l - (long double)b.l * b.l;
  t1 = t1 / 2 / len(a.a - b.a);
  node t = ((b.a - a.a) / len(b.a - a.a)) * t1 + a.a;
  t1 = sqrt(a.l * a.l - t1 * t1);
  ll++;
  c[ll].a = t + (zhuan(b.a - a.a, pi / 2) / len(b.a - a.a)) * t1;
  c[ll].l = fla;
  ll++;
  c[ll].a = t + (zhuan(b.a - a.a, -pi / 2) / len(b.a - a.a)) * t1;
  c[ll].l = fla;
}
bool cmp(nodee a, nodee b) { return (a.ccc < b.ccc); }
int check(double mid) {
  int i, j, k;
  ll = 0, rr = 0;
  for (i = 1; i <= n; i++) {
    b[i].a = a[i];
    b[i].l = len(a[i] - node(-w, 0));
  }
  for (i = 1; i <= n; i++) {
    work(b[i], CC(node(w, 0), mid), i);
  }
  for (i = 1; i <= ll; i++) c[i].ccc = atan2(c[i].a.x - w, c[i].a.y);
  sort(c + 1, c + ll + 1, cmp);
  for (i = 1; i <= ll; i++) {
    if (d[rr] != c[i].l) {
      rr++;
      d[rr] = c[i].l;
    } else {
      rr--;
    }
  }
  if (rr == 0)
    return 0;
  else
    return 1;
}
int main() {
  n = read();
  w = read();
  ans = 2 * w;
  for (i = 1; i <= n; i++) {
    a[i].x = read();
    a[i].y = read();
    if (a[i].x == 0) j++;
  }
  if (j >= 2) {
    printf("0\n");
    return 0;
  }
  l = 0;
  r = 2 * w;
  while (r - l >= eps) {
    mid = (l + r) / 2.0;
    if (check(mid) == 1) {
      ans = mid;
      r = mid;
    } else
      l = mid;
  }
  printf("%.8lf\n", ans);
  return 0;
}



INSTRUCTIONS:
Solve the current question.
Provide:
1. A complete and efficient code solution, optimized for both time and space complexity.
2. A detailed explanation of the solution, including:
   - The intuition behind the approach;
   - Time and space complexity;
   - Important considerations about the algorithm.
3. You can use the example questions as general references for coding patterns and structure, but solve the current problem independently.
4. Don't use any external libraries. Any language is accepted.