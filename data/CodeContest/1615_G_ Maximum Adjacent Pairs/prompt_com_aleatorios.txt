CURRENT QUESTION:
You are given an array a consisting of n non-negative integers.

You have to replace each 0 in a with an integer from 1 to n (different elements equal to 0 can be replaced by different integers).

The value of the array you obtain is the number of integers k from 1 to n such that the following condition holds: there exist a pair of adjacent elements equal to k (i. e. there exists some i ∈ [1, n - 1] such that a_i = a_{i + 1} = k). If there are multiple such pairs for some integer k, this integer is counted in the value only once.

Your task is to obtain the array with the maximum possible value.

Input

The first line contains one integer n (2 ≤ n ≤ 3 ⋅ 10^5) — the number of elements in the array.

The second line contains n integers a_1, a_2, ..., a_n (0 ≤ a_i ≤ min(n, 600)) — the elements of the array.

Output

Print n integers not less than 1 and not greater than n — the array with the maximum possible value you can obtain.

If there are multiple answers, print any of them.

Examples

Input


4
1 1 0 2


Output


1 1 2 2 


Input


5
0 0 0 0 0


Output


3 1 1 3 3


Input


5
1 2 3 4 5


Output


1 2 3 4 5 


Input


6
1 0 0 0 0 1


Output


1 2 3 3 1 1


Input


3
3 0 2


Output


3 2 2 


Input


5
1 0 2 0 1


Output


1 2 2 1 1 


Input


7
1 0 2 3 1 0 2


Output


1 2 2 3 1 1 2 

EXAMPLE QUESTIONS:
Example question 1:
Name: 55_C. Pie or die
Tags: ['games']
Description: Volodya and Vlad play the following game. There are k pies at the cells of n × m board. Each turn Volodya moves one pie to the neighbouring (by side) cell. If the pie lies at the border of the board then Volodya can move it outside the board, get the pie and win. After Volodya's move, Vlad bans some edge at the border of the board of length 1 (between two knots of the board) so that Volodya is not able to move the pie outside the board through this edge anymore. The question is: will Volodya win this game? We suppose both players follow the optimal strategy.

<image>

Input

First line contains 3 integers, separated by space: 1 ≤ n, m ≤ 100 — dimensions of the board and 0 ≤ k ≤ 100 — the number of pies. Each of the next k lines contains 2 integers, separated by space: 1 ≤ x ≤ n, 1 ≤ y ≤ m — coordinates of the corresponding pie. There could be more than one pie at a cell. 

Output

Output only one word: "YES" — if Volodya wins, "NO" — otherwise.

Examples

Input

2 2 1
1 2


Output

YES

Input

3 4 0


Output

NO

Input

100 50 2
50 25
50 25


Output

NO
Difficulty: 9
Solutions: import java.util.Scanner;

public class C {
    public static void main(String[] args) {
        Scanner sc=new Scanner(System.in);
        int n=sc.nextInt();
        int m=sc.nextInt();
        int pies=sc.nextInt();
        boolean win=false;
        for(int i=0;i<pies;i++){
            int r=sc.nextInt();
            int c=sc.nextInt();
            if(Math.abs(r-1)<=4||Math.abs(r-n)<=4||Math.abs(c-1)<=4||Math.abs(c-m)<=4)
                win=true;
        }
        if(win) System.out.println("YES");
        else System.out.println("NO");
    }
}


Example question 2:
Name: p01628 Amidakuji
Tags: ['']
Description: Problem Statement

Mr. Takatsuki, who is planning to participate in the Aizu training camp, has a poor house and always tries to save as much paper as possible. She decided to play a ghost leg with other participants to decide the team for the Aizu training camp.

How to make Amidakuji for this training camp is as follows. First, write N vertical bars in parallel on the paper. Then, write the M horizontal bars in order from the top so that they are perpendicular to the vertical bars and the heights of the horizontal bars are all different. For example, the Amida of Sample Input 1 is as shown in Fig. 1.

Here, Mr. Takatsuki, a little dissatisfied expression. It's a waste of paper to write a ghost leg so vertically. You should be able to compress the height more. So, I want her to solve the problem of height compression of Amidakuji shown below.

First, the height of the Amidakuji is the value obtained by counting the horizontal bars that exist at the same height together as the height 1 and counting this to the bottom horizontal bar. Here, it is assumed that each horizontal bar can be freely moved up and down in order to perform height compression. However, it is not permissible to remove or add horizontal bars. The Amidakuji after height compression must meet the following conditions.

* The end points of the horizontal bar do not touch the end points of other horizontal bars.
* The result of tracing the Amidakuji after compression and the result of tracing the Amidakuji before compression match.



FIG. 2 is a compressed version of FIG. The "horizontal bar connecting vertical bars 1 and 2" moves to the top and becomes the same height as the "horizontal bar connecting vertical bars 4 and 5", and these two are height 1. After that, the "horizontal bar connecting the vertical bars 3 and 4" and the "horizontal bar connecting the vertical bars 2 and 3" have different heights, and the total height is 3.

<image>

Compress the height of the given Amidakuji and output the compressed height.

Constraints

* 2 <= N <= 8
* 1 <= M <= 8
* 1 <= ai <= N --1

Input

Each data set is input in the following format.


N M
a1
a2
...
aM


All inputs are integers. N indicates the number of vertical bars and M indicates the number of horizontal bars. Then, the information of the horizontal bar is input over M lines. ai indicates that the i-th horizontal bar connects the vertical bar ai and the vertical bar to the right of it. The i-th horizontal bar exists above the i + 1-th horizontal bar.

Output

Outputs the height of the compressed Amidakuji in one line.

Examples

Input

5 4
4
3
1
2


Output

3


Input

4 3
1
2
3


Output

3
Difficulty: 0
Solutions: #include <iostream>
#include <vector>
#include <algorithm>
using namespace std;
const int INF = 1e9;
int N, M;
vector<int> res;

vector<int> simu(const vector<vector<bool>> &A){
  vector<int> ret(N+1);
  for(int i = 0; i < N+1; ++i) ret[i] = i;
  for(size_t j = 0; j < A[0].size(); ++j){
    for(size_t i = 0; i < ret.size(); ++i){
      if(A[i][j]) swap(ret[i],ret[i+1]);
    }
  }
  return ret;
}

int dfs(vector<int> &A, vector<int> &H, vector<vector<bool>> &B, int idx){
  int ret = INF;
  if(idx == A.size()){
    vector<int> s = simu(B);
    if(s == res) return *max_element(H.begin(),H.end());
    else return INF;
  }
  int a = A[idx];
  for(int i = H[a]+1; i < M; ++i){
    if(B[a+1][i] or B[a-1][i] or B[a][i]) continue;
    B[a][i] = true;
    int h = H[a];
    H[a] = i;
    ret = min(ret,dfs(A,H,B,idx+1));
    H[a] = h;
    B[a][i] = false;
  }
  return ret;
}

int main(){
  cin >> N >> M;
  vector<int> A(M);
  vector<vector<bool>> B(N+1,vector<bool>(M,false));
  for(int i = 0; i < M; ++i){
    cin >> A[i];
    B[A[i]][i] = true;
  }
  res = simu(B);
  vector<vector<bool>> B_(N+1,vector<bool>(M,false));
  vector<int> H(N,-1);
  cout << dfs(A,H,B_,0)+1 << endl;
}




INSTRUCTIONS:
Solve the current question.
Provide:
1. A complete and efficient code solution, optimized for both time and space complexity.
2. A detailed explanation of the solution, including:
   - The intuition behind the approach;
   - Time and space complexity;
   - Important considerations about the algorithm.
3. If the language has classes, implement in 'Solution' class. Any language is accepted.
4. You can use the example questions as general references for coding patterns and structure, but solve the current problem independently.
5. Don't use any external libraries. Don't need to import any libraries.
