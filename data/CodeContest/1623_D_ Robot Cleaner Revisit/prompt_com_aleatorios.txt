CURRENT QUESTION:
The statement of this problem shares a lot with problem A. The differences are that in this problem, the probability is introduced, and the constraint is different.

A robot cleaner is placed on the floor of a rectangle room, surrounded by walls. The floor consists of n rows and m columns. The rows of the floor are numbered from 1 to n from top to bottom, and columns of the floor are numbered from 1 to m from left to right. The cell on the intersection of the r-th row and the c-th column is denoted as (r,c). The initial position of the robot is (r_b, c_b).

In one second, the robot moves by dr rows and dc columns, that is, after one second, the robot moves from the cell (r, c) to (r + dr, c + dc). Initially dr = 1, dc = 1. If there is a vertical wall (the left or the right walls) in the movement direction, dc is reflected before the movement, so the new value of dc is -dc. And if there is a horizontal wall (the upper or lower walls), dr is reflected before the movement, so the new value of dr is -dr.

Each second (including the moment before the robot starts moving), the robot cleans every cell lying in the same row or the same column as its position. There is only one dirty cell at (r_d, c_d). The job of the robot is to clean that dirty cell. 

After a lot of testings in problem A, the robot is now broken. It cleans the floor as described above, but at each second the cleaning operation is performed with probability \frac p {100} only, and not performed with probability 1 - \frac p {100}. The cleaning or not cleaning outcomes are independent each second.

Given the floor size n and m, the robot's initial position (r_b, c_b) and the dirty cell's position (r_d, c_d), find the expected time for the robot to do its job.

It can be shown that the answer can be expressed as an irreducible fraction \frac x y, where x and y are integers and y not ≡ 0 \pmod{10^9 + 7} . Output the integer equal to x ⋅ y^{-1} mod (10^9 + 7). In other words, output such an integer a that 0 ≤ a < 10^9 + 7 and a ⋅ y ≡ x \pmod {10^9 + 7}.

Input

Each test contains multiple test cases. The first line contains the number of test cases t (1 ≤ t ≤ 10). Description of the test cases follows.

A test case consists of only one line, containing n, m, r_b, c_b, r_d, c_d, and p (4 ≤ n ⋅ m ≤ 10^5, n, m ≥ 2, 1 ≤ r_b, r_d ≤ n, 1 ≤ c_b, c_d ≤ m, 1 ≤ p ≤ 99) — the sizes of the room, the initial position of the robot, the position of the dirt cell and the probability of cleaning in percentage.

Output

For each test case, print a single integer — the expected time for the robot to clean the dirty cell, modulo 10^9 + 7.

Example

Input


6
2 2 1 1 2 1 25
3 3 1 2 2 2 25
10 10 1 1 10 10 75
10 10 10 10 1 1 75
5 5 1 3 2 2 10
97 98 3 5 41 43 50


Output


3
3
15
15
332103349
99224487

Note

In the first test case, the robot has the opportunity to clean the dirty cell every second. Using the [geometric distribution](https://en.wikipedia.org/wiki/Geometric_distribution), we can find out that with the success rate of 25\%, the expected number of tries to clear the dirty cell is \frac 1 {0.25} = 4. But because the first moment the robot has the opportunity to clean the cell is before the robot starts moving, the answer is 3.

<image> Illustration for the first example. The blue arc is the robot. The red star is the target dirt cell. The purple square is the initial position of the robot. Each second the robot has an opportunity to clean a row and a column, denoted by yellow stripes.

In the second test case, the board size and the position are different, but the robot still has the opportunity to clean the dirty cell every second, and it has the same probability of cleaning. Therefore the answer is the same as in the first example.

<image> Illustration for the second example.

The third and the fourth case are almost the same. The only difference is that the position of the dirty cell and the robot are swapped. But the movements in both cases are identical, hence the same result.

EXAMPLE QUESTIONS:
Example question 1:
Name: 56_E. Domino Principle
Tags: ['binary search', 'data structures', 'sortings']
Description: Vasya is interested in arranging dominoes. He is fed up with common dominoes and he uses the dominoes of different heights. He put n dominoes on the table along one axis, going from left to right. Every domino stands perpendicular to that axis so that the axis passes through the center of its base. The i-th domino has the coordinate xi and the height hi. Now Vasya wants to learn for every domino, how many dominoes will fall if he pushes it to the right. Help him do that. 

Consider that a domino falls if it is touched strictly above the base. In other words, the fall of the domino with the initial coordinate x and height h leads to the fall of all dominoes on the segment [x + 1, x + h - 1].

<image>

Input

The first line contains integer n (1 ≤ n ≤ 105) which is the number of dominoes. Then follow n lines containing two integers xi and hi ( - 108 ≤ xi ≤ 108, 2 ≤ hi ≤ 108) each, which are the coordinate and height of every domino. No two dominoes stand on one point.

Output

Print n space-separated numbers zi — the number of dominoes that will fall if Vasya pushes the i-th domino to the right (including the domino itself).

Examples

Input

4
16 5
20 5
10 10
18 2


Output

3 1 4 1 

Input

4
0 10
1 5
9 10
15 10


Output

4 1 2 1 
Difficulty: 11
Solutions: #include <bits/stdc++.h>
using namespace std;
int tree[4 * 200005], cs[200005], ar[200005];
struct dt {
  int b, e, h, id, res;
} st[100005];
bool cmp1(dt x, dt y) { return x.b < y.b; }
bool cmp2(dt x, dt y) { return x.id < y.id; }
void update(int nd, int b, int e, int x, int v) {
  if (b > x || e < x) return;
  if (b == x && e == x) {
    tree[nd] = v;
    return;
  }
  int left = 2 * nd;
  int right = 2 * nd + 1;
  int md = (b + e) / 2;
  update(left, b, md, x, v);
  update(right, md + 1, e, x, v);
  tree[nd] = max(tree[left], tree[right]);
}
int query(int nd, int b, int e, int x, int y) {
  if (e < x || b > y) return 0;
  if (b >= x && e <= y) return tree[nd];
  int left = 2 * nd;
  int right = 2 * nd + 1;
  int md = (b + e) / 2;
  int p1 = query(left, b, md, x, y);
  int p2 = query(right, md + 1, e, x, y);
  return max(p1, p2);
}
int main() {
  int n;
  scanf("%d", &n);
  set<int> ss;
  for (int i = 1; i <= n; i++) {
    int b, h, e;
    scanf("%d%d", &b, &h);
    e = b + h - 1;
    st[i].b = b;
    st[i].e = e;
    st[i].h = h;
    st[i].id = i;
    st[i].res = -1;
    ss.insert(b);
    ss.insert(e);
  }
  map<int, int> mp;
  set<int>::iterator it;
  int m = 0;
  for (it = ss.begin(); it != ss.end(); it++) mp[*it] = ++m;
  sort(st + 1, st + n + 1, cmp1);
  int sz = ss.size();
  for (int i = 1; i <= n; i++) {
    int v = mp[st[i].b];
    ar[v] = 1;
    int u = mp[st[i].e];
    update(1, 1, sz, v, u);
  }
  cs[0] = 0;
  for (int i = 1; i <= sz; i++) cs[i] = cs[i - 1] + ar[i];
  for (int i = n; i >= 1; i--) {
    int b = mp[st[i].b];
    int e = mp[st[i].e];
    int p = query(1, 1, sz, b, e);
    int res = cs[p] - cs[b - 1];
    st[i].res = res;
    update(1, 1, sz, b, p);
  }
  sort(st + 1, st + n + 1, cmp2);
  for (int i = 1; i <= n; i++) {
    if (i == n)
      printf("%d\n", st[i].res);
    else
      printf("%d ", st[i].res);
  }
  return 0;
}



INSTRUCTIONS:
Solve the current question.
Provide:
1. A complete and efficient code solution, optimized for both time and space complexity.
2. A detailed explanation of the solution, including:
   - The intuition behind the approach;
   - Time and space complexity;
   - Important considerations about the algorithm.
3. If the language has classes, implement in 'Solution' class. Any language is accepted.
4. You can use the example questions as general references for coding patterns and structure, but solve the current problem independently.
5. Don't use any external libraries. Don't need to import any libraries.
