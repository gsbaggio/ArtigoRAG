CURRENT QUESTION:
You are given an array a of length n.

Let's define the eversion operation. Let x = a_n. Then array a is partitioned into two parts: left and right. The left part contains the elements of a that are not greater than x (≤ x). The right part contains the elements of a that are strictly greater than x (> x). The order of elements in each part is kept the same as before the operation, i. e. the partition is stable. Then the array is replaced with the concatenation of the left and the right parts.

For example, if the array a is [2, 4, 1, 5, 3], the eversion goes like this: [2, 4, 1, 5, 3] → [2, 1, 3], [4, 5] → [2, 1, 3, 4, 5].

We start with the array a and perform eversions on this array. We can prove that after several eversions the array a stops changing. Output the minimum number k such that the array stops changing after k eversions.

Input

Each test contains multiple test cases. The first line contains the number of test cases t (1 ≤ t ≤ 100). Description of the test cases follows.

The first line contains a single integer n (1 ≤ n ≤ 2 ⋅ 10^5).

The second line contains n integers a_1, a_2, ..., a_n (1 ≤ a_i ≤ 10^9).

It is guaranteed that the sum of n over all test cases does not exceed 2 ⋅ 10^5.

Output

For each test case print a single integer k — the number of eversions after which the array stops changing.

Example

Input


3
5
2 4 1 5 3
5
5 3 2 4 1
4
1 1 1 1


Output


1
2
0

Note

Consider the fist example.

  * The first eversion: a = [1, 4, 2, 5, 3], x = 3. [2, 4, 1, 5, 3] → [2, 1, 3], [4, 5] → [2, 1, 3, 4, 5]. 
  * The second and following eversions: a = [2, 1, 3, 4, 5], x = 5. [2, 1, 3, 4, 5] → [2, 1, 3, 4, 5], [] → [2, 1, 3, 4, 5]. This eversion does not change the array, so the answer is 1. 



Consider the second example. 

  * The first eversion: a = [5, 3, 2, 4, 1], x = 1. [5, 3, 2, 4, 1] → [1], [5, 3, 2, 4] → [1, 5, 3, 2, 4]. 
  * The second eversion: a = [1, 5, 3, 2, 4], x = 4. [1, 5, 3, 2, 4] → [1, 3, 2, 4], [5] → [1, 3, 2, 4, 5]. 
  * The third and following eversions: a = [1, 3, 2, 4, 5], x = 5. [1, 3, 2, 4, 5] → [1, 3, 2, 4, 5], [] → [1, 3, 2, 4, 5]. This eversion does not change the array, so the answer is 2. 

EXAMPLE QUESTIONS:
Example question 1:
Name: 1100_C. NN and the Optical Illusion
Tags: ['binary search', 'geometry', 'math']
Description: NN is an experienced internet user and that means he spends a lot of time on the social media. Once he found the following image on the Net, which asked him to compare the sizes of inner circles:

<image>

It turned out that the circles are equal. NN was very surprised by this fact, so he decided to create a similar picture himself.

He managed to calculate the number of outer circles n and the radius of the inner circle r. NN thinks that, using this information, you can exactly determine the radius of the outer circles R so that the inner circle touches all of the outer ones externally and each pair of neighboring outer circles also touches each other. While NN tried very hard to guess the required radius, he didn't manage to do that. 

Help NN find the required radius for building the required picture.

Input

The first and the only line of the input file contains two numbers n and r (3 ≤ n ≤ 100, 1 ≤ r ≤ 100) — the number of the outer circles and the radius of the inner circle respectively.

Output

Output a single number R — the radius of the outer circle required for building the required picture. 

Your answer will be accepted if its relative or absolute error does not exceed 10^{-6}.

Formally, if your answer is a and the jury's answer is b. Your answer is accepted if and only when (|a-b|)/(max(1, |b|)) ≤ 10^{-6}.

Examples

Input

3 1


Output

6.4641016


Input

6 1


Output

1.0000000


Input

100 100


Output

3.2429391
Difficulty: 9
Solutions: #include <bits/stdc++.h>
using namespace std;
const long long INF = 999999999999999999;
const double PI = acos(-1.0);
void stop() { exit(0); }
int main() {
  double n, r;
  cin >> n >> r;
  double sn = sin(PI / n);
  double x = (2.0 * r * sn) / (2.0 - 2.0 * sn);
  printf("%.9lf", x);
  stop();
}



INSTRUCTIONS:
Solve the current question.
Provide:
1. A complete and efficient code solution, optimized for both time and space complexity.
2. A detailed explanation of the solution, including:
   - The intuition behind the approach;
   - Time and space complexity;
   - Important considerations about the algorithm.
3. If the language has classes, implement in 'Solution' class. Any language is accepted.
4. You can use the example questions as general references for coding patterns and structure, but solve the current problem independently.
5. Don't use any external libraries. Don't need to import any libraries.
