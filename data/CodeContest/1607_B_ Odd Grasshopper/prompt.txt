CURRENT QUESTION:
The grasshopper is located on the numeric axis at the point with coordinate x_0.

Having nothing else to do he starts jumping between integer points on the axis. Making a jump from a point with coordinate x with a distance d to the left moves the grasshopper to a point with a coordinate x - d, while jumping to the right moves him to a point with a coordinate x + d.

The grasshopper is very fond of positive integers, so for each integer i starting with 1 the following holds: exactly i minutes after the start he makes a jump with a distance of exactly i. So, in the first minutes he jumps by 1, then by 2, and so on.

The direction of a jump is determined as follows: if the point where the grasshopper was before the jump has an even coordinate, the grasshopper jumps to the left, otherwise he jumps to the right.

For example, if after 18 consecutive jumps he arrives at the point with a coordinate 7, he will jump by a distance of 19 to the right, since 7 is an odd number, and will end up at a point 7 + 19 = 26. Since 26 is an even number, the next jump the grasshopper will make to the left by a distance of 20, and it will move him to the point 26 - 20 = 6.

Find exactly which point the grasshopper will be at after exactly n jumps.

Input

The first line of input contains an integer t (1 ≤ t ≤ 10^4) — the number of test cases.

Each of the following t lines contains two integers x_0 (-10^{14} ≤ x_0 ≤ 10^{14}) and n (0 ≤ n ≤ 10^{14}) — the coordinate of the grasshopper's initial position and the number of jumps.

Output

Print exactly t lines. On the i-th line print one integer — the answer to the i-th test case — the coordinate of the point the grasshopper will be at after making n jumps from the point x_0.

Example

Input


9
0 1
0 2
10 10
10 99
177 13
10000000000 987654321
-433494437 87178291199
1 0
-1 1


Output


-1
1
11
110
190
9012345679
-87611785637
1
0

Note

The first two test cases in the example correspond to the first two jumps from the point x_0 = 0. 

Since 0 is an even number, the first jump of length 1 is made to the left, and the grasshopper ends up at the point 0 - 1 = -1.

Then, since -1 is an odd number, a jump of length 2 is made to the right, bringing the grasshopper to the point with coordinate -1 + 2 = 1.

SIMILAR QUESTIONS:
Similar question 1 (Similarity score: 0.73):
Name: 18_B. Platforms
Tags: ['brute force', 'math']
Description: In one one-dimensional world there are n platforms. Platform with index k (platforms are numbered from 1) is a segment with coordinates [(k - 1)m, (k - 1)m + l], and l < m. Grasshopper Bob starts to jump along the platforms from point 0, with each jump he moves exactly d units right. Find out the coordinate of the point, where Bob will fall down. The grasshopper falls down, if he finds himself not on the platform, but if he finds himself on the edge of the platform, he doesn't fall down.

Input

The first input line contains 4 integer numbers n, d, m, l (1 ≤ n, d, m, l ≤ 106, l < m) — respectively: amount of platforms, length of the grasshopper Bob's jump, and numbers m and l needed to find coordinates of the k-th platform: [(k - 1)m, (k - 1)m + l].

Output

Output the coordinates of the point, where the grosshopper will fall down. Don't forget that if Bob finds himself on the platform edge, he doesn't fall down.

Examples

Input

2 2 5 3


Output

4


Input

5 4 11 8


Output

20
Difficulty: 8
Solutions: import java.util.Scanner;

public class Platforms18B {
    public static void main(String[] args) {
        long n,d,m,l;

        Scanner scanner = new Scanner(System.in);
        n = scanner.nextLong();
        d = scanner.nextLong();
        m = scanner.nextLong();
        l = scanner.nextLong();
        if (m-l == 1) {
            long x = (n*m -1)/d;
            System.out.println(d*(x+1));
        } else {
            System.out.println(findFallDown(n,d,m,l));
        }
    }

    static long findFallDown(long n, long d, long m, long l) {
        long k = 1;
        long nextMove = d;
        while (k <= n) {
            long left = (k-1) * m;
            if (nextMove < left) {
                return nextMove;
            }
            long right = left + l;
            while (nextMove >= left && nextMove <= right) {
                nextMove += d;
            }
            k++;
        }
        return nextMove;
    }
}


Similar question 2 (Similarity score: 0.72):
Name: help-the-hungry-grasshopper
Tags: []
Description: Today grasshopper Jimmy Jumper is very hungry and his friend is notorious. Jimmy's friend puts an insect infront of him at a distance d. Jimmy can jump only a finite no of steps in each turn. Jimmy is initially at position 0. He can now jump 1 step to reach position 1 then jump 2 steps to reach position 3 then jump 4 steps to position 7 and so on.

Since Momu is very hungry and could not take risk of jumping but not reaching to the destination point, so you have to tell him whether he can reach to position d or not.

Input: 

First line contains t test cases.
Next t lines contains an integer d.

Constraints:

1 ≤ t ≤ 10

1 ≤ d ≤ 10^9

Output: 

t lines each containing "YES" if he can reach or "NO" if cannot   

Test case:

Input:

3

3

15

5

Output:

YES

YES

NO

SAMPLE INPUT
3
3
15
5

SAMPLE OUTPUT
YES
YES
NO
Difficulty: 0
Solutions: '''
# Read input from stdin and provide input before running code

name = raw_input('What is your name?\n')
print 'Hi, %s.' % name
'''
#print 'Hello World!'
from math import sqrt
t=input()
while t>0:
	t-=1
	n=input()
	a=0
	b=1
	while(a<n):
		a+=b
		b*=2
	if n==a:
			print"YES"
	else:
		print"NO"


INSTRUCTIONS:
Solve the current question.
Provide:
1. A complete and efficient code solution, optimized for both time and space complexity.
2. A detailed explanation of the solution, including:
   - The intuition behind the approach;
   - Time and space complexity;
   - Important considerations about the algorithm.
3. If the language has classes, implement in 'Solution' class. Any language is accepted.
4. Use the similar questions as references to improve the solution, but only if they are relevant.
5. Don't use any external libraries. Don't need to import any libraries.
