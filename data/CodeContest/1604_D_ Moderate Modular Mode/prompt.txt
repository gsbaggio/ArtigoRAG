CURRENT QUESTION:
YouKn0wWho has two even integers x and y. Help him to find an integer n such that 1 ≤ n ≤ 2 ⋅ 10^{18} and n mod x = y mod n. Here, a mod b denotes the remainder of a after division by b. If there are multiple such integers, output any. It can be shown that such an integer always exists under the given constraints.

Input

The first line contains a single integer t (1 ≤ t ≤ 10^5) — the number of test cases.

The first and only line of each test case contains two integers x and y (2 ≤ x, y ≤ 10^9, both are even).

Output

For each test case, print a single integer n (1 ≤ n ≤ 2 ⋅ 10^{18}) that satisfies the condition mentioned in the statement. If there are multiple such integers, output any. It can be shown that such an integer always exists under the given constraints.

Example

Input


4
4 8
4 2
420 420
69420 42068


Output


4
10
420
9969128

Note

In the first test case, 4 mod 4 = 8 mod 4 = 0.

In the second test case, 10 mod 4 = 2 mod 10 = 2.

In the third test case, 420 mod 420 = 420 mod 420 = 0.

SIMILAR QUESTIONS:
Similar question 1 (Similarity score: 0.81):
Name: 1374_A. Required Remainder
Tags: ['math']
Description: You are given three integers x, y and n. Your task is to find the maximum integer k such that 0 ≤ k ≤ n that k mod x = y, where mod is modulo operation. Many programming languages use percent operator % to implement it.

In other words, with given x, y and n you need to find the maximum possible integer from 0 to n that has the remainder y modulo x.

You have to answer t independent test cases. It is guaranteed that such k exists for each test case.

Input

The first line of the input contains one integer t (1 ≤ t ≤ 5 ⋅ 10^4) — the number of test cases. The next t lines contain test cases.

The only line of the test case contains three integers x, y and n (2 ≤ x ≤ 10^9;~ 0 ≤ y < x;~ y ≤ n ≤ 10^9).

It can be shown that such k always exists under the given constraints.

Output

For each test case, print the answer — maximum non-negative integer k such that 0 ≤ k ≤ n and k mod x = y. It is guaranteed that the answer always exists.

Example

Input


7
7 5 12345
5 0 4
10 5 15
17 8 54321
499999993 9 1000000000
10 5 187
2 0 999999999


Output


12339
0
15
54306
999999995
185
999999998

Note

In the first test case of the example, the answer is 12339 = 7 ⋅ 1762 + 5 (thus, 12339 mod 7 = 5). It is obvious that there is no greater integer not exceeding 12345 which has the remainder 5 modulo 7.
Difficulty: 7
Solutions: t=int(input())
for i in range(t):
    x, y, n=map(int,input().split())
    print(n-(n-y)%x)

Similar question 2 (Similarity score: 0.73):
Name: p03586 Tenka1 Programmer Contest - ModularPowerEquation!!
Tags: ['']
Description: Process the Q queries below.

* You are given two integers A_i and M_i. Determine whether there exists a positive integer K_i not exceeding 2 × 10^{18} such that A_i^{K_i} ≡ K_i (mod M_i), and find one if it exists.

Constraints

* 1 \leq Q \leq 100
* 0 \leq A_i \leq 10^9(1 \leq i \leq Q)
* 1 \leq M_i \leq 10^9(1 \leq i \leq Q)



Examples

Input

4
2 4
3 8
9 6
10 7


Output

4
11
9
2


Input

3
177 168
2028 88772
123456789 987654321


Output

7953
234831584
471523108231963269
Difficulty: 0
Solutions: #include<cstdio>
#include<cstring>
#include<algorithm>
#include<cmath>
#include<map>
#define SF scanf
#define PF printf
using namespace std;
long long power(long long x,long long num,long long mod){
    long long res=1;
    while(num){
        if(num&1){res=res*x;res%=mod;}
        x*=x;
        x%=mod;
        num>>=1;
    }
    return res;
}
long long phi(long long n){
    long long res=n,t=n;
    for(long long i=2;i*i<=t;i++)
        if(t%i==0){
            res-=res/i;
            while(t%i==0)
                t/=i;
        }
    if(t>1)
        res-=res/t;
    return res;
}
long long gcd(long long x,long long y){
    if(y==0)
        return x;
    return gcd(y,x%y);
}
long long exgcd(long long a,long long b,long long &x,long long &y){
    if(b==0){
        x=1;
        y=0;
        return a;
    }
    long long g;
    g=exgcd(b,a%b,y,x);
    y-=a/b*x;
    return g;
}
long long solve(long long a,long long mod){
    if(mod==1)
        return 1;
    long long x,y;
    long long pm=phi(mod);
    long long d=gcd(mod,pm);
    long long t=solve(a,d);
    long long at=power(a,t,mod);
    exgcd(mod/d,pm/d,x,y);
    x=x*(((t-at)%pm+pm)%pm)/d;
    x=((x%(pm/d))+pm/d)%(pm/d)+pm/d;
    return x*mod+at;
}
long long a,mod;
int main(){
    int q;
    SF("%d",&q);
    while(q--){
        SF("%lld%lld",&a,&mod);
        PF("%lld\n",solve(a,mod));
    }
}


Similar question 3 (Similarity score: 0.72):
Name: 1389_A. LCM Problem
Tags: ['constructive algorithms', 'greedy', 'math', 'number theory']
Description: Let LCM(x, y) be the minimum positive integer that is divisible by both x and y. For example, LCM(13, 37) = 481, LCM(9, 6) = 18.

You are given two integers l and r. Find two integers x and y such that l ≤ x < y ≤ r and l ≤ LCM(x, y) ≤ r.

Input

The first line contains one integer t (1 ≤ t ≤ 10000) — the number of test cases.

Each test case is represented by one line containing two integers l and r (1 ≤ l < r ≤ 10^9).

Output

For each test case, print two integers:

  * if it is impossible to find integers x and y meeting the constraints in the statement, print two integers equal to -1; 
  * otherwise, print the values of x and y (if there are multiple valid answers, you may print any of them). 

Example

Input


4
1 1337
13 69
2 4
88 89


Output


6 7
14 21
2 4
-1 -1
Difficulty: 7
Solutions: #include <bits/stdc++.h>
using namespace std;
int main() {
  long long l, r, x;
  int sum;
  cin >> sum;
  for (int i = 1; i <= sum; ++i) {
    cin >> l >> r;
    x = l * 2;
    if (x <= r)
      cout << l << " " << x << endl;
    else
      cout << "-1 -1\n";
  }
  return 0;
}



INSTRUCTIONS:
Solve the current question.
Provide:
1. A complete and efficient code solution, optimized for both time and space complexity.
2. A detailed explanation of the solution, including:
   - The intuition behind the approach;
   - Time and space complexity;
   - Important considerations about the algorithm.
3. Use the similar questions as references to improve the solution, but only if they are relevant.
4. Don't use any external libraries. Any language is accepted.