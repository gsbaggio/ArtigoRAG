CURRENT QUESTION:
The robot is located on a checkered rectangular board of size n × m (n rows, m columns). The rows in the board are numbered from 1 to n from top to bottom, and the columns — from 1 to m from left to right.

The robot is able to move from the current cell to one of the four cells adjacent by side.

Each cell has one of the symbols 'L', 'R', 'D' or 'U' written on it, indicating the direction in which the robot will move when it gets in that cell — left, right, down or up, respectively.

The robot can start its movement in any cell. He then moves to the adjacent square in the direction indicated on the current square in one move. 

  * If the robot moves beyond the edge of the board, it falls and breaks. 
  * If the robot appears in the cell it already visited before, it breaks (it stops and doesn't move anymore). 



Robot can choose any cell as the starting cell. Its goal is to make the maximum number of steps before it breaks or stops.

Determine from which square the robot should start its movement in order to execute as many commands as possible. A command is considered successfully completed if the robot has moved from the square on which that command was written (it does not matter whether to another square or beyond the edge of the board).

Input

The first line contains an integer t (1 ≤ t ≤ 10000) — the number of test cases in the test.

Each test case's description is preceded by a blank line. Next is a line that contains integers n and m (1 ≤ n ≤ 2000; 1 ≤ m ≤ 2000) — the height and width of the board. This line followed by n lines, the i-th of which describes the i-th line of the board. Each of them is exactly m letters long and consists of symbols 'L', 'R', 'D' and 'U'.

It is guaranteed that the sum of sizes of all boards in the input does not exceed 4⋅10^6.

Output

For each test case, output three integers r, c and d (1 ≤ r ≤ n; 1 ≤ c ≤ m; d ≥ 0), which denote that the robot should start moving from cell (r, c) to make the maximum number of moves d. If there are several answers, output any of them.

Example

Input


7

1 1
R

1 3
RRL

2 2
DL
RU

2 2
UD
RU

3 2
DL
UL
RU

4 4
RRRD
RUUD
URUD
ULLR

4 4
DDLU
RDDU
UUUU
RDLD


Output


1 1 1
1 1 3
1 1 4
2 1 3
3 1 5
4 3 12
1 1 4

EXAMPLE QUESTIONS:
Example question 1:
Name: p02196 Queries with Six Inequeties
Tags: ['']
Description: Queries with Six Inequeties

Given a set of four integer pairs (a, b, c, d).

The jth query determines if i exists, x_j <a_i <y_j <b_i and z_j <c_i <w_j <d_i.

input


N Q
a_1 b_1 c_1 d_1
a_2 b_2 c_2 d_2
::
a_n b_n c_n d_n
x_1 y_1 z_1 w_1
x_2 y_2 z_2 w_2
::
x_q y_q z_q w_q


output


ans_1
ans_2
::
ans_q


On line j, print the answer to the jth query.

If the subscript i that satisfies the condition exists, `Yes` is output, and if it does not exist,` No` is output.

Constraint

* 1 \ leq N, Q \ leq 10 ^ 5
* 1 \ leq a_i <b_i \ leq 10 ^ 5
* 1 \ leq c_i <d_i \ leq 10 ^ 5
* 1 \ leq x_j <y_j \ leq 10 ^ 5
* 1 \ leq z_j <w_j \ leq 10 ^ 5



Input example


twenty two
14 86 9 121
3 34 3 34
1 14 5 14
1 9 1 9


Output example


No
Yes






Example

Input

2 2
14 86 9 121
3 34 3 34
1 14 5 14
1 9 1 9


Output

No
Yes
Difficulty: 0
Solutions: #include <bits/stdc++.h>
using namespace std;

using ll=long long;
//#define int ll

#define rng(i,a,b) for(int i=int(a);i<int(b);i++)
#define rep(i,b) rng(i,0,b)
#define gnr(i,a,b) for(int i=int(b)-1;i>=int(a);i--)
#define per(i,b) gnr(i,0,b)
#define pb push_back
#define eb emplace_back
#define a first
#define b second
#define bg begin()
#define ed end()
#define all(x) x.bg,x.ed
#ifdef LOCAL
#define dmp(x) cerr<<__LINE__<<" "<<#x<<" "<<x<<endl
#else
#define dmp(x) void(0)
#endif

template<class t,class u> void chmax(t&a,u b){if(a<b)a=b;}
template<class t,class u> void chmin(t&a,u b){if(b<a)a=b;}

template<class t> using vc=vector<t>;
template<class t> using vvc=vc<vc<t>>;

using pi=pair<int,int>;
using vi=vc<int>;

template<class t,class u>
ostream& operator<<(ostream& os,const pair<t,u>& p){
	return os<<"{"<<p.a<<","<<p.b<<"}";
}

template<class t> ostream& operator<<(ostream& os,const vc<t>& v){
	os<<"{";
	for(auto e:v)os<<e<<",";
	return os<<"}";
}

#define mp make_pair
#define mt make_tuple
#define one(x) memset(x,-1,sizeof(x))
#define zero(x) memset(x,0,sizeof(x))
#ifdef LOCAL
void dmpr(ostream&os){os<<endl;}
template<class T,class... Args>
void dmpr(ostream&os,const T&t,const Args&... args){
	os<<t<<" ";
	dmpr(os,args...);
}
#define dmp2(...) dmpr(cerr,"Line:",__LINE__,##__VA_ARGS__)
#else
#define dmp2(...) void(0)
#endif

using uint=unsigned;
using ull=unsigned long long;

template<class t,size_t n>
ostream& operator<<(ostream&os,const array<t,n>&a){
	return os<<vc<t>(all(a));
}

template<int i,class T>
void print_tuple(ostream&,const T&){
}

template<int i,class T,class H,class ...Args>
void print_tuple(ostream&os,const T&t){
	if(i)os<<",";
	os<<get<i>(t);
	print_tuple<i+1,T,Args...>(os,t);
}

template<class ...Args>
ostream& operator<<(ostream&os,const tuple<Args...>&t){
	os<<"{";
	print_tuple<0,tuple<Args...>,Args...>(os,t);
	return os<<"}";
}

void print(ll x,int suc=1){
	cout<<x;
	if(suc==1)
		cout<<"\n";
	if(suc==2)
		cout<<" ";
}

ll read(){
	ll i;
	cin>>i;
	return i;
}

vi readvi(int n,int off=0){
	vi v(n);
	rep(i,n)v[i]=read()+off;
	return v;
}

template<class T>
void print(const vector<T>&v,int suc=1){
	rep(i,v.size())
		print(v[i],i==int(v.size())-1?suc:2);
}

string readString(){
	string s;
	cin>>s;
	return s;
}

template<class T>
T sq(const T& t){
	return t*t;
}

//#define CAPITAL
void yes(bool ex=true){
	#ifdef CAPITAL
	cout<<"YES"<<endl;
	#else
	cout<<"Yes"<<"\n";
	#endif
	if(ex)exit(0);
}
void no(bool ex=true){
	#ifdef CAPITAL
	cout<<"NO"<<endl;
	#else
	cout<<"No"<<"\n";
	#endif
	if(ex)exit(0);
}
void possible(bool ex=true){
	#ifdef CAPITAL
	cout<<"POSSIBLE"<<endl;
	#else
	cout<<"Possible"<<endl;
	#endif
	if(ex)exit(0);
}
void impossible(bool ex=true){
	#ifdef CAPITAL
	cout<<"IMPOSSIBLE"<<endl;
	#else
	cout<<"Impossible"<<endl;
	#endif
	if(ex)exit(0);
}

constexpr ll ten(int n){
	return n==0?1:ten(n-1)*10;
}

const ll infLL=LLONG_MAX/3;

#ifdef int
const int inf=infLL;
#else
const int inf=INT_MAX/2-100;
#endif

int topbit(signed t){
	return t==0?-1:31-__builtin_clz(t);
}
int topbit(ll t){
	return t==0?-1:63-__builtin_clzll(t);
}
int botbit(signed a){
	return a==0?32:__builtin_ctz(a);
}
int botbit(ll a){
	return a==0?64:__builtin_ctzll(a);
}
int popcount(signed t){
	return __builtin_popcount(t);
}
int popcount(ll t){
	return __builtin_popcountll(t);
}
bool ispow2(int i){
	return i&&(i&-i)==i;
}
int mask(int i){
	return (int(1)<<i)-1;
}

bool inc(int a,int b,int c){
	return a<=b&&b<=c;
}

template<class t> void mkuni(vc<t>&v){
	sort(all(v));
	v.erase(unique(all(v)),v.ed);
}

ll rand_int(ll l, ll r) { //[l, r]
	#ifdef LOCAL
	static mt19937_64 gen;
	#else
    static random_device rd;
    static mt19937_64 gen(rd());
    #endif
    return uniform_int_distribution<ll>(l, r)(gen);
}

template<class t>
int lwb(const vc<t>&v,const t&a){
	return lower_bound(all(v),a)-v.bg;
}

//CF Global3 H
//ARC073 F
//point update
template<class T,class F>
struct SegTree{
	vc<T> buf;
	int s;
	const F f;
	const T g;
	SegTree(F ff,T gg):f(ff),g(gg){}
	void init(const vc<T>& d){
		int n=d.size();
		s=1;
		while(s<n)s*=2;
		buf.resize(s*2,g);
		rep(i,n)
			buf[i+s]=d[i];
		gnr(i,1,s)
			u(i);
	}
	SegTree(const vc<T>& d,F ff,T gg):f(ff),g(gg){
		init(d);
	}
	void u(int i){
		buf[i]=f(buf[i*2],buf[i*2+1]);
	}
	void set(int i,T t){
		i+=s;
		buf[i]=t;
		while(i>>=1)u(i);
	}
	void upd(int i,T t){
		i+=s;
		buf[i]=f(buf[i],t);
		while(i>>=1)u(i);
	}
	T get(int b,int e,int l,int r,int i){
		if(e<=l||r<=b)return g;
		if(b<=l&&r<=e)return buf[i];
		int m=(l+r)/2;
		return f(get(b,e,l,m,i*2),get(b,e,m,r,i*2+1));
	}
	T get(int b,int e){
		return get(b,e,0,s,1);
	}
};

template<class t,class F>
struct Point1D{
	SegTree<t,F> seg;
	vi pos;
	const t g;
	Point1D(F ff,t gg):seg(ff,gg),g(gg){}
	void addp(int p){
		pos.pb(p);
	}
	void init(){
		mkuni(pos);
		seg.init(vc<t>(pos.size(),g));
	}
	int idx(int p){
		return lwb(pos,p);
	}
	//void addv(int p,t v){
	void updv(int p,t v){
		seg.upd(idx(p),v);
	}
	t get(int b,int e){
		return seg.get(idx(b),idx(e));
	}
};

template<class t,class F>
struct Point2D{
	vc<Point1D<t,F>> buf;
	vi pos,xs,ys;
	const F f;
	const t g;
	int s;
	Point2D(F ff,t gg):f(ff),g(gg){}
	void addp(int x,int y){
		xs.pb(x);
		ys.pb(y);
	}
	int idx(int p){
		return lwb(pos,p);
	}
	void init(){
		pos=xs;
		mkuni(pos);
		s=1;
		while(s<(int)pos.size())s*=2;
		//buf.resize(s*2,Point1D<t,F>(f,g));
		rep(i,s*2)buf.emplace_back(f,g);
		rep(i,xs.size()){
			int j=lwb(pos,xs[i])+s;
			while(j>=1){
				buf[j].addp(ys[i]);
				j>>=1;
			}
		}
		for(auto&b:buf)b.init();
	}
	void updv(int x,int y,t v){
		int j=idx(x)+s;
		while(j>=1){
			buf[j].updv(y,v);
			j>>=1;
		}
	}
	t get(int b,int e,int p,int q,int l,int r,int i){
		if(e<=l||r<=b)return g;
		if(b<=l&&r<=e)return buf[i].get(p,q);
		int m=(l+r)/2;
		return f(get(b,e,p,q,l,m,i*2),get(b,e,p,q,m,r,i*2+1));
	}
	//[x1,x2)*[y1,y2)
	t get(int x1,int x2,int y1,int y2){
		return get(idx(x1),idx(x2),y1,y2,0,s,1);
	}
};

struct rect{
	int a,b,c,d;
	void init(){
		cin>>a>>b>>c>>d;
	}
};

struct query{
	int y,t,i;
	bool operator<(const query&q)const{
		if(y!=q.y)return y>q.y;
		return t<q.t;
	}
};

signed main(){
	cin.tie(0);
	ios::sync_with_stdio(0);
	cout<<fixed<<setprecision(20);
	
	int n,q;cin>>n>>q;
	
	vc<rect> x(n),y(q);
	auto imax=[&](int a,int b){
		return max(a,b);
	};
	vc<query> qs;
	Point2D<int,decltype(imax)> p2(imax,-inf);
	rep(i,n){
		x[i].init();
		p2.addp(x[i].a,x[i].c);
		qs.pb({x[i].d,1,i});
	}
	rep(i,q){
		y[i].init();
		qs.pb({y[i].d,0,i});
	}
	p2.init();
	vi ans(q);
	sort(all(qs));
	for(auto z:qs){
		int i=z.i;
		if(z.t==0){
			int mx=p2.get(y[i].a+1,y[i].b,y[i].c+1,y[i].d);
			dmp(mx);
			ans[i]=y[i].b<mx;
		}else{
			p2.updv(x[i].a,x[i].c,x[i].b);
		}
	}
	rep(i,q)
		if(ans[i])
			yes(0);
		else
			no(0);
}



Example question 2:
Name: sherlock-and-xor
Tags: []
Description: You are given an array A1,A2...AN. You have to tell how many pairs (i, j) exist such that 1 ≤ i < j ≤ N and Ai XOR Aj is odd.      

Input and Output 
First line T, the number of testcases. Each testcase: first line N, followed by N integers in next line. For each testcase, print the required answer in one line.       

Constraints 
1 ≤ T ≤ 10 
1 ≤ N ≤ 10^5 
0 ≤ Ai ≤ 10^9

SAMPLE INPUT
2
3
1 2 3
4
1 2 3 4

SAMPLE OUTPUT
2
4

Explanation

For first testcase: 1 XOR 2 is 3 and 2 XOR 3 is 1. So, 2 valid pairs.
For second testcase: 1 XOR 2 is 3 and 2 XOR 3 is 1 and 1 XOR 4 is 5 and 3 XOR 4 is 7. So, 4 valid pairs.
Difficulty: 0
Solutions: t=input()
for j in range(t):
	n=input()
	res=sum(int(i)%2 for i in raw_input().split())
	print res*(n-res)


INSTRUCTIONS:
Solve the current question.
Provide:
1. A complete and efficient code solution, optimized for both time and space complexity.
2. A detailed explanation of the solution, including:
   - The intuition behind the approach;
   - Time and space complexity;
   - Important considerations about the algorithm.
3. You can use the example questions as general references for coding patterns and structure, but solve the current problem independently.
4. Don't use any external libraries. Any language is accepted.