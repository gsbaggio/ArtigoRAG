CURRENT QUESTION:
The robot is located on a checkered rectangular board of size n × m (n rows, m columns). The rows in the board are numbered from 1 to n from top to bottom, and the columns — from 1 to m from left to right.

The robot is able to move from the current cell to one of the four cells adjacent by side.

Each cell has one of the symbols 'L', 'R', 'D' or 'U' written on it, indicating the direction in which the robot will move when it gets in that cell — left, right, down or up, respectively.

The robot can start its movement in any cell. He then moves to the adjacent square in the direction indicated on the current square in one move. 

  * If the robot moves beyond the edge of the board, it falls and breaks. 
  * If the robot appears in the cell it already visited before, it breaks (it stops and doesn't move anymore). 



Robot can choose any cell as the starting cell. Its goal is to make the maximum number of steps before it breaks or stops.

Determine from which square the robot should start its movement in order to execute as many commands as possible. A command is considered successfully completed if the robot has moved from the square on which that command was written (it does not matter whether to another square or beyond the edge of the board).

Input

The first line contains an integer t (1 ≤ t ≤ 10000) — the number of test cases in the test.

Each test case's description is preceded by a blank line. Next is a line that contains integers n and m (1 ≤ n ≤ 2000; 1 ≤ m ≤ 2000) — the height and width of the board. This line followed by n lines, the i-th of which describes the i-th line of the board. Each of them is exactly m letters long and consists of symbols 'L', 'R', 'D' and 'U'.

It is guaranteed that the sum of sizes of all boards in the input does not exceed 4⋅10^6.

Output

For each test case, output three integers r, c and d (1 ≤ r ≤ n; 1 ≤ c ≤ m; d ≥ 0), which denote that the robot should start moving from cell (r, c) to make the maximum number of moves d. If there are several answers, output any of them.

Example

Input


7

1 1
R

1 3
RRL

2 2
DL
RU

2 2
UD
RU

3 2
DL
UL
RU

4 4
RRRD
RUUD
URUD
ULLR

4 4
DDLU
RDDU
UUUU
RDLD


Output


1 1 1
1 1 3
1 1 4
2 1 3
3 1 5
4 3 12
1 1 4

EXAMPLE QUESTIONS:
Example question 1:
Name: 164_B. Ancient Berland Hieroglyphs
Tags: ['two pointers']
Description: Polycarpus enjoys studying Berland hieroglyphs. Once Polycarp got hold of two ancient Berland pictures, on each of which was drawn a circle of hieroglyphs. We know that no hieroglyph occurs twice in either the first or the second circle (but in can occur once in each of them).

Polycarpus wants to save these pictures on his laptop, but the problem is, laptops do not allow to write hieroglyphs circles. So Polycarp had to break each circle and write down all of its hieroglyphs in a clockwise order in one line. A line obtained from the first circle will be called a, and the line obtained from the second one will be called b.

There are quite many ways to break hieroglyphic circles, so Polycarpus chooses the method, that makes the length of the largest substring of string a, which occurs as a subsequence in string b, maximum.

Help Polycarpus — find the maximum possible length of the desired substring (subsequence) if the first and the second circles are broken optimally.

The length of string s is the number of characters in it. If we denote the length of string s as |s|, we can write the string as s = s1s2... s|s|.

A substring of s is a non-empty string x = s[a... b] = sasa + 1... sb (1 ≤ a ≤ b ≤ |s|). For example, "code" and "force" are substrings of "codeforces", while "coders" is not. 

A subsequence of s is a non-empty string y = s[p1p2... p|y|] = sp1sp2... sp|y| (1 ≤ p1 < p2 < ... < p|y| ≤ |s|). For example, "coders" is a subsequence of "codeforces".

Input

The first line contains two integers la and lb (1 ≤ la, lb ≤ 1000000) — the number of hieroglyphs in the first and second circles, respectively.

Below, due to difficulties with encoding of Berland hieroglyphs, they are given as integers from 1 to 106.

The second line contains la integers — the hieroglyphs in the first picture, in the clockwise order, starting with one of them.

The third line contains lb integers — the hieroglyphs in the second picture, in the clockwise order, starting with one of them.

It is guaranteed that the first circle doesn't contain a hieroglyph, which occurs twice. The second circle also has this property.

Output

Print a single number — the maximum length of the common substring and subsequence. If at any way of breaking the circles it does not exist, print 0.

Examples

Input

5 4
1 2 3 4 5
1 3 5 6


Output

2


Input

4 6
1 3 5 2
1 2 3 4 5 6


Output

3


Input

3 3
1 2 3
3 2 1


Output

2

Note

In the first test Polycarpus picks a string that consists of hieroglyphs 5 and 1, and in the second sample — from hieroglyphs 1, 3 and 5.
Difficulty: 8
Solutions: #include <bits/stdc++.h>
using namespace std;
int a, b;
int L1[1 << 20], L2[1 << 20];
int pos[1 << 20];
int res = 0;
int main() {
  memset(pos, -1, sizeof(pos));
  scanf("%d%d", &a, &b);
  for (int i = 0; i < a; ++i) scanf("%d", &L1[i]);
  for (int i = 0; i < b; ++i) {
    scanf("%d", &L2[i]);
    pos[L2[i]] = i;
  }
  int cur = -1;
  int len = 0;
  for (int i = 0; i < a; ++i) {
    if (pos[L1[i]] == -1) {
      cur = -1;
      continue;
    }
    if (cur == -1) {
      cur = i;
      len = 1;
    }
    while (1) {
      if (pos[L1[(cur + 1) % a]] == -1) break;
      int dist = pos[L1[(cur + 1) % a]] - pos[L1[cur]];
      if (dist <= 0) dist += b;
      int p = pos[L1[i]] - pos[L1[cur]];
      if (p <= 0) p += b;
      if (dist >= p) break;
      cur = (cur + 1) % a;
      len++;
    }
    res = max(res, len);
    len--;
  }
  cout << res << endl;
  return 0;
}


Example question 2:
Name: 875_B. Sorting the Coins
Tags: ['dsu', 'implementation', 'sortings', 'two pointers']
Description: Recently, Dima met with Sasha in a philatelic store, and since then they are collecting coins together. Their favorite occupation is to sort collections of coins. Sasha likes having things in order, that is why he wants his coins to be arranged in a row in such a way that firstly come coins out of circulation, and then come coins still in circulation. 

For arranging coins Dima uses the following algorithm. One step of his algorithm looks like the following:

  1. He looks through all the coins from left to right; 
  2. If he sees that the i-th coin is still in circulation, and (i + 1)-th coin is already out of circulation, he exchanges these two coins and continues watching coins from (i + 1)-th. 



Dima repeats the procedure above until it happens that no two coins were exchanged during this procedure. Dima calls hardness of ordering the number of steps required for him according to the algorithm above to sort the sequence, e.g. the number of times he looks through the coins from the very beginning. For example, for the ordered sequence hardness of ordering equals one.

Today Sasha invited Dima and proposed him a game. First he puts n coins in a row, all of them are out of circulation. Then Sasha chooses one of the coins out of circulation and replaces it with a coin in circulation for n times. During this process Sasha constantly asks Dima what is the hardness of ordering of the sequence. 

The task is more complicated because Dima should not touch the coins and he should determine hardness of ordering in his mind. Help Dima with this task. 

Input

The first line contains single integer n (1 ≤ n ≤ 300 000) — number of coins that Sasha puts behind Dima.

Second line contains n distinct integers p1, p2, ..., pn (1 ≤ pi ≤ n) — positions that Sasha puts coins in circulation to. At first Sasha replaces coin located at position p1, then coin located at position p2 and so on. Coins are numbered from left to right.

Output

Print n + 1 numbers a0, a1, ..., an, where a0 is a hardness of ordering at the beginning, a1 is a hardness of ordering after the first replacement and so on. 

Examples

Input

4
1 3 4 2


Output

1 2 3 2 1


Input

8
6 8 3 4 7 2 1 5


Output

1 2 2 3 4 3 4 5 1

Note

Let's denote as O coin out of circulation, and as X — coin is circulation.

At the first sample, initially in row there are coins that are not in circulation, so Dima will look through them from left to right and won't make any exchanges.

After replacement of the first coin with a coin in circulation, Dima will exchange this coin with next three times and after that he will finally look through the coins and finish the process.

XOOO →  OOOX

After replacement of the third coin, Dima's actions look this way:

XOXO →  OXOX →  OOXX

After replacement of the fourth coin, Dima's actions look this way:

XOXX →  OXXX

Finally, after replacement of the second coin, row becomes consisting of coins that are in circulation and Dima will look through coins from left to right without any exchanges.
Difficulty: 8
Solutions: #include <bits/stdc++.h>
using namespace std;
int n, i, R, x, c[333333];
void add(int x) {
  for (; x; x -= x & -x) c[x]++;
}
int qu(int x) {
  if (!x) return 0;
  int V = 0;
  for (; x <= n; x += x & -x) V += c[x];
  return V;
}
int main() {
  scanf("%d", &n);
  R = n;
  printf("1");
  for (int i = 1; i <= n; i++) {
    scanf("%d", &x);
    add(x);
    for (; qu(R) == n - R + 1 && R; R--)
      ;
    printf(" %d", i - (n - R) + 1);
  }
}


Example question 3:
Name: 919_C. Seat Arrangements
Tags: ['brute force', 'implementation']
Description: Suppose that you are in a campus and have to go for classes day by day. As you may see, when you hurry to a classroom, you surprisingly find that many seats there are already occupied. Today you and your friends went for class, and found out that some of the seats were occupied.

The classroom contains n rows of seats and there are m seats in each row. Then the classroom can be represented as an n × m matrix. The character '.' represents an empty seat, while '*' means that the seat is occupied. You need to find k consecutive empty seats in the same row or column and arrange those seats for you and your friends. Your task is to find the number of ways to arrange the seats. Two ways are considered different if sets of places that students occupy differs.

Input

The first line contains three positive integers n,m,k (1 ≤ n, m, k ≤ 2 000), where n,m represent the sizes of the classroom and k is the number of consecutive seats you need to find.

Each of the next n lines contains m characters '.' or '*'. They form a matrix representing the classroom, '.' denotes an empty seat, and '*' denotes an occupied seat.

Output

A single number, denoting the number of ways to find k empty seats in the same row or column.

Examples

Input

2 3 2
**.
...


Output

3


Input

1 2 2
..


Output

1


Input

3 3 4
.*.
*.*
.*.


Output

0

Note

In the first sample, there are three ways to arrange those seats. You can take the following seats for your arrangement. 

  * (1,3), (2,3) 
  * (2,2), (2,3) 
  * (2,1), (2,2) 
Difficulty: 9
Solutions: '''input
1 10 1
..........
'''
n,m,k = map(int,raw_input().split())
arr = []
for i in range(n):
	tmp = list(raw_input().strip())
	arr.append(tmp)
ans = 0
for i in range(n):
	cnt = 0
	tmp = []
	for j in range(m):
		if arr[i][j] == '.':
			cnt += 1
		else:
			if cnt >= k:
				tmp.append(cnt)
			cnt = 0
	if cnt >= k:
		tmp.append(cnt)
	for o in tmp:
		ans += (o-k+1)
for i in range(m):
	cnt = 0
	tmp = []
	for j in range(n):
		if arr[j][i] == '.':
			cnt += 1
		else:
			if cnt >= k:
				tmp.append(cnt)
			cnt = 0
	if cnt >= k:
		tmp.append(cnt)
	for o in tmp:
		ans += (o-k+1)
if k == 1:
	print ans//2
else:
	print ans




INSTRUCTIONS:
Solve the current question.
Provide:
1. A complete and efficient code solution, optimized for both time and space complexity.
2. A detailed explanation of the solution, including:
   - The intuition behind the approach;
   - Time and space complexity;
   - Important considerations about the algorithm.
3. If the language has classes, implement in 'Solution' class. Any language is accepted.
4. You can use the example questions as general references for coding patterns and structure, but solve the current problem independently.
5. Don't use any external libraries. Don't need to import any libraries.
