import collections
import sys

def main():
    data = sys.stdin.read().splitlines()
    t = int(data[0].strip())
    index = 1
    results = []
    for _ in range(t):
        # Skip blank lines
        while index < len(data) and data[index].strip() == "":
            index += 1
        if index >= len(data):
            break
        n_m_line = data[index].split()
        index += 1
        n = int(n_m_line[0])
        m = int(n_m_line[1])
        grid = []
        for i in range(n):
            grid.append(data[index].strip())
            index += 1
        
        next_node = [[(-1, -1) for j in range(m)] for i in range(n)]
        prev = [[[] for j in range(m)] for i in range(n)]
        
        for i in range(n):
            for j in range(m):
                ch = grid[i][j]
                ni, nj = i, j
                if ch == 'L':
                    nj -= 1
                elif ch == 'R':
                    nj += 1
                elif ch == 'U':
                    ni -= 1
                elif ch == 'D':
                    ni += 1
                if 0 <= ni < n and 0 <= nj < m:
                    next_node[i][j] = (ni, nj)
                else:
                    next_node[i][j] = (-1, -1)
        
        for i in range(n):
            for j in range(m):
                if next_node[i][j] != (-1, -1):
                    ni, nj = next_node[i][j]
                    prev[ni][nj].append((i, j))
        
        dist = [[-1] * m for _ in range(n)]
        Q = collections.deque()
        
        for i in range(n):
            for j in range(m):
                if next_node[i][j] == (-1, -1):
                    dist[i][j] = 1
                    Q.append((i, j))
                    
        while Q:
            i, j = Q.popleft()
            for (x, y) in prev[i][j]:
                if dist[x][y] == -1:
                    dist[x][y] = dist[i][j] + 1
                    Q.append((x, y))
                    
        for i in range(n):
            for j in range(m):
                if dist[i][j] == -1:
                    path = []
                    path_index = {}
                    cur = (i, j)
                    while dist[cur[0]][cur[1]] == -1 and cur not in path_index:
                        path_index[cur] = len(path)
                        path.append(cur)
                        cur = next_node[cur[0]][cur[1]]
                    if cur in path_index:
                        idx = path_index[cur]
                        cycle_len = len(path) - idx
                        for k in range(idx, len(path)):
                            node = path[k]
                            if dist[node[0]][node[1]] == -1:
                                dist[node[0]][node[1]] = cycle_len
                                Q.append(node)
        
        while Q:
            i, j = Q.popleft()
            for (x, y) in prev[i][j]:
                if dist[x][y] == -1:
                    dist[x][y] = dist[i][j] + 1
                    Q.append((x, y))
                    
        max_d = 0
        max_i, max_j = 0, 0
        for i in range(n):
            for j in range(m):
                if dist[i][j] > max_d:
                    max_d = dist[i][j]
                    max_i, max_j = i, j
                    
        results.append(f"{max_i+1} {max_j+1} {max_d}")
    
    for res in results:
        print(res)

if __name__ == "__main__":
    main()