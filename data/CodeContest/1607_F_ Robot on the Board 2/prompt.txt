CURRENT QUESTION:
The robot is located on a checkered rectangular board of size n × m (n rows, m columns). The rows in the board are numbered from 1 to n from top to bottom, and the columns — from 1 to m from left to right.

The robot is able to move from the current cell to one of the four cells adjacent by side.

Each cell has one of the symbols 'L', 'R', 'D' or 'U' written on it, indicating the direction in which the robot will move when it gets in that cell — left, right, down or up, respectively.

The robot can start its movement in any cell. He then moves to the adjacent square in the direction indicated on the current square in one move. 

  * If the robot moves beyond the edge of the board, it falls and breaks. 
  * If the robot appears in the cell it already visited before, it breaks (it stops and doesn't move anymore). 



Robot can choose any cell as the starting cell. Its goal is to make the maximum number of steps before it breaks or stops.

Determine from which square the robot should start its movement in order to execute as many commands as possible. A command is considered successfully completed if the robot has moved from the square on which that command was written (it does not matter whether to another square or beyond the edge of the board).

Input

The first line contains an integer t (1 ≤ t ≤ 10000) — the number of test cases in the test.

Each test case's description is preceded by a blank line. Next is a line that contains integers n and m (1 ≤ n ≤ 2000; 1 ≤ m ≤ 2000) — the height and width of the board. This line followed by n lines, the i-th of which describes the i-th line of the board. Each of them is exactly m letters long and consists of symbols 'L', 'R', 'D' and 'U'.

It is guaranteed that the sum of sizes of all boards in the input does not exceed 4⋅10^6.

Output

For each test case, output three integers r, c and d (1 ≤ r ≤ n; 1 ≤ c ≤ m; d ≥ 0), which denote that the robot should start moving from cell (r, c) to make the maximum number of moves d. If there are several answers, output any of them.

Example

Input


7

1 1
R

1 3
RRL

2 2
DL
RU

2 2
UD
RU

3 2
DL
UL
RU

4 4
RRRD
RUUD
URUD
ULLR

4 4
DDLU
RDDU
UUUU
RDLD


Output


1 1 1
1 1 3
1 1 4
2 1 3
3 1 5
4 3 12
1 1 4

SIMILAR QUESTIONS:
Similar question 1 (Similarity score: 0.77):
Name: 888_B. Buggy Robot
Tags: ['greedy']
Description: Ivan has a robot which is situated on an infinite grid. Initially the robot is standing in the starting cell (0, 0). The robot can process commands. There are four types of commands it can perform:

  * U — move from the cell (x, y) to (x, y + 1); 
  * D — move from (x, y) to (x, y - 1); 
  * L — move from (x, y) to (x - 1, y); 
  * R — move from (x, y) to (x + 1, y). 



Ivan entered a sequence of n commands, and the robot processed it. After this sequence the robot ended up in the starting cell (0, 0), but Ivan doubts that the sequence is such that after performing it correctly the robot ends up in the same cell. He thinks that some commands were ignored by robot. To acknowledge whether the robot is severely bugged, he needs to calculate the maximum possible number of commands that were performed correctly. Help Ivan to do the calculations!

Input

The first line contains one number n — the length of sequence of commands entered by Ivan (1 ≤ n ≤ 100).

The second line contains the sequence itself — a string consisting of n characters. Each character can be U, D, L or R.

Output

Print the maximum possible number of commands from the sequence the robot could perform to end up in the starting cell.

Examples

Input

4
LDUR


Output

4


Input

5
RRRUU


Output

0


Input

6
LLRRRR


Output

4
Difficulty: 8
Solutions: import java.util.*;
import java.io.*;
public class solution
{
	static int min(int a,int b)
	{
		if(a>b)
		{
			return b;
		}
		return a;
	}
	public static void main(String args[])
	{
		Scanner sc = new Scanner(System.in);
		int n = sc.nextInt();
		String s = sc.next();
		int l = 0;
		int r = 0;
		int u = 0;
		int d = 0;
		for(int i=0;i<s.length();i++)
		{
			char c = s.charAt(i);
			switch(c)
			{
				case 'L':
				l++;
				break;
				case 'R':
				r++;
				break;
				case 'U':
				u++;
				break;
				case 'D':
				d++;
				break;
			}
		}
		System.out.println(2*(min(u,d)+min(l,r)));
	}
}

Similar question 2 (Similarity score: 0.76):
Name: 1467_D. Sum of Paths
Tags: ['combinatorics', 'dp', 'math']
Description: There are n cells, numbered 1,2,..., n from left to right. You have to place a robot at any cell initially. The robot must make exactly k moves.

In one move, the robot must move one cell to the left or right, provided that it doesn't move out of bounds. In other words, if the robot was in the cell i, it must move to either the cell i-1 or the cell i+1, as long as it lies between 1 and n (endpoints inclusive). The cells, in the order they are visited (including the cell the robot is placed), together make a good path.

Each cell i has a value a_i associated with it. Let c_0, c_1, ..., c_k be the sequence of cells in a good path in the order they are visited (c_0 is the cell robot is initially placed, c_1 is the cell where the robot is after its first move, and so on; more formally, c_i is the cell that the robot is at after i moves). Then the value of the path is calculated as a_{c_0} + a_{c_1} + ... + a_{c_k}.

Your task is to calculate the sum of values over all possible good paths. Since this number can be very large, output it modulo 10^9 + 7. Two good paths are considered different if the starting cell differs or there exists an integer i ∈ [1, k] such that the current cell of the robot after exactly i moves is different in those paths.

You must process q updates to a and print the updated sum each time. Each update changes the value of exactly one cell. See the input format and the sample input-output for more details.

Input

The first line of the input contains three space-separated integers n, k and q (2 ≤ n ≤ 5000; 1 ≤ k ≤ 5000; 1 ≤ q ≤ 2 ⋅ 10^5).

The second line of the input contains n integers a_1, a_2, ..., a_n (1 ≤ a_i ≤ 10^9).

q lines follow. Each line contains two space-separated integers i and x (1 ≤ i ≤ n; 1 ≤ x ≤ 10^9) indicating that you must change the value of a_i to x.

Output

Print q integers. The i-th integer should be the sum of values over all good paths after the first i updates are performed. Since the answers may be large, print them modulo 10^9 + 7.

Examples

Input


5 1 5
3 5 1 4 2
1 9
2 4
3 6
4 6
5 2


Output


62
58
78
86
86


Input


5 2 5
3 5 1 4 2
1 9
2 4
3 6
4 6
5 2


Output


157
147
207
227
227


Input


4 40 6
92 21 82 46
3 56
1 72
4 28
1 97
2 49
2 88


Output


239185261
666314041
50729936
516818968
766409450
756910476

Note

In the first example, the good paths are (1, 2), (2, 1), (2, 3), (3, 2), (3, 4), (4, 3), (4, 5), (5, 4).

Initially the values of a are [3, 5, 1, 4, 2]. After the first update, they become [9, 5, 1, 4, 2]. After the second update, they become [9, 4, 1, 4, 2], and so on.
Difficulty: 10
Solutions: #include<cstdio>
#include<algorithm>
#include<vector>
#include<queue>
#include<set>
using namespace std;
typedef long long ll;
const int N = 5005;
const int p = 1e9 + 7;

int n, k, q;
int a[N];
ll ans;
ll num[N], dp[N][N];

int main(){
    scanf("%d%d%d", &n, &k, &q);  ++k;
    for(int i = 1; i <= n; ++i)  scanf("%d", &a[i]);
    for(int i = 1; i <= k; ++i)
        for(int t = 1; t <= n; ++t)
            dp[t][i] = (i == 1 ? 1 : (dp[t - 1][i - 1] + dp[t + 1][i - 1]) % p);
    for(int i = 1; i <= n; ++i){
        for(int t = 1; t <= k; ++t){
            num[i] = (num[i] + dp[i][t] * dp[i][k - t + 1]) % p;
		}
        ans = (ans + a[i] * num[i]) % p;
    }
    //for(int i = 1; i <= k; ++i)  printf("%lld ", dp[2][i]);puts("kk");
    for(int i = 1, id, x; i <= q; ++i){
        scanf("%d%d", &id, &x);
        ans = (ans + 1LL * (x - a[id]) * num[id] % p + p) % p;
        a[id] = x;
        printf("%lld\n", ans);
    }
    return 0;
}

Similar question 3 (Similarity score: 0.75):
Name: 1202_C. You Are Given a WASD-string...
Tags: ['brute force', 'data structures', 'dp', 'greedy', 'implementation', 'math', 'strings']
Description: You have a string s — a sequence of commands for your toy robot. The robot is placed in some cell of a rectangular grid. He can perform four commands:

  * 'W' — move one cell up; 
  * 'S' — move one cell down; 
  * 'A' — move one cell left; 
  * 'D' — move one cell right. 



Let Grid(s) be the grid of minimum possible area such that there is a position in the grid where you can place the robot in such a way that it will not fall from the grid while running the sequence of commands s. For example, if s = DSAWWAW then Grid(s) is the 4 × 3 grid:

  1. you can place the robot in the cell (3, 2); 
  2. the robot performs the command 'D' and moves to (3, 3); 
  3. the robot performs the command 'S' and moves to (4, 3); 
  4. the robot performs the command 'A' and moves to (4, 2); 
  5. the robot performs the command 'W' and moves to (3, 2); 
  6. the robot performs the command 'W' and moves to (2, 2); 
  7. the robot performs the command 'A' and moves to (2, 1); 
  8. the robot performs the command 'W' and moves to (1, 1). 

<image>

You have 4 extra letters: one 'W', one 'A', one 'S', one 'D'. You'd like to insert at most one of these letters in any position of sequence s to minimize the area of Grid(s).

What is the minimum area of Grid(s) you can achieve?

Input

The first line contains one integer T (1 ≤ T ≤ 1000) — the number of queries.

Next T lines contain queries: one per line. This line contains single string s (1 ≤ |s| ≤ 2 ⋅ 10^5, s_i ∈ \{W, A, S, D\}) — the sequence of commands.

It's guaranteed that the total length of s over all queries doesn't exceed 2 ⋅ 10^5.

Output

Print T integers: one per query. For each query print the minimum area of Grid(s) you can achieve.

Example

Input


3
DSAWWAW
D
WA


Output


8
2
4

Note

In the first query you have to get string DSAWW\underline{D}AW.

In second and third queries you can not decrease the area of Grid(s).
Difficulty: 9
Solutions: #include <bits/stdc++.h>
using namespace std;
const int maxs = 200000;
const char dbuf[] = "DWAS";
const int dx[] = {1, 0, -1, 0};
const int dy[] = {0, 1, 0, -1};
char s[maxs + 1];
int xv[maxs + 1];
int yv[maxs + 1];
int lprv[maxs + 1];
int bprv[maxs + 1];
int rprv[maxs + 1];
int tprv[maxs + 1];
int lnxt[maxs + 1];
int bnxt[maxs + 1];
int rnxt[maxs + 1];
int tnxt[maxs + 1];
int main() {
  ios::sync_with_stdio(false);
  cin.tie(nullptr);
  cout.tie(nullptr);
  int T;
  cin >> T;
  for (int TN = 0; TN < T; TN++) {
    cin >> s;
    int n = strlen(s);
    xv[0] = 0;
    yv[0] = 0;
    for (int i = 0; i < n; i++) {
      int d = find(dbuf, dbuf + 4, s[i]) - dbuf;
      xv[i + 1] = xv[i] + dx[d];
      yv[i + 1] = yv[i] + dy[d];
    }
    lprv[0] = rprv[0] = xv[0];
    bprv[0] = tprv[0] = yv[0];
    for (int i = 1; i <= n; i++) {
      lprv[i] = min(lprv[i - 1], xv[i]);
      bprv[i] = min(bprv[i - 1], yv[i]);
      rprv[i] = max(rprv[i - 1], xv[i]);
      tprv[i] = max(tprv[i - 1], yv[i]);
    }
    lnxt[n] = rnxt[n] = xv[n];
    bnxt[n] = tnxt[n] = yv[n];
    for (int i = n - 1; i >= 0; i--) {
      lnxt[i] = min(lnxt[i + 1], xv[i]);
      bnxt[i] = min(bnxt[i + 1], yv[i]);
      rnxt[i] = max(rnxt[i + 1], xv[i]);
      tnxt[i] = max(tnxt[i + 1], yv[i]);
    }
    long long ans = 0x7f7f7f7f7f7f7f7fll;
    for (int i = 0; i <= n; i++) {
      for (int d = 0; d < 4; d++) {
        int w =
            max(rprv[i], rnxt[i] + dx[d]) - min(lprv[i], lnxt[i] + dx[d]) + 1;
        int h =
            max(tprv[i], tnxt[i] + dy[d]) - min(bprv[i], bnxt[i] + dy[d]) + 1;
        ans = min(ans, (long long)w * h);
      }
    }
    cout << ans << '\n';
  }
  return 0;
}



INSTRUCTIONS:
Solve the current question.
Provide:
1. A complete and efficient code solution, optimized for both time and space complexity.
2. A detailed explanation of the solution, including:
   - The intuition behind the approach;
   - Time and space complexity;
   - Important considerations about the algorithm.
3. If the language has classes, implement in 'Solution' class. Any language is accepted.
4. Use the similar questions as references to improve the solution, but only if they are relevant.
5. Don't use any external libraries. Don't need to import any libraries.
