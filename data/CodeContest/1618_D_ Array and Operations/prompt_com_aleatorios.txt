CURRENT QUESTION:
You are given an array a of n integers, and another integer k such that 2k ≤ n.

You have to perform exactly k operations with this array. In one operation, you have to choose two elements of the array (let them be a_i and a_j; they can be equal or different, but their positions in the array must not be the same), remove them from the array, and add ⌊ (a_i)/(a_j) ⌋ to your score, where ⌊ x/y ⌋ is the maximum integer not exceeding x/y.

Initially, your score is 0. After you perform exactly k operations, you add all the remaining elements of the array to the score.

Calculate the minimum possible score you can get.

Input

The first line of the input contains one integer t (1 ≤ t ≤ 500) — the number of test cases.

Each test case consists of two lines. The first line contains two integers n and k (1 ≤ n ≤ 100; 0 ≤ k ≤ ⌊ n/2 ⌋).

The second line contains n integers a_1, a_2, ..., a_n (1 ≤ a_i ≤ 2 ⋅ 10^5).

Output

Print one integer — the minimum possible score you can get.

Example

Input


5
7 3
1 1 1 2 1 3 1
5 1
5 5 5 5 5
4 2
1 3 3 7
2 0
4 2
9 2
1 10 10 1 10 2 7 10 3


Output


2
16
0
6
16

Note

Let's consider the example test.

In the first test case, one way to obtain a score of 2 is the following one:

  1. choose a_7 = 1 and a_4 = 2 for the operation; the score becomes 0 + ⌊ 1/2 ⌋ = 0, the array becomes [1, 1, 1, 1, 3]; 
  2. choose a_1 = 1 and a_5 = 3 for the operation; the score becomes 0 + ⌊ 1/3 ⌋ = 0, the array becomes [1, 1, 1]; 
  3. choose a_1 = 1 and a_2 = 1 for the operation; the score becomes 0 + ⌊ 1/1 ⌋ = 1, the array becomes [1]; 
  4. add the remaining element 1 to the score, so the resulting score is 2. 



In the second test case, no matter which operations you choose, the resulting score is 16.

In the third test case, one way to obtain a score of 0 is the following one:

  1. choose a_1 = 1 and a_2 = 3 for the operation; the score becomes 0 + ⌊ 1/3 ⌋ = 0, the array becomes [3, 7]; 
  2. choose a_1 = 3 and a_2 = 7 for the operation; the score becomes 0 + ⌊ 3/7 ⌋ = 0, the array becomes empty; 
  3. the array is empty, so the score doesn't change anymore. 



In the fourth test case, no operations can be performed, so the score is the sum of the elements of the array: 4 + 2 = 6.

EXAMPLE QUESTIONS:
Example question 1:
Name: 292_A. SMSC
Tags: ['implementation']
Description: Some large corporation where Polycarpus works has its own short message service center (SMSC). The center's task is to send all sorts of crucial information. Polycarpus decided to check the efficiency of the SMSC. 

For that, he asked to give him the statistics of the performance of the SMSC for some period of time. In the end, Polycarpus got a list of n tasks that went to the SMSC of the corporation. Each task was described by the time it was received by the SMSC and the number of text messages to send. More formally, the i-th task was described by two integers ti and ci — the receiving time (the second) and the number of the text messages, correspondingly.

Polycarpus knows that the SMSC cannot send more than one text message per second. The SMSC uses a queue to organize its work. Consider a time moment x, the SMSC work at that moment as follows:

  1. If at the time moment x the queue is not empty, then SMSC sends one message from the queue (SMSC gets the message from the head of the queue). Otherwise it doesn't send messages at the time moment x. 
  2. If at the time moment x SMSC receives a task, then it adds to the queue all the messages from this task (SMSC adds messages to the tail of the queue). Note, that the messages from the task cannot be send at time moment x. That's because the decision about sending message or not is made at point 1 before adding these messages to the queue. 



Given the information about all n tasks, Polycarpus wants to count two values: the time when the last text message was sent and the maximum size of the queue at some time. Help him count these two characteristics he needs to evaluate the efficiency of the SMSC.

Input

The first line contains a single integer n (1 ≤ n ≤ 103) — the number of tasks of the SMSC. Next n lines contain the tasks' descriptions: the i-th line contains two space-separated integers ti and ci (1 ≤ ti, ci ≤ 106) — the time (the second) when the i-th task was received and the number of messages to send, correspondingly.

It is guaranteed that all tasks were received at different moments of time. It is guaranteed that the tasks are sorted in the chronological order, that is, ti < ti + 1 for all integer i (1 ≤ i < n).

Output

In a single line print two space-separated integers — the time when the last text message was sent and the maximum queue size at a certain moment of time.

Examples

Input

2
1 1
2 1


Output

3 1


Input

1
1000000 10


Output

1000010 10


Input

3
3 3
4 3
5 3


Output

12 7

Note

In the first test sample: 

  * second 1: the first message has appeared in the queue, the queue's size is 1; 
  * second 2: the first message is sent, the second message has been received, the queue's size is 1; 
  * second 3: the second message is sent, the queue's size is 0, 



Thus, the maximum size of the queue is 1, the last message was sent at the second 3.
Difficulty: 7
Solutions: 

import java.io.BufferedReader;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.StringTokenizer;

public class SMSC {
	static int n;
	
	public static void main(String[] args){
		FastScanner sc = new FastScanner();
		n = sc.nextInt();
		long time = 0;
		long size = 0;
		long largestSize = 0;
		int[] remain = new int[n+1];
		int[] jobsArrive = new int[n+1];
		int[] jobsLength = new int[n+1];
		for(int i=0;i<n;i++){
			jobsArrive[i] = sc.nextInt();
			jobsLength[i] = sc.nextInt();
		}
		jobsArrive[n] = Integer.MAX_VALUE;
		
		time = jobsArrive[0];
		remain[0] = jobsLength[0];
		size = jobsLength[0];
		largestSize = size;
		int lastTask = 0;
		int curTask = 0;
		while(curTask != n){
			largestSize = Math.max(size, largestSize);
			long consumption = Math.min(remain[curTask], jobsArrive[lastTask+1]-time);
			size -= consumption;
			time += consumption;
			remain[curTask] -= consumption;
			if(remain[curTask] == 0){
				curTask++;
			}
			
			if(curTask != n && (curTask > lastTask || jobsArrive[lastTask+1] == time)){
				//get new job
				lastTask++;
				remain[lastTask] = jobsLength[lastTask];
				size += jobsLength[lastTask];
				time = jobsArrive[lastTask];
			}
		}
		System.out.println(time + " " + largestSize);
	}
	
	public static class FastScanner {
		BufferedReader br;
		StringTokenizer st;

		public FastScanner(String s) {
			try {
				br = new BufferedReader(new FileReader(s));
			} catch (FileNotFoundException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}
		}

		public FastScanner() {
			br = new BufferedReader(new InputStreamReader(System.in));
		}

		String nextToken() {
			while (st == null || !st.hasMoreElements()) {
				try {
					st = new StringTokenizer(br.readLine());
				} catch (IOException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}
			}
			return st.nextToken();
		}

		int nextInt() {
			return Integer.parseInt(nextToken());
		}

		long nextLong() {
			return Long.parseLong(nextToken());
		}

		double nextDouble() {
			return Double.parseDouble(nextToken());
		}
	}
}


Example question 2:
Name: 1355_D. Game With Array
Tags: ['constructive algorithms', 'math']
Description: Petya and Vasya are competing with each other in a new interesting game as they always do.

At the beginning of the game Petya has to come up with an array of N positive integers. Sum of all elements in his array should be equal to S. Then Petya has to select an integer K such that 0 ≤ K ≤ S.

In order to win, Vasya has to find a non-empty subarray in Petya's array such that the sum of all selected elements equals to either K or S - K. Otherwise Vasya loses.

You are given integers N and S. You should determine if Petya can win, considering Vasya plays optimally. If Petya can win, help him to do that.

Input

The first line contains two integers N and S (1 ≤ N ≤ S ≤ 10^{6}) — the required length of the array and the required sum of its elements.

Output

If Petya can win, print "YES" (without quotes) in the first line. Then print Petya's array in the second line. The array should contain N positive integers with sum equal to S. In the third line print K. If there are many correct answers, you can print any of them.

If Petya can't win, print "NO" (without quotes).

You can print each letter in any register (lowercase or uppercase).

Examples

Input


1 4


Output


YES
4
2

Input


3 4


Output


NO

Input


3 8


Output


YES
2 1 5
4
Difficulty: 10
Solutions: #include <bits/stdc++.h>
using namespace std;
int main() {
  int n, s;
  cin >> n >> s;
  if (2 * n <= s) {
    cout << "YES\n";
    for (int i = 0; i < n - 1; i++) {
      cout << 2 << ' ';
      s -= 2;
    }
    cout << s << '\n' << 1;
  } else {
    cout << "NO";
  }
  return 0;
}



INSTRUCTIONS:
Solve the current question.
Provide:
1. A complete and efficient code solution, optimized for both time and space complexity.
2. A detailed explanation of the solution, including:
   - The intuition behind the approach;
   - Time and space complexity;
   - Important considerations about the algorithm.
3. You can use the example questions as general references for coding patterns and structure, but solve the current problem independently.
4. Don't use any external libraries. Any language is accepted.