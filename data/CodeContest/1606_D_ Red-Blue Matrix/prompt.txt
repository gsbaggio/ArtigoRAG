CURRENT QUESTION:
You are given a matrix, consisting of n rows and m columns. The j-th cell of the i-th row contains an integer a_{ij}.

First, you have to color each row of the matrix either red or blue in such a way that at least one row is colored red and at least one row is colored blue.

Then, you have to choose an integer k (1 ≤ k < m) and cut the colored matrix in such a way that the first k columns become a separate matrix (the left matrix) and the last m-k columns become a separate matrix (the right matrix).

The coloring and the cut are called perfect if two properties hold: 

  * every red cell in the left matrix contains an integer greater than every blue cell in the left matrix; 
  * every blue cell in the right matrix contains an integer greater than every red cell in the right matrix. 



Find any perfect coloring and cut, or report that there are none.

Input

The first line contains a single integer t (1 ≤ t ≤ 1000) — the number of testcases.

Then the descriptions of t testcases follow.

The first line of each testcase contains two integers n and m (2 ≤ n, m ≤ 5 ⋅ 10^5; n ⋅ m ≤ 10^6) — the number of rows and the number of columns in the matrix, respectively.

The i-th of the next n lines contains m integers a_{i1}, a_{i2}, ..., a_{im} (1 ≤ a_{ij} ≤ 10^6).

The sum of n ⋅ m over all testcases doesn't exceed 10^6.

Output

For each testcase print an answer. If there are no perfect colorings and cuts in the matrix, then print "NO".

Otherwise, first, print "YES". Then a string, consisting of n characters: the i-th character should be 'R' if the i-th row is colored red and 'B' if it's colored blue. The string should contain at least one 'R' and at least one 'B'. Finally, print an integer k (1 ≤ k < m) — the number of columns from the left that are cut.

Example

Input


3
5 5
1 5 8 8 7
5 2 1 4 3
1 6 9 7 5
9 3 3 3 2
1 7 9 9 8
3 3
8 9 8
1 5 3
7 5 7
2 6
3 3 3 2 2 2
1 1 1 4 4 4


Output


YES
BRBRB 1
NO
YES
RB 3

Note

The coloring and the cut for the first testcase:

<image>

SIMILAR QUESTIONS:
Similar question 1 (Similarity score: 0.70):
Name: 1521_E. Nastia and a Beautiful Matrix
Tags: ['binary search', 'constructive algorithms', 'greedy']
Description: You like numbers, don't you? Nastia has a lot of numbers and she wants to share them with you! Isn't it amazing?

Let a_i be how many numbers i (1 ≤ i ≤ k) you have.

An n × n matrix is called beautiful if it contains all the numbers you have, and for each 2 × 2 submatrix of the original matrix is satisfied: 

  1. The number of occupied cells doesn't exceed 3; 
  2. The numbers on each diagonal are distinct. 



Make a beautiful matrix of minimum size.

Input

The first line contains a single integer t (1 ≤ t ≤ 10 000) — the number of test cases.

The first line of each test case contains 2 integers m and k (1 ≤ m, k ≤ 10^5) — how many numbers Nastia gave you and the length of the array a, respectively.

The second line of each test case contains k integers a_1, a_2, …, a_{k} (0 ≤ a_i ≤ m, a_1 + a_2 + … + a_{k} = m), where a_i is how many numbers i you have.

It's guaranteed that the sum of m and k in one test doesn't exceed 2 ⋅ 10^5.

Output

For each t test case print a single integer n — the size of the beautiful matrix.

In the next n lines print n integers b_{i, j} (0 ≤ b_{i, j} ≤ k; if position is empty, print b_{i, j} = 0) — the beautiful matrix b you made up. 

Example

Input


2
3 4
2 0 0 1
15 4
2 4 8 1


Output


2
4 1
0 1
5
3 0 0 2 2
3 2 3 3 0
0 1 0 4 0
3 0 0 0 0
2 1 3 3 3

Note

Note that 0 in this problem represents a blank, not a number.

Examples of possible answers for the first test case:

\begin{array}{cc} 1 & 1 \\\ 4 & 0 \\\ \end{array} \hspace{0,5cm} \begin{array}{cc} 1 & 4 \\\ 1 & 0 \\\ \end{array} \hspace{0,5cm} \begin{array}{cc} 4 & 0 \\\ 1 & 1 \\\ \end{array}

Examples of not beautiful matrices for the first test case:

\begin{array}{cc} 1 & 0 \\\ 4 & 1 \\\ \end{array} \hspace{0,5cm} \begin{array}{cc} 4 & 1 \\\ 7 & 1 \\\ \end{array} \hspace{0,5cm} \begin{array}{cc} 1 & 0 \\\ 4 & 0 \\\ \end{array}

The example of the not beautiful matrix for the second test case:

\begin{array}{cc} 3 & 4 & 0 & 2 & 2 \\\ 3 & 2 & 3 & 3 & 0 \\\ 0 & 1 & 0 & 0 & 0 \\\ 3 & 0 & 0 & 0 & 0 \\\ 2 & 1 & 3 & 3 & 3 \\\ \end{array}

Everything is okay, except the left-top submatrix contains 4 numbers.
Difficulty: 11
Solutions: #include <bits/stdc++.h>
using namespace std;
#define int long long
void read (int &x) {
    char ch = getchar(); x = 0; while (!isdigit(ch)) ch = getchar();
    while (isdigit(ch)) x = x * 10 + ch - 48, ch = getchar();
} const int N = 2e5 + 5, M = 2000, NN = N * 5;
int n, s, mx, a[N], res[M][M], sr, sb, sy, id[N];
pair<int, int> r[NN], b[NN], y[NN];
#define xx first
#define yy second
int get () {
    int l = 0, r = 1000, mid, res = 0;
    while (l <= r) {
        mid = l + r >> 1;
        if (s <= mid * mid - (mid / 2) * (mid / 2) && a[1] <= mid * ((mid + 1) / 2))
            res = mid, r = mid - 1;
        else l = mid + 1;
    }
    return res;
}
signed main() {
    int T; read (T);
    while (T--) {
        read (s), read (n); mx = 0;
        for (int i = 1; i <= n; ++i) {
            read (a[i]), id[i] = i;
            if (a[i] > a[mx]) mx = i;
        }
        id[1] = mx, id[mx] = 1; swap (a[1], a[mx]);
        int len = get (); sr = sb = sy = 0;
        for (int i = 2; i <= len; i += 2)
            for (int j = 1; j <= len; j += 2) r[++sr] = {i, j};
        for (int i = 1; i <= len; i += 2)
            for (int j = 1; j <= len; j += 2) b[++sb] = {i, j};
        for (int i = 1; i <= len; i += 2)
            for (int j = 2; j <= len; j += 2) y[++sy] = {i, j};
        for (int i = 1; i <= len; ++i)
            for (int j = 1; j <= len; ++j) res[i][j] = 0;
        for (int i = 1; i <= n; ++i) {
            for (int j = 1; j <= a[i]; ++j) {
                if (sr) res[r[sr].xx][r[sr].yy] = id[i], --sr;
                else if (sb) res[b[sb].xx][b[sb].yy] = id[i], --sb;
                else res[y[sy].xx][y[sy].yy] = id[i], --sy;
            }
        }
        printf ("%d\n", len);
        for (int i = 1; i <= len; ++i) {
            for (int j = 1; j <= len; ++j) printf ("%d ", res[i][j]); puts ("");
        }
    }
    return 0;
}



INSTRUCTIONS:
Solve the current question.
Provide:
1. A complete and efficient code solution, optimized for both time and space complexity.
2. A detailed explanation of the solution, including:
   - The intuition behind the approach;
   - Time and space complexity;
   - Important considerations about the algorithm.
3. If the language has classes, implement in 'Solution' class. Any language is accepted.
4. Use the similar questions as references to improve the solution, but only if they are relevant.
5. Don't use any external libraries. Don't need to import any libraries.
