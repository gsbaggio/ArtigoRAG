CURRENT QUESTION:
You are given a matrix, consisting of n rows and m columns. The j-th cell of the i-th row contains an integer a_{ij}.

First, you have to color each row of the matrix either red or blue in such a way that at least one row is colored red and at least one row is colored blue.

Then, you have to choose an integer k (1 ≤ k < m) and cut the colored matrix in such a way that the first k columns become a separate matrix (the left matrix) and the last m-k columns become a separate matrix (the right matrix).

The coloring and the cut are called perfect if two properties hold: 

  * every red cell in the left matrix contains an integer greater than every blue cell in the left matrix; 
  * every blue cell in the right matrix contains an integer greater than every red cell in the right matrix. 



Find any perfect coloring and cut, or report that there are none.

Input

The first line contains a single integer t (1 ≤ t ≤ 1000) — the number of testcases.

Then the descriptions of t testcases follow.

The first line of each testcase contains two integers n and m (2 ≤ n, m ≤ 5 ⋅ 10^5; n ⋅ m ≤ 10^6) — the number of rows and the number of columns in the matrix, respectively.

The i-th of the next n lines contains m integers a_{i1}, a_{i2}, ..., a_{im} (1 ≤ a_{ij} ≤ 10^6).

The sum of n ⋅ m over all testcases doesn't exceed 10^6.

Output

For each testcase print an answer. If there are no perfect colorings and cuts in the matrix, then print "NO".

Otherwise, first, print "YES". Then a string, consisting of n characters: the i-th character should be 'R' if the i-th row is colored red and 'B' if it's colored blue. The string should contain at least one 'R' and at least one 'B'. Finally, print an integer k (1 ≤ k < m) — the number of columns from the left that are cut.

Example

Input


3
5 5
1 5 8 8 7
5 2 1 4 3
1 6 9 7 5
9 3 3 3 2
1 7 9 9 8
3 3
8 9 8
1 5 3
7 5 7
2 6
3 3 3 2 2 2
1 1 1 4 4 4


Output


YES
BRBRB 1
NO
YES
RB 3

Note

The coloring and the cut for the first testcase:

<image>

EXAMPLE QUESTIONS:
Example question 1:
Name: p03440 AtCoder Petrozavodsk Contest 001 - Forest
Tags: ['']
Description: You are given a forest with N vertices and M edges. The vertices are numbered 0 through N-1. The edges are given in the format (x_i,y_i), which means that Vertex x_i and y_i are connected by an edge.

Each vertex i has a value a_i. You want to add edges in the given forest so that the forest becomes connected. To add an edge, you choose two different vertices i and j, then span an edge between i and j. This operation costs a_i + a_j dollars, and afterward neither Vertex i nor j can be selected again.

Find the minimum total cost required to make the forest connected, or print `Impossible` if it is impossible.

Constraints

* 1 ≤ N ≤ 100,000
* 0 ≤ M ≤ N-1
* 1 ≤ a_i ≤ 10^9
* 0 ≤ x_i,y_i ≤ N-1
* The given graph is a forest.
* All input values are integers.

Input

Input is given from Standard Input in the following format:


N M
a_0 a_1 .. a_{N-1}
x_1 y_1
x_2 y_2
:
x_M y_M


Output

Print the minimum total cost required to make the forest connected, or print `Impossible` if it is impossible.

Examples

Input

7 5
1 2 3 4 5 6 7
3 0
4 0
1 2
1 3
5 6


Output

7


Input

5 0
3 1 4 1 5


Output

Impossible


Input

1 0
5


Output

0
Difficulty: 0
Solutions: # -*- coding: utf-8 -*-
from collections import defaultdict
from heapq import merge
import sys
sys.setrecursionlimit(10**7)
def inpl(): return tuple(map(int, input().split()))
 
N, M = inpl()
A = inpl()
tree = [[-1, 1]  for _ in range(N)] # [next, rank]
 
def find(i):
    if tree[i][0] == -1:
        group = i
    else:
        group = find(tree[i][0]) 
        tree[i][0] = group
    return group
  
def unite(x, y):
    px = find(x)
    py = find(y)
      
    if tree[px][1] == tree[py][1]: # rank is same
        tree[py][0] = px
        tree[px][1] += 1
    else:
        if tree[px][1] < tree[py][1]:
            px, py = py, px
        tree[py][0] = px
  
for _ in range(M):
    x, y = tuple(map(int, input().split()))
    if not int(find(x) == find(y)):
        unite(x, y)
 
D = defaultdict(list)
for n in range(N):
    D[find(n)].append(A[n])
 
H = []
res = 0 

for k, v in D.items():
    v = sorted(v)
    res += v[0]
    H.append(v[1:])
 
if N < 2*(N-M-1):
    print("Impossible")
elif M == N-1:
    print(0)
else:
    res += sum(list(merge(*H))[:2*(N-M-1) - len(D.keys())])
    print(res)


INSTRUCTIONS:
Solve the current question.
Provide:
1. A complete and efficient code solution, optimized for both time and space complexity.
2. A detailed explanation of the solution, including:
   - The intuition behind the approach;
   - Time and space complexity;
   - Important considerations about the algorithm.
3. You can use the example questions as general references for coding patterns and structure, but solve the current problem independently.
4. Don't use any external libraries. Any language is accepted.