def min_changes_to_k_occurrences(n, m, a, b):
    # Precompute the cost to convert each substring of a to b
    costs = [0] * (n - m + 1)
    for i in range(n - m + 1):
        cost = 0
        for j in range(m):
            if a[i + j] != b[j]:
                cost += 1
        costs[i] = cost

    # Initialize DP table
    max_k = n - m + 1
    dp = [[float('inf')] * (max_k + 1) for _ in range(max_k + 1)]
    dp[0][0] = 0  # Base case: 0 occurrences require 0 changes

    # Fill DP table
    for i in range(max_k):
        for k in range(max_k + 1):
            if dp[i][k] == float('inf'):
                continue
            # Option 1: Do not include the current substring
            dp[i + 1][k] = min(dp[i + 1][k], dp[i][k])
            # Option 2: Include the current substring
            if k + 1 <= max_k:
                dp[i + m][k + 1] = min(dp[i + m][k + 1], dp[i][k] + costs[i])

    # Extract results for each k
    result = []
    for k in range(max_k + 1):
        result.append(dp[max_k][k] if dp[max_k][k] != float('inf') else -1)

    return result


# Input reading
n, m = map(int, input().split())
a = input().strip()
b = input().strip()

# Solve and output the result
result = min_changes_to_k_occurrences(n, m, a, b)
print(" ".join(map(str, result)))