def min_changes_for_k_occurrences(n, m, a, b):
    # Step 1: Precompute costs for matching b at each position in a
    costs = []
    for i in range(n - m + 1):
        cost = 0
        for j in range(m):
            if a[i + j] != b[j]:
                cost += 1
        costs.append(cost)

    # Step 2: Initialize DP table
    max_k = n - m + 1
    dp = [[float('inf')] * (max_k + 1) for _ in range(max_k + 1)]
    dp[0][0] = 0  # Base case: 0 occurrences, 0 cost

    # Step 3: Fill DP table
    for i in range(1, max_k + 1):  # Iterate over positions in a
        for k in range(max_k + 1):  # Iterate over possible k values
            # Case 1: Skip this position
            dp[i][k] = dp[i - 1][k]
            # Case 2: Use this position as an occurrence of b
            if k > 0 and i >= 1:
                dp[i][k] = min(dp[i][k], dp[i - 1][k - 1] + costs[i - 1])

    # Step 4: Extract results for each k
    result = []
    for k in range(max_k + 1):
        min_cost = dp[max_k][k]
        result.append(min_cost if min_cost != float('inf') else -1)

    return result


# Input reading
n, m = map(int, input().split())
a = input().strip()
b = input().strip()

# Solve the problem
result = min_changes_for_k_occurrences(n, m, a, b)

# Output the result
print(" ".join(map(str, result)))