def min_changes_to_k_occurrences(n, m, a, b):
    # Precompute the cost of converting each window in `a` to `b`
    costs = []
    for i in range(n - m + 1):
        cost = 0
        for j in range(m):
            if a[i + j] != b[j]:
                cost += 1
        costs.append(cost)
    
    # Initialize DP table
    max_k = n - m + 1
    dp = [[float('inf')] * (max_k + 1) for _ in range(max_k + 1)]
    dp[0][0] = 0  # Base case: 0 occurrences with 0 changes
    
    # Fill DP table
    for i in range(1, max_k + 1):
        for k in range(max_k + 1):
            # Option 1: Skip the current window
            dp[i][k] = dp[i - 1][k]
            # Option 2: Include the current window as a match
            if k > 0:
                dp[i][k] = min(dp[i][k], dp[i - 1][k - 1] + costs[i - 1])
    
    # Extract results for each k
    result = []
    for k in range(max_k + 1):
        result.append(dp[max_k][k] if dp[max_k][k] != float('inf') else -1)
    
    return result

# Input reading
n, m = map(int, input().split())
a = input().strip()
b = input().strip()

# Solve and output the result
result = min_changes_to_k_occurrences(n, m, a, b)
print(" ".join(map(str, result)))