CURRENT QUESTION:
The Winter holiday will be here soon. Mr. Chanek wants to decorate his house's wall with ornaments. The wall can be represented as a binary string a of length n. His favorite nephew has another binary string b of length m (m ≤ n).

Mr. Chanek's nephew loves the non-negative integer k. His nephew wants exactly k occurrences of b as substrings in a. 

However, Mr. Chanek does not know the value of k. So, for each k (0 ≤ k ≤ n - m + 1), find the minimum number of elements in a that have to be changed such that there are exactly k occurrences of b in a.

A string s occurs exactly k times in t if there are exactly k different pairs (p,q) such that we can obtain s by deleting p characters from the beginning and q characters from the end of t.

Input

The first line contains two integers n and m (1 ≤ m ≤ n ≤ 500) — size of the binary string a and b respectively.

The second line contains a binary string a of length n.

The third line contains a binary string b of length m.

Output

Output n - m + 2 integers — the (k+1)-th integer denotes the minimal number of elements in a that have to be changed so there are exactly k occurrences of b as a substring in a.

Example

Input


9 3
100101011
101


Output


1 1 0 1 6 -1 -1 -1

Note

For k = 0, to make the string a have no occurrence of 101, you can do one character change as follows.

100101011 → 100100011

For k = 1, you can also change a single character.

100101011 → 100001011

For k = 2, no changes are needed.

EXAMPLE QUESTIONS:
Example question 1:
Name: 104_A. Blackjack
Tags: ['implementation']
Description: One rainy gloomy evening when all modules hid in the nearby cafes to drink hot energetic cocktails, the Hexadecimal virus decided to fly over the Mainframe to look for a Great Idea. And she has found one!

Why not make her own Codeforces, with blackjack and other really cool stuff? Many people will surely be willing to visit this splendid shrine of high culture.

In Mainframe a standard pack of 52 cards is used to play blackjack. The pack contains cards of 13 values: 2, 3, 4, 5, 6, 7, 8, 9, 10, jacks, queens, kings and aces. Each value also exists in one of four suits: hearts, diamonds, clubs and spades. Also, each card earns some value in points assigned to it: cards with value from two to ten earn from 2 to 10 points, correspondingly. An ace can either earn 1 or 11, whatever the player wishes. The picture cards (king, queen and jack) earn 10 points. The number of points a card earns does not depend on the suit. The rules of the game are very simple. The player gets two cards, if the sum of points of those cards equals n, then the player wins, otherwise the player loses.

The player has already got the first card, it's the queen of spades. To evaluate chances for victory, you should determine how many ways there are to get the second card so that the sum of points exactly equals n.

Input

The only line contains n (1 ≤ n ≤ 25) — the required sum of points.

Output

Print the numbers of ways to get the second card in the required way if the first card is the queen of spades.

Examples

Input

12


Output

4

Input

20


Output

15

Input

10


Output

0

Note

In the first sample only four two's of different suits can earn the required sum of points.

In the second sample we can use all tens, jacks, queens and kings; overall it's 15 cards, as the queen of spades (as any other card) is only present once in the pack of cards and it's already in use.

In the third sample there is no card, that would add a zero to the current ten points.
Difficulty: 7
Solutions: n=int(input())
if n<11 or n>21:
    print(0)
elif n==20:
    print(15)
else:
    print(4)

Example question 2:
Name: 610_A. Pasha and Stick
Tags: ['combinatorics', 'math']
Description: Pasha has a wooden stick of some positive integer length n. He wants to perform exactly three cuts to get four parts of the stick. Each part must have some positive integer length and the sum of these lengths will obviously be n. 

Pasha likes rectangles but hates squares, so he wonders, how many ways are there to split a stick into four parts so that it's possible to form a rectangle using these parts, but is impossible to form a square.

Your task is to help Pasha and count the number of such ways. Two ways to cut the stick are considered distinct if there exists some integer x, such that the number of parts of length x in the first way differ from the number of parts of length x in the second way.

Input

The first line of the input contains a positive integer n (1 ≤ n ≤ 2·109) — the length of Pasha's stick.

Output

The output should contain a single integer — the number of ways to split Pasha's stick into four parts of positive integer length so that it's possible to make a rectangle by connecting the ends of these parts, but is impossible to form a square. 

Examples

Input

6


Output

1


Input

20


Output

4

Note

There is only one way to divide the stick in the first sample {1, 1, 2, 2}.

Four ways to divide the stick in the second sample are {1, 1, 9, 9}, {2, 2, 8, 8}, {3, 3, 7, 7} and {4, 4, 6, 6}. Note that {5, 5, 5, 5} doesn't work.
Difficulty: 7
Solutions: x=int(input())
print((x%2==0)*((x//2-1)//2))
#fueaijskrgd/t


Example question 3:
Name: 316_G3. Good Substrings
Tags: ['string suffix structures']
Description: Smart Beaver recently got interested in a new word game. The point is as follows: count the number of distinct good substrings of some string s. To determine if a string is good or not the game uses rules. Overall there are n rules. Each rule is described by a group of three (p, l, r), where p is a string and l and r (l ≤ r) are integers. We’ll say that string t complies with rule (p, l, r), if the number of occurrences of string t in string p lies between l and r, inclusive. For example, string "ab", complies with rules ("ab", 1, 2) and ("aab", 0, 1), but does not comply with rules ("cd", 1, 2) and ("abab", 0, 1).

A substring s[l... r] (1 ≤ l ≤ r ≤ |s|) of string s = s1s2... s|s| (|s| is a length of s) is string slsl + 1... sr.

Consider a number of occurrences  of string t in string p as a number of pairs of integers l, r (1 ≤ l ≤ r ≤ |p|) such that p[l... r] = t.

We’ll say that string t is good if it complies with all n rules. Smart Beaver asks you to help him to write a program that can calculate the number of distinct good substrings of string s. Two substrings s[x... y] and s[z... w] are cosidered to be distinct iff s[x... y] ≠ s[z... w].

Input

The first line contains string s. The second line contains integer n. Next n lines contain the rules, one per line. Each of these lines contains a string and two integers pi, li, ri, separated by single spaces (0 ≤ li ≤ ri ≤ |pi|). It is guaranteed that all the given strings are non-empty and only contain lowercase English letters.

The input limits for scoring 30 points are (subproblem G1): 

  * 0 ≤ n ≤ 10. 
  * The length of string s and the maximum length of string p is  ≤ 200. 



The input limits for scoring 70 points are (subproblems G1+G2): 

  * 0 ≤ n ≤ 10. 
  * The length of string s and the maximum length of string p is  ≤ 2000. 



The input limits for scoring 100 points are (subproblems G1+G2+G3): 

  * 0 ≤ n ≤ 10. 
  * The length of string s and the maximum length of string p is  ≤ 50000. 

Output

Print a single integer — the number of good substrings of string s.

Examples

Input

aaab
2
aa 0 0
aab 1 1


Output

3


Input

ltntlnen
3
n 0 0
ttlneenl 1 4
lelllt 1 1


Output

2


Input

a
0


Output

1

Note

There are three good substrings in the first sample test: «aab», «ab» and «b».

In the second test only substrings «e» and «t» are good.
Difficulty: 13
Solutions: #include <bits/stdc++.h>
using namespace std;
const int maxn = (int)4e5;
struct state {
  int next[37], len, suff;
  state() {
    memset(next, -1, sizeof(next));
    suff = -1;
    len = 0;
  }
} st[2 * maxn];
int sz = 1, last = 0;
vector<int> g[maxn];
char second[maxn];
int L[maxn], R[maxn], n;
int dp[maxn * 3][11], cnt[maxn * 2], was[maxn * 2];
long long ans;
void addAutomat(int ch) {
  int p = last;
  int nv = sz++;
  st[nv].len = st[last].len + 1;
  memset(st[nv].next, -1, sizeof(st[nv].next));
  for (; p != -1 && st[p].next[ch] == -1; p = st[p].suff) st[p].next[ch] = nv;
  if (p == -1)
    st[nv].suff = 0;
  else {
    int q = st[p].next[ch];
    if (st[q].len == st[p].len + 1)
      st[nv].suff = q;
    else {
      int clone = sz++;
      memcpy(st[clone].next, st[q].next, sizeof(st[clone].next));
      st[clone].suff = st[q].suff;
      st[clone].len = st[p].len + 1;
      for (; p != -1 && st[p].next[ch] == q; p = st[p].suff)
        st[p].next[ch] = clone;
      st[nv].suff = st[q].suff = clone;
    }
  }
  last = nv;
}
int Count(int v) {
  if (v == 0) return 1;
  if (cnt[v] != -1) return cnt[v];
  cnt[v] = 0;
  for (typeof(g[v].begin()) it = g[v].begin(); it != g[v].end(); ++it) {
    int to = *it;
    cnt[v] += Count(to);
  }
  return cnt[v];
}
void Dfs(int v) {
  if (was[v]) return;
  was[v] = true;
  for (int i = 0; i <= n; ++i)
    if (st[v].next[26 + i] != -1) {
      dp[v][i] = 1;
    }
  for (int i = 0; i < 26; ++i)
    if (st[v].next[i] != -1) {
      int u = st[v].next[i];
      Dfs(u);
      for (int j = 0; j <= n; ++j) dp[v][j] += dp[u][j];
    }
  if (v && dp[v][0]) {
    bool ok = true;
    for (int i = 1; ok && i <= n; ++i)
      if (!(L[i] <= dp[v][i] && dp[v][i] <= R[i])) ok = false;
    if (ok) {
      ans += Count(v);
    }
  }
}
int main() {
  scanf("%s", second);
  for (int i = 0; second[i]; ++i) addAutomat(second[i] - 'a');
  addAutomat(26);
  scanf("%d", &n);
  for (int i = 1; i <= n; ++i) {
    scanf("\n%s %d %d", &second, &L[i], &R[i]);
    for (int j = 0; second[j]; ++j) addAutomat(second[j] - 'a');
    addAutomat(i + 26);
  }
  for (int i = 0; i < sz; ++i) {
    for (int ch = 0; ch < 26; ++ch)
      if (st[i].next[ch] != -1) {
        g[st[i].next[ch]].push_back(i);
      }
  }
  memset(cnt, -1, sizeof(cnt));
  Dfs(0);
  cout << ans << endl;
  return 0;
}



INSTRUCTIONS:
Solve the current question.
Provide:
1. A complete and efficient code solution, optimized for both time and space complexity.
2. A detailed explanation of the solution, including:
   - The intuition behind the approach;
   - Time and space complexity;
   - Important considerations about the algorithm.
3. You can use the example questions as general references for coding patterns and structure, but solve the current problem independently.
4. Don't use any external libraries. Any language is accepted.