CURRENT QUESTION:
The Winter holiday will be here soon. Mr. Chanek wants to decorate his house's wall with ornaments. The wall can be represented as a binary string a of length n. His favorite nephew has another binary string b of length m (m ≤ n).

Mr. Chanek's nephew loves the non-negative integer k. His nephew wants exactly k occurrences of b as substrings in a. 

However, Mr. Chanek does not know the value of k. So, for each k (0 ≤ k ≤ n - m + 1), find the minimum number of elements in a that have to be changed such that there are exactly k occurrences of b in a.

A string s occurs exactly k times in t if there are exactly k different pairs (p,q) such that we can obtain s by deleting p characters from the beginning and q characters from the end of t.

Input

The first line contains two integers n and m (1 ≤ m ≤ n ≤ 500) — size of the binary string a and b respectively.

The second line contains a binary string a of length n.

The third line contains a binary string b of length m.

Output

Output n - m + 2 integers — the (k+1)-th integer denotes the minimal number of elements in a that have to be changed so there are exactly k occurrences of b as a substring in a.

Example

Input


9 3
100101011
101


Output


1 1 0 1 6 -1 -1 -1

Note

For k = 0, to make the string a have no occurrence of 101, you can do one character change as follows.

100101011 → 100100011

For k = 1, you can also change a single character.

100101011 → 100001011

For k = 2, no changes are needed.

EXAMPLE QUESTIONS:
Example question 1:
Name: day-4-basic-mathematics
Tags: []
Description: Problem :

The Starks(S),Lannisters(L) and the Baratheons(B) are fighting for the
Iron Throne. These three houses are fighting from ages to capture the
throne.

The N th battle goes on for N days before a winner
emerges. Interestingly,the battles follow a pattern. 

If the battle
number N is divisible by 3 it is fought between S and L, 

if the
remainder of division with 3 is 1 it is fought between L and B and

if the
remainder of divison with 3 is 2 it is fought between B and S.

Given a day number D, you
will have to say which two houses are fighting on the D th day.

Input :

First line will contain an integer T (number of testcases). The next T
lines will contain an integer D.

Output :

You will have to report which of the two houses are fighting on the
D th day (i.e you will have to print one of the three
battles ( SL, LB, BS ) ). 

Constraints :

1 ≤ T ≤ 1000

1 ≤ D ≤ 10^9 

Problem Setter : Sayan

Problem Tester : Sandeep

(By IIT Kgp HackerEarth Programming Club)

SAMPLE INPUT
3
1
6
12

SAMPLE OUTPUT
LB
SL
BS

Explanation

In test case 3:­
The battle 1 goes on for 1 day, 2 for 2 days and so on.The series is
1 2 2 3 3 3 4 4 4 4 5 5.
On the 12th day battle number 5 is going on.
Difficulty: 0
Solutions: __author__ = 'apritam'

import math

no_of_test=int(raw_input())
while no_of_test > 0:
    t_range = raw_input()
    t= long(t_range)
    n = long(math.ceil((-1+(math.ceil(math.sqrt(8*t-1))))/2))
    if n % 3 == 0:
        print 'SL'
    elif n % 3 == 1:
        print 'LB'
    else:
        print 'BS'
    no_of_test-=1

Example question 2:
Name: 1420_E. Battle Lemmings
Tags: ['dp', 'greedy']
Description: A lighthouse keeper Peter commands an army of n battle lemmings. He ordered his army to stand in a line and numbered the lemmings from 1 to n from left to right. Some of the lemmings hold shields. Each lemming cannot hold more than one shield.

The more protected Peter's army is, the better. To calculate the protection of the army, he finds the number of protected pairs of lemmings, that is such pairs that both lemmings in the pair don't hold a shield, but there is a lemming with a shield between them.

Now it's time to prepare for defence and increase the protection of the army. To do this, Peter can give orders. He chooses a lemming with a shield and gives him one of the two orders: 

  * give the shield to the left neighbor if it exists and doesn't have a shield; 
  * give the shield to the right neighbor if it exists and doesn't have a shield. 



In one second Peter can give exactly one order.

It's not clear how much time Peter has before the defence. So he decided to determine the maximal value of army protection for each k from 0 to \frac{n(n-1)}2, if he gives no more that k orders. Help Peter to calculate it!

Input

First line contains a single integer n (1 ≤ n ≤ 80), the number of lemmings in Peter's army.

Second line contains n integers a_i (0 ≤ a_i ≤ 1). If a_i = 1, then the i-th lemming has a shield, otherwise a_i = 0.

Output

Print \frac{n(n-1)}2 + 1 numbers, the greatest possible protection after no more than 0, 1, ..., \frac{n(n-1)}2 orders.

Examples

Input


5
1 0 0 0 1


Output


0 2 3 3 3 3 3 3 3 3 3 


Input


12
0 0 0 0 1 1 1 1 0 1 1 0


Output


9 12 13 14 14 14 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 

Note

Consider the first example.

The protection is initially equal to zero, because for each pair of lemmings without shields there is no lemmings with shield.

In one second Peter can order the first lemming give his shield to the right neighbor. In this case, the protection is two, as there are two protected pairs of lemmings, (1, 3) and (1, 4).

In two seconds Peter can act in the following way. First, he orders the fifth lemming to give a shield to the left neighbor. Then, he orders the first lemming to give a shield to the right neighbor. In this case Peter has three protected pairs of lemmings — (1, 3), (1, 5) and (3, 5).

You can make sure that it's impossible to give orders in such a way that the protection becomes greater than three.
Difficulty: 11
Solutions: #include <bits/stdc++.h>
using namespace std;
int n, dp[85][85][6500], a[65], s, m, p[100];
int main() {
  scanf("%d", &n);
  for (int i = 1; i <= n; i++) {
    scanf("%d", &a[i]);
    if (a[i] == 1) p[++s] = i;
  }
  m = (n - 1) * n / 2;
  memset(dp, 128, sizeof(dp));
  dp[0][0][0] = 0;
  for (int i = 0; i <= n - 1; i++) {
    for (int j = 0; j <= min(s - 1, i); j++) {
      for (int k = 0; k <= m; k++) {
        if (dp[i][j][k] < 0) continue;
        for (int x = i + 1; x <= n; x++)
          dp[x][j + 1][k + abs(p[j + 1] - x)] =
              max(dp[x][j + 1][k + abs(p[j + 1] - x)],
                  dp[i][j][k] + (i - j) * (x - i - 1));
      }
    }
  }
  int ans = 0;
  for (int i = 0; i <= m; i++) {
    for (int j = 0; j <= n; j++)
      ans = max(ans, dp[j][s][i] + (n - j) * (j - s));
    printf("%d ", ans);
  }
  return 0;
}



INSTRUCTIONS:
Solve the current question.
Provide:
1. A complete and efficient code solution, optimized for both time and space complexity.
2. A detailed explanation of the solution, including:
   - The intuition behind the approach;
   - Time and space complexity;
   - Important considerations about the algorithm.
3. If the language has classes, implement in 'Solution' class. Any language is accepted.
4. You can use the example questions as general references for coding patterns and structure, but solve the current problem independently.
5. Don't use any external libraries. Don't need to import any libraries.
