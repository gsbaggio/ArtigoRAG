def solve(n, k, x):
    MOD = 998244353
    
    # Case 1: x = 0
    # Need to exclude empty subsequence, so each position must have non-zero value
    if x == 0:
        return pow(pow(2, k, MOD) - 1, n, MOD)
    
    # Case 2: x â‰  0
    # Define:
    # dp[0][i] = number of valid sequences of length i
    # dp[1][i] = number of sequences of length i that have at least one element
    #            with XOR = x, but no subsequence with XOR = x
    
    # Initialize base case: empty sequence
    dp = [[1, 0]]
    
    # Compute dp for length 1
    all_values = pow(2, k, MOD)
    non_x_values = all_values - 1  # All values except x
    
    dp.append([non_x_values, 1])  # [valid sequences, sequences with one x]
    
    if n == 1:
        return dp[1][0]
    
    # Set up recurrence matrix
    A = [
        [non_x_values, 1],
        [0, non_x_values]
    ]
    
    # Use matrix exponentiation
    A_pow = matrix_pow(A, n-1, MOD)
    
    # Compute final result
    result = (A_pow[0][0] * dp[1][0] + A_pow[0][1] * dp[1][1]) % MOD
    
    return result

def matrix_multiply(A, B, MOD):
    C = [[0, 0], [0, 0]]
    for i in range(2):
        for j in range(2):
            for k in range(2):
                C[i][j] = (C[i][j] + A[i][k] * B[k][j]) % MOD
    return C

def matrix_pow(A, n, MOD):
    if n == 0:
        return [[1, 0], [0, 1]]  # Identity matrix
    if n % 2 == 1:
        return matrix_multiply(A, matrix_pow(A, n-1, MOD), MOD)
    half_pow = matrix_pow(A, n//2, MOD)
    return matrix_multiply(half_pow, half_pow, MOD)

def main():
    t = int(input())
    for _ in range(t):
        n, k, x = map(int, input().split())
        print(solve(n, k, x))

if __name__ == "__main__":
    main()