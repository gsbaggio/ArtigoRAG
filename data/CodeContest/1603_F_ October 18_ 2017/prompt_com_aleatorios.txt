CURRENT QUESTION:
It was October 18, 2017. Shohag, a melancholic soul, made a strong determination that he will pursue Competitive Programming seriously, by heart, because he found it fascinating. Fast forward to 4 years, he is happy that he took this road. He is now creating a contest on Codeforces. He found an astounding problem but has no idea how to solve this. Help him to solve the final problem of the round.

You are given three integers n, k and x. Find the number, modulo 998 244 353, of integer sequences a_1, a_2, …, a_n such that the following conditions are satisfied: 

  * 0 ≤ a_i < 2^k for each integer i from 1 to n. 
  * There is no non-empty subsequence in a such that the [bitwise XOR](https://en.wikipedia.org/wiki/Bitwise_operation#XOR) of the elements of the subsequence is x. 



A sequence b is a subsequence of a sequence c if b can be obtained from c by deletion of several (possibly, zero or all) elements.

Input

The first line contains a single integer t (1 ≤ t ≤ 10^5) — the number of test cases.

The first and only line of each test case contains three space-separated integers n, k, and x (1 ≤ n ≤ 10^9, 0 ≤ k ≤ 10^7, 0 ≤ x < 2^{\operatorname{min}(20, k)}).

It is guaranteed that the sum of k over all test cases does not exceed 5 ⋅ 10^7.

Output

For each test case, print a single integer — the answer to the problem.

Example

Input


6
2 2 0
2 1 1
3 2 3
69 69 69
2017 10 18
5 7 0


Output


6
1
15
699496932
892852568
713939942

Note

In the first test case, the valid sequences are [1, 2], [1, 3], [2, 1], [2, 3], [3, 1] and [3, 2].

In the second test case, the only valid sequence is [0, 0].

EXAMPLE QUESTIONS:
Example question 1:
Name: 1257_D. Yet Another Monster Killing Problem
Tags: ['binary search', 'data structures', 'dp', 'greedy', 'sortings', 'two pointers']
Description: You play a computer game. In this game, you lead a party of m heroes, and you have to clear a dungeon with n monsters. Each monster is characterized by its power a_i. Each hero is characterized by his power p_i and endurance s_i.

The heroes clear the dungeon day by day. In the beginning of each day, you choose a hero (exactly one) who is going to enter the dungeon this day.

When the hero enters the dungeon, he is challenged by the first monster which was not defeated during the previous days (so, if the heroes have already defeated k monsters, the hero fights with the monster k + 1). When the hero fights the monster, there are two possible outcomes:

  * if the monster's power is strictly greater than the hero's power, the hero retreats from the dungeon. The current day ends; 
  * otherwise, the monster is defeated. 



After defeating a monster, the hero either continues fighting with the next monster or leaves the dungeon. He leaves the dungeon either if he has already defeated the number of monsters equal to his endurance during this day (so, the i-th hero cannot defeat more than s_i monsters during each day), or if all monsters are defeated — otherwise, he fights with the next monster. When the hero leaves the dungeon, the current day ends.

Your goal is to defeat the last monster. What is the minimum number of days that you need to achieve your goal? Each day you have to use exactly one hero; it is possible that some heroes don't fight the monsters at all. Each hero can be used arbitrary number of times.

Input

The first line contains one integer t (1 ≤ t ≤ 10^5) — the number of test cases. Then the test cases follow.

The first line of each test case contains one integer n (1 ≤ n ≤ 2 ⋅ 10^5) — the number of monsters in the dungeon.

The second line contains n integers a_1, a_2, ..., a_n (1 ≤ a_i ≤ 10^9), where a_i is the power of the i-th monster.

The third line contains one integer m (1 ≤ m ≤ 2 ⋅ 10^5) — the number of heroes in your party.

Then m lines follow, each describing a hero. Each line contains two integers p_i and s_i (1 ≤ p_i ≤ 10^9, 1 ≤ s_i ≤ n) — the power and the endurance of the i-th hero.

It is guaranteed that the sum of n + m over all test cases does not exceed 2 ⋅ 10^5.

Output

For each test case print one integer — the minimum number of days you have to spend to defeat all of the monsters (or -1 if it is impossible).

Example

Input


2
6
2 3 11 14 1 8
2
3 2
100 1
5
3 5 100 2 3
2
30 5
90 1


Output


5
-1
Difficulty: 10
Solutions: #include <bits/stdc++.h>
using namespace std;
const int INF = 0x3f3f3f3f;
const int inf = 0x3f3f3f3f;
int p[200005];
int v[200005];
int main() {
  int t;
  scanf("%d", &t);
  while (t--) {
    int n;
    scanf("%d", &n);
    for (int a = 1; a <= n; a++) {
      scanf("%d", &v[a]);
      p[a] = 0;
    }
    int m, x, y;
    scanf("%d", &m);
    for (int a = 1; a <= m; a++) {
      scanf("%d%d", &x, &y);
      p[y] = max(p[y], x);
    }
    for (int a = n - 1; a >= 1; a--) {
      p[a] = max(p[a], p[a + 1]);
    }
    int mx = 0, num = 1, flog = 0, ans = 0;
    for (int a = 1; a <= n; a++) {
      mx = max(mx, v[a]);
      if (p[a - ans] < mx) {
        mx = v[a];
        num++;
        ans = a - 1;
      }
      if (p[1] < mx) {
        flog = 1;
        break;
      }
    }
    if (flog) {
      printf("-1\n");
    } else {
      printf("%d\n", num);
    }
  }
  return 0;
}



INSTRUCTIONS:
Solve the current question.
Provide:
1. A complete and efficient code solution, optimized for both time and space complexity.
2. A detailed explanation of the solution, including:
   - The intuition behind the approach;
   - Time and space complexity;
   - Important considerations about the algorithm.
3. You can use the example questions as general references for coding patterns and structure, but solve the current problem independently.
4. Don't use any external libraries. Any language is accepted.