MOD = 998244353

def matmul(A, B):
    """Multiplies two matrices A and B modulo MOD."""
    n = len(A)
    m = len(B[0])
    l = len(B)
    C = [[0] * m for _ in range(n)]
    for i in range(n):
        for j in range(m):
            for k in range(l):
                C[i][j] = (C[i][j] + A[i][k] * B[k][j]) % MOD
    return C

def matpow(M, exp):
    """Computes M^exp modulo MOD using matrix exponentiation."""
    n = len(M)
    result = [[1 if i == j else 0 for j in range(n)] for i in range(n)]  # Identity matrix
    base = M
    while exp > 0:
        if exp % 2 == 1:
            result = matmul(result, base)
        base = matmul(base, base)
        exp //= 2
    return result

def solve(n, k, x):
    """Solves the problem for a given n, k, and x."""
    num_masks = 1 << min(k, 20)  # Only consider masks up to 2^min(k, 20)
    
    # Initialize the transition matrix
    transition_matrix = [[0] * num_masks for _ in range(num_masks)]
    for mask in range(num_masks):
        for a_i in range(num_masks):
            new_mask = mask ^ a_i
            transition_matrix[mask][new_mask] += 1
    
    # Raise the transition matrix to the power of n
    final_matrix = matpow(transition_matrix, n)
    
    # Calculate the total number of sequences
    total_sequences = final_matrix[0][0]
    for mask in range(1, num_masks):
        total_sequences = (total_sequences + final_matrix[0][mask]) % MOD
    
    # Subtract the invalid sequences (those with XOR equal to x)
    if x < num_masks:
        total_sequences = (total_sequences - final_matrix[0][x] + MOD) % MOD
    
    return total_sequences

# Read input
import sys
input = sys.stdin.read().split()
t = int(input[0])
index = 1
results = []

for _ in range(t):
    n = int(input[index])
    k = int(input[index + 1])
    x = int(input[index + 2])
    index += 3
    results.append(solve(n, k, x))

# Print results
for result in results:
    print(result)