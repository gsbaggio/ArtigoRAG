CURRENT QUESTION:
On an endless checkered sheet of paper, n cells are chosen and colored in three colors, where n is divisible by 3. It turns out that there are exactly n/3 marked cells of each of three colors! 

Find the largest such k that it's possible to choose k/3 cells of each color, remove all other marked cells, and then select three rectangles with sides parallel to the grid lines so that the following conditions hold:

  * No two rectangles can intersect (but they can share a part of the boundary). In other words, the area of intersection of any two of these rectangles must be 0.
  * The i-th rectangle contains all the chosen cells of the i-th color and no chosen cells of other colors, for i = 1, 2, 3. 

Input

The first line of the input contains a single integer n — the number of the marked cells (3 ≤ n ≤ 10^5, n is divisible by 3).

The i-th of the following n lines contains three integers x_i, y_i, c_i (|x_i|,|y_i| ≤ 10^9; 1 ≤ c_i ≤ 3), where (x_i, y_i) are the coordinates of the i-th marked cell and c_i is its color.

It's guaranteed that all cells (x_i, y_i) in the input are distinct, and that there are exactly n/3 cells of each color.

Output

Output a single integer k — the largest number of cells you can leave.

Examples

Input


9
2 3 1
4 1 2
2 1 3
3 4 1
5 3 2
4 4 3
2 4 1
5 2 2
3 5 3


Output


6


Input


3
1 1 1
2 2 2
3 3 3


Output


3

Note

In the first sample, it's possible to leave 6 cells with indexes 1, 5, 6, 7, 8, 9.

In the second sample, it's possible to leave 3 cells with indexes 1, 2, 3.

EXAMPLE QUESTIONS:
Example question 1:
Name: p03357 AtCoder Regular Contest 097 - Sorted and Sorted
Tags: ['']
Description: There are 2N balls, N white and N black, arranged in a row. The integers from 1 through N are written on the white balls, one on each ball, and they are also written on the black balls, one on each ball. The integer written on the i-th ball from the left (1 ≤ i ≤ 2N) is a_i, and the color of this ball is represented by a letter c_i. c_i = `W` represents the ball is white; c_i = `B` represents the ball is black.

Takahashi the human wants to achieve the following objective:

* For every pair of integers (i,j) such that 1 ≤ i < j ≤ N, the white ball with i written on it is to the left of the white ball with j written on it.
* For every pair of integers (i,j) such that 1 ≤ i < j ≤ N, the black ball with i written on it is to the left of the black ball with j written on it.



In order to achieve this, he can perform the following operation:

* Swap two adjacent balls.



Find the minimum number of operations required to achieve the objective.

Constraints

* 1 ≤ N ≤ 2000
* 1 ≤ a_i ≤ N
* c_i = `W` or c_i = `B`.
* If i ≠ j, (a_i,c_i) ≠ (a_j,c_j).

Input

Input is given from Standard Input in the following format:


N
c_1 a_1
c_2 a_2
:
c_{2N} a_{2N}


Output

Print the minimum number of operations required to achieve the objective.

Examples

Input

3
B 1
W 2
B 3
W 1
W 3
B 2


Output

4


Input

4
B 4
W 4
B 3
W 3
B 2
W 2
B 1
W 1


Output

18


Input

9
W 3
B 1
B 4
W 1
B 5
W 9
W 2
B 6
W 5
B 3
W 8
B 9
W 7
B 2
B 8
W 4
W 6
B 7


Output

41
Difficulty: 0
Solutions: #include <bits/stdc++.h>
#define SZ(x) ((int)x.size())
#define ALL(x) (x).begin(), (x).end()
using namespace std;
typedef long long ll;
typedef long double ld;
int n, a[4010], b[4010], sum[2][4010][2010];
int pos[2][2010];
int dp[2010][2010];
int main() {
	scanf("%d", &n);
	for(int i=1; i<=n+n; i++) {
		char ch;
		scanf(" %c %d", &ch, a+i);
		b[i] = ch == 'B';
		pos[b[i]][a[i]] = i;
		for(int j=a[i]; j<=n; j++)
			sum[b[i]][i][j]++;
	}
	for(int k=0; k<2; k++)
		for(int i=1; i<=n+n; i++)
			for(int j=1; j<=n; j++)
				sum[k][i][j] += sum[k][i-1][j];
	for(int i=0; i<=n; i++) {
		for(int j=0; j<=n; j++) {
			int p1 = pos[0][i];
			int p2 = pos[1][j];
			if(!i && !j) continue;
			else if(!i) {
				dp[i][j] = dp[i][j-1] + p2 - 1 - sum[1][p2][j-1] - sum[0][p2][i];
			} else if(!j) {
				dp[i][j] = dp[i-1][j] + p1 - 1 - sum[0][p1][i-1] - sum[1][p1][j];
			} else {
				dp[i][j] = min(dp[i-1][j] + p1 - 1 - sum[0][p1][i-1] - sum[1][p1][j], dp[i][j-1] + p2 - 1 - sum[1][p2][j-1] - sum[0][p2][i]);
			}
		}
	}
	printf("%d", dp[n][n]);
	return 0;
}

Example question 2:
Name: p01940 Unique Subsequence
Tags: ['']
Description: C: Only one subsequence --Unique Subsequence-

problem

One day Ebi-chan noticed that a text string T of length n and a pattern string P (m \ leq n) of length m were placed on the desk. Ebi-chan loves the "only one subsequence" that appears in strings, so she immediately began investigating whether P was the only subsequence of T.

The property that P is the only subsequence of T is expressed as follows: Now write the i-th character of the string X as X_i.

* A sequence of length m S = (s_1, ..., s_m) (where s_1 <s_2 <... <s_m) and for each i (i = 1, ..., m) T_ {s_i} The sequence S with = P_i is uniquely determined.



For several hours after starting the investigation, Ebi-chan was staring at the string, but it seems that she was tired because the string was too long. If you couldn't see it, you decided to help Ebi-chan. For Ebi-chan, write a program that outputs “yes” if P is only one subsequence of T, and “no” otherwise.

Input format


T
P


The first line is given the text string T. The second line is given the pattern string P.

Constraint

* 1 \ leq | P | \ leq | T | \ leq 5 \ times 10 ^ 5
* T and P are composed of lowercase letters ‘a’-’z’.



Output format

Print “yes” if P is a single subsequence of T, otherwise “no” on one line.

Input example 1


aizucamp
azu


Output example 1


yes

Input example 2


abracadabra
rada


Output example 2


no

Input example 3


hokkaido
dekai


Output example 3


no





Example

Input

aizucamp
azu


Output

yes
Difficulty: 0
Solutions: #include<bits/stdc++.h>
using namespace std;

// macro
#define rep(i,n) for(i=0;i<n;i++)
#define ll long long
#define all(v) v.begin(), v.end()

// code starts
int main()
{
  string t,p;cin>>t>>p;
  int nowi=0;
  vector<int> use_front(0);
  vector<int> use_back(0);
  int i;
  rep(i,t.size())
  {
    if(t[i]==p[nowi])
    {
      use_front.emplace_back(i);
      nowi++;
    }
    if(nowi>=p.size())break;
  }
  nowi=p.size()-1;
  for(i=t.size()-1;i>=0;i--)
  {
    if(t[i]==p[nowi])
    {
      use_back.emplace_back(i);
      nowi--;
    }
    if(nowi<0)break;
  }
  if(use_front.size()<p.size()||use_back.size()<p.size())
  {
    cout<<"no"<<endl;
  }
  else
  {
    reverse(all(use_back));
    if(use_back==use_front)cout<<"yes"<<endl;
    else cout<<"no"<<endl;
  }
  
}



Example question 3:
Name: 1015_E2. Stars Drawing (Hard Edition)
Tags: ['binary search', 'dp', 'greedy']
Description: A star is a figure of the following type: an asterisk character '*' in the center of the figure and four rays (to the left, right, top, bottom) of the same positive length. The size of a star is the length of its rays. The size of a star must be a positive number (i.e. rays of length 0 are not allowed).

Let's consider empty cells are denoted by '.', then the following figures are stars:

<image> The leftmost figure is a star of size 1, the middle figure is a star of size 2 and the rightmost figure is a star of size 3.

You are given a rectangular grid of size n × m consisting only of asterisks '*' and periods (dots) '.'. Rows are numbered from 1 to n, columns are numbered from 1 to m. Your task is to draw this grid using any number of stars or find out that it is impossible. Stars can intersect, overlap or even coincide with each other. The number of stars in the output can't exceed n ⋅ m. Each star should be completely inside the grid. You can use stars of same and arbitrary sizes.

In this problem, you do not need to minimize the number of stars. Just find any way to draw the given grid with at most n ⋅ m stars.

Input

The first line of the input contains two integers n and m (3 ≤ n, m ≤ 1000) — the sizes of the given grid.

The next n lines contains m characters each, the i-th line describes the i-th row of the grid. It is guaranteed that grid consists of characters '*' and '.' only.

Output

If it is impossible to draw the given grid using stars only, print "-1".

Otherwise in the first line print one integer k (0 ≤ k ≤ n ⋅ m) — the number of stars needed to draw the given grid. The next k lines should contain three integers each — x_j, y_j and s_j, where x_j is the row index of the central star character, y_j is the column index of the central star character and s_j is the size of the star. Each star should be completely inside the grid.

Examples

Input

6 8
....*...
...**...
..*****.
...**...
....*...
........


Output

3
3 4 1
3 5 2
3 5 1


Input

5 5
.*...
****.
.****
..**.
.....


Output

3
2 2 1
3 3 1
3 4 1


Input

5 5
.*...
***..
.*...
.*...
.....


Output

-1


Input

3 3
*.*
.*.
*.*


Output

-1

Note

In the first example the output 
    
    
    2  
    3 4 1  
    3 5 2  
    

is also correct.
Difficulty: 11
Solutions: import java.io.OutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.PrintWriter;
import java.io.OutputStream;
import java.util.Arrays;
import java.util.Collection;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.ArrayList;
import java.io.BufferedOutputStream;
import java.util.stream.Stream;
import java.util.StringTokenizer;
import java.io.BufferedReader;
import java.io.InputStream;

/**
 * Built using CHelper plug-in
 * Actual solution is at the top
 */
public class Main {
    public static void main(String[] args) {
        InputStream inputStream = System.in;
        OutputStream outputStream = System.out;
        Kattio in = new Kattio(inputStream);
        PrintWriter out = new PrintWriter(outputStream);
        TaskE2 solver = new TaskE2();
        solver.solve(1, in, out);
        out.close();
    }

    static class TaskE2 {
        public void solve(int testNumber, Kattio in, PrintWriter out) {
            int n = in.nextInt();
            int m = in.nextInt();

            char[][] arr = new char[n + 1][m + 1];
            int[][][] pre = new int[n + 2][m + 2][2];
            int[][][] clo = new int[n + 2][m + 2][4];

            for (int i = 1; i <= n; ++i) {
                char[] tmp = in.next().toCharArray();
                Arrays.fill(clo[i][0], -1);
                Arrays.fill(clo[i][m + 1], -1);
                for (int j = 1; j <= m; ++j) {
                    arr[i][j] = tmp[j - 1];
                    Arrays.fill(clo[i][j], -1);
                }
            }

            for (int j = 0; j <= m + 1; ++j) {
                Arrays.fill(clo[0][j], -1);
                Arrays.fill(clo[n + 1][j], -1);
            }

            // Mark the index of the furthest * from the left and top
            for (int i = 1; i <= n; ++i) {
                for (int j = 1; j <= m; ++j) {
                    if (arr[i][j] == '*') {

                        clo[i][j][0] = j;
                        clo[i][j][2] = i;

                        if (clo[i][j - 1][0] != -1) {
                            clo[i][j][0] = clo[i][j - 1][0];
                        }

                        if (clo[i - 1][j][2] != -1) {
                            clo[i][j][2] = clo[i - 1][j][2];
                        }
                    }
                }
            }


            // Mark the index of the furthest * from the right and bottom
            for (int i = n; i > 0; --i) {
                for (int j = m; j > 0; --j) {
                    if (arr[i][j] == '*') {
                        clo[i][j][1] = j;
                        clo[i][j][3] = i;

                        if (clo[i][j + 1][1] != -1) {
                            clo[i][j][1] = clo[i][j + 1][1];
                        }

                        if (clo[i + 1][j][3] != -1) {
                            clo[i][j][3] = clo[i + 1][j][3];
                        }
                    }
                }
            }

            ArrayList<Star> ans = new ArrayList<>();
            for (int i = 1; i <= n; ++i) {
                for (int j = 1; j <= m; ++j) {
                    if (arr[i][j] == '*') {
                        int diff1 = Math.min(j - clo[i][j][0], clo[i][j][1] - j);
                        int diff2 = Math.min(i - clo[i][j][2], clo[i][j][3] - i);
                        int diff = Math.min(diff1, diff2);

                        if (diff == 0)
                            continue;

                        pre[i][j - diff][0] += 1;
                        pre[i][j + diff + 1][0] -= 1;

                        pre[i - diff][j][1] += 1;
                        pre[i + diff + 1][j][1] -= 1;

                        ans.add(new Star(i, j, diff));
                    }
                }
            }


            for (int i = 1; i <= n; ++i) {
                for (int j = 1; j <= m; ++j) {
                    pre[i][j][0] += pre[i][j - 1][0];
                    pre[i][j][1] += pre[i - 1][j][1];

                    if (pre[i][j][0] + pre[i][j][1] == 0 && arr[i][j] == '*') {
                        out.println(-1);
                        return;
                    }
                }
            }

            out.println(ans.size());
            ans.stream().forEach(out::println);
        }

        public class Star {
            int x;
            int y;
            int l;

            public Star(int x, int y, int l) {
                this.x = x;
                this.y = y;
                this.l = l;
            }


            public String toString() {
                return x + " " + y + " " + l;
            }

        }

    }

    static class Kattio extends PrintWriter {
        private BufferedReader r;
        private String line;
        private StringTokenizer st;
        private String token;

        public Kattio(InputStream i) {
            super(new BufferedOutputStream(System.out));
            r = new BufferedReader(new InputStreamReader(i));
        }

        public Kattio(InputStream i, OutputStream o) {
            super(new BufferedOutputStream(o));
            r = new BufferedReader(new InputStreamReader(i));
        }

        public int nextInt() {
            return Integer.parseInt(nextToken());
        }

        public String next() {
            return nextToken();
        }

        private String peekToken() {
            if (token == null)
                try {
                    while (st == null || !st.hasMoreTokens()) {
                        line = r.readLine();
                        if (line == null) return null;
                        st = new StringTokenizer(line);
                    }
                    token = st.nextToken();
                } catch (IOException e) {
                }
            return token;
        }

        private String nextToken() {
            String ans = peekToken();
            token = null;
            return ans;
        }

    }
}




INSTRUCTIONS:
Solve the current question.
Provide:
1. A complete and efficient code solution, optimized for both time and space complexity.
2. A detailed explanation of the solution, including:
   - The intuition behind the approach;
   - Time and space complexity;
   - Important considerations about the algorithm.
3. You can use the example questions as general references for coding patterns and structure, but solve the current problem independently.
4. Don't use any external libraries. Any language is accepted.