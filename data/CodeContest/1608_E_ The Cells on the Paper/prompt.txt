CURRENT QUESTION:
On an endless checkered sheet of paper, n cells are chosen and colored in three colors, where n is divisible by 3. It turns out that there are exactly n/3 marked cells of each of three colors! 

Find the largest such k that it's possible to choose k/3 cells of each color, remove all other marked cells, and then select three rectangles with sides parallel to the grid lines so that the following conditions hold:

  * No two rectangles can intersect (but they can share a part of the boundary). In other words, the area of intersection of any two of these rectangles must be 0.
  * The i-th rectangle contains all the chosen cells of the i-th color and no chosen cells of other colors, for i = 1, 2, 3. 

Input

The first line of the input contains a single integer n — the number of the marked cells (3 ≤ n ≤ 10^5, n is divisible by 3).

The i-th of the following n lines contains three integers x_i, y_i, c_i (|x_i|,|y_i| ≤ 10^9; 1 ≤ c_i ≤ 3), where (x_i, y_i) are the coordinates of the i-th marked cell and c_i is its color.

It's guaranteed that all cells (x_i, y_i) in the input are distinct, and that there are exactly n/3 cells of each color.

Output

Output a single integer k — the largest number of cells you can leave.

Examples

Input


9
2 3 1
4 1 2
2 1 3
3 4 1
5 3 2
4 4 3
2 4 1
5 2 2
3 5 3


Output


6


Input


3
1 1 1
2 2 2
3 3 3


Output


3

Note

In the first sample, it's possible to leave 6 cells with indexes 1, 5, 6, 7, 8, 9.

In the second sample, it's possible to leave 3 cells with indexes 1, 2, 3.

SIMILAR QUESTIONS:
Similar question 1 (Similarity score: 0.70):
Name: 1198_E. Rectangle Painting 2
Tags: ['flows', 'graph matchings', 'graphs']
Description: There is a square grid of size n × n. Some cells are colored in black, all others are colored in white. In one operation you can select some rectangle and color all its cells in white. It costs min(h, w) to color a rectangle of size h × w. You are to make all cells white for minimum total cost.

The square is large, so we give it to you in a compressed way. The set of black cells is the union of m rectangles.

Input

The first line contains two integers n and m (1 ≤ n ≤ 10^{9}, 0 ≤ m ≤ 50) — the size of the square grid and the number of black rectangles.

Each of the next m lines contains 4 integers x_{i1} y_{i1} x_{i2} y_{i2} (1 ≤ x_{i1} ≤ x_{i2} ≤ n, 1 ≤ y_{i1} ≤ y_{i2} ≤ n) — the coordinates of the bottom-left and the top-right corner cells of the i-th black rectangle.

The rectangles may intersect.

Output

Print a single integer — the minimum total cost of painting the whole square in white.

Examples

Input


10 2
4 1 5 10
1 4 10 5


Output


4


Input


7 6
2 1 2 1
4 2 4 3
2 5 2 5
2 3 5 3
1 2 1 2
3 2 5 3


Output


3

Note

The examples and some of optimal solutions are shown on the pictures below.

<image>
Difficulty: 11
Solutions: #include <bits/stdc++.h>
using namespace std;
const int maxn = 10005;
const int inf = 0x3f3f3f3f;
int n, m, cnt = -1, p[maxn], dep[maxn], cur[maxn], s, t, zx[maxn], zy[maxn],
          cntx, cnty;
struct kkk {
  int lx, ly, rx, ry;
} a[maxn];
struct node {
  int v, next, cap, flow;
} e[maxn * 10];
void add(int u, int v, int cap, int flow) {
  cnt++;
  e[cnt].v = v;
  e[cnt].next = p[u];
  e[cnt].cap = cap;
  e[cnt].flow = flow;
  p[u] = cnt;
}
bool bfs() {
  queue<int> q;
  memset(dep, -1, sizeof(dep));
  q.push(s);
  dep[s] = 0;
  while (!q.empty()) {
    int u = q.front();
    q.pop();
    for (int i = p[u]; i != -1; i = e[i].next) {
      if (e[i].cap - e[i].flow > 0 && dep[e[i].v] == -1) {
        dep[e[i].v] = dep[u] + 1;
        q.push(e[i].v);
      }
    }
  }
  if (dep[t] == -1) return false;
  return true;
}
int dfs(int u, int maxflow) {
  if (u == t || maxflow == 0) return maxflow;
  int flow = 0;
  for (int &i = cur[u]; i != -1; i = e[i].next) {
    if (dep[e[i].v] == dep[u] + 1 && e[i].cap > e[i].flow) {
      int fl = dfs(e[i].v, min(maxflow, e[i].cap - e[i].flow));
      maxflow -= fl;
      flow += fl;
      e[i].flow += fl;
      e[i ^ 1].flow -= fl;
      if (maxflow == 0) break;
    }
  }
  return flow;
}
int dinic() {
  int ans = 0;
  while (bfs()) {
    for (int i = s; i <= t; i++) {
      cur[i] = p[i];
    }
    ans += dfs(s, inf);
  }
  return ans;
}
int main() {
  memset(p, -1, sizeof(p));
  int n, m;
  cin >> n >> m;
  s = 0, t = 201;
  for (int i = 1; i <= m; i++) {
    scanf("%d%d%d%d", &a[i].lx, &a[i].ly, &a[i].rx, &a[i].ry);
    a[i].lx--;
    a[i].ly--;
    zx[++cntx] = a[i].lx;
    zx[++cntx] = a[i].rx;
    zy[++cnty] = a[i].ly;
    zy[++cnty] = a[i].ry;
  }
  sort(zx + 1, zx + cntx + 1);
  sort(zy + 1, zy + cnty + 1);
  cntx = unique(zx + 1, zx + cntx + 1) - zx - 1;
  cnty = unique(zy + 1, zy + cnty + 1) - zy - 1;
  for (int i = 2; i <= cntx; i++) {
    for (int j = 2; j <= cnty; j++) {
      for (int k = 1; k <= m; k++) {
        if (a[k].lx <= zx[i - 1] && a[k].rx >= zx[i] && a[k].ly <= zy[j - 1] &&
            a[k].ry >= zy[j]) {
          add(i, j + 100, inf, 0);
          add(j + 100, i, 0, 0);
          break;
        }
      }
    }
  }
  for (int i = 2; i <= cntx; i++)
    add(s, i, zx[i] - zx[i - 1], 0), add(i, s, 0, 0);
  for (int i = 2; i <= cnty; i++)
    add(i + 100, t, zy[i] - zy[i - 1], 0), add(t, i + 100, 0, 0);
  cout << dinic();
  return 0;
}



INSTRUCTIONS:
Solve the current question.
Provide:
1. A complete and efficient code solution, optimized for both time and space complexity.
2. A detailed explanation of the solution, including:
   - The intuition behind the approach;
   - Time and space complexity;
   - Important considerations about the algorithm.
3. If the language has classes, implement in 'Solution' class. Any language is accepted.
4. Use the similar questions as references to improve the solution, but only if they are relevant.
5. Don't use any external libraries. Don't need to import any libraries.
