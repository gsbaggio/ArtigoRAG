#include <iostream>
#include <vector>
#include <algorithm>
#include <set>
using namespace std;

struct Cell {
    int x, y, color;
};

// Get the bounding rectangle for a set of cells
void getBoundingRect(const vector<Cell>& cells, int& min_x, int& min_y, int& max_x, int& max_y) {
    min_x = INT_MAX; min_y = INT_MAX;
    max_x = INT_MIN; max_y = INT_MIN;
    
    for (const auto& cell : cells) {
        min_x = min(min_x, cell.x);
        min_y = min(min_y, cell.y);
        max_x = max(max_x, cell.x);
        max_y = max(max_y, cell.y);
    }
}

// Check if rectangles overlap
bool doRectanglesOverlap(int min_x1, int min_y1, int max_x1, int max_y1,
                         int min_x2, int min_y2, int max_x2, int max_y2) {
    // They don't overlap if one is to the left of the other or one is above the other
    if (max_x1 < min_x2 || max_x2 < min_x1 || max_y1 < min_y2 || max_y2 < min_y1)
        return false;
    return true;
}

int main() {
    int n;
    cin >> n;
    
    vector<Cell> cells(n);
    for (int i = 0; i < n; i++) {
        cin >> cells[i].x >> cells[i].y >> cells[i].color;
    }
    
    // Separate cells by color
    vector<vector<Cell>> by_color(4); // 1-indexed colors
    for (const auto& cell : cells) {
        by_color[cell.color].push_back(cell);
    }
    
    int max_k = 0;
    
    // For each possible selection of k/3 cells of each color
    for (int k = n; k >= 3; k -= 3) {
        int per_color = k / 3;
        bool valid = false;
        
        // Generate all possible selections
        for (int color1 = 1; color1 <= 3 && !valid; color1++) {
            for (int color2 = 1; color2 <= 3 && !valid; color2++) {
                if (color2 == color1) continue;
                int color3 = 6 - color1 - color2; // The remaining color
                
                // Check if we have enough cells of each color
                if (by_color[color1].size() < per_color || by_color[color2].size() < per_color || by_color[color3].size() < per_color)
                    continue;
                
                // Try all possible selections for color1
                for (int select_type1 = 0; select_type1 < 4 && !valid; select_type1++) {
                    vector<Cell> selected1;
                    
                    // Select cells based on type (sorted by x or y, from beginning or end)
                    if (select_type1 == 0) { // leftmost
                        vector<Cell> sorted = by_color[color1];
                        sort(sorted.begin(), sorted.end(), [](const Cell& a, const Cell& b) { return a.x < b.x; });
                        selected1.assign(sorted.begin(), sorted.begin() + per_color);
                    } else if (select_type1 == 1) { // rightmost
                        vector<Cell> sorted = by_color[color1];
                        sort(sorted.begin(), sorted.end(), [](const Cell& a, const Cell& b) { return a.x < b.x; });
                        selected1.assign(sorted.end() - per_color, sorted.end());
                    } else if (select_type1 == 2) { // bottommost
                        vector<Cell> sorted = by_color[color1];
                        sort(sorted.begin(), sorted.end(), [](const Cell& a, const Cell& b) { return a.y < b.y; });
                        selected1.assign(sorted.begin(), sorted.begin() + per_color);
                    } else { // topmost
                        vector<Cell> sorted = by_color[color1];
                        sort(sorted.begin(), sorted.end(), [](const Cell& a, const Cell& b) { return a.y < b.y; });
                        selected1.assign(sorted.end() - per_color, sorted.end());
                    }
                    
                    int min_x1, min_y1, max_x1, max_y1;
                    getBoundingRect(selected1, min_x1, min_y1, max_x1, max_y1);
                    
                    // Try all possible selections for color2
                    for (int select_type2 = 0; select_type2 < 4 && !valid; select_type2++) {
                        vector<Cell> selected2;
                        
                        if (select_type2 == 0) { // leftmost
                            vector<Cell> sorted = by_color[color2];
                            sort(sorted.begin(), sorted.end(), [](const Cell& a, const Cell& b) { return a.x < b.x; });
                            selected2.assign(sorted.begin(), sorted.begin() + per_color);
                        } else if (select_type2 == 1) { // rightmost
                            vector<Cell> sorted = by_color[color2];
                            sort(sorted.begin(), sorted.end(), [](const Cell& a, const Cell& b) { return a.x < b.x; });
                            selected2.assign(sorted.end() - per_color, sorted.end());
                        } else if (select_type2 == 2) { // bottommost
                            vector<Cell> sorted = by_color[color2];
                            sort(sorted.begin(), sorted.end(), [](const Cell& a, const Cell& b) { return a.y < b.y; });
                            selected2.assign(sorted.begin(), sorted.begin() + per_color);
                        } else { // topmost
                            vector<Cell> sorted = by_color[color2];
                            sort(sorted.begin(), sorted.end(), [](const Cell& a, const Cell& b) { return a.y < b.y; });
                            selected2.assign(sorted.end() - per_color, sorted.end());
                        }
                        
                        int min_x2, min_y2, max_x2, max_y2;
                        getBoundingRect(selected2, min_x2, min_y2, max_x2, max_y2);
                        
                        // Check if the first two rectangles overlap
                        if (doRectanglesOverlap(min_x1, min_y1, max_x1, max_y1, min_x2, min_y2, max_x2, max_y2))
                            continue;
                        
                        // Try all possible selections for color3
                        for (int select_type3 = 0; select_type3 < 4 && !valid; select_type3++) {
                            vector<Cell> selected3;
                            
                            if (select_type3 == 0) { // leftmost
                                vector<Cell> sorted = by_color[color3];
                                sort(sorted.begin(), sorted.end(), [](const Cell& a, const Cell& b) { return a.x < b.x; });
                                selected3.assign(sorted.begin(), sorted.begin() + per_color);
                            } else if (select_type3 == 1) { // rightmost
                                vector<Cell> sorted = by_color[color3];
                                sort(sorted.begin(), sorted.end(), [](const Cell& a, const Cell& b) { return a.x < b.x; });
                                selected3.assign(sorted.end() - per_color, sorted.end());
                            } else if (select_type3 == 2) { // bottommost
                                vector<Cell> sorted = by_color[color3];
                                sort(sorted.begin(), sorted.end(), [](const Cell& a, const Cell& b) { return a.y < b.y; });
                                selected3.assign(sorted.begin(), sorted.begin() + per_color);
                            } else { // topmost
                                vector<Cell> sorted = by_color[color3];
                                sort(sorted.begin(), sorted.end(), [](const Cell& a, const Cell& b) { return a.y < b.y; });
                                selected3.assign(sorted.end() - per_color, sorted.end());
                            }
                            
                            int min_x3, min_y3, max_x3, max_y3;
                            getBoundingRect(selected3, min_x3, min_y3, max_x3, max_y3);
                            
                            // Check if the third rectangle overlaps with the first two
                            if (!doRectanglesOverlap(min_x1, min_y1, max_x1, max_y1, min_x3, min_y3, max_x3, max_y3) && 
                                !doRectanglesOverlap(min_x2, min_y2, max_x2, max_y2, min_x3, min_y3, max_x3, max_y3)) {
                                valid = true;
                                max_k = k;
                                break;
                            }
                        }
                    }
                }
            }
        }
        
        if (valid) break;
    }
    
    cout << max_k << endl;
    
    return 0;
}