CURRENT QUESTION:
You are given a string s of length n consisting of characters a and/or b.

Let \operatorname{AB}(s) be the number of occurrences of string ab in s as a substring. Analogically, \operatorname{BA}(s) is the number of occurrences of ba in s as a substring.

In one step, you can choose any index i and replace s_i with character a or b.

What is the minimum number of steps you need to make to achieve \operatorname{AB}(s) = \operatorname{BA}(s)?

Reminder:

The number of occurrences of string d in s as substring is the number of indices i (1 ≤ i ≤ |s| - |d| + 1) such that substring s_i s_{i + 1} ... s_{i + |d| - 1} is equal to d. For example, \operatorname{AB}(aabbbabaa) = 2 since there are two indices i: i = 2 where aabbbabaa and i = 6 where aabbbabaa.

Input

Each test contains multiple test cases. The first line contains the number of test cases t (1 ≤ t ≤ 1000). Description of the test cases follows.

The first and only line of each test case contains a single string s (1 ≤ |s| ≤ 100, where |s| is the length of the string s), consisting only of characters a and/or b.

Output

For each test case, print the resulting string s with \operatorname{AB}(s) = \operatorname{BA}(s) you'll get making the minimum number of steps.

If there are multiple answers, print any of them.

Example

Input


4
b
aabbbabaa
abbb
abbaab


Output


b
aabbbabaa
bbbb
abbaaa

Note

In the first test case, both \operatorname{AB}(s) = 0 and \operatorname{BA}(s) = 0 (there are no occurrences of ab (ba) in b), so can leave s untouched.

In the second test case, \operatorname{AB}(s) = 2 and \operatorname{BA}(s) = 2, so you can leave s untouched. 

In the third test case, \operatorname{AB}(s) = 1 and \operatorname{BA}(s) = 0. For example, we can change s_1 to b and make both values zero.

In the fourth test case, \operatorname{AB}(s) = 2 and \operatorname{BA}(s) = 1. For example, we can change s_6 to a and make both values equal to 1.

EXAMPLE QUESTIONS:
Example question 1:
Name: 13_E. Holes
Tags: ['data structures', 'dsu']
Description: Little Petya likes to play a lot. Most of all he likes to play a game «Holes». This is a game for one person with following rules:

There are N holes located in a single row and numbered from left to right with numbers from 1 to N. Each hole has it's own power (hole number i has the power ai). If you throw a ball into hole i it will immediately jump to hole i + ai, then it will jump out of it and so on. If there is no hole with such number, the ball will just jump out of the row. On each of the M moves the player can perform one of two actions: 

  * Set the power of the hole a to value b. 
  * Throw a ball into the hole a and count the number of jumps of a ball before it jump out of the row and also write down the number of the hole from which it jumped out just before leaving the row. 



Petya is not good at math, so, as you have already guessed, you are to perform all computations.

Input

The first line contains two integers N and M (1 ≤ N ≤ 105, 1 ≤ M ≤ 105) — the number of holes in a row and the number of moves. The second line contains N positive integers not exceeding N — initial values of holes power. The following M lines describe moves made by Petya. Each of these line can be one of the two types: 

  * 0 a b
  * 1 a

Type 0 means that it is required to set the power of hole a to b, and type 1 means that it is required to throw a ball into the a-th hole. Numbers a and b are positive integers do not exceeding N.

Output

For each move of the type 1 output two space-separated numbers on a separate line — the number of the last hole the ball visited before leaving the row and the number of jumps it made.

Examples

Input

8 5
1 1 1 1 1 2 8 2
1 1
0 1 3
1 1
0 3 4
1 2


Output

8 7
8 5
7 3
Difficulty: 11
Solutions: #include <bits/stdc++.h>
using namespace std;
const double PI =
    3.141592653589793238462643383279502884197169399375105820974944;
int n, m;
int bl;
int a[100005], nex[100005], steps[100005], b[100005];
int main() {
  scanf("%d%d", &n, &m);
  bl = sqrt(n);
  for (int i = 0; i < (n); i++) scanf("%d", &a[i]), b[i] = i / bl;
  for (int i = (n - 1); i >= 0; i--) {
    int x = i + a[i];
    if (x >= n)
      nex[i] = -1, steps[i] = 1;
    else if (b[i] == b[x])
      nex[i] = nex[x], steps[i] = 1 + steps[x];
    else
      nex[i] = x, steps[i] = 1;
  }
  while (m--) {
    int type, x, y, z;
    scanf("%d", &type);
    if (type == 0) {
      scanf("%d%d", &x, &y);
      x--;
      a[x] = y;
      if (x + y >= n)
        nex[x] = -1, steps[x] = 1;
      else if (b[x] == b[x + y])
        nex[x] = nex[x + y], steps[x] = 1 + steps[x + y];
      else
        nex[x] = x + y, steps[x] = 1;
      while (x > 0 and b[x] == b[x - 1]) {
        x--;
        y = a[x];
        if (x + y >= n)
          nex[x] = -1, steps[x] = 1;
        else if (b[x] == b[x + y])
          nex[x] = nex[x + y], steps[x] = 1 + steps[x + y];
        else
          nex[x] = x + y, steps[x] = 1;
      }
    } else {
      scanf("%d", &x);
      x--;
      int ans = 0, cur = x;
      while (x != -1) {
        ans += steps[x];
        cur = x;
        x = nex[x];
      }
      while (cur < n) x = cur, cur = cur + a[cur];
      printf("%d %d\n", x + 1, ans);
    }
  }
}


Example question 2:
Name: 449_A. Jzzhu and Chocolate
Tags: ['greedy', 'math']
Description: Jzzhu has a big rectangular chocolate bar that consists of n × m unit squares. He wants to cut this bar exactly k times. Each cut must meet the following requirements:

  * each cut should be straight (horizontal or vertical); 
  * each cut should go along edges of unit squares (it is prohibited to divide any unit chocolate square with cut); 
  * each cut should go inside the whole chocolate bar, and all cuts must be distinct. 



The picture below shows a possible way to cut a 5 × 6 chocolate for 5 times.

<image>

Imagine Jzzhu have made k cuts and the big chocolate is splitted into several pieces. Consider the smallest (by area) piece of the chocolate, Jzzhu wants this piece to be as large as possible. What is the maximum possible area of smallest piece he can get with exactly k cuts? The area of a chocolate piece is the number of unit squares in it.

Input

A single line contains three integers n, m, k (1 ≤ n, m ≤ 109; 1 ≤ k ≤ 2·109).

Output

Output a single integer representing the answer. If it is impossible to cut the big chocolate k times, print -1.

Examples

Input

3 4 1


Output

6


Input

6 4 2


Output

8


Input

2 3 4


Output

-1

Note

In the first sample, Jzzhu can cut the chocolate following the picture below:

<image>

In the second sample the optimal division looks like this:

<image>

In the third sample, it's impossible to cut a 2 × 3 chocolate 4 times.
Difficulty: 7
Solutions: n,m,k=map(int,raw_input().split())
if k>n+m-2:
    print -1
else:
    print max((n*(m/(k+1))),(m*(n/(k+1))),(n/max(1,k-m+2)),(m/max(1,k-n+2)))



INSTRUCTIONS:
Solve the current question.
Provide:
1. A complete and efficient code solution, optimized for both time and space complexity.
2. A detailed explanation of the solution, including:
   - The intuition behind the approach;
   - Time and space complexity;
   - Important considerations about the algorithm.
3. If the language has classes, implement in 'Solution' class. Any language is accepted.
4. You can use the example questions as general references for coding patterns and structure, but solve the current problem independently.
5. Don't use any external libraries. Don't need to import any libraries.
