CURRENT QUESTION:
Given n, find any array a_1, a_2, …, a_n of integers such that all of the following conditions hold: 

  * 1 ≤ a_i ≤ 10^9 for every i from 1 to n.

  * a_1 < a_2 < … <a_n

  * For every i from 2 to n, a_i isn't divisible by a_{i-1}




It can be shown that such an array always exists under the constraints of the problem.

Input

The first line contains the number of test cases t (1 ≤ t ≤ 100). Description of the test cases follows.

The only line of each test case contains a single integer n (1 ≤ n ≤ 1000).

It is guaranteed that the sum of n over all test cases does not exceed 10^4.

Output

For each test case print n integers a_1, a_2, …, a_n — the array you found. If there are multiple arrays satisfying all the conditions, print any of them.

Example

Input


3
1
2
7


Output


1
2 3
111 1111 11111 111111 1111111 11111111 111111111

Note

In the first test case, array [1] satisfies all the conditions.

In the second test case, array [2, 3] satisfies all the conditions, as 2<3 and 3 is not divisible by 2.

In the third test case, array [111, 1111, 11111, 111111, 1111111, 11111111, 111111111] satisfies all the conditions, as it's increasing and a_i isn't divisible by a_{i-1} for any i from 2 to 7.

EXAMPLE QUESTIONS:
Example question 1:
Name: 430_C. Xor-tree
Tags: ['dfs and similar', 'trees']
Description: Iahub is very proud of his recent discovery, propagating trees. Right now, he invented a new tree, called xor-tree. After this new revolutionary discovery, he invented a game for kids which uses xor-trees.

The game is played on a tree having n nodes, numbered from 1 to n. Each node i has an initial value initi, which is either 0 or 1. The root of the tree is node 1.

One can perform several (possibly, zero) operations on the tree during the game. The only available type of operation is to pick a node x. Right after someone has picked node x, the value of node x flips, the values of sons of x remain the same, the values of sons of sons of x flips, the values of sons of sons of sons of x remain the same and so on.

The goal of the game is to get each node i to have value goali, which can also be only 0 or 1. You need to reach the goal of the game by using minimum number of operations.

Input

The first line contains an integer n (1 ≤ n ≤ 105). Each of the next n - 1 lines contains two integers ui and vi (1 ≤ ui, vi ≤ n; ui ≠ vi) meaning there is an edge between nodes ui and vi. 

The next line contains n integer numbers, the i-th of them corresponds to initi (initi is either 0 or 1). The following line also contains n integer numbers, the i-th number corresponds to goali (goali is either 0 or 1).

Output

In the first line output an integer number cnt, representing the minimal number of operations you perform. Each of the next cnt lines should contain an integer xi, representing that you pick a node xi.

Examples

Input

10
2 1
3 1
4 2
5 1
6 2
7 5
8 6
9 8
10 5
1 0 1 1 0 1 0 1 0 1
1 0 1 0 0 1 1 1 0 1


Output

2
4
7
Difficulty: 9
Solutions: #include <bits/stdc++.h>
using namespace std;
const int N = 100001;
int n;
vector<int> g[N];
int a[N];
int b[N];
vector<int> ans;
void dfs(int now, int fa, int depth, int k[2]) {
  a[now] ^= k[depth & 1];
  if (a[now] != b[now]) {
    ans.push_back(now);
    k[depth & 1] ^= 1;
  }
  for (int i = 0; i < g[now].size(); ++i)
    if (g[now][i] != fa) {
      int kk[2];
      kk[0] = k[0];
      kk[1] = k[1];
      dfs(g[now][i], now, depth + 1, kk);
    }
}
int main() {
  scanf("%d", &n);
  int u, v;
  for (int i = 0; i < n - 1; ++i) {
    scanf("%d%d", &u, &v);
    g[u].push_back(v);
    g[v].push_back(u);
  }
  for (int i = 1; i <= n; ++i) scanf("%d", &a[i]);
  for (int i = 1; i <= n; ++i) scanf("%d", &b[i]);
  int k[2] = {0, 0};
  dfs(1, 0, 0, k);
  printf("%d\n", ans.size());
  for (int i = 0; i < ans.size(); ++i) printf("%d\n", ans[i]);
  return 0;
}


Example question 2:
Name: 66_B. Petya and Countryside
Tags: ['brute force', 'implementation']
Description: Little Petya often travels to his grandmother in the countryside. The grandmother has a large garden, which can be represented as a rectangle 1 × n in size, when viewed from above. This rectangle is divided into n equal square sections. The garden is very unusual as each of the square sections possesses its own fixed height and due to the newest irrigation system we can create artificial rain above each section.

Creating artificial rain is an expensive operation. That's why we limit ourselves to creating the artificial rain only above one section. At that, the water from each watered section will flow into its neighbouring sections if their height does not exceed the height of the section. That is, for example, the garden can be represented by a 1 × 5 rectangle, where the section heights are equal to 4, 2, 3, 3, 2. Then if we create an artificial rain over any of the sections with the height of 3, the water will flow over all the sections, except the ones with the height of 4. See the illustration of this example at the picture:

<image>

As Petya is keen on programming, he decided to find such a section that if we create artificial rain above it, the number of watered sections will be maximal. Help him. 

Input

The first line contains a positive integer n (1 ≤ n ≤ 1000). The second line contains n positive integers which are the height of the sections. All the numbers are no less than 1 and not more than 1000.

Output

Print a single number, the maximal number of watered sections if we create artificial rain above exactly one section.

Examples

Input

1
2


Output

1


Input

5
1 2 1 2 1


Output

3


Input

8
1 2 1 1 1 3 3 4


Output

6
Difficulty: 8
Solutions: 
def readints():
    return map(int,raw_input().split())

n=input()
x=readints()
def main():
    f=1
    for i in xrange(n):
        c=x[i]
        nf=1
        for k in xrange(i-1,-1,-1):
            if c<x[k]:break
            c=x[k]
            nf+=1
        c=x[i]
        for k in xrange(i+1,n):
            if c<x[k]:break
            c=x[k]
            nf+=1
        f=max(f,nf)
    print f

main()

Example question 3:
Name: small-is-cute-1
Tags: []
Description: Given three positive integers N, A and B (A < B < N), find the sum of all positive integers less than N, which are divisible by either A or B.

For example, when N = 20, A = 4 and B = 7, the possible values are 4, 7, 8, 12, 14, and 16. Their sum is 61.
Input Format
The only line of the input file contains three space separated integers N, A and B.

Output Format
Output the required sum.

Constraints
10 ≤ N ≤ 50000
2 ≤ A < B < N

SAMPLE INPUT
20 4 7

SAMPLE OUTPUT
61
Difficulty: 0
Solutions: #! /usr/bin/python

s = raw_input()
lst = s.split(' ')
n = int(lst[0])
a = int(lst[1])
b = int(lst[2])

sum = 0
for x in xrange(a,n,1):
        if (((x % a) == 0) or ((x % b) == 0)):
                sum = sum + x

print sum


INSTRUCTIONS:
Solve the current question.
Provide:
1. A complete and efficient code solution, optimized for both time and space complexity.
2. A detailed explanation of the solution, including:
   - The intuition behind the approach;
   - Time and space complexity;
   - Important considerations about the algorithm.
3. You can use the example questions as general references for coding patterns and structure, but solve the current problem independently.
4. Don't use any external libraries. Any language is accepted.