CURRENT QUESTION:
Given n, find any array a_1, a_2, …, a_n of integers such that all of the following conditions hold: 

  * 1 ≤ a_i ≤ 10^9 for every i from 1 to n.

  * a_1 < a_2 < … <a_n

  * For every i from 2 to n, a_i isn't divisible by a_{i-1}




It can be shown that such an array always exists under the constraints of the problem.

Input

The first line contains the number of test cases t (1 ≤ t ≤ 100). Description of the test cases follows.

The only line of each test case contains a single integer n (1 ≤ n ≤ 1000).

It is guaranteed that the sum of n over all test cases does not exceed 10^4.

Output

For each test case print n integers a_1, a_2, …, a_n — the array you found. If there are multiple arrays satisfying all the conditions, print any of them.

Example

Input


3
1
2
7


Output


1
2 3
111 1111 11111 111111 1111111 11111111 111111111

Note

In the first test case, array [1] satisfies all the conditions.

In the second test case, array [2, 3] satisfies all the conditions, as 2<3 and 3 is not divisible by 2.

In the third test case, array [111, 1111, 11111, 111111, 1111111, 11111111, 111111111] satisfies all the conditions, as it's increasing and a_i isn't divisible by a_{i-1} for any i from 2 to 7.

SIMILAR QUESTIONS:
Similar question 1 (Similarity score: 0.83):
Name: 1497_B. M-arrays
Tags: ['constructive algorithms', 'greedy', 'math']
Description: You are given an array a_1, a_2, …, a_n consisting of n positive integers and a positive integer m.

You should divide elements of this array into some arrays. You can order the elements in the new arrays as you want.

Let's call an array m-divisible if for each two adjacent numbers in the array (two numbers on the positions i and i+1 are called adjacent for each i) their sum is divisible by m. An array of one element is m-divisible.

Find the smallest number of m-divisible arrays that a_1, a_2, …, a_n is possible to divide into.

Input

The first line contains a single integer t (1 ≤ t ≤ 1000) — the number of test cases.

The first line of each test case contains two integers n, m (1 ≤ n ≤ 10^5, 1 ≤ m ≤ 10^5).

The second line of each test case contains n integers a_1, a_2, …, a_n (1 ≤ a_i ≤ 10^9).

It is guaranteed that the sum of n and the sum of m over all test cases do not exceed 10^5.

Output

For each test case print the answer to the problem.

Example

Input


4
6 4
2 2 8 6 9 4
10 8
1 1 1 5 2 4 4 8 6 7
1 1
666
2 2
2 4


Output


3
6
1
1

Note

In the first test case we can divide the elements as follows:

  * [4, 8]. It is a 4-divisible array because 4+8 is divisible by 4. 
  * [2, 6, 2]. It is a 4-divisible array because 2+6 and 6+2 are divisible by 4. 
  * [9]. It is a 4-divisible array because it consists of one element. 
Difficulty: 8
Solutions: #include<bits/stdc++.h>
#define ll long long
#define rep(i, m, n) for (int i = m; i <= n; i++)
#define per(i, m, n) for (int i = m; i >= n; i--)
#define pii pair<int, int>
#define pb push_back
#define mp make_pair
#define INF 0x3f3f3f3f
using namespace std;

const int maxn = 1e5 + 5;

int a[maxn], cnt[maxn];

int main() {
    ios::sync_with_stdio(false);
    cin.tie(0); cout.tie(0);
    int T;
    cin >> T;
    while (T--) {
        int N, M;
        cin >> N >> M;
        rep(i, 0, M - 1) cnt[i] = 0;
        rep(i, 1, N) cin >> a[i], cnt[(a[i] % M)]++;
        int ans = (cnt[0] > 0);
        rep(i, 1, M - 1) {
            int x = cnt[i], y = cnt[M - i];
            if (x == 0 && y == 0) continue;
            else ans++;
            if (i == M - i) {
                cnt[i] = 0;
                continue;
            }
            if (x > y) {
                cnt[i] -= (y + 1);
                cnt[M - i] -= y;
            } else if (x < y) {
                cnt[i] -= x;
                cnt[M - i] -= (x + 1);
            } else {
                cnt[i] = 0, cnt[M - i] = 0;
            }
        }
        rep(i, 1, M - 1) ans += cnt[i];
        cout << ans << "\n";
    }
    return 0;
}


Similar question 2 (Similarity score: 0.80):
Name: 1416_B. Make Them Equal
Tags: ['constructive algorithms', 'greedy', 'math']
Description: You are given an array a consisting of n positive integers, numbered from 1 to n. You can perform the following operation no more than 3n times:

  1. choose three integers i, j and x (1 ≤ i, j ≤ n; 0 ≤ x ≤ 10^9); 
  2. assign a_i := a_i - x ⋅ i, a_j := a_j + x ⋅ i. 



After each operation, all elements of the array should be non-negative.

Can you find a sequence of no more than 3n operations after which all elements of the array are equal?

Input

The first line contains one integer t (1 ≤ t ≤ 10^4) — the number of test cases. Then t test cases follow.

The first line of each test case contains one integer n (1 ≤ n ≤ 10^4) — the number of elements in the array. The second line contains n integers a_1, a_2, ..., a_n (1 ≤ a_i ≤ 10^5) — the elements of the array.

It is guaranteed that the sum of n over all test cases does not exceed 10^4.

Output

For each test case print the answer to it as follows:

  * if there is no suitable sequence of operations, print -1; 
  * otherwise, print one integer k (0 ≤ k ≤ 3n) — the number of operations in the sequence. Then print k lines, the m-th of which should contain three integers i, j and x (1 ≤ i, j ≤ n; 0 ≤ x ≤ 10^9) for the m-th operation. 



If there are multiple suitable sequences of operations, print any of them. Note that you don't have to minimize k.

Example

Input


3
4
2 16 4 18
6
1 2 3 4 5 6
5
11 19 1 1 3


Output


2
4 1 2
2 3 3
-1
4
1 2 4
2 4 5
2 3 3
4 5 1
Difficulty: 8
Solutions: #include <bits/stdc++.h>
signed main() {
  int t;
  std::cin >> t;
  while (t--) {
    int n;
    std::cin >> n;
    int a[n];
    int sum = 0;
    for (int i = 0; i < n; i++) {
      std::cin >> a[i];
      sum += a[i];
    }
    if (sum % n != 0) {
      std::cout << -1 << std::endl;
      continue;
    }
    std::vector<std::pair<int, std::pair<int, int> > > ans;
    for (int i = 1; i < n; i++) {
      if (a[i] % (i + 1) != 0) {
        ans.push_back({1, {i + 1, i + 1 - (a[i] % (i + 1))}});
        a[i] += i + 1 - (a[i] % (i + 1));
      }
      ans.push_back({i + 1, {1, a[i] / (i + 1)}});
    }
    for (int i = 1; i < n; i++) {
      ans.push_back({1, {i + 1, sum / n}});
    }
    std::cout << ans.size() << std::endl;
    for (int i = 0; i < ans.size(); i++) {
      std::cout << ans[i].first << " " << ans[i].second.first << " "
                << ans[i].second.second << std::endl;
    }
  }
  return 0;
}


Similar question 3 (Similarity score: 0.80):
Name: 1417_D. Make Them Equal
Tags: ['constructive algorithms', 'greedy', 'math']
Description: You are given an array a consisting of n positive integers, numbered from 1 to n. You can perform the following operation no more than 3n times:

  1. choose three integers i, j and x (1 ≤ i, j ≤ n; 0 ≤ x ≤ 10^9); 
  2. assign a_i := a_i - x ⋅ i, a_j := a_j + x ⋅ i. 



After each operation, all elements of the array should be non-negative.

Can you find a sequence of no more than 3n operations after which all elements of the array are equal?

Input

The first line contains one integer t (1 ≤ t ≤ 10^4) — the number of test cases. Then t test cases follow.

The first line of each test case contains one integer n (1 ≤ n ≤ 10^4) — the number of elements in the array. The second line contains n integers a_1, a_2, ..., a_n (1 ≤ a_i ≤ 10^5) — the elements of the array.

It is guaranteed that the sum of n over all test cases does not exceed 10^4.

Output

For each test case print the answer to it as follows:

  * if there is no suitable sequence of operations, print -1; 
  * otherwise, print one integer k (0 ≤ k ≤ 3n) — the number of operations in the sequence. Then print k lines, the m-th of which should contain three integers i, j and x (1 ≤ i, j ≤ n; 0 ≤ x ≤ 10^9) for the m-th operation. 



If there are multiple suitable sequences of operations, print any of them. Note that you don't have to minimize k.

Example

Input


3
4
2 16 4 18
6
1 2 3 4 5 6
5
11 19 1 1 3


Output


2
4 1 2
2 3 3
-1
4
1 2 4
2 4 5
2 3 3
4 5 1
Difficulty: 10
Solutions: # ------------------- fast io --------------------
import os
import sys
from io import BytesIO, IOBase

BUFSIZE = 8192


class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = "x" in file.mode or "r" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b"\n") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)


class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode("ascii"))
        self.read = lambda: self.buffer.read().decode("ascii")
        self.readline = lambda: self.buffer.readline().decode("ascii")


sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip("\r\n")

# ------------------- fast io --------------------
from math import gcd, ceil

def pre(s):
    n = len(s)
    pi = [0] * n
    for i in range(1, n):
        j = pi[i - 1]
        while j and s[i] != s[j]:
            j = pi[j - 1]
        if s[i] == s[j]:
            j += 1
        pi[i] = j
    return pi


def prod(a):
    ans = 1
    for each in a:
        ans = (ans * each)
    return ans

def lcm(a, b): return a * b // gcd(a, b)


def binary(x, length=16):
    y = bin(x)[2:]
    return y if len(y) >= length else "0" * (length - len(y)) + y


for _ in range(int(input()) if True else 1):
    n = int(input())
    #n, k = map(int, input().split())
    #a, b = map(int, input().split())
    #c, d = map(int, input().split())
    a = list(map(int, input().split()))
    #b = list(map(int, input().split()))
    #s = input()
    req = sum(a) / n
    if req != int(req):
        print(-1)
        continue
    req = int(req)
    print((n-1)*3)
    for i in range(1, n):
        next = (i + 1 - a[i]) % (i+1)
        print(1, i+1, next)
        a[0] -= next
        a[i] += next
        print(i+1, 1, a[i]//(i+1))
        a[0] += a[i]
        a[i] = 0

    for i in range(1, n):
        print(1, i+1, req)










INSTRUCTIONS:
Solve the current question.
Provide:
1. A complete and efficient code solution, optimized for both time and space complexity.
2. A detailed explanation of the solution, including:
   - The intuition behind the approach;
   - Time and space complexity;
   - Important considerations about the algorithm.
3. Use the similar questions as references to improve the solution, but only if they are relevant.
4. Don't use any external libraries. Any language is accepted.