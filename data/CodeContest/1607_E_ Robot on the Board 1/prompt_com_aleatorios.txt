CURRENT QUESTION:
The robot is located on a checkered rectangular board of size n × m (n rows, m columns). The rows in the board are numbered from 1 to n from top to bottom, and the columns — from 1 to m from left to right.

The robot is able to move from the current cell to one of the four cells adjacent by side.

The sequence of commands s executed by the robot is given. Each command is denoted by one of the symbols 'L', 'R', 'D' or 'U', and triggers the movement to left, right, down or up, respectively.

The robot can start its movement in any cell. The robot executes the commands starting from the first one, strictly in the order in which they are listed in s. If the robot moves beyond the edge of the board, it falls and breaks. A command that causes the robot to break is not considered successfully executed.

The robot's task is to execute as many commands as possible without falling off the board. For example, on board 3 × 3, if the robot starts a sequence of actions s="RRDLUU" ("right", "right", "down", "left", "up", "up") from the central cell, the robot will perform one command, then the next command will force him to cross the edge. If the robot starts moving from the cell (2, 1) (second row, first column) then all commands will be executed successfully and the robot will stop at the cell (1, 2) (first row, second column).

<image> The robot starts from cell (2, 1) (second row, first column). It moves right, right, down, left, up, and up. In this case it ends in the cell (1, 2) (first row, second column).

Determine the cell from which the robot should start its movement in order to execute as many commands as possible.

Input

The first line contains an integer t (1 ≤ t ≤ 10^4) — the number of test cases.

The next 2t lines contain descriptions of the test cases.

In the description of each test case, the first line contains two integers n and m (1 ≤ n, m ≤ 10^6) — the height and width of the field that the robot is located on. The second line of the description is a string s consisting solely of characters 'L', 'R', 'D' and 'U' — the sequence of commands the robot executes. The string has a length from 1 to 10^6 commands.

It is guaranteed that the total length of s over all test cases does not exceed 10^6.

Output

Print t lines, each of which contains the answer to the corresponding test case. The answer to the test case are two integers r (1 ≤ r ≤ n) and c (1 ≤ c ≤ m), separated by a space — the coordinates of the cell (row number and column number) from which the robot should start moving to perform as many commands as possible.

If there are several such cells, you may output any of them.

Example

Input


4
1 1
L
1 2
L
3 3
RRDLUU
4 3
LUURRDDLLLUU


Output


1 1
1 2
2 1
3 2

EXAMPLE QUESTIONS:
Example question 1:
Name: 983_E. NN country
Tags: ['binary search', 'data structures', 'trees']
Description: In the NN country, there are n cities, numbered from 1 to n, and n - 1 roads, connecting them. There is a roads path between any two cities.

There are m bidirectional bus routes between cities. Buses drive between two cities taking the shortest path with stops in every city they drive through. Travelling by bus, you can travel from any stop on the route to any other. You can travel between cities only by bus.

You are interested in q questions: is it possible to get from one city to another and what is the minimum number of buses you need to use for it?

Input

The first line contains a single integer n (2 ≤ n ≤ 2 ⋅ 10^5) — the number of cities.

The second line contains n - 1 integers p_2, p_3, …, p_n (1 ≤ p_i < i), where p_i means that cities p_i and i are connected by road.

The third line contains a single integer m (1 ≤ m ≤ 2 ⋅ 10^5) — the number of bus routes.

Each of the next m lines contains 2 integers a and b (1 ≤ a, b ≤ n, a ≠ b), meaning that there is a bus route between cities a and b. It is possible that there is more than one route between two cities.

The next line contains a single integer q (1 ≤ q ≤ 2 ⋅ 10^5) — the number of questions you are interested in.

Each of the next q lines contains 2 integers v and u (1 ≤ v, u ≤ n, v ≠ u), meaning that you are interested if it is possible to get from city v to city u and what is the minimum number of buses you need to use for it.

Output

Print the answer for each question on a separate line. If there is no way to get from one city to another, print -1. Otherwise print the minimum number of buses you have to use.

Examples

Input

7
1 1 1 4 5 6
4
4 2
5 4
1 3
6 7
6
4 5
3 5
7 2
4 5
3 2
5 3


Output

1
3
-1
1
2
3


Input

7
1 1 2 3 4 1
4
4 7
3 5
7 6
7 6
6
4 6
3 1
3 2
2 7
6 3
5 3


Output

1
-1
-1
1
-1
1

Note

<image> Routes for first sample are marked on the picture. 
Difficulty: 11
Solutions: #include <bits/stdc++.h>
using namespace std;
const int N = 200005;
int n, m, q, t, tt, a[N], dfn[N], r[N], dep[N], fa[N][25], f[N][25], qq[N][2],
    rt[N], s[N * 20], ls[N * 20], rs[N * 20], ans[N], ff[N];
pair<int, int> e[N];
vector<int> g[N];
void dfs1(int x, int p) {
  dfn[x] = ++t;
  fa[x][0] = p;
  dep[x] = dep[p] + 1;
  for (int i = 0; i < g[x].size(); i++) dfs1(g[x][i], x);
  r[x] = t;
}
void dfs2(int x) {
  for (int i = 0; i < g[x].size(); i++) {
    dfs2(g[x][i]);
    f[x][0] = (dep[f[g[x][i]][0]] > dep[f[x][0]] ? f[x][0] : f[g[x][i]][0]);
  }
}
int lca(int x, int y) {
  if (dep[x] < dep[y]) swap(x, y);
  int sub = dep[x] - dep[y];
  for (int i = 0; i <= 20; i++)
    if (sub & (1 << i)) x = fa[x][i];
  if (x == y) return x;
  for (int i = 20; i >= 0; i--)
    if (fa[x][i] != fa[y][i]) x = fa[x][i], y = fa[y][i];
  return fa[x][0];
}
int gtdis(int x, int y, int id, int kd) {
  int s = 0;
  for (int i = 20; i >= 0; i--)
    if (dep[f[x][i]] > dep[y]) s |= (1 << i), x = f[x][i];
  qq[id][kd] = x;
  return s;
}
bool cmp(pair<int, int> a, pair<int, int> b) {
  return dfn[a.first] < dfn[b.first];
}
void ins(int &x, int y, int l, int r, int p) {
  x = ++tt;
  s[x] = s[y] + 1;
  if (l == r) return;
  int md = l + r >> 1;
  if (p <= md)
    rs[x] = rs[y], ins(ls[x], ls[y], l, md, p);
  else
    ls[x] = ls[y], ins(rs[x], rs[y], md + 1, r, p);
}
int qry(int x, int y, int l, int r, int tl, int tr) {
  if (tl <= l && r <= tr) return s[y] - s[x];
  int md = l + r >> 1, res = 0;
  if (tl <= md) res += qry(ls[x], ls[y], l, md, tl, tr);
  if (tr > md) res += qry(rs[x], rs[y], md + 1, r, tl, tr);
  return res;
}
int main() {
  scanf("%d", &n);
  for (int i = 2, p; i <= n; i++) {
    scanf("%d", &p);
    g[p].push_back(i);
  }
  dfs1(1, 0);
  for (int i = 1; i <= 20; i++)
    for (int j = 1; j <= n; j++) fa[j][i] = fa[fa[j][i - 1]][i - 1];
  for (int i = 1; i <= n; i++) f[i][0] = i;
  scanf("%d", &m);
  for (int i = 1; i <= m; i++) {
    int u, v;
    scanf("%d%d", &u, &v);
    int t = lca(u, v);
    e[i] = make_pair(u, v);
    if (dep[f[u][0]] > dep[t]) f[u][0] = t;
    if (dep[f[v][0]] > dep[t]) f[v][0] = t;
  }
  dfs2(1);
  for (int i = 1; i <= 20; i++)
    for (int j = 1; j <= n; j++) f[j][i] = f[f[j][i - 1]][i - 1];
  scanf("%d", &q);
  for (int i = 1; i <= q; i++) {
    int u, v;
    scanf("%d%d", &u, &v);
    int t = lca(u, v);
    if (dep[f[u][20]] > dep[t] || dep[f[v][20]] > dep[t])
      ans[i] = -1;
    else {
      if (u == t)
        ff[i] = 1, ans[i] = gtdis(v, t, i, 0) + 1;
      else if (v == t)
        ff[i] = 1, ans[i] = gtdis(u, t, i, 0) + 1;
      else
        ans[i] = gtdis(u, t, i, 0) + gtdis(v, t, i, 1) + 1;
    }
  }
  sort(e + 1, e + m + 1, cmp);
  for (int i = 1; i <= m; i++) a[i] = dfn[e[i].first];
  for (int i = 1; i <= m; i++) ins(rt[i], rt[i - 1], 1, n, dfn[e[i].second]);
  for (int i = 1; i <= q; i++) {
    if (ans[i] == -1 || ff[i] == 1) continue;
    int pl = lower_bound(a + 1, a + m + 1, dfn[qq[i][0]]) - a - 1;
    int pr = lower_bound(a + 1, a + m + 1, r[qq[i][0]] + 1) - a - 1;
    int res1 = qry(rt[pl], rt[pr], 1, n, dfn[qq[i][1]], r[qq[i][1]]);
    pl = lower_bound(a + 1, a + m + 1, dfn[qq[i][1]]) - a - 1;
    pr = lower_bound(a + 1, a + m + 1, r[qq[i][1]] + 1) - a - 1;
    int res2 = qry(rt[pl], rt[pr], 1, n, dfn[qq[i][0]], r[qq[i][0]]);
    if (res1 == 0 && res2 == 0) ans[i]++;
  }
  for (int i = 1; i <= q; i++) printf("%d\n", ans[i]);
  return 0;
}


Example question 2:
Name: 932_D. Tree
Tags: ['binary search', 'dp', 'trees']
Description: You are given a node of the tree with index 1 and with weight 0. Let cnt be the number of nodes in the tree at any instant (initially, cnt is set to 1). Support Q queries of following two types:

  * <image> Add a new node (index cnt + 1) with weight W and add edge between node R and this node. 
  * <image> Output the maximum length of sequence of nodes which 
    1. starts with R. 
    2. Every node in the sequence is an ancestor of its predecessor. 
    3. Sum of weight of nodes in sequence does not exceed X. 
    4. For some nodes i, j that are consecutive in the sequence if i is an ancestor of j then w[i] ≥ w[j] and there should not exist a node k on simple path from i to j such that w[k] ≥ w[j]



The tree is rooted at node 1 at any instant.

Note that the queries are given in a modified way.

Input

First line containing the number of queries Q (1 ≤ Q ≤ 400000).

Let last be the answer for previous query of type 2 (initially last equals 0).

Each of the next Q lines contains a query of following form: 

  * 1 p q (1 ≤ p, q ≤ 1018): This is query of first type where <image> and <image>. It is guaranteed that 1 ≤ R ≤ cnt and 0 ≤ W ≤ 109. 
  * 2 p q (1 ≤ p, q ≤ 1018): This is query of second type where <image> and <image>. It is guaranteed that 1 ≤ R ≤ cnt and 0 ≤ X ≤ 1015. 



<image> denotes bitwise XOR of a and b.

It is guaranteed that at least one query of type 2 exists.

Output

Output the answer to each query of second type in separate line.

Examples

Input

6
1 1 1
2 2 0
2 2 1
1 3 0
2 2 0
2 2 2


Output

0
1
1
2


Input

6
1 1 0
2 2 0
2 0 3
1 0 2
2 1 3
2 1 6


Output

2
2
3
2


Input

7
1 1 2
1 2 3
2 3 3
1 0 0
1 5 1
2 5 0
2 4 0


Output

1
1
2


Input

7
1 1 3
1 2 3
2 3 4
1 2 0
1 5 3
2 5 5
2 7 22


Output

1
2
3

Note

In the first example,

last = 0

- Query 1: 1 1 1, Node 2 with weight 1 is added to node 1.

- Query 2: 2 2 0, No sequence of nodes starting at 2 has weight less than or equal to 0. last = 0

- Query 3: 2 2 1, Answer is 1 as sequence will be {2}. last = 1

- Query 4: 1 2 1, Node 3 with weight 1 is added to node 2. 

- Query 5: 2 3 1, Answer is 1 as sequence will be {3}. Node 2 cannot be added as sum of weights cannot be greater than 1. last = 1

- Query 6: 2 3 3, Answer is 2 as sequence will be {3, 2}. last = 2
Difficulty: 10
Solutions: #include <bits/stdc++.h>
using namespace std;
const int inf = 0x3f3f3f3f;
const long long INF = 0x3f3f3f3f3f3f3f3f;
const int N = 5e5 + 7;
const int M = 22;
long long w[N], last;
long long sum[N][M];
int nx[N][M], cnt = 1;
void add(int u, int v) {
  if (w[u] <= w[v])
    nx[u][0] = v;
  else {
    for (int i = 20; i >= 0; i--)
      if (nx[v][i] != -1 && w[nx[v][i]] < w[u]) v = nx[v][i];
    nx[u][0] = nx[v][0];
  }
  if (nx[u][0] != -1) sum[u][0] = w[nx[u][0]];
  for (int i = 1; i <= 20; i++) {
    if (nx[u][i - 1] == -1)
      nx[u][i] = -1;
    else {
      nx[u][i] = nx[nx[u][i - 1]][i - 1];
      sum[u][i] = sum[u][i - 1] + sum[nx[u][i - 1]][i - 1];
    }
  }
}
long long cal(int u, long long all) {
  if (w[u] > all) return 0;
  all -= w[u];
  long long ans = 1;
  for (int i = 20; i >= 0; i--) {
    if (u != -1 && all >= sum[u][i]) {
      all -= sum[u][i];
      ans += (1 << i);
      u = nx[u][i];
    }
  }
  return ans;
}
void init() {
  memset(sum, INF, sizeof(sum));
  memset(nx, -1, sizeof(nx));
  w[0] = INF;
}
int main() {
  init();
  int q;
  scanf("%d", &q);
  while (q--) {
    int op;
    scanf("%d", &op);
    if (op == 1) {
      long long p, q;
      scanf("%lld", &p);
      scanf("%lld", &q);
      p ^= last;
      q ^= last;
      w[++cnt] = q;
      add(cnt, p);
    } else {
      long long p, q;
      scanf("%lld", &p);
      scanf("%lld", &q);
      p ^= last;
      q ^= last;
      last = cal(p, q);
      printf("%lld\n", last);
    }
  }
  return 0;
}



INSTRUCTIONS:
Solve the current question.
Provide:
1. A complete and efficient code solution, optimized for both time and space complexity.
2. A detailed explanation of the solution, including:
   - The intuition behind the approach;
   - Time and space complexity;
   - Important considerations about the algorithm.
3. You can use the example questions as general references for coding patterns and structure, but solve the current problem independently.
4. Don't use any external libraries. Any language is accepted.