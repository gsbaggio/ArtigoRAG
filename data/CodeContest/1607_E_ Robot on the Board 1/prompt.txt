CURRENT QUESTION:
The robot is located on a checkered rectangular board of size n × m (n rows, m columns). The rows in the board are numbered from 1 to n from top to bottom, and the columns — from 1 to m from left to right.

The robot is able to move from the current cell to one of the four cells adjacent by side.

The sequence of commands s executed by the robot is given. Each command is denoted by one of the symbols 'L', 'R', 'D' or 'U', and triggers the movement to left, right, down or up, respectively.

The robot can start its movement in any cell. The robot executes the commands starting from the first one, strictly in the order in which they are listed in s. If the robot moves beyond the edge of the board, it falls and breaks. A command that causes the robot to break is not considered successfully executed.

The robot's task is to execute as many commands as possible without falling off the board. For example, on board 3 × 3, if the robot starts a sequence of actions s="RRDLUU" ("right", "right", "down", "left", "up", "up") from the central cell, the robot will perform one command, then the next command will force him to cross the edge. If the robot starts moving from the cell (2, 1) (second row, first column) then all commands will be executed successfully and the robot will stop at the cell (1, 2) (first row, second column).

<image> The robot starts from cell (2, 1) (second row, first column). It moves right, right, down, left, up, and up. In this case it ends in the cell (1, 2) (first row, second column).

Determine the cell from which the robot should start its movement in order to execute as many commands as possible.

Input

The first line contains an integer t (1 ≤ t ≤ 10^4) — the number of test cases.

The next 2t lines contain descriptions of the test cases.

In the description of each test case, the first line contains two integers n and m (1 ≤ n, m ≤ 10^6) — the height and width of the field that the robot is located on. The second line of the description is a string s consisting solely of characters 'L', 'R', 'D' and 'U' — the sequence of commands the robot executes. The string has a length from 1 to 10^6 commands.

It is guaranteed that the total length of s over all test cases does not exceed 10^6.

Output

Print t lines, each of which contains the answer to the corresponding test case. The answer to the test case are two integers r (1 ≤ r ≤ n) and c (1 ≤ c ≤ m), separated by a space — the coordinates of the cell (row number and column number) from which the robot should start moving to perform as many commands as possible.

If there are several such cells, you may output any of them.

Example

Input


4
1 1
L
1 2
L
3 3
RRDLUU
4 3
LUURRDDLLLUU


Output


1 1
1 2
2 1
3 2

SIMILAR QUESTIONS:
Similar question 1 (Similarity score: 0.80):
Name: 1202_C. You Are Given a WASD-string...
Tags: ['brute force', 'data structures', 'dp', 'greedy', 'implementation', 'math', 'strings']
Description: You have a string s — a sequence of commands for your toy robot. The robot is placed in some cell of a rectangular grid. He can perform four commands:

  * 'W' — move one cell up; 
  * 'S' — move one cell down; 
  * 'A' — move one cell left; 
  * 'D' — move one cell right. 



Let Grid(s) be the grid of minimum possible area such that there is a position in the grid where you can place the robot in such a way that it will not fall from the grid while running the sequence of commands s. For example, if s = DSAWWAW then Grid(s) is the 4 × 3 grid:

  1. you can place the robot in the cell (3, 2); 
  2. the robot performs the command 'D' and moves to (3, 3); 
  3. the robot performs the command 'S' and moves to (4, 3); 
  4. the robot performs the command 'A' and moves to (4, 2); 
  5. the robot performs the command 'W' and moves to (3, 2); 
  6. the robot performs the command 'W' and moves to (2, 2); 
  7. the robot performs the command 'A' and moves to (2, 1); 
  8. the robot performs the command 'W' and moves to (1, 1). 

<image>

You have 4 extra letters: one 'W', one 'A', one 'S', one 'D'. You'd like to insert at most one of these letters in any position of sequence s to minimize the area of Grid(s).

What is the minimum area of Grid(s) you can achieve?

Input

The first line contains one integer T (1 ≤ T ≤ 1000) — the number of queries.

Next T lines contain queries: one per line. This line contains single string s (1 ≤ |s| ≤ 2 ⋅ 10^5, s_i ∈ \{W, A, S, D\}) — the sequence of commands.

It's guaranteed that the total length of s over all queries doesn't exceed 2 ⋅ 10^5.

Output

Print T integers: one per query. For each query print the minimum area of Grid(s) you can achieve.

Example

Input


3
DSAWWAW
D
WA


Output


8
2
4

Note

In the first query you have to get string DSAWW\underline{D}AW.

In second and third queries you can not decrease the area of Grid(s).
Difficulty: 9
Solutions: #include <bits/stdc++.h>
using namespace std;
const int maxs = 200000;
const char dbuf[] = "DWAS";
const int dx[] = {1, 0, -1, 0};
const int dy[] = {0, 1, 0, -1};
char s[maxs + 1];
int xv[maxs + 1];
int yv[maxs + 1];
int lprv[maxs + 1];
int bprv[maxs + 1];
int rprv[maxs + 1];
int tprv[maxs + 1];
int lnxt[maxs + 1];
int bnxt[maxs + 1];
int rnxt[maxs + 1];
int tnxt[maxs + 1];
int main() {
  ios::sync_with_stdio(false);
  cin.tie(nullptr);
  cout.tie(nullptr);
  int T;
  cin >> T;
  for (int TN = 0; TN < T; TN++) {
    cin >> s;
    int n = strlen(s);
    xv[0] = 0;
    yv[0] = 0;
    for (int i = 0; i < n; i++) {
      int d = find(dbuf, dbuf + 4, s[i]) - dbuf;
      xv[i + 1] = xv[i] + dx[d];
      yv[i + 1] = yv[i] + dy[d];
    }
    lprv[0] = rprv[0] = xv[0];
    bprv[0] = tprv[0] = yv[0];
    for (int i = 1; i <= n; i++) {
      lprv[i] = min(lprv[i - 1], xv[i]);
      bprv[i] = min(bprv[i - 1], yv[i]);
      rprv[i] = max(rprv[i - 1], xv[i]);
      tprv[i] = max(tprv[i - 1], yv[i]);
    }
    lnxt[n] = rnxt[n] = xv[n];
    bnxt[n] = tnxt[n] = yv[n];
    for (int i = n - 1; i >= 0; i--) {
      lnxt[i] = min(lnxt[i + 1], xv[i]);
      bnxt[i] = min(bnxt[i + 1], yv[i]);
      rnxt[i] = max(rnxt[i + 1], xv[i]);
      tnxt[i] = max(tnxt[i + 1], yv[i]);
    }
    long long ans = 0x7f7f7f7f7f7f7f7fll;
    for (int i = 0; i <= n; i++) {
      for (int d = 0; d < 4; d++) {
        int w =
            max(rprv[i], rnxt[i] + dx[d]) - min(lprv[i], lnxt[i] + dx[d]) + 1;
        int h =
            max(tprv[i], tnxt[i] + dy[d]) - min(bprv[i], bnxt[i] + dy[d]) + 1;
        ans = min(ans, (long long)w * h);
      }
    }
    cout << ans << '\n';
  }
  return 0;
}


Similar question 2 (Similarity score: 0.77):
Name: 888_B. Buggy Robot
Tags: ['greedy']
Description: Ivan has a robot which is situated on an infinite grid. Initially the robot is standing in the starting cell (0, 0). The robot can process commands. There are four types of commands it can perform:

  * U — move from the cell (x, y) to (x, y + 1); 
  * D — move from (x, y) to (x, y - 1); 
  * L — move from (x, y) to (x - 1, y); 
  * R — move from (x, y) to (x + 1, y). 



Ivan entered a sequence of n commands, and the robot processed it. After this sequence the robot ended up in the starting cell (0, 0), but Ivan doubts that the sequence is such that after performing it correctly the robot ends up in the same cell. He thinks that some commands were ignored by robot. To acknowledge whether the robot is severely bugged, he needs to calculate the maximum possible number of commands that were performed correctly. Help Ivan to do the calculations!

Input

The first line contains one number n — the length of sequence of commands entered by Ivan (1 ≤ n ≤ 100).

The second line contains the sequence itself — a string consisting of n characters. Each character can be U, D, L or R.

Output

Print the maximum possible number of commands from the sequence the robot could perform to end up in the starting cell.

Examples

Input

4
LDUR


Output

4


Input

5
RRRUU


Output

0


Input

6
LLRRRR


Output

4
Difficulty: 8
Solutions: import java.util.*;
import java.io.*;
public class solution
{
	static int min(int a,int b)
	{
		if(a>b)
		{
			return b;
		}
		return a;
	}
	public static void main(String args[])
	{
		Scanner sc = new Scanner(System.in);
		int n = sc.nextInt();
		String s = sc.next();
		int l = 0;
		int r = 0;
		int u = 0;
		int d = 0;
		for(int i=0;i<s.length();i++)
		{
			char c = s.charAt(i);
			switch(c)
			{
				case 'L':
				l++;
				break;
				case 'R':
				r++;
				break;
				case 'U':
				u++;
				break;
				case 'D':
				d++;
				break;
			}
		}
		System.out.println(2*(min(u,d)+min(l,r)));
	}
}

Similar question 3 (Similarity score: 0.75):
Name: 1272_B. Snow Walking Robot
Tags: ['constructive algorithms', 'greedy', 'implementation']
Description: Recently you have bought a snow walking robot and brought it home. Suppose your home is a cell (0, 0) on an infinite grid.

You also have the sequence of instructions of this robot. It is written as the string s consisting of characters 'L', 'R', 'U' and 'D'. If the robot is in the cell (x, y) right now, he can move to one of the adjacent cells (depending on the current instruction).

  * If the current instruction is 'L', then the robot can move to the left to (x - 1, y); 
  * if the current instruction is 'R', then the robot can move to the right to (x + 1, y); 
  * if the current instruction is 'U', then the robot can move to the top to (x, y + 1); 
  * if the current instruction is 'D', then the robot can move to the bottom to (x, y - 1). 



You've noticed the warning on the last page of the manual: if the robot visits some cell (except (0, 0)) twice then it breaks.

So the sequence of instructions is valid if the robot starts in the cell (0, 0), performs the given instructions, visits no cell other than (0, 0) two or more times and ends the path in the cell (0, 0). Also cell (0, 0) should be visited at most two times: at the beginning and at the end (if the path is empty then it is visited only once). For example, the following sequences of instructions are considered valid: "UD", "RL", "UUURULLDDDDLDDRRUU", and the following are considered invalid: "U" (the endpoint is not (0, 0)) and "UUDD" (the cell (0, 1) is visited twice).

The initial sequence of instructions, however, might be not valid. You don't want your robot to break so you decided to reprogram it in the following way: you will remove some (possibly, all or none) instructions from the initial sequence of instructions, then rearrange the remaining instructions as you wish and turn on your robot to move. 

Your task is to remove as few instructions from the initial sequence as possible and rearrange the remaining ones so that the sequence is valid. Report the valid sequence of the maximum length you can obtain.

Note that you can choose any order of remaining instructions (you don't need to minimize the number of swaps or any other similar metric).

You have to answer q independent test cases.

Input

The first line of the input contains one integer q (1 ≤ q ≤ 2 ⋅ 10^4) — the number of test cases.

The next q lines contain test cases. The i-th test case is given as the string s consisting of at least 1 and no more than 10^5 characters 'L', 'R', 'U' and 'D' — the initial sequence of instructions.

It is guaranteed that the sum of |s| (where |s| is the length of s) does not exceed 10^5 over all test cases (∑ |s| ≤ 10^5).

Output

For each test case print the answer on it. In the first line print the maximum number of remaining instructions. In the second line print the valid sequence of remaining instructions t the robot has to perform. The moves are performed from left to right in the order of the printed sequence. If there are several answers, you can print any. If the answer is 0, you are allowed to print an empty line (but you can don't print it).

Example

Input


6
LRU
DURLDRUDRULRDURDDL
LRUDDLRUDRUL
LLLLRRRR
URDUR
LLL


Output


2
LR
14
RUURDDDDLLLUUR
12
ULDDDRRRUULL
2
LR
2
UD
0

Note

There are only two possible answers in the first test case: "LR" and "RL".

The picture corresponding to the second test case:

<image> Note that the direction of traverse does not matter 

Another correct answer to the third test case: "URDDLLLUURDR".
Difficulty: 8
Solutions: n = int(input())
for i in range(n):
	s = input()
	l, r, u, d = 0, 0, 0, 0
	for v in s:
		if v == 'L':
			l += 1
		if v == 'R':
			r += 1
		if v == 'U':
			u += 1
		if v == 'D':
			d += 1
	if l == 0 or r == 0:
		if u and d:
			print(2)
			print('UD')
		else:
			print(0)
	elif u == 0 or d == 0:
		if l and r:
			print(2)
			print('LR')
		else:
			print(0)
	else:
		x = min(l, r)
		y = min(u, d)
		f = 'R' * x + 'U' * y + 'L' * x + 'D' * y
		print(len(f))
		print(f)


INSTRUCTIONS:
Solve the current question.
Provide:
1. A complete and efficient code solution, optimized for both time and space complexity.
2. A detailed explanation of the solution, including:
   - The intuition behind the approach;
   - Time and space complexity;
   - Important considerations about the algorithm.
3. If the language has classes, implement in 'Solution' class. Any language is accepted.
4. Use the similar questions as references to improve the solution, but only if they are relevant.
5. Don't use any external libraries. Don't need to import any libraries.
