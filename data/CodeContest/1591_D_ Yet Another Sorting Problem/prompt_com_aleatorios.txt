CURRENT QUESTION:
Petya has an array of integers a_1, a_2, …, a_n. He only likes sorted arrays. Unfortunately, the given array could be arbitrary, so Petya wants to sort it.

Petya likes to challenge himself, so he wants to sort array using only 3-cycles. More formally, in one operation he can pick 3 pairwise distinct indices i, j, and k (1 ≤ i, j, k ≤ n) and apply i → j → k → i cycle to the array a. It simultaneously places a_i on position j, a_j on position k, and a_k on position i, without changing any other element.

For example, if a is [10, 50, 20, 30, 40, 60] and he chooses i = 2, j = 1, k = 5, then the array becomes [\underline{50}, \underline{40}, 20, 30, \underline{10}, 60].

Petya can apply arbitrary number of 3-cycles (possibly, zero). You are to determine if Petya can sort his array a, i. e. make it non-decreasing.

Input

Each test contains multiple test cases. The first line contains the number of test cases t (1 ≤ t ≤ 5 ⋅ 10^5). Description of the test cases follows.

The first line of each test case contains a single integer n (1 ≤ n ≤ 5 ⋅ 10^5) — the length of the array a.

The second line of each test case contains n integers a_1, a_2, …, a_n (1 ≤ a_i ≤ n).

It is guaranteed that the sum of n over all test cases does not exceed 5 ⋅ 10^5.

Output

For each test case, print "YES" (without quotes) if Petya can sort the array a using 3-cycles, and "NO" (without quotes) otherwise. You can print each letter in any case (upper or lower).

Example

Input


7
1
1
2
2 2
2
2 1
3
1 2 3
3
2 1 3
3
3 1 2
4
2 1 4 3


Output


YES
YES
NO
YES
NO
YES
YES

Note

In the 6-th test case Petya can use the 3-cycle 1 → 3 → 2 → 1 to sort the array.

In the 7-th test case Petya can apply 1 → 3 → 2 → 1 and make a = [1, 4, 2, 3]. Then he can apply 2 → 4 → 3 → 2 and finally sort the array.

EXAMPLE QUESTIONS:
Example question 1:
Name: p01729 Air Pollution
Tags: ['']
Description: In 20XX, the owners of the ICPC (Ikuta's Computer Pollutes Community) shopping district were suffering from air pollution. In order to regain the vitality of the past, the cleanliness of the atmosphere must be kept above a certain level.

The shops in the shopping district are lined up in a row and are numbered from 1 to n. Currently, the cleanliness of the atmosphere around each store is pi. You can change the cleanliness of the atmosphere in that store and the surrounding stores by choosing the 2nd to n-1st stores and circulating the air around them. To be precise, when the i (2 ≤ i ≤ n−1) th is selected, only pi is added to pi−1 and pi + 1, and conversely, only 2 pi is subtracted from pi. In other words, the new cleanliness of the atmosphere p'is,

* p'i−1 = pi−1 + pi
* p'i = pi − 2 pi
* p'i + 1 = pi + 1 + pi. The purpose is to repeat this operation to make the air cleanliness pi of all stores equal to or greater than the minimum acceptable air cleanliness li.



It costs a lot to circulate the atmosphere, so we want to achieve it as few times as possible. I want you to help us for the future of the ICPC shopping district.



Input

The input is given in the following format.


n
p1 ... pn
l1 ... ln


n is the number of stores, pi is the current clean air of the i-th store, and li is the clean air that the i-th store should achieve.

Constraints

Each variable being input satisfies the following constraints.

* 3 ≤ n ≤ 105
* −108 ≤ pi ≤ 108
* 1 ≤ li ≤ 108

Output

Output the minimum number of air circulations required by all stores to achieve clean air in one line.

If you cannot achieve it no matter how you operate it, output -1.

Examples

Input

3
3 -1 4
2 1 3


Output

1


Input

3
3 -1 4
2 1 5


Output

-1


Input

4
3 -1 -1 3
1 1 1 1


Output

3
Difficulty: 0
Solutions: #include <bits/stdc++.h>
using namespace std;
using ll = long long;

template <typename T>
class fenwick_tree {
	const int n;
	vector<T> data;
public:
	fenwick_tree(int n_) : n(n_), data(n + 1) {}
	T find(int p) const {
		T res = 0;
		while (p > 0) {
			res += data[p];
			p -= p & -p;
		}
		return res;
	}
	T find(int l, int r) const {
		return find(r) - find(l);
	}
	void add(int p, T val) {
		++p;
		while (p <= n) {
			data[p] += val;
			p += p & -p;
		}
	}
};

int main()
{
	int n;
	cin >> n;
	vector<pair<ll, int>> sp(n);
	vector<ll> l(n);
	for (int i = 0; i < n; i++) {
		sp[i].second = i;
		cin >> sp[i].first;
		if (0 <= i - 1) sp[i].first += sp[i - 1].first;
	}
	for (int i = 0; i < n; i++) {
		cin >> l[i];
	}
	sort(sp.begin(), sp.end() - 1);
	bool ng = false;
	vector<pair<int, int>> all;
	for (int i = 0; i < n; i++) {
		if ((i ? sp[i].first - sp[i - 1].first : sp[i].first) < l[i]) {
			ng = true;
			break;
		}
		if (i + 1 < n) all.emplace_back(sp[i].second, i);
	}
	if (ng) {
		cout << -1 << endl;
		return 0;
	}
	sort(all.begin(), all.end());
	ll res = 0;
	fenwick_tree<int> ft(n);
	for (auto p : all) {
		res += ft.find(p.second, n);
		ft.add(p.second, 1);
	}
	cout << res << endl;
	return 0;
}




INSTRUCTIONS:
Solve the current question.
Provide:
1. A complete and efficient code solution, optimized for both time and space complexity.
2. A detailed explanation of the solution, including:
   - The intuition behind the approach;
   - Time and space complexity;
   - Important considerations about the algorithm.
3. You can use the example questions as general references for coding patterns and structure, but solve the current problem independently.
4. Don't use any external libraries. Any language is accepted.