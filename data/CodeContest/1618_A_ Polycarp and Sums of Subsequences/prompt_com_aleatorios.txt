CURRENT QUESTION:
Polycarp had an array a of 3 positive integers. He wrote out the sums of all non-empty subsequences of this array, sorted them in non-decreasing order, and got an array b of 7 integers.

For example, if a = \{1, 4, 3\}, then Polycarp wrote out 1, 4, 3, 1 + 4 = 5, 1 + 3 = 4, 4 + 3 = 7, 1 + 4 + 3 = 8. After sorting, he got an array b = \{1, 3, 4, 4, 5, 7, 8\}.

Unfortunately, Polycarp lost the array a. He only has the array b left. Help him to restore the array a.

Input

The first line contains one integer t (1 ≤ t ≤ 5000) — the number of test cases.

Each test case consists of one line which contains 7 integers b_1, b_2, ..., b_7 (1 ≤ b_i ≤ 10^9; b_i ≤ b_{i+1}). 

Additional constraint on the input: there exists at least one array a which yields this array b as described in the statement.

Output

For each test case, print 3 integers — a_1, a_2 and a_3. If there can be several answers, print any of them.

Example

Input


5
1 3 4 4 5 7 8
1 2 3 4 5 6 7
300000000 300000000 300000000 600000000 600000000 600000000 900000000
1 1 2 999999998 999999999 999999999 1000000000
1 2 2 3 3 4 5


Output


1 4 3
4 1 2
300000000 300000000 300000000
999999998 1 1
1 2 2

Note

The subsequence of the array a is a sequence that can be obtained from a by removing zero or more of its elements.

Two subsequences are considered different if index sets of elements included in them are different. That is, the values of the elements don't matter in the comparison of subsequences. In particular, any array of length 3 has exactly 7 different non-empty subsequences.

EXAMPLE QUESTIONS:
Example question 1:
Name: 1391_E. Pairs of Pairs
Tags: ['constructive algorithms', 'dfs and similar', 'graphs', 'greedy', 'trees']
Description: You have a simple and connected undirected graph consisting of n nodes and m edges.

Consider any way to pair some subset of these n nodes such that no node is present in more than one pair. 

This pairing is valid if for every pair of pairs, the induced subgraph containing all 4 nodes, two from each pair, has at most 2 edges (out of the 6 possible edges). More formally, for any two pairs, (a,b) and (c,d), the induced subgraph with nodes \\{a,b,c,d\} should have at most 2 edges. 

Please note that the subgraph induced by a set of nodes contains nodes only from this set and edges which have both of its end points in this set.

Now, do one of the following: 

  * Find a simple path consisting of at least ⌈ n/2 ⌉ nodes. Here, a path is called simple if it does not visit any node multiple times. 
  * Find a valid pairing in which at least ⌈ n/2 ⌉ nodes are paired. 



It can be shown that it is possible to find at least one of the two in every graph satisfying constraints from the statement. 

Input

Each test contains multiple test cases. The first line contains the number of test cases t (1 ≤ t ≤ 10^5). Description of the test cases follows.

The first line of each test case contains 2 integers n, m (2 ≤ n ≤ 5⋅ 10^5, 1 ≤ m ≤ 10^6), denoting the number of nodes and edges, respectively. 

The next m lines each contain 2 integers u and v (1 ≤ u, v ≤ n, u ≠ v), denoting that there is an undirected edge between nodes u and v in the given graph.

It is guaranteed that the given graph is connected, and simple — it does not contain multiple edges between the same pair of nodes, nor does it have any self-loops. 

It is guaranteed that the sum of n over all test cases does not exceed 5⋅ 10^5.

It is guaranteed that the sum of m over all test cases does not exceed 10^6.

Output

For each test case, the output format is as follows. 

If you have found a pairing, in the first line output "PAIRING" (without quotes). 

  * Then, output k (⌈ n/2 ⌉ ≤ 2⋅ k ≤ n), the number of pairs in your pairing. 
  * Then, in each of the next k lines, output 2 integers a and b — denoting that a and b are paired with each other. Note that the graph does not have to have an edge between a and b!
  * This pairing has to be valid, and every node has to be a part of at most 1 pair. 



Otherwise, in the first line output "PATH" (without quotes). 

  * Then, output k (⌈ n/2 ⌉ ≤ k ≤ n), the number of nodes in your path. 
  * Then, in the second line, output k integers, v_1, v_2, …, v_k, in the order in which they appear on the path. Formally, v_i and v_{i+1} should have an edge between them for every i (1 ≤ i < k).
  * This path has to be simple, meaning no node should appear more than once. 

Example

Input


4
6 5
1 4
2 5
3 6
1 5
3 5
6 5
1 4
2 5
3 6
1 5
3 5
12 14
1 2
2 3
3 4
4 1
1 5
1 12
2 6
2 7
3 8
3 9
4 10
4 11
2 4
1 3
12 14
1 2
2 3
3 4
4 1
1 5
1 12
2 6
2 7
3 8
3 9
4 10
4 11
2 4
1 3


Output


PATH
4 
1 5 3 6
PAIRING
2
1 6
2 4
PAIRING
3
1 8
2 5
4 10
PAIRING
4
1 7
2 9
3 11
4 5

Note

The path outputted in the first case is the following. 

<image>

The pairing outputted in the second case is the following. 

<image>

Here is an invalid pairing for the same graph — the subgraph \{1,3,4,5\} has 3 edges. 

<image>

Here is the pairing outputted in the third case. 

<image>

It's valid because — 

  * The subgraph \{1,8,2,5\} has edges (1,2) and (1,5). 
  * The subgraph \{1,8,4,10\} has edges (1,4) and (4,10). 
  * The subgraph \{4,10,2,5\} has edges (2,4) and (4,10). 



Here is the pairing outputted in the fourth case. 

<image>
Difficulty: 11
Solutions: #include <bits/stdc++.h>
using namespace std;
int32_t main() {
  ios_base::sync_with_stdio(0);
  cin.tie(0);
  long long T;
  cin >> T;
  while (T--) {
    long long N, M;
    cin >> N >> M;
    vector<vector<long long>> L(N + 1);
    for (long long i = 0; i < M; i++) {
      long long a, b;
      cin >> a >> b;
      L[a].push_back(b);
      L[b].push_back(a);
    }
    vector<long long> T(N + 1);
    vector<long long> H(N + 1);
    vector<bool> mk(N + 1);
    bool flag = false;
    vector<long long> path;
    vector<long long> temp;
    function<void(long long, long long)> DFS = [&](long long nodo,
                                                   long long lvl) {
      mk[nodo] = true;
      temp.push_back(nodo);
      if (flag == false && lvl == ((N - 1) / 2 + 1)) {
        flag = true;
        path = temp;
      }
      for (auto v : L[nodo]) {
        if (!mk[v]) {
          DFS(v, lvl + 1);
          T[v] = nodo;
          H[nodo]++;
        }
      }
      temp.pop_back();
    };
    DFS(1, 1);
    if (flag) {
      cout << "PATH" << '\n';
      cout << path.size() << '\n';
      for (auto x : path) {
        cout << x << " ";
      }
      cout << '\n';
      continue;
    }
    cout << "PAIRING" << '\n';
    vector<pair<long long, long long>> vect;
    queue<long long> Q;
    for (long long i = 1; i <= N; i++) {
      if (H[i] == 0) {
        Q.push(i);
      }
    }
    while (Q.size() > 1) {
      long long p1 = Q.front();
      Q.pop();
      long long p2 = Q.front();
      Q.pop();
      vect.push_back({p1, p2});
      H[T[p1]]--;
      if (H[T[p1]] == 0) Q.push(T[p1]);
      H[T[p2]]--;
      if (H[T[p2]] == 0) Q.push(T[p2]);
    }
    cout << vect.size() << '\n';
    for (auto x : vect) {
      cout << x.first << " " << x.second << '\n';
    }
  }
  return 0;
}



INSTRUCTIONS:
Solve the current question.
Provide:
1. A complete and efficient code solution, optimized for both time and space complexity.
2. A detailed explanation of the solution, including:
   - The intuition behind the approach;
   - Time and space complexity;
   - Important considerations about the algorithm.
3. You can use the example questions as general references for coding patterns and structure, but solve the current problem independently.
4. Don't use any external libraries. Any language is accepted.