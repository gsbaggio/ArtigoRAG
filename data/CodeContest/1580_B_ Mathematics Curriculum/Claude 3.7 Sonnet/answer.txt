#include <iostream>
#include <vector>
using namespace std;

const int MAXN = 105;
long long fact[MAXN];
long long inv[MAXN];
long long invfact[MAXN];

// Calculate modular inverse
long long pow_mod(long long base, long long exp, long long mod) {
    long long res = 1;
    base %= mod;
    while (exp > 0) {
        if (exp & 1)
            res = (res * base) % mod;
        base = (base * base) % mod;
        exp >>= 1;
    }
    return res;
}

// Precompute factorial, inverse factorial and inverses
void precompute(int n, long long mod) {
    fact[0] = invfact[0] = 1;
    for (int i = 1; i <= n; i++) {
        fact[i] = (fact[i-1] * i) % mod;
    }
    
    inv[1] = 1;
    for (int i = 2; i <= n; i++) {
        inv[i] = mod - (mod/i) * inv[mod%i] % mod;
    }
    
    invfact[0] = 1;
    for (int i = 1; i <= n; i++) {
        invfact[i] = (invfact[i-1] * inv[i]) % mod;
    }
}

// Combinatorial function: C(n,k) = n! / (k! * (n-k)!)
long long C(int n, int k, long long mod) {
    if (k < 0 || k > n) return 0;
    return (((fact[n] * invfact[k]) % mod) * invfact[n-k]) % mod;
}

// Calculate Stirling numbers of the second kind: S(n,k)
// Number of ways to partition n objects into k non-empty subsets
vector<vector<long long>> stirling2(int n, long long mod) {
    vector<vector<long long>> S(n+1, vector<long long>(n+1, 0));
    S[0][0] = 1;
    
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= i; j++) {
            S[i][j] = (S[i-1][j-1] + (j * S[i-1][j]) % mod) % mod;
        }
    }
    
    return S;
}

int main() {
    int n, m, k;
    long long p;
    cin >> n >> m >> k >> p;
    
    precompute(n, p);
    
    // Calculate answer based on combinatorial properties
    long long answer = 0;
    
    // A number is good if it has exactly m different maximum values in subsegments
    // This depends on the position of the number and larger numbers
    
    // Generate all possible configurations with k good numbers
    vector<vector<long long>> dp(n+1, vector<long long>(k+1, 0));
    dp[0][0] = 1;
    
    // For each position, decide if it contains a good number
    for (int i = 1; i <= n; i++) {
        for (int j = 0; j <= k; j++) {
            // Place a non-good number
            dp[i][j] = (dp[i-1][j] * (n-j)) % p;
            
            // Place a good number if possible
            if (j > 0) {
                long long good_ways = calculate_good_ways(n, i, m, p);
                dp[i][j] = (dp[i][j] + dp[i-1][j-1] * good_ways % p) % p;
            }
        }
    }
    
    cout << dp[n][k] << endl;
    
    return 0;
}