def solve():
    import sys
    input = sys.stdin.read
    data = input().strip().split()
    n, m, k, p = map(int, data)

    # Precompute factorials and modular inverses
    fact = [1] * (n + 1)
    for i in range(2, n + 1):
        fact[i] = fact[i - 1] * i % p

    def mod_inverse(x, p):
        return pow(x, p - 2, p)

    inv_fact = [1] * (n + 1)
    for i in range(2, n + 1):
        inv_fact[i] = mod_inverse(fact[i], p)

    def comb(n, r):
        if r > n or r < 0:
            return 0
        return fact[n] * inv_fact[r] % p * inv_fact[n - r] % p

    # DP table
    dp = [[0] * (n + 1) for _ in range(n + 1)]
    dp[0][0] = 1

    for i in range(1, n + 1):
        for j in range(i + 1):
            # Case 1: Current number is not "good"
            dp[i][j] = dp[i - 1][j] * (i - j) % p
            # Case 2: Current number is "good"
            if j > 0:
                dp[i][j] += dp[i - 1][j - 1] * j % p
                dp[i][j] %= p

    # Final result
    result = comb(n, k) * dp[n][k] % p
    print(result)