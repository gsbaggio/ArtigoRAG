CURRENT QUESTION:
Let c_1, c_2, …, c_n be a permutation of integers 1, 2, …, n. Consider all subsegments of this permutation containing an integer x. Given an integer m, we call the integer x good if there are exactly m different values of maximum on these subsegments.

Cirno is studying mathematics, and the teacher asks her to count the number of permutations of length n with exactly k good numbers.

Unfortunately, Cirno isn't good at mathematics, and she can't answer this question. Therefore, she asks you for help.

Since the answer may be very big, you only need to tell her the number of permutations modulo p.

A permutation is an array consisting of n distinct integers from 1 to n in arbitrary order. For example, [2,3,1,5,4] is a permutation, but [1,2,2] is not a permutation (2 appears twice in the array) and [1,3,4] is also not a permutation (n=3 but there is 4 in the array).

A sequence a is a subsegment of a sequence b if a can be obtained from b by deletion of several (possibly, zero or all) elements from the beginning and several (possibly, zero or all) elements from the end.

Input

The first line contains four integers n, m, k, p (1 ≤ n ≤ 100, 1 ≤ m ≤ n, 1 ≤ k ≤ n, 1 ≤ p ≤ 10^9).

Output

Output the number of permutations modulo p.

Examples

Input


4 3 2 10007


Output


4


Input


6 4 1 769626776


Output


472


Input


66 11 9 786747482


Output


206331312


Input


99 30 18 650457567


Output


77365367

Note

In the first test case, there are four permutations: [1, 3, 2, 4], [2, 3, 1, 4], [4, 1, 3, 2] and [4, 2, 3, 1].

Take permutation [1, 3, 2, 4] as an example:

For number 1, all subsegments containing it are: [1], [1, 3], [1, 3, 2] and [1, 3, 2, 4], and there're three different maxima 1, 3 and 4.

Similarly, for number 3, there're two different maxima 3 and 4. For number 2, there're three different maxima 2, 3 and 4. And for number 4, there're only one, that is 4 itself.

EXAMPLE QUESTIONS:
Example question 1:
Name: p02054 Skewering
Tags: ['']
Description: C: Skewering

problem

One day, when Homura was playing with blocks, Tempura came. Homura decided to play with blocks with Tempura.

There is a rectangular parallelepiped of A \ times B \ times C, which is made by stacking A \ times B \ times C blocks of cubic blocks with a side length of 1 without any gaps. Each side of all cubes and rectangular parallelepipeds is parallel to the x-axis, y-axis, or z-axis.

Homura-chan and Tempura-kun alternately repeat the following operations.

* Select a row of blocks of building blocks lined up in a row from a rectangular parallelepiped in any of the vertical, horizontal, and depth directions, and paint all the blocks included in the row in red. However, you cannot select columns that contain blocks that are already painted red.



More precisely

* Select one of the blocks contained in the rectangular parallelepiped and one of the three directions x, y, and z.
* When the selected block is moved in the selected direction by an integer distance, all the blocks that completely overlap are painted in red (think of moving the distance of 0 or a negative integer). However, this operation cannot be performed if there is at least one block that meets the conditions and has already been painted.



Homura-chan is the first player to lose the game if he can't operate it first.

Also, initially all cubes are uncolored.

Determine which one wins when the two act optimally.

Input format


A B C

Constraint

* 1 \ leq A, B, C \ leq 100
* All inputs are integers.



Output format

When the two act optimally, if Homura wins, `Hom` is output, and if Tempura wins,` Tem` is output on one line.

Input example 1


1 1 10

Output example 1


Hom

* The first time Homura can paint all the blocks red.



Input example 2


4 3 5

Output example 2


Hom

Input example 3


6 4 10

Output example 3


Tem





Example

Input

1 1 10


Output

Hom
Difficulty: 0
Solutions: A,B,C=map(int,input().split())
ANS=0
for i in [A,B,C]:
    if i%2==1:
        ANS+=1
if ANS>=2:
    print("Hom")
else:
    print("Tem")



Example question 2:
Name: 21_C. Stripe 2
Tags: ['binary search', 'dp', 'sortings']
Description: Once Bob took a paper stripe of n squares (the height of the stripe is 1 square). In each square he wrote an integer number, possibly negative. He became interested in how many ways exist to cut this stripe into three pieces so that the sum of numbers from each piece is equal to the sum of numbers from any other piece, and each piece contains positive integer amount of squares. Would you help Bob solve this problem?

Input

The first input line contains integer n (1 ≤ n ≤ 105) — amount of squares in the stripe. The second line contains n space-separated numbers — they are the numbers written in the squares of the stripe. These numbers are integer and do not exceed 10000 in absolute value.

Output

Output the amount of ways to cut the stripe into three non-empty pieces so that the sum of numbers from each piece is equal to the sum of numbers from any other piece. Don't forget that it's allowed to cut the stripe along the squares' borders only.

Examples

Input

4
1 2 3 3


Output

1


Input

5
1 2 3 4 5


Output

0
Difficulty: 9
Solutions: #include <bits/stdc++.h>
using namespace std;
int n, cnt, sum, now, a[100000];
long long ans;
int main() {
  scanf("%d", &n);
  for (int i = 0; i < n; i++) {
    scanf("%d", a + i);
    sum += a[i];
  }
  if (sum % 3) return puts("0");
  for (int i = 0; i < n - 1; i++) {
    now += a[i];
    if (now == sum / 3 * 2) ans += cnt;
    if (now == sum / 3) cnt++;
  }
  printf("%I64d\n", ans);
}



INSTRUCTIONS:
Solve the current question.
Provide:
1. A complete and efficient code solution, optimized for both time and space complexity.
2. A detailed explanation of the solution, including:
   - The intuition behind the approach;
   - Time and space complexity;
   - Important considerations about the algorithm.
3. You can use the example questions as general references for coding patterns and structure, but solve the current problem independently.
4. Don't use any external libraries. Any language is accepted.