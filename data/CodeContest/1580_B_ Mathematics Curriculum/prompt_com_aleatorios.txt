CURRENT QUESTION:
Let c_1, c_2, …, c_n be a permutation of integers 1, 2, …, n. Consider all subsegments of this permutation containing an integer x. Given an integer m, we call the integer x good if there are exactly m different values of maximum on these subsegments.

Cirno is studying mathematics, and the teacher asks her to count the number of permutations of length n with exactly k good numbers.

Unfortunately, Cirno isn't good at mathematics, and she can't answer this question. Therefore, she asks you for help.

Since the answer may be very big, you only need to tell her the number of permutations modulo p.

A permutation is an array consisting of n distinct integers from 1 to n in arbitrary order. For example, [2,3,1,5,4] is a permutation, but [1,2,2] is not a permutation (2 appears twice in the array) and [1,3,4] is also not a permutation (n=3 but there is 4 in the array).

A sequence a is a subsegment of a sequence b if a can be obtained from b by deletion of several (possibly, zero or all) elements from the beginning and several (possibly, zero or all) elements from the end.

Input

The first line contains four integers n, m, k, p (1 ≤ n ≤ 100, 1 ≤ m ≤ n, 1 ≤ k ≤ n, 1 ≤ p ≤ 10^9).

Output

Output the number of permutations modulo p.

Examples

Input


4 3 2 10007


Output


4


Input


6 4 1 769626776


Output


472


Input


66 11 9 786747482


Output


206331312


Input


99 30 18 650457567


Output


77365367

Note

In the first test case, there are four permutations: [1, 3, 2, 4], [2, 3, 1, 4], [4, 1, 3, 2] and [4, 2, 3, 1].

Take permutation [1, 3, 2, 4] as an example:

For number 1, all subsegments containing it are: [1], [1, 3], [1, 3, 2] and [1, 3, 2, 4], and there're three different maxima 1, 3 and 4.

Similarly, for number 3, there're two different maxima 3 and 4. For number 2, there're three different maxima 2, 3 and 4. And for number 4, there're only one, that is 4 itself.

EXAMPLE QUESTIONS:
Example question 1:
Name: 1036_D. Vasya and Arrays
Tags: ['greedy', 'two pointers']
Description: Vasya has two arrays A and B of lengths n and m, respectively.

He can perform the following operation arbitrary number of times (possibly zero): he takes some consecutive subsegment of the array and replaces it with a single element, equal to the sum of all elements on this subsegment. For example, from the array [1, 10, 100, 1000, 10000] Vasya can obtain array [1, 1110, 10000], and from array [1, 2, 3] Vasya can obtain array [6].

Two arrays A and B are considered equal if and only if they have the same length and for each valid i A_i = B_i.

Vasya wants to perform some of these operations on array A, some on array B, in such a way that arrays A and B become equal. Moreover, the lengths of the resulting arrays should be maximal possible.

Help Vasya to determine the maximum length of the arrays that he can achieve or output that it is impossible to make arrays A and B equal.

Input

The first line contains a single integer n~(1 ≤ n ≤ 3 ⋅ 10^5) — the length of the first array.

The second line contains n integers a_1, a_2, ⋅⋅⋅, a_n~(1 ≤ a_i ≤ 10^9) — elements of the array A.

The third line contains a single integer m~(1 ≤ m ≤ 3 ⋅ 10^5) — the length of the second array.

The fourth line contains m integers b_1, b_2, ⋅⋅⋅, b_m~(1 ≤ b_i ≤ 10^9) - elements of the array B.

Output

Print a single integer — the maximum length of the resulting arrays after some operations were performed on arrays A and B in such a way that they became equal.

If there is no way to make array equal, print "-1".

Examples

Input

5
11 2 3 5 7
4
11 7 3 7


Output

3


Input

2
1 2
1
100


Output

-1


Input

3
1 2 3
3
1 2 3


Output

3
Difficulty: 10
Solutions: /*
 *
 * @author Mukesh Singh
 *
 */

import java.io.*;
import java.util.*;
import java.text.DecimalFormat;
@SuppressWarnings("unchecked")



public class Main {	
	//solve test cases
	
	void solve() throws Exception {
		//int T = in.nextInt();
		//for(int tid = 1; tid <= T; ++tid)
			solveT();
    }
    
    	void solveT() throws Exception{

		int n = in.nextInt();
		long []A=new long[n];

		for(int i=0;i<n;i++){
			A[i]=in.nextLong();
		}
		int m = in.nextInt();
		long []B=new long[m];

		for(int i=0;i<m;i++){
			B[i]=in.nextLong();
		}


		


		long a=0,b=0;
		int i=0,j=0,p=1,q=1;
		int count=0;

		while(i<n && j<m){
			if(p==1)
			a+=A[i];
			if(q==1)
			b+=B[j];
			p=0;
			q=0;
			if(a==b){
				count++;
				i++;
				j++;
				a=0;
				b=0;
				p=1;
				q=1;
			}else if(a<b){
				i++;
				p=1;
			}else {
				j++;
				q=1;
			}
		}

		

		if(i<n|| j<m)
		System.out.println("-1");
		else
		System.out.println(count);


		

	} 
	//@ main function
	public static void main(String[] args) throws Exception {
		new Main();
	}
	
	InputReader in;
	PrintStream out ;
	DecimalFormat df ;
	Main() {
		try {
			File defaultInput = new File("file.in");
			if (defaultInput.exists()) 
				in = new InputReader("file.in");
			else 
				in = new InputReader();
			defaultInput = new File("file.out");
			if (defaultInput.exists()) 
				out = new PrintStream(new FileOutputStream("file.out"));
			else
				out = new PrintStream(System.out);
			df = new DecimalFormat("######0.00");
			solve();
			out.close();
		} 
		catch (Exception e) {
			e.printStackTrace();
			System.exit(261);
		}
	}
	
	class InputReader {
		BufferedReader reader;
		StringTokenizer tokenizer;
		
		InputReader() {
			reader = new BufferedReader(new InputStreamReader(System.in));
		}
		
		InputReader(String fileName) throws FileNotFoundException {
			reader = new BufferedReader(new FileReader(new File(fileName)));
		}
		
		String readLine() throws IOException {
			return reader.readLine();
		}
		
		String nextToken() throws IOException {
			while (tokenizer == null || !tokenizer.hasMoreTokens())
				tokenizer = new StringTokenizer(readLine());
			return tokenizer.nextToken();
		}
		
		boolean hasMoreTokens() throws IOException {
			while (tokenizer == null || !tokenizer.hasMoreTokens()) {
				String s = readLine();
				if (s == null)
					return false;
				tokenizer = new StringTokenizer(s);
			}
			return true;
		}
		
		int nextInt() throws NumberFormatException, IOException {
			return Integer.parseInt(nextToken());
		}
		
		long nextLong() throws NumberFormatException, IOException {
			return Long.parseLong(nextToken());
		}
		
		double nextDouble() throws NumberFormatException, IOException {
			return Double.parseDouble(nextToken());
		}
	}
}


INSTRUCTIONS:
Solve the current question.
Provide:
1. A complete and efficient code solution, optimized for both time and space complexity.
2. A detailed explanation of the solution, including:
   - The intuition behind the approach;
   - Time and space complexity;
   - Important considerations about the algorithm.
3. If the language has classes, implement in 'Solution' class. Any language is accepted.
4. You can use the example questions as general references for coding patterns and structure, but solve the current problem independently.
5. Don't use any external libraries. Don't need to import any libraries.
