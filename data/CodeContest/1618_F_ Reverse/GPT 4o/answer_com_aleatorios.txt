from collections import deque

def can_transform(x, y):
    # Edge case: if x is already equal to y
    if x == y:
        print("YES")
        return

    # BFS setup
    queue = deque([x])
    visited = set([x])

    while queue:
        current = queue.popleft()
        binary = bin(current)[2:]  # Get binary representation without '0b'

        # Generate next states
        for bit in ['0', '1']:
            new_binary = binary + bit
            reversed_binary = new_binary[::-1]  # Reverse the binary string
            new_number = int(reversed_binary, 2)  # Convert back to decimal

            # Check if we reached the target
            if new_number == y:
                print("YES")
                return

            # Add to queue if not visited
            if new_number not in visited:
                visited.add(new_number)
                queue.append(new_number)

    # If we exhaust the queue without finding y
    print("NO")