CURRENT QUESTION:
There is a grid, consisting of n rows and m columns. Each cell of the grid is either free or blocked. One of the free cells contains a lab. All the cells beyond the borders of the grid are also blocked.

A crazy robot has escaped from this lab. It is currently in some free cell of the grid. You can send one of the following commands to the robot: "move right", "move down", "move left" or "move up". Each command means moving to a neighbouring cell in the corresponding direction.

However, as the robot is crazy, it will do anything except following the command. Upon receiving a command, it will choose a direction such that it differs from the one in command and the cell in that direction is not blocked. If there is such a direction, then it will move to a neighbouring cell in that direction. Otherwise, it will do nothing.

We want to get the robot to the lab to get it fixed. For each free cell, determine if the robot can be forced to reach the lab starting in this cell. That is, after each step of the robot a command can be sent to a robot such that no matter what different directions the robot chooses, it will end up in a lab.

Input

The first line contains a single integer t (1 ≤ t ≤ 1000) — the number of testcases.

The first line of each testcase contains two integers n and m (1 ≤ n, m ≤ 10^6; n ⋅ m ≤ 10^6) — the number of rows and the number of columns in the grid.

The i-th of the next n lines provides a description of the i-th row of the grid. It consists of m elements of one of three types: 

  * '.' — the cell is free; 
  * '#' — the cell is blocked; 
  * 'L' — the cell contains a lab. 



The grid contains exactly one lab. The sum of n ⋅ m over all testcases doesn't exceed 10^6.

Output

For each testcase find the free cells that the robot can be forced to reach the lab from. Given the grid, replace the free cells (marked with a dot) with a plus sign ('+') for the cells that the robot can be forced to reach the lab from. Print the resulting grid.

Example

Input


4
3 3
...
.L.
...
4 5
#....
..##L
...#.
.....
1 1
L
1 9
....L..#.


Output


...
.L.
...
#++++
..##L
...#+
...++
L
++++L++#.

Note

In the first testcase there is no free cell that the robot can be forced to reach the lab from. Consider a corner cell. Given any direction, it will move to a neighbouring border grid that's not a corner. Now consider a non-corner free cell. No matter what direction you send to the robot, it can choose a different direction such that it ends up in a corner.

In the last testcase, you can keep sending the command that is opposite to the direction to the lab and the robot will have no choice other than move towards the lab.

EXAMPLE QUESTIONS:
Example question 1:
Name: 990_C. Bracket Sequences Concatenation Problem
Tags: ['implementation']
Description: A bracket sequence is a string containing only characters "(" and ")".

A regular bracket sequence is a bracket sequence that can be transformed into a correct arithmetic expression by inserting characters "1" and "+" between the original characters of the sequence. For example, bracket sequences "()()", "(())" are regular (the resulting expressions are: "(1)+(1)", "((1+1)+1)"), and ")(" and "(" are not.

You are given n bracket sequences s_1, s_2, ... , s_n. Calculate the number of pairs i, j   (1 ≤ i, j ≤ n) such that the bracket sequence s_i + s_j is a regular bracket sequence. Operation + means concatenation i.e. "()(" + ")()" = "()()()".

If s_i + s_j and s_j + s_i are regular bracket sequences and i ≠ j, then both pairs (i, j) and (j, i) must be counted in the answer. Also, if s_i + s_i is a regular bracket sequence, the pair (i, i) must be counted in the answer.

Input

The first line contains one integer n   (1 ≤ n ≤ 3 ⋅ 10^5) — the number of bracket sequences. The following n lines contain bracket sequences — non-empty strings consisting only of characters "(" and ")". The sum of lengths of all bracket sequences does not exceed 3 ⋅ 10^5.

Output

In the single line print a single integer — the number of pairs i, j   (1 ≤ i, j ≤ n) such that the bracket sequence s_i + s_j is a regular bracket sequence.

Examples

Input

3
)
()
(


Output

2


Input

2
()
()


Output

4

Note

In the first example, suitable pairs are (3, 1) and (2, 2).

In the second example, any pair is suitable, namely (1, 1), (1, 2), (2, 1), (2, 2).
Difficulty: 9
Solutions: n = input()
zz = 3*10**5 + 1
tm = [0]*zz
tp = [0]*zz
tz = [0]
w = 0
b = False
b2 = False
for x in range(0,n,+1):
    s = str(raw_input())
    tmp = 0
    if s[0] == ')' and s[-1] == '(':
        continue
    for y in range(0, len(s), +1):
        if s[y] == '(':
           tmp += 1
        else:
            tmp -=1
    if tmp < 0:
        tmp4 = 0
        b3 = False
        for yyyy in range(len(s)-1,-1, -1):
            if s[yyyy] == '(':
                tmp4 += 1
            else:
                tmp4 -= 1
            if tmp4 > 0:
                b3 = True
                break
        if b3 == False:
            tm[abs(tmp)] += 1
    elif tmp > 0:
        tmp3 = 0
        b2 = False
        for yyy in range(0, len(s), +1):
            if s[yyy] == '(':
                tmp3 += 1
            else:
                tmp3 -= 1
            if tmp3 < 0:
                b2 = True
                break
        if b2 == False:
            tp[tmp] += 1
    else:
        tmp2 = 0
        b = False
        for yy in range(0, len(s), +1):
            if s[yy] == '(':
                tmp2 += 1
            else:
                tmp2 -= 1
            if tmp2 < 0:
                b = True
                break
        if b == False:
            tz[0] += 1
w += tz[0]*tz[0]
for x in range(0,zz,+1):
    w += tm[x] * tp[x]
print w

Example question 2:
Name: p00221 FizzBuzz
Tags: ['']
Description: There is a game that uses numbers called "Fizz Buzz". In this game, multiple players count the numbers one by one, starting with 1, and each player says only one number after the previous player. At that time, you must say "Fizz" if it is divisible by 3, "Buzz" if it is divisible by 5, and "FizzBuzz" if it is divisible by both. For example, the first 16 statements are as follows:

1, 2, Fizz, 4, Buzz, Fizz, 7, 8, Fizz, Buzz, 11, Fizz, 13, 14, FizzBuzz, 16, ・ ・ ・

Taro decided to play "Fizz Buzz" with his friends. Taro and his colleagues decided the rules as follows.

"The wrong person will drop out. The next person will start with the next number after the wrong number. That is, if you say 1, 2, 3, you made a mistake with 3, so you will start with 4."

I play the game according to this rule, but because I am not used to the game, I sometimes do not notice that I made a mistake, and I cannot make a fair decision. So you decided to create a program that outputs the remaining people at the end of the set number of remarks so that Taro and his friends can enjoy this game.

Create a program that inputs the number of players, the number of times spoken during the game, and each statement, and outputs the number of the remaining players at the end of the input in ascending order. However, the players are numbered from 1, and the order of speaking is also from the first player, and when the speaking is completed, the first player will speak again. If the player in turn has already dropped out, the next player will speak. Also, the program must ignore subsequent statements when the player is alone.



Input

A sequence of multiple datasets is given as input. The end of the input is indicated by two lines of zeros. Each dataset is given in the following format:


m n
s1
s2
::
sn


The first line gives the number of players m (2 ≤ m ≤ 1000) and the number of remarks n (1 ≤ n ≤ 10000).

The next n lines are given the i-th statement s1. si is an integer, Fizz, Buzz, or a string (up to 8 characters) that indicates FizzBuzz.

The number of datasets does not exceed 50.

Output

For each input dataset, the number of the player remaining when the specified number of remarks is input is output in ascending order.

Example

Input

5 7
1
2
Fizz
4
Buzz
6
7
3 5
1
2
3
4
5
0 0


Output

2 3 4 5
1
Difficulty: 0
Solutions: #include <iostream>
#include <algorithm>
#include <queue>
#include <string>

using namespace std;

bool check(int turn, string str, int player)
{
  if(turn%3 == 0 && turn%5 == 0){
    return str == "FizzBuzz";
  } else if(turn%3 == 0){
    return str == "Fizz";
  } else if(turn%5 == 0){
    return str == "Buzz";
  }

  return atoi(str.c_str()) == turn;
}

int main()
{
  int n, m;
  string str;

  while(cin>>m>>n && n+m){
    queue<int> players;

    for(int i = 1; i <= m; ++i)
      players.push(i);

    for(int i = 1; i <= n; ++i){
      cin >> str;
      if(players.size() == 1) continue;

      int player = players.front();
      players.pop();

      if(check(i, str, player)){
	players.push(player);
      }
    }

    vector<int> vec;
    while(!players.empty()){
      vec.push_back(players.front());
      players.pop();
    }
    sort(vec.begin(), vec.end());

    for(int i = 0; i < vec.size()-1; ++i)
      cout << vec[i] << " ";
    cout << vec.back() << endl;
  }

  return 0;
}


INSTRUCTIONS:
Solve the current question.
Provide:
1. A complete and efficient code solution, optimized for both time and space complexity.
2. A detailed explanation of the solution, including:
   - The intuition behind the approach;
   - Time and space complexity;
   - Important considerations about the algorithm.
3. You can use the example questions as general references for coding patterns and structure, but solve the current problem independently.
4. Don't use any external libraries. Any language is accepted.