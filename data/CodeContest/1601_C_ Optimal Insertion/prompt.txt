CURRENT QUESTION:
You are given two arrays of integers a_1, a_2, …, a_n and b_1, b_2, …, b_m.

You need to insert all elements of b into a in an arbitrary way. As a result you will get an array c_1, c_2, …, c_{n+m} of size n + m.

Note that you are not allowed to change the order of elements in a, while you can insert elements of b at arbitrary positions. They can be inserted at the beginning, between any elements of a, or at the end. Moreover, elements of b can appear in the resulting array in any order.

What is the minimum possible number of inversions in the resulting array c? Recall that an inversion is a pair of indices (i, j) such that i < j and c_i > c_j.

Input

Each test contains multiple test cases. The first line contains the number of test cases t (1 ≤ t ≤ 10^4). Description of the test cases follows.

The first line of each test case contains two integers n and m (1 ≤ n, m ≤ 10^6).

The second line of each test case contains n integers a_1, a_2, …, a_n (1 ≤ a_i ≤ 10^9).

The third line of each test case contains m integers b_1, b_2, …, b_m (1 ≤ b_i ≤ 10^9).

It is guaranteed that the sum of n for all tests cases in one input doesn't exceed 10^6. The sum of m for all tests cases doesn't exceed 10^6 as well.

Output

For each test case, print one integer — the minimum possible number of inversions in the resulting array c.

Example

Input


3
3 4
1 2 3
4 3 2 1
3 3
3 2 1
1 2 3
5 4
1 3 5 3 1
4 3 6 1


Output


0
4
6

Note

Below is given the solution to get the optimal answer for each of the example test cases (elements of a are underscored).

  * In the first test case, c = [\underline{1}, 1, \underline{2}, 2, \underline{3}, 3, 4]. 
  * In the second test case, c = [1, 2, \underline{3}, \underline{2}, \underline{1}, 3]. 
  * In the third test case, c = [\underline{1}, 1, 3, \underline{3}, \underline{5}, \underline{3}, \underline{1}, 4, 6]. 

SIMILAR QUESTIONS:
Similar question 1 (Similarity score: 0.73):
Name: 1408_B. Arrays Sum
Tags: ['constructive algorithms', 'greedy', 'math']
Description: You are given a non-decreasing array of non-negative integers a_1, a_2, …, a_n. Also you are given a positive integer k.

You want to find m non-decreasing arrays of non-negative integers b_1, b_2, …, b_m, such that:

  * The size of b_i is equal to n for all 1 ≤ i ≤ m. 
  * For all 1 ≤ j ≤ n, a_j = b_{1, j} + b_{2, j} + … + b_{m, j}. In the other word, array a is the sum of arrays b_i. 
  * The number of different elements in the array b_i is at most k for all 1 ≤ i ≤ m. 



Find the minimum possible value of m, or report that there is no possible m.

Input

The first line contains one integer t (1 ≤ t ≤ 100): the number of test cases.

The first line of each test case contains two integers n, k (1 ≤ n ≤ 100, 1 ≤ k ≤ n).

The second line contains n integers a_1, a_2, …, a_n (0 ≤ a_1 ≤ a_2 ≤ … ≤ a_n ≤ 100, a_n > 0).

Output

For each test case print a single integer: the minimum possible value of m. If there is no such m, print -1.

Example

Input


6
4 1
0 0 0 1
3 1
3 3 3
11 3
0 1 2 2 3 3 3 4 4 4 4
5 3
1 2 3 4 5
9 4
2 2 3 5 7 11 13 13 17
10 7
0 1 1 2 3 3 4 5 5 6


Output


-1
1
2
2
2
1

Note

In the first test case, there is no possible m, because all elements of all arrays should be equal to 0. But in this case, it is impossible to get a_4 = 1 as the sum of zeros.

In the second test case, we can take b_1 = [3, 3, 3]. 1 is the smallest possible value of m.

In the third test case, we can take b_1 = [0, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2] and b_2 = [0, 0, 1, 1, 1, 1, 1, 2, 2, 2, 2]. It's easy to see, that a_i = b_{1, i} + b_{2, i} for all i and the number of different elements in b_1 and in b_2 is equal to 3 (so it is at most 3). It can be proven that 2 is the smallest possible value of m.
Difficulty: 8
Solutions: import sys as _sys


def main():
    t = int(input())
    for i_t in range(t):
        n, k = _read_ints()
        a = tuple(_read_ints())
        try:
            result = find_min_m(a, k)
        except ValueError:
            result = -1
        print(result)


def _read_line():
    result = _sys.stdin.readline()
    assert result[-1] == "\n"
    return result[:-1]


def _read_ints():
    return map(int, _read_line().split(" "))


def find_min_m(a_seq, k):
    assert k >= 1
    a_seq = tuple(a_seq)
    if a_seq.count(0) == len(a_seq):
        return 0
    steps_n = sum(x1 != x2 for x1, x2 in zip(a_seq, a_seq[1:]))
    
    if k == 1:
        if steps_n == 0:
            return 1
        else:
            raise ValueError("can't find min m")
    
    result = 0
    steps_per_b_seq = k - 1
    if a_seq[0] != 0:
        steps_n += 1
        if steps_n <= k:
            return 1
        steps_n -= k
        result += 1
    result += _ceil_div(steps_n, steps_per_b_seq)
    return result


def _ceil_div(x, y):
    assert y > 0
    result = x // y
    if x % y != 0:
        result += 1
    return result


if __name__ == '__main__':
    main()


Similar question 2 (Similarity score: 0.72):
Name: 1445_A. Array Rearrangment
Tags: ['greedy', 'sortings']
Description: You are given two arrays a and b, each consisting of n positive integers, and an integer x. Please determine if one can rearrange the elements of b so that a_i + b_i ≤ x holds for each i (1 ≤ i ≤ n).

Input

The first line of input contains one integer t (1 ≤ t ≤ 100) — the number of test cases. t blocks follow, each describing an individual test case.

The first line of each test case contains two integers n and x (1 ≤ n ≤ 50; 1 ≤ x ≤ 1000) — the length of arrays a and b, and the parameter x, described in the problem statement.

The second line of each test case contains n integers a_1, a_2, …, a_n (1 ≤ a_1 ≤ a_2 ≤ ... ≤ a_n ≤ x) — the elements of array a in non-descending order.

The third line of each test case contains n integers b_1, b_2, …, b_n (1 ≤ b_1 ≤ b_2 ≤ ... ≤ b_n ≤ x) — the elements of array b in non-descending order.

Test cases are separated by a blank line.

Output

For each test case print Yes if one can rearrange the corresponding array b so that a_i + b_i ≤ x holds for each i (1 ≤ i ≤ n) or No otherwise.

Each character can be printed in any case.

Example

Input


4
3 4
1 2 3
1 1 2

2 6
1 4
2 5

4 4
1 2 3 4
1 2 3 4

1 5
5
5


Output


Yes
Yes
No
No

Note

In the first test case, one can rearrange b so it'll look like [1, 2, 1]. In this case, 1 + 1 ≤ 4; 2 + 2 ≤ 4; 3 + 1 ≤ 4.

In the second test case, one can set b to [5, 2], then 1 + 5 ≤ 6; 4 + 2 ≤ 6.

In the third test case, no matter how one shuffles array b, a_4 + b_4 = 4 + b_4 > 4.

In the fourth test case, there is only one rearrangement of array b and it doesn't satisfy the condition since 5 + 5 > 5.
Difficulty: 7
Solutions: y = int(input())
for _ in range(y):
    q = list(map(int, input().split()))
    a = list(map(int, input().split()))
    b = list(map(int, input().split()))[::-1]
    e = True
    for i in range(q[0]):
        if a[i] + b[i] <= q[1]:
            pass
        else:
            print("No")
            e = False
            break
    if e:
        print("Yes")
    if _ < y-1:
        input()

Similar question 3 (Similarity score: 0.71):
Name: 1416_C. XOR Inverse
Tags: ['bitmasks', 'data structures', 'divide and conquer', 'dp', 'greedy', 'math', 'sortings', 'strings', 'trees']
Description: You are given an array a consisting of n non-negative integers. You have to choose a non-negative integer x and form a new array b of size n according to the following rule: for all i from 1 to n, b_i = a_i ⊕ x (⊕ denotes the operation [bitwise XOR](https://en.wikipedia.org/wiki/Bitwise_operation#XOR)).

An inversion in the b array is a pair of integers i and j such that 1 ≤ i < j ≤ n and b_i > b_j.

You should choose x in such a way that the number of inversions in b is minimized. If there are several options for x — output the smallest one.

Input

First line contains a single integer n (1 ≤ n ≤ 3 ⋅ 10^5) — the number of elements in a.

Second line contains n space-separated integers a_1, a_2, ..., a_n (0 ≤ a_i ≤ 10^9), where a_i is the i-th element of a.

Output

Output two integers: the minimum possible number of inversions in b, and the minimum possible value of x, which achieves those number of inversions.

Examples

Input


4
0 1 3 2


Output


1 0


Input


9
10 7 9 10 7 5 5 3 5


Output


4 14


Input


3
8 10 3


Output


0 8

Note

In the first sample it is optimal to leave the array as it is by choosing x = 0.

In the second sample the selection of x = 14 results in b: [4, 9, 7, 4, 9, 11, 11, 13, 11]. It has 4 inversions:

  * i = 2, j = 3; 
  * i = 2, j = 4; 
  * i = 3, j = 4; 
  * i = 8, j = 9. 



In the third sample the selection of x = 8 results in b: [0, 2, 11]. It has no inversions.
Difficulty: 9
Solutions: #include <bits/stdc++.h>
using namespace std;
int main() {
  cin.tie(0);
  ios::sync_with_stdio(false);
  int N;
  scanf("%d", &N);
  vector<int> A(N);
  for (int i = 0; i < N; ++i) scanf("%d", &A[i]);
  int res = 0;
  long long score = 0;
  vector<vector<int>> div(1, A);
  for (int d = 30; d >= 0; --d) {
    vector<vector<int>> nex;
    int mask = 1 << d;
    long long ok = 0, ng = 0;
    for (const auto &v : div) {
      vector<int> zero, one;
      for (auto val : v) {
        if (val & mask) {
          ok += zero.size();
          one.push_back(val);
        } else {
          ng += one.size();
          zero.push_back(val);
        }
      }
      if (!one.empty()) nex.emplace_back(one);
      if (!zero.empty()) nex.emplace_back(zero);
    }
    swap(div, nex);
    score += min(ok, ng);
    if (ok < ng) res += mask;
  }
  printf("%lld %d\n", score, res);
}



INSTRUCTIONS:
Solve the current question.
Provide:
1. A complete and efficient code solution, optimized for both time and space complexity.
2. A detailed explanation of the solution, including:
   - The intuition behind the approach;
   - Time and space complexity;
   - Important considerations about the algorithm.
3. If the language has classes, implement in 'Solution' class. Any language is accepted.
4. Use the similar questions as references to improve the solution, but only if they are relevant.
5. Don't use any external libraries. Don't need to import any libraries.
