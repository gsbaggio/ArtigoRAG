class BIT:
    def __init__(self, n):
        self.n = n
        self.bit = [0] * (n + 1)

    def update(self, index, val):
        index += 1
        while index <= self.n:
            self.bit[index] += val
            index += index & -index

    def query(self, index):
        index += 1
        res = 0
        while index > 0:
            res += self.bit[index]
            index -= index & -index
        return res

def min_inversions(t, test_cases):
    def count_inversions(a, b):
        bit = BIT(10**9)
        inversions = 0
        for num in a:
            inversions += bit.query(10**9) - bit.query(num)
            bit.update(num, 1)
        sorted_b = sorted(b)
        for num in sorted_b:
            inversions += bit.query(10**9) - bit.query(num)
            bit.update(num, 1)
        return inversions

    results = []
    for _ in range(t):
        n, m = test_cases[_][0]
        a = test_cases[_][1]
        b = test_cases[_][2]
        result = count_inversions(a, b)
        results.append(result)
    
    return results

# Input processing
t = int(input())
test_cases = []
for _ in range(t):
    n, m = map(int, input().split())
    a = list(map(int, input().split()))
    b = list(map(int, input().split()))
    test_cases.append((n, m, a, b))

# Get the results
results = min_inversions(t, test_cases)

# Output the results
for result in results:
    print(result)