def min_inversions(a, b):
    # Sort array b
    b.sort()
    
    # Initialize pointers and inversion count
    j = 0
    inversions = 0
    
    # Iterate through array a
    for num in a:
        # Move pointer j in b until b[j] is greater than num
        while j < len(b) and b[j] <= num:
            j += 1
        # Count inversions created by num
        inversions += len(b) - j
    
    return inversions

# Read input
import sys
input = sys.stdin.read
data = input().split()

# Process each test case
index = 0
t = int(data[index])
index += 1
results = []

for _ in range(t):
    n, m = map(int, data[index:index+2])
    index += 2
    a = list(map(int, data[index:index+n]))
    index += n
    b = list(map(int, data[index:index+m]))
    index += m
    
    # Calculate minimum inversions for the current test case
    results.append(min_inversions(a, b))

# Print results
for result in results:
    print(result)