CURRENT QUESTION:
Alice and Bob play the following game. Alice has a set S of disjoint ranges of integers, initially containing only one range [1, n]. In one turn, Alice picks a range [l, r] from the set S and asks Bob to pick a number in the range. Bob chooses a number d (l ≤ d ≤ r). Then Alice removes [l, r] from S and puts into the set S the range [l, d - 1] (if l ≤ d - 1) and the range [d + 1, r] (if d + 1 ≤ r). The game ends when the set S is empty. We can show that the number of turns in each game is exactly n.

After playing the game, Alice remembers all the ranges [l, r] she picked from the set S, but Bob does not remember any of the numbers that he picked. But Bob is smart, and he knows he can find out his numbers d from Alice's ranges, and so he asks you for help with your programming skill.

Given the list of ranges that Alice has picked ([l, r]), for each range, help Bob find the number d that Bob has picked.

We can show that there is always a unique way for Bob to choose his number for a list of valid ranges picked by Alice.

Input

Each test contains multiple test cases. The first line contains the number of test cases t (1 ≤ t ≤ 1000). Description of the test cases follows.

The first line of each test case contains a single integer n (1 ≤ n ≤ 1000).

Each of the next n lines contains two integers l and r (1 ≤ l ≤ r ≤ n), denoting the range [l, r] that Alice picked at some point.

Note that the ranges are given in no particular order.

It is guaranteed that the sum of n over all test cases does not exceed 1000, and the ranges for each test case are from a valid game.

Output

For each test case print n lines. Each line should contain three integers l, r, and d, denoting that for Alice's range [l, r] Bob picked the number d.

You can print the lines in any order. We can show that the answer is unique.

It is not required to print a new line after each test case. The new lines in the output of the example are for readability only. 

Example

Input


4
1
1 1
3
1 3
2 3
2 2
6
1 1
3 5
4 4
3 6
4 5
1 6
5
1 5
1 2
4 5
2 2
4 4


Output


1 1 1

1 3 1
2 2 2
2 3 3

1 1 1
3 5 3
4 4 4
3 6 6
4 5 5
1 6 2

1 5 3
1 2 1
4 5 5
2 2 2
4 4 4

Note

In the first test case, there is only 1 range [1, 1]. There was only one range [1, 1] for Alice to pick, and there was only one number 1 for Bob to pick.

In the second test case, n = 3. Initially, the set contains only one range [1, 3]. 

  * Alice picked the range [1, 3]. Bob picked the number 1. Then Alice put the range [2, 3] back to the set, which after this turn is the only range in the set. 
  * Alice picked the range [2, 3]. Bob picked the number 3. Then Alice put the range [2, 2] back to the set. 
  * Alice picked the range [2, 2]. Bob picked the number 2. The game ended. 



In the fourth test case, the game was played with n = 5. Initially, the set contains only one range [1, 5]. The game's turn is described in the following table. 

Game turn| Alice's picked range| Bob's picked number| The range set after  
---|---|---|---  
Before the game start| | |  \{ [1, 5] \}   
1| [1, 5]| 3|  \{ [1, 2], [4, 5] \}  
2| [1, 2]| 1|  \{ [2, 2], [4, 5] \}   
3| [4, 5]| 5|  \{ [2, 2], [4, 4] \}   
4| [2, 2]| 2|  \{ [4, 4] \}   
5| [4, 4]| 4|  \{ \}  (empty set)

EXAMPLE QUESTIONS:
Example question 1:
Name: 1077_D. Cutting Out
Tags: ['binary search', 'sortings']
Description: You are given an array s consisting of n integers.

You have to find any array t of length k such that you can cut out maximum number of copies of array t from array s.

Cutting out the copy of t means that for each element t_i of array t you have to find t_i in s and remove it from s. If for some t_i you cannot find such element in s, then you cannot cut out one more copy of t. The both arrays can contain duplicate elements.

For example, if s = [1, 2, 3, 2, 4, 3, 1] and k = 3 then one of the possible answers is t = [1, 2, 3]. This array t can be cut out 2 times. 

  * To cut out the first copy of t you can use the elements [1, \underline{2}, 3, 2, 4, \underline{3}, \underline{1}] (use the highlighted elements). After cutting out the first copy of t the array s can look like [1, 3, 2, 4]. 
  * To cut out the second copy of t you can use the elements [\underline{1}, \underline{3}, \underline{2}, 4]. After cutting out the second copy of t the array s will be [4]. 



Your task is to find such array t that you can cut out the copy of t from s maximum number of times. If there are multiple answers, you may choose any of them.

Input

The first line of the input contains two integers n and k (1 ≤ k ≤ n ≤ 2 ⋅ 10^5) — the number of elements in s and the desired number of elements in t, respectively.

The second line of the input contains exactly n integers s_1, s_2, ..., s_n (1 ≤ s_i ≤ 2 ⋅ 10^5).

Output

Print k integers — the elements of array t such that you can cut out maximum possible number of copies of this array from s. If there are multiple answers, print any of them. The required array t can contain duplicate elements. All the elements of t (t_1, t_2, ..., t_k) should satisfy the following condition: 1 ≤ t_i ≤ 2 ⋅ 10^5.

Examples

Input


7 3
1 2 3 2 4 3 1


Output


1 2 3 


Input


10 4
1 3 1 3 10 3 7 7 12 3


Output


7 3 1 3


Input


15 2
1 2 1 1 1 2 1 1 2 1 2 1 1 1 1


Output


1 1 

Note

The first example is described in the problem statement.

In the second example the only answer is [7, 3, 1, 3] and any its permutations. It can be shown that you cannot choose any other array such that the maximum number of copies you can cut out would be equal to 2.

In the third example the array t can be cut out 5 times.
Difficulty: 10
Solutions: #include <bits/stdc++.h>
using namespace std;
const int MAXN = 200000;
int n, k, v[MAXN + 10];
bool can(int fr) {
  int qtd = 0;
  for (int i = 0; i <= MAXN; ++i) qtd += v[i] / fr;
  return qtd >= k;
}
inline int bs() {
  int lo = 1;
  int hi = n / k;
  while (lo < hi) {
    int mid = (lo + hi) / 2;
    if (can(mid))
      lo = mid;
    else
      hi = mid - 1;
    if (can(hi))
      lo = hi;
    else
      hi--;
  }
  return lo;
}
int main() {
  ios_base::sync_with_stdio(false);
  cin.tie(NULL);
  cin >> n >> k;
  for (int i = 0, x; i < n; ++i) {
    cin >> x;
    v[x]++;
  }
  int lo = bs();
  for (int i = 0; i <= MAXN; ++i) {
    while (v[i] >= lo) {
      if (k > 1)
        cout << i << " ";
      else {
        cout << i << endl;
        return 0;
      }
      k--;
      v[i] -= lo;
    }
  }
  return 0;
}


Example question 2:
Name: p01735 Optimal alpha beta pruning
Tags: ['']
Description: Fox Ciel is developing an artificial intelligence (AI) for a game. This game is described as a game tree T with n vertices. Each node in the game has an evaluation value which shows how good a situation is. This value is the same as maximum value of child nodes’ values multiplied by -1. Values on leaf nodes are evaluated with Ciel’s special function -- which is a bit heavy. So, she will use alpha-beta pruning for getting root node’s evaluation value to decrease the number of leaf nodes to be calculated.

By the way, changing evaluation order of child nodes affects the number of calculation on the leaf nodes. Therefore, Ciel wants to know the minimum and maximum number of times to calculate in leaf nodes when she could evaluate child node in arbitrary order. She asked you to calculate minimum evaluation number of times and maximum evaluation number of times in leaf nodes.

Ciel uses following algotithm:


function negamax(node, α, β)
if node is a terminal node
return value of leaf node
else
foreach child of node
val := -negamax(child, -β, -α)
if val >= β
return val
if val > α
α := val
return α


[NOTE] negamax algorithm

Input

Input follows following format:


n
p_1 p_2 ... p_n
k_1 t_{11} t_{12} ... t_{1k}
:
:
k_n t_{n1} t_{n2} ... t_{nk}


The first line contains an integer n, which means the number of vertices in game tree T.
The second line contains n integers p_i, which means the evaluation value of vertex i.
Then, next n lines which contain the information of game tree T.
k_i is the number of child nodes of vertex i, and t_{ij} is the indices of the child node of vertex i.
Input follows following constraints:

* 2 \leq n \leq 100
* -10,000 \leq p_i \leq 10,000
* 0 \leq k_i \leq 5
* 2 \leq t_{ij} \leq n
* Index of root node is 1.
* Evaluation value except leaf node is always 0. This does not mean the evaluation values of non-leaf nodes are 0. You have to calculate them if necessary.
* Leaf node sometimes have evaluation value of 0.
* Game tree T is tree structure.



Output

Print the minimum evaluation number of times and the maximum evaluation number of times in leaf node.
Please separated by whitespace between minimum and maximum.


minimum maximum

Sample Input 1


3
0 1 1
2 2 3
0
0


Output for the Sample Input 1


2 2


Sample Input 2


8
0 0 100 100 0 -100 -100 -100
2 2 5
2 3 4
0
0
3 6 7 8
0
0
0


Output for the Sample Input 2


3 5


Sample Input 3


8
0 0 100 100 0 100 100 100
2 2 5
2 3 4
0
0
3 6 7 8
0
0
0


Output for the Sample Input 3


3 4


Sample Input 4


19
0 100 0 100 0 0 0 0 0 1 2 3 4 5 6 7 8 9 10
2 2 3
0
2 4 5
0
3 6 7 8
3 9 10 11
3 12 13 14
3 15 16 17
2 18 19
0
0
0
0
0
0
0
0
0
0


Output for the Sample Input 4


7 12






Example

Input

3
0 1 1
2 2 3
0
0


Output

2 2
Difficulty: 0
Solutions: #include<bits/stdc++.h>
using namespace std;
using Int = long long;

const Int inf = 1LL<<55;

Int n;
Int p[111];
vector<Int> graph[111];

map<Int, Int> mp;

using Pi = pair<Int, Int>;

Pi val[111][222][222];
Int dp_min[111][222][222];
Int dp_max[111][222][222];
bool visited[111][222][222];

Pi dfs(Int v, Int a, Int b) {
  if(visited[v][mp[a]][mp[b]]) return val[v][mp[a]][mp[b]];
  visited[v][mp[a]][mp[b]] = true;  
  if(graph[v].empty()) {
    dp_min[v][mp[a]][mp[b]] = 1;
    dp_max[v][mp[a]][mp[b]] = 1;
    val[v][mp[a]][mp[b]] = Pi(p[v], p[v]);
    //cout<<v<<" "<<val[v][mp[a]][mp[b]].first<<" "<<val[v][mp[a]][mp[b]].second<<endl;
    return val[v][mp[a]][mp[b]];
  }
  val[v][mp[a]][mp[b]] = Pi(-inf, inf);
  dp_min[v][mp[a]][mp[b]] = inf;
  dp_max[v][mp[a]][mp[b]] = -inf;  
  do {
    Pi a_tmp = Pi(a, a), b_tmp = Pi(b, b);
    Int mn = 0, mx = 0;
    bool f_mn = true, f_mx = true;
    for(Int u : graph[v]) {
      if(f_mn) {
	Int x = -dfs(u, -b_tmp.first, -a_tmp.first).first;
	mn += dp_min[u][mp[-b_tmp.first]][mp[-a_tmp.first]];
	if(x >= b_tmp.first) {
	  a_tmp.first = x;
	  f_mn = false;
	} else if(x > a_tmp.first) {
	  a_tmp.first = x;
	}
      }
      if(f_mx) {
	Int x = -dfs(u, -b_tmp.second, -a_tmp.second).second;
	mx += dp_max[u][mp[-b_tmp.second]][mp[-a_tmp.second]];	
	if(x >= b_tmp.second) {
	  a_tmp.second = x;
	  f_mx = false;
	} else if(x > a_tmp.second) {
	  a_tmp.second = x;
	}
      }
    }
    if(dp_min[v][mp[a]][mp[b]] >= mn) {
      dp_min[v][mp[a]][mp[b]] = mn;
      val[v][mp[a]][mp[b]].first = max(val[v][mp[a]][mp[b]].first, a_tmp.first);
    }
    if(dp_max[v][mp[a]][mp[b]] <= mx) {
      dp_max[v][mp[a]][mp[b]] = mx;
      val[v][mp[a]][mp[b]].second = min(val[v][mp[a]][mp[b]].second, a_tmp.second);
    }
  }while(next_permutation(graph[v].begin(), graph[v].end()));
  //cout<<v<<" "<<val[v][mp[a]][mp[b]].first << " " << val[v][mp[a]][mp[b]].second << endl;
  //assert(val[v][mp[a]][mp[b]].first == val[v][mp[a]][mp[b]].second); 
  return val[v][mp[a]][mp[b]];
}

signed main(){  
  cin.tie(0);
  ios::sync_with_stdio(0);

  cin >> n;
  for(Int i = 0; i < n; ++i) cin >> p[i];
  for(Int i = 0; i < n; ++i) {
    Int k; cin >> k;
    for(Int j = 0; j < k; ++j) {
      Int t; cin >> t; --t;
      graph[i].push_back(t);
    }
    sort(graph[i].begin(), graph[i].end());
  }
  vector<Int> vec;
  vec.push_back(-inf);
  vec.push_back(inf);
  for(Int i = 0; i < n; ++i) {
    vec.push_back(p[i]);
    vec.push_back(-p[i]);
  }
  sort(vec.begin(), vec.end());
  vec.erase(unique(vec.begin(), vec.end()), vec.end());
  for(Int i = 0; i < n; ++i) {
    mp[p[i]] = lower_bound(vec.begin(), vec.end(), p[i])-vec.begin();
    mp[-p[i]] = lower_bound(vec.begin(), vec.end(), -p[i])-vec.begin();
  }
  memset(visited, false, sizeof(visited));
  dfs(0, -inf, inf);
  cout << dp_min[0][mp[-inf]][mp[inf]] << " " << dp_max[0][mp[-inf]][mp[inf]] << endl;
  
  return 0;
}




INSTRUCTIONS:
Solve the current question.
Provide:
1. A complete and efficient code solution, optimized for both time and space complexity.
2. A detailed explanation of the solution, including:
   - The intuition behind the approach;
   - Time and space complexity;
   - Important considerations about the algorithm.
3. If the language has classes, implement in 'Solution' class. Any language is accepted.
4. You can use the example questions as general references for coding patterns and structure, but solve the current problem independently.
5. Don't use any external libraries. Don't need to import any libraries.
