CURRENT QUESTION:
YouKn0wWho has an integer sequence a_1, a_2, … a_n. Now he will split the sequence a into one or more consecutive subarrays so that each element of a belongs to exactly one subarray. Let k be the number of resulting subarrays, and h_1, h_2, …, h_k be the lengths of the longest increasing subsequences of corresponding subarrays.

For example, if we split [2, 5, 3, 1, 4, 3, 2, 2, 5, 1] into [2, 5, 3, 1, 4], [3, 2, 2, 5], [1], then h = [3, 2, 1].

YouKn0wWho wonders if it is possible to split the sequence a in such a way that the [bitwise XOR](https://en.wikipedia.org/wiki/Bitwise_operation#XOR) of h_1, h_2, …, h_k is equal to 0. You have to tell whether it is possible.

The longest increasing subsequence (LIS) of a sequence b_1, b_2, …, b_m is the longest sequence of valid indices i_1, i_2, …, i_k such that i_1 < i_2 < … < i_k and b_{i_1} < b_{i_2} < … < b_{i_k}. For example, the LIS of [2, 5, 3, 3, 5] is [2, 3, 5], which has length 3.

An array c is a subarray of an array b if c can be obtained from b by deletion of several (possibly, zero or all) elements from the beginning and several (possibly, zero or all) elements from the end.

Input

The first line contains a single integer t (1 ≤ t ≤ 10 000) — the number of test cases.

The first line of each test case contains a single integer n (2 ≤ n ≤ 10^5).

The second line of each test case contains n integers a_1, a_2, …, a_n (1 ≤ a_i ≤ 10^9).

It is guaranteed that the sum of n over all test cases doesn't exceed 3 ⋅ 10^5.

Output

For each test case, print "YES" (without quotes) if it is possible to split into subarrays in the desired way, print "NO" (without quotes) otherwise. You can print each letter in any register (upper or lower).

Example

Input


4
7
1 3 4 2 2 1 5
3
1 3 4
5
1 3 2 4 2
4
4 3 2 1


Output


YES
NO
YES
YES

Note

In the first test case, YouKn0wWho can split the sequence in the following way: [1, 3, 4], [2, 2], [1, 5]. This way, the LIS lengths are h = [3, 1, 2], and the bitwise XOR of the LIS lengths is 3 ⊕ 1 ⊕ 2 = 0.

In the second test case, it can be shown that it is impossible to split the sequence into subarrays that will satisfy the condition.

EXAMPLE QUESTIONS:
Example question 1:
Name: 12_E. Start of the season
Tags: ['constructive algorithms']
Description: Before the start of the football season in Berland a strange magic ritual is held. The most experienced magicians have to find a magic matrix of the size n × n (n is even number). Gods will never allow to start the championship without it. Matrix should contain integers from 0 to n - 1, main diagonal should contain only zeroes and matrix should be symmetric. Moreover, all numbers in each row should be different. Magicians are very tired of the thinking process, so they ask you to write a program to find such matrix.

Input

The first line contains one integer n (2 ≤ n ≤ 1000), n is even.

Output

Output n lines with n numbers each — the required matrix. Separate numbers with spaces. If there are several solutions, output any.

Examples

Input

2


Output

0 1
1 0


Input

4


Output

0 1 3 2
1 0 2 3
3 2 0 1
2 3 1 0
Difficulty: 11
Solutions: #include <bits/stdc++.h>
using namespace std;
short lastrow[1002];
int main() {
  int n, r, c, p, remember;
  cin >> n;
  lastrow[0] = n - 1;
  lastrow[n - 1] = 0;
  for (r = 0; r < n - 1; r++) {
    for (p = 0, c = r; c < r + n; c++, p++) {
      if (p == r) {
        cout << "0 ";
        if (c < n)
          remember = c;
        else
          remember = c - n + 1;
      } else if (p == n - 1 && r > 0) {
        cout << remember;
        lastrow[r] = remember;
      } else {
        if (c < n)
          cout << c << ' ';
        else
          cout << c - n + 1 << ' ';
      }
    }
    cout << '\n';
  }
  for (c = 0; c < n; c++) cout << lastrow[c] << ' ';
  cout << '\n';
  return 0;
}


Example question 2:
Name: p04029 AtCoder Beginner Contest 043 - Children and Candies (ABC Edit)
Tags: ['']
Description: There are N children in AtCoder Kindergarten. Mr. Evi will arrange the children in a line, then give 1 candy to the first child in the line, 2 candies to the second child, ..., N candies to the N-th child. How many candies will be necessary in total?

Constraints

* 1≦N≦100

Input

The input is given from Standard Input in the following format:


N


Output

Print the necessary number of candies in total.

Examples

Input

3


Output

6


Input

10


Output

55


Input

1


Output

1
Difficulty: 0
Solutions: #include<bits/stdc++.h>
using namespace std;
int main(void){
    int n;
    cin>>n;
    cout<<n*(1+n)/2<<endl;
}

Example question 3:
Name: 1271_B. Blocks
Tags: ['greedy', 'math']
Description: There are n blocks arranged in a row and numbered from left to right, starting from one. Each block is either black or white. 

You may perform the following operation zero or more times: choose two adjacent blocks and invert their colors (white block becomes black, and vice versa). 

You want to find a sequence of operations, such that they make all the blocks having the same color. You don't have to minimize the number of operations, but it should not exceed 3 ⋅ n. If it is impossible to find such a sequence of operations, you need to report it.

Input

The first line contains one integer n (2 ≤ n ≤ 200) — the number of blocks.

The second line contains one string s consisting of n characters, each character is either "W" or "B". If the i-th character is "W", then the i-th block is white. If the i-th character is "B", then the i-th block is black. 

Output

If it is impossible to make all the blocks having the same color, print -1.

Otherwise, print an integer k (0 ≤ k ≤ 3 ⋅ n) — the number of operations. Then print k integers p_1, p_2, ..., p_k (1 ≤ p_j ≤ n - 1), where p_j is the position of the left block in the pair of blocks that should be affected by the j-th operation.

If there are multiple answers, print any of them.

Examples

Input


8
BWWWWWWB


Output


3
6 2 4


Input


4
BWBB


Output


-1


Input


5
WWWWW


Output


0


Input


3
BWB


Output


2
2 1 

Note

In the first example, it is possible to make all blocks black in 3 operations. Start with changing blocks 6 and 7, so the sequence is "BWWWWBBB". Then change blocks 2 and 3, so the sequence is "BBBWWBB". And finally, change blocks 4 and 5, so all blocks are black.

It is impossible to make all colors equal in the second example.

All blocks are already white in the third example.

In the fourth example it is possible to make all blocks white in two operations: first operation is to change blocks 2 and 3 (so the sequence is "BBW"), and then change blocks 1 and 2 (so all blocks are white).
Difficulty: 8
Solutions: n=int(input())
s=list(input())
s.append("B")
b=s.count("B")

w=len(s)-b
if b==1 or w==0:
    print(0)
    exit(0)
s.pop(n)
b-=1
if b%2 and w%2:
    print("-1")
    exit(0)

if b%2==0:
    p=[]
    for i in range(s.index('B'),n-1): 
        if s[i]=="W":
            continue
        if s[i+1:].count('B')==0:
            break
        p.append(i+1)
        if s[i+1]=='W':
            s[i+1]="B"
        else:
            s[i+1]="W"
    print(len(p))
    print(*p)

else:
    p=[]
    for i in range(s.index('W'),n-1):   
        if s[i]=="B":
            continue
        if s[i+1:].count('W')==0:
            break
        p.append(i+1)
        if s[i+1]=='W':
            s[i+1]="B"
        else:
            s[i+1]="W"
    print(len(p))
    print(*p)


INSTRUCTIONS:
Solve the current question.
Provide:
1. A complete and efficient code solution, optimized for both time and space complexity.
2. A detailed explanation of the solution, including:
   - The intuition behind the approach;
   - Time and space complexity;
   - Important considerations about the algorithm.
3. You can use the example questions as general references for coding patterns and structure, but solve the current problem independently.
4. Don't use any external libraries. Any language is accepted.