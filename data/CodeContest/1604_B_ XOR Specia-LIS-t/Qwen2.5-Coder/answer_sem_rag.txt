def lis_length(arr):
    n = len(arr)
    if n == 0:
        return 0
    
    # This will store the smallest tail of all increasing subsequences
    # with different lengths
    tails = []
    
    for num in arr:
        # Use binary search to find the insertion point of the current number
        # in tails
        left, right = 0, len(tails)
        while left < right:
            mid = (left + right) // 2
            if tails[mid] < num:
                left = mid + 1
            else:
                right = mid
        
        # If left is equal to the length of tails, it means num is greater
        # than any element in tails, so we can extend the largest subsequence
        if left == len(tails):
            tails.append(num)
        else:
            # Otherwise, replace the element at the found position
            tails[left] = num
    
    return len(tails)

def can_split_with_zero_xor(arr):
    n = len(arr)
    if n == 0:
        return "NO"
    
    # Calculate the LIS length for the entire array
    lis_len = lis_length(arr)
    
    # Check if the LIS length is a power of 2
    if lis_len & (lis_len - 1) == 0:
        return "YES"
    
    # Check if there exists a subarray with LIS length 1
    for i in range(n):
        if i == 0 or arr[i] <= arr[i - 1]:
            return "YES"
    
    return "NO"

def main():
    import sys
    input = sys.stdin.read().split()
    
    index = 0
    t = int(input[index])
    index += 1
    
    results = []
    for _ in range(t):
        n = int(input[index])
        index += 1
        arr = list(map(int, input[index:index + n]))
        index += n
        results.append(can_split_with_zero_xor(arr))
    
    for result in results:
        print(result)

if __name__ == "__main__":
    main()