CURRENT QUESTION:
You are given a permutation p of n elements. A permutation of n elements is an array of length n containing each integer from 1 to n exactly once. For example, [1, 2, 3] and [4, 3, 5, 1, 2] are permutations, but [1, 2, 4] and [4, 3, 2, 1, 2] are not permutations. You should perform q queries.

There are two types of queries:

  * 1 x y — swap p_x and p_y. 
  * 2 i k — print the number that i will become if we assign i = p_i k times. 

Input

The first line contains two integers n and q (1 ≤ n, q ≤ 10^5).

The second line contains n integers p_1, p_2, ..., p_n.

Each of the next q lines contains three integers. The first integer is t (1 ≤ t ≤ 2) — type of query. If t = 1, then the next two integers are x and y (1 ≤ x, y ≤ n; x ≠ y) — first-type query. If t = 2, then the next two integers are i and k (1 ≤ i, k ≤ n) — second-type query.

It is guaranteed that there is at least one second-type query.

Output

For every second-type query, print one integer in a new line — answer to this query.

Examples

Input


5 4
5 3 4 2 1
2 3 1
2 1 2
1 1 3
2 1 2


Output


4
1
2


Input


5 9
2 3 5 1 4
2 3 5
2 5 5
2 5 1
2 5 3
2 5 4
1 5 4
2 5 3
2 2 5
2 5 1


Output


3
5
4
2
3
3
3
1

Note

In the first example p = \{5, 3, 4, 2, 1\}. 

The first query is to print p_3. The answer is 4.

The second query is to print p_{p_1}. The answer is 1.

The third query is to swap p_1 and p_3. Now p = \{4, 3, 5, 2, 1\}.

The fourth query is to print p_{p_1}. The answer is 2.

EXAMPLE QUESTIONS:
Example question 1:
Name: 305_B. Continued Fractions
Tags: ['brute force', 'implementation', 'math']
Description: A continued fraction of height n is a fraction of form <image>. You are given two rational numbers, one is represented as <image> and the other one is represented as a finite fraction of height n. Check if they are equal.

Input

The first line contains two space-separated integers p, q (1 ≤ q ≤ p ≤ 1018) — the numerator and the denominator of the first fraction.

The second line contains integer n (1 ≤ n ≤ 90) — the height of the second fraction. The third line contains n space-separated integers a1, a2, ..., an (1 ≤ ai ≤ 1018) — the continued fraction.

Please, do not use the %lld specifier to read or write 64-bit integers in С++. It is preferred to use the cin, cout streams or the %I64d specifier.

Output

Print "YES" if these fractions are equal and "NO" otherwise.

Examples

Input

9 4
2
2 4


Output

YES


Input

9 4
3
2 3 1


Output

YES


Input

9 4
3
1 2 4


Output

NO

Note

In the first sample <image>.

In the second sample <image>.

In the third sample <image>.
Difficulty: 8
Solutions: #include <bits/stdc++.h>
using namespace std;
const int MM = 1200000;
bool solve(long long int p, long long int q, vector<long long int> x) {
  if (p <= 0 || q <= 0) {
    return 0;
  }
  if (x.size() == 1) {
    return (p / q == x.back() && p == x.back() * q);
  }
  long long int tp = x.back();
  x.pop_back();
  if (abs(p / q - tp) > 2) {
    return 0;
  }
  return solve(q, p - q * tp, x);
}
int main() {
  ios_base::sync_with_stdio(0);
  cin.tie(0);
  cout.tie(0);
  long long int P, Q;
  cin >> P >> Q;
  int N;
  cin >> N;
  vector<long long int> A(N);
  for (int i = 0; i < N; i++) {
    cin >> A[N - i - 1];
  }
  if (solve(P, Q, A)) {
    cout << "YES";
  } else {
    cout << "NO";
  }
  return 0;
}


Example question 2:
Name: p01037 A White Wall
Tags: ['']
Description: Background

The site of Mr. A's house, which lives in a certain city, is surrounded by white walls. Feeling unsatisfied with the wall, Mr. A decided to invite the children in the neighborhood to paint the wall freely. Ask the children to choose their favorite section of the wall and paint it. So how was the wall painted?

Problem

There is a circular white wall as shown below, which consists of sections 0 to N-1.


Figure 1



M children specify the starting position a of this wall and the length L from the starting position, and paint counterclockwise from a to (a + L) mod N (however, a mod N is Represents the remainder when a is divided by N). Here, it is possible to paint over the section painted by another person, in which case it is regarded as one section painted with color. Output the colored sections in descending order. Also, output at the same time how many sections of that size are.

Constrains

Input meets the following conditions

* 2 ≤ N ≤ 100
* 1 ≤ M ≤ 50
* 0 ≤ ai <N
* 1 ≤ Li ≤ N



Input

The input is given in the following format.


N M
a0 L0
a1 L1
...
aM−1 LM−1


The first line is given two integers N, M, separated by blanks, which represent the length of the wall and the number of people who paint the wall, respectively. The following M line is given the start position ai and the length Li of the section to be painted by each person.

Output

The length of the colored section and the total number of the lengths are output in descending order of the colored section.

Examples

Input

5 3
0 1
2 1
3 1


Output

2 1
1 1


Input

4 2
0 2
1 2


Output

3 1


Input

10 3
2 1
4 1
9 2


Output

2 1
1 2
Difficulty: 0
Solutions: #include<bits/stdc++.h>
using namespace std;
vector< int > Sum;
vector< bool > v;
int rec(const vector< int >& Color, int idx) {
  if(v[idx]) return(0);
  v[idx] = true;
  int cnt = 1;
  if(Color[(idx + Color.size() - 1) % Color.size()] >= 0) cnt += rec(Color, (idx + Color.size() - 1) % Color.size()); 
  if(Color[(idx + 1) % Color.size()] >= 0) cnt += rec(Color, (idx + 1) % Color.size());
  return(cnt);
}

int main() {
  int N, M;
  cin >> N >> M;
  vector< int > a(M), L(M);
  for(int i = 0; i < M; i++) {
    cin >> a[i] >> L[i];
  }
  vector< int > Color(N, -1);
  for(int i = 0; i < M; i++) {
    int begin = a[i], end = (a[i] + L[i] - 1) % N;
    while(begin != end){
      Color[begin] = i;
      begin = (begin + 1) % N;
    }
    Color[end] = i;
  }

  Sum.resize(N + 1, 0);
  v.resize(N + 1, false);
  for(int i = 0; i < N; i++) {
    if(Color[i] >= 0 && !v[i]) Sum[rec(Color, i)]++;
  }

  for(int i = N; i >= 0; i--) {
    if(Sum[i] > 0) cout << i << " " << Sum[i] << endl;
  }
}



INSTRUCTIONS:
Solve the current question.
Provide:
1. A complete and efficient code solution, optimized for both time and space complexity.
2. A detailed explanation of the solution, including:
   - The intuition behind the approach;
   - Time and space complexity;
   - Important considerations about the algorithm.
3. You can use the example questions as general references for coding patterns and structure, but solve the current problem independently.
4. Don't use any external libraries. Any language is accepted.