def solve():
    n, q = map(int, input().split())
    p = list(map(int, input().split()))
    
    for _ in range(q):
        query = list(map(int, input().split()))
        
        if query[0] == 1:
            # Swap operation
            x, y = query[1], query[2]
            p[x-1], p[y-1] = p[y-1], p[x-1]
            
        else:  # query[0] == 2
            i, k = query[1], query[2]
            
            # Find the position after k applications using cycle detection
            # This optimization isn't necessary for the given constraints
            # but it would handle larger k values efficiently
            pos = i
            for _ in range(k):
                pos = p[pos-1]
            
            print(pos)

if __name__ == "__main__":
    solve()