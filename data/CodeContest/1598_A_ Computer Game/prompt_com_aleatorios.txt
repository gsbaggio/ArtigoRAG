CURRENT QUESTION:
Monocarp is playing a computer game. Now he wants to complete the first level of this game.

A level is a rectangular grid of 2 rows and n columns. Monocarp controls a character, which starts in cell (1, 1) — at the intersection of the 1-st row and the 1-st column.

Monocarp's character can move from one cell to another in one step if the cells are adjacent by side and/or corner. Formally, it is possible to move from cell (x_1, y_1) to cell (x_2, y_2) in one step if |x_1 - x_2| ≤ 1 and |y_1 - y_2| ≤ 1. Obviously, it is prohibited to go outside the grid.

There are traps in some cells. If Monocarp's character finds himself in such a cell, he dies, and the game ends.

To complete a level, Monocarp's character should reach cell (2, n) — at the intersection of row 2 and column n.

Help Monocarp determine if it is possible to complete the level.

Input

The first line contains a single integer t (1 ≤ t ≤ 100) — the number of test cases. Then the test cases follow. Each test case consists of three lines.

The first line contains a single integer n (3 ≤ n ≤ 100) — the number of columns.

The next two lines describe the level. The i-th of these lines describes the i-th line of the level — the line consists of the characters '0' and '1'. The character '0' corresponds to a safe cell, the character '1' corresponds to a trap cell.

Additional constraint on the input: cells (1, 1) and (2, n) are safe.

Output

For each test case, output YES if it is possible to complete the level, and NO otherwise.

Example

Input


4
3
000
000
4
0011
1100
4
0111
1110
6
010101
101010


Output


YES
YES
NO
YES

Note

Consider the example from the statement.

In the first test case, one of the possible paths is (1, 1) → (2, 2) → (2, 3).

In the second test case, one of the possible paths is (1, 1) → (1, 2) → (2, 3) → (2, 4).

In the fourth test case, one of the possible paths is (1, 1) → (2, 2) → (1, 3) → (2, 4) → (1, 5) → (2, 6).

EXAMPLE QUESTIONS:
Example question 1:
Name: 364_C. Beautiful Set
Tags: ['brute force', 'number theory']
Description: We'll call a set of positive integers a beautiful if the following condition fulfills: for any prime p, if <image>, then <image>. In other words, if one number from the set is divisible by prime p, then at least half of numbers from the set is divisible by p.

Your task is to find any beautiful set, where the number of elements is equal to k and each element doesn't exceed 2k2.

Input

The first line contains integer k (10 ≤ k ≤ 5000) that shows how many numbers the required beautiful set should have.

Output

In the first line print k space-separated integers that are a beautiful set. If there are multiple such sets, you are allowed to print any of them.

Examples

Input

10


Output

16 18 24 27 36 48 54 72 108 144 
Difficulty: 9
Solutions: #include <bits/stdc++.h>
template <typename T>
inline void checkMin(T &a, T b) {
  if (b < a) a = b;
}
template <typename T>
inline void checkMax(T &a, T b) {
  if (a < b) a = b;
}
using namespace std;
const int MAX_K = 5005;
const int MAX_KK = MAX_K * MAX_K * 2;
vector<int> prime;
void gen_prime(vector<int> &p, int MAX_N) {
  vector<bool> np(MAX_N, false);
  for (int i = 2; i < MAX_N; ++i) {
    if (!np[i]) p.push_back(i);
    for (int j : p) {
      if (j * i >= MAX_N) break;
      np[j * i] = true;
      if (i % j == 0) break;
    }
  }
}
int k, kk, pn, i, buf[MAX_K];
void dfs(int val, int o) {
  if (o == pn) {
    buf[i++] = val;
    return;
  }
  for (; val <= kk && i < k; val *= prime[o]) {
    dfs(val, o + 1);
  }
}
bool check(int pn) {
  if (i != k) return false;
  vector<int> acc(pn, 0);
  for (int j = 0; j < int(k); ++j) {
    for (int o = 0; o < int(pn); ++o) {
      if (buf[j] % prime[o] == 0) {
        ++acc[o];
      }
    }
  }
  for (int o = 0; o < int(pn); ++o) {
    if (2 * acc[o] < k) {
      return false;
    }
  }
  return true;
}
int main() {
  gen_prime(prime, MAX_K);
  scanf("%d", &k);
  kk = 2 * k * k;
  for (pn = 1;; ++pn) {
    i = 0;
    dfs(1, 0);
    if (check(pn)) {
      break;
    }
  }
  for (int i = 0; i < int(k); ++i) {
    printf("%d%s", buf[i], i + 1 == k ? "\n" : " ");
  }
  return 0;
}


Example question 2:
Name: 920_B. Tea Queue
Tags: ['implementation']
Description: Recently n students from city S moved to city P to attend a programming camp.

They moved there by train. In the evening, all students in the train decided that they want to drink some tea. Of course, no two people can use the same teapot simultaneously, so the students had to form a queue to get their tea.

i-th student comes to the end of the queue at the beginning of li-th second. If there are multiple students coming to the queue in the same moment, then the student with greater index comes after the student with lesser index. Students in the queue behave as follows: if there is nobody in the queue before the student, then he uses the teapot for exactly one second and leaves the queue with his tea; otherwise the student waits for the people before him to get their tea. If at the beginning of ri-th second student i still cannot get his tea (there is someone before him in the queue), then he leaves the queue without getting any tea. 

For each student determine the second he will use the teapot and get his tea (if he actually gets it).

Input

The first line contains one integer t — the number of test cases to solve (1 ≤ t ≤ 1000).

Then t test cases follow. The first line of each test case contains one integer n (1 ≤ n ≤ 1000) — the number of students.

Then n lines follow. Each line contains two integer li, ri (1 ≤ li ≤ ri ≤ 5000) — the second i-th student comes to the end of the queue, and the second he leaves the queue if he still cannot get his tea.

It is guaranteed that for every <image> condition li - 1 ≤ li holds.

The sum of n over all test cases doesn't exceed 1000.

Note that in hacks you have to set t = 1.

Output

For each test case print n integers. i-th of them must be equal to the second when i-th student gets his tea, or 0 if he leaves without tea.

Example

Input

2
2
1 3
1 4
3
1 5
1 1
2 3


Output

1 2 
1 0 2 

Note

The example contains 2 tests:

  1. During 1-st second, students 1 and 2 come to the queue, and student 1 gets his tea. Student 2 gets his tea during 2-nd second. 
  2. During 1-st second, students 1 and 2 come to the queue, student 1 gets his tea, and student 2 leaves without tea. During 2-nd second, student 3 comes and gets his tea. 
Difficulty: 8
Solutions: if __name__ == '__main__':
    cin = input
    t = int(cin())

    while t > 0:
        n = int(cin())
        a, cnt = [0] * n, 0
        for i in range(n):
            l, r = map(int, cin().split())
            if r >= cnt + max(l - cnt, 1):
                cnt += max(l - cnt, 1)
                a[i] += cnt
        print(*a)
        t -= 1


INSTRUCTIONS:
Solve the current question.
Provide:
1. A complete and efficient code solution, optimized for both time and space complexity.
2. A detailed explanation of the solution, including:
   - The intuition behind the approach;
   - Time and space complexity;
   - Important considerations about the algorithm.
3. You can use the example questions as general references for coding patterns and structure, but solve the current problem independently.
4. Don't use any external libraries. Any language is accepted.