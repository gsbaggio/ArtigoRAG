from collections import deque

def solve():
    import sys
    input = sys.stdin.read
    data = input().split()
    
    t = int(data[0])  # Number of test cases
    index = 1
    results = []
    
    for _ in range(t):
        n = int(data[index])  # Number of columns
        index += 1
        row1 = data[index]    # First row of the grid
        index += 1
        row2 = data[index]    # Second row of the grid
        index += 1
        
        # BFS to check if we can reach (2, n)
        queue = deque([(0, 0)])  # Start at (1, 1) -> (0, 0) in 0-based indexing
        visited = [[False] * n for _ in range(2)]
        visited[0][0] = True
        
        while queue:
            x, y = queue.popleft()
            
            # If we reach (2, n) -> (1, n-1) in 0-based indexing
            if x == 1 and y == n - 1:
                results.append("YES")
                break
            
            # Explore all possible moves
            for dx, dy in [(0, 1), (1, 0), (-1, 0), (0, -1), (1, 1), (-1, -1), (1, -1), (-1, 1)]:
                nx, ny = x + dx, y + dy
                if 0 <= nx < 2 and 0 <= ny < n and not visited[nx][ny]:
                    if (nx == 0 and row1[ny] == '0') or (nx == 1 and row2[ny] == '0'):
                        visited[nx][ny] = True
                        queue.append((nx, ny))
        else:
            # If we exhaust the queue without reaching (2, n)
            results.append("NO")
    
    # Print all results
    sys.stdout.write("\n".join(results) + "\n")