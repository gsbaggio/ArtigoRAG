from collections import deque

def can_complete_level(t, test_cases):
    results = []
    
    for case in test_cases:
        n, row1, row2 = case
        # Create the grid
        grid = [row1, row2]
        
        # BFS setup
        queue = deque([(0, 0)])  # Start at (1, 1) -> (0, 0) in 0-indexed
        visited = set()
        visited.add((0, 0))
        
        # BFS loop
        while queue:
            x, y = queue.popleft()
            
            # If we reach (2, n) -> (1, n-1) in 0-indexed
            if (x, y) == (1, n - 1):
                results.append("YES")
                break
            
            # Explore neighbors
            for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1), (-1, -1), (-1, 1), (1, -1), (1, 1)]:
                nx, ny = x + dx, y + dy
                if 0 <= nx < 2 and 0 <= ny < n and (nx, ny) not in visited and grid[nx][ny] == '0':
                    visited.add((nx, ny))
                    queue.append((nx, ny))
        else:
            # If we exhaust the queue without reaching the target
            results.append("NO")
    
    return results

# Input reading and processing
if __name__ == "__main__":
    t = int(input())
    test_cases = []
    for _ in range(t):
        n = int(input())
        row1 = input().strip()
        row2 = input().strip()
        test_cases.append((n, row1, row2))
    
    # Solve and output results
    results = can_complete_level(t, test_cases)
    print("\n".join(results))