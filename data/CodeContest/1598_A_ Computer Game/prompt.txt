CURRENT QUESTION:
Monocarp is playing a computer game. Now he wants to complete the first level of this game.

A level is a rectangular grid of 2 rows and n columns. Monocarp controls a character, which starts in cell (1, 1) — at the intersection of the 1-st row and the 1-st column.

Monocarp's character can move from one cell to another in one step if the cells are adjacent by side and/or corner. Formally, it is possible to move from cell (x_1, y_1) to cell (x_2, y_2) in one step if |x_1 - x_2| ≤ 1 and |y_1 - y_2| ≤ 1. Obviously, it is prohibited to go outside the grid.

There are traps in some cells. If Monocarp's character finds himself in such a cell, he dies, and the game ends.

To complete a level, Monocarp's character should reach cell (2, n) — at the intersection of row 2 and column n.

Help Monocarp determine if it is possible to complete the level.

Input

The first line contains a single integer t (1 ≤ t ≤ 100) — the number of test cases. Then the test cases follow. Each test case consists of three lines.

The first line contains a single integer n (3 ≤ n ≤ 100) — the number of columns.

The next two lines describe the level. The i-th of these lines describes the i-th line of the level — the line consists of the characters '0' and '1'. The character '0' corresponds to a safe cell, the character '1' corresponds to a trap cell.

Additional constraint on the input: cells (1, 1) and (2, n) are safe.

Output

For each test case, output YES if it is possible to complete the level, and NO otherwise.

Example

Input


4
3
000
000
4
0011
1100
4
0111
1110
6
010101
101010


Output


YES
YES
NO
YES

Note

Consider the example from the statement.

In the first test case, one of the possible paths is (1, 1) → (2, 2) → (2, 3).

In the second test case, one of the possible paths is (1, 1) → (1, 2) → (2, 3) → (2, 4).

In the fourth test case, one of the possible paths is (1, 1) → (2, 2) → (1, 3) → (2, 4) → (1, 5) → (2, 6).

SIMILAR QUESTIONS:
Similar question 1 (Similarity score: 0.71):
Name: 1392_E. Omkar and Duck
Tags: ['bitmasks', 'constructive algorithms', 'interactive', 'math']
Description: This is an interactive problem.

Omkar has just come across a duck! The duck is walking on a grid with n rows and n columns (2 ≤ n ≤ 25) so that the grid contains a total of n^2 cells. Let's denote by (x, y) the cell in the x-th row from the top and the y-th column from the left. Right now, the duck is at the cell (1, 1) (the cell in the top left corner) and would like to reach the cell (n, n) (the cell in the bottom right corner) by moving either down 1 cell or to the right 1 cell each second.

Since Omkar thinks ducks are fun, he wants to play a game with you based on the movement of the duck. First, for each cell (x, y) in the grid, you will tell Omkar a nonnegative integer a_{x,y} not exceeding 10^{16}, and Omkar will then put a_{x,y} uninteresting problems in the cell (x, y). After that, the duck will start their journey from (1, 1) to (n, n). For each cell (x, y) that the duck crosses during their journey (including the cells (1, 1) and (n, n)), the duck will eat the a_{x,y} uninteresting problems in that cell. Once the duck has completed their journey, Omkar will measure their mass to determine the total number k of uninteresting problems that the duck ate on their journey, and then tell you k.

Your challenge, given k, is to exactly reproduce the duck's path, i. e. to tell Omkar precisely which cells the duck crossed on their journey. To be sure of your mastery of this game, Omkar will have the duck complete q different journeys (1 ≤ q ≤ 10^3). Note that all journeys are independent: at the beginning of each journey, the cell (x, y) will still contain a_{x,y} uninteresting tasks.

Interaction

The interaction will begin with a line containing a single integer n (2 ≤ n ≤ 25), the amount of rows and columns in the grid. Read it.

Your program should then print n lines. The x-th line should contain n integers a_{x,1}, a_{x,2}, ..., a_{x,n} satisfying 0 ≤ a_{x,y} ≤ 10^{16}, where a_{x,y} is the amount of uninteresting problems Omkar should place in the cell (x, y).

After that, you will first receive a single integer q, the amount of journeys that the duck will take. q queries will follow; each query will consist of a single line containing an integer k, the amount of uninteresting problems that the duck ate on that journey. After each query, given that you have determined that the duck visited the cells (x_1, y_1), (x_2, y_2), ..., (x_{2n - 1}, y_{2n - 1}) in that order (it should always be true that (x_1, y_1) = (1, 1) and (x_{2n - 1}, y_{2n - 1}) = (n, n)), you should output 2n - 1 lines so that the j-th line contains the two integers x_j, y_j.

Bear in mind that if the sum on your path is k, but your path is different from the actual hidden path, then your solution is still wrong!

After printing each line do not forget to output end of line and flush the output. Otherwise, you will get Idleness limit exceeded. To do this, use:

  * fflush(stdout) or cout.flush() in C++;
  * System.out.flush() in Java;
  * flush(output) in Pascal;
  * stdout.flush() in Python;
  * see documentation for other languages.



Hack Format

To hack, first output a line containing n and another line containing q. It must be true that 2 ≤ n ≤ 25 and 1 ≤ q ≤ 1000. Then, output the q journeys taken by the duck in the same format as described above: for each journey, given that the duck visited the cells (x_1, y_1), (x_2, y_2), ..., (x_{2n - 1}, y_{2n - 1}) in that order, you should output 2n - 1 lines so that the j-th line contains the two integers x_j, y_j. It must be true that (x_1, y_1) = (1, 1) and (x_{2n - 1}, y_{2n - 1}) = (n, n). Additionally, for each j such that 2 ≤ j ≤ 2n - 1, it must be true that 1 ≤ x_j, y_j ≤ n and either (x_j, y_j) = (x_{j - 1} + 1, y_{j - 1}) or (x_j, y_j) = (x_{j - 1}, y_{j - 1} + 1).

Example

Input


4




3
23







26







27









Output


1 2 3 6
4 6 2 10
9 0 7 3
2 8 8 2


1 1
1 2
1 3
2 3
2 4
3 4
4 4

1 1
2 1
3 1
3 2
3 3
3 4
4 4

1 1
1 2
1 3
1 4
2 4
3 4
4 4

Note

The duck's three journeys are illustrated below.

1 + 2 + 3 + 2 + 10 + 3 + 2 = 23 

<image>

1 + 4 + 9 + 0 + 7 + 3 + 2 = 26 

<image>

1 + 2 + 3 + 6 + 10 + 3 + 2 = 27 

<image>
Difficulty: 11
Solutions: #include <bits/stdc++.h>
using namespace std;
const long long inf = 2000000000000000000LL;
int main() {
  ios_base::sync_with_stdio(0);
  cin.tie(0);
  cout.tie(0);
  long long t, i, j, k, l, m, n, o, p, q, temp, ans = 0, flag = 0,
                                                mod = 1000000007;
  cin >> n;
  long long a[n][n];
  for (i = 0, temp = 1; i < n; i++, temp *= 2) {
    for (j = 0, k = temp; j < n; j++, k *= 2) {
      if (i % 2)
        a[i][j] = 0;
      else
        a[i][j] = k;
      cout << a[i][j] << endl;
      fflush(stdout);
    }
  }
  cin >> q;
  while (q--) {
    cin >> temp;
    map<long long, long long> mp;
    p = 1LL << 52;
    while (temp) {
      if (temp >= p) {
        mp[p]++;
        temp -= p;
      }
      p /= 2;
    }
    cout << "1 1" << endl;
    fflush(stdout);
    for (i = 0, j = 0, temp = 0; (i != n - 1 || j != n - 1) && temp < 60;
         temp++) {
      if (i + 1 >= n) {
        cout << i + 1 << " " << j + 2 << endl;
        j++;
      } else if (j + 1 >= n) {
        cout << i + 2 << " " << j + 1 << endl;
        i++;
      } else {
        if (i % 2 == 0) {
          if (mp[a[i][j + 1]]) {
            cout << i + 1 << " " << j + 2 << endl;
            j++;
          } else {
            cout << i + 2 << " " << j + 1 << endl;
            i++;
          }
        } else {
          if (mp[a[i + 1][j]]) {
            cout << i + 2 << " " << j + 1 << endl;
            i++;
          } else {
            cout << i + 1 << " " << j + 2 << endl;
            j++;
          }
        }
      }
      fflush(stdout);
    }
  }
}



INSTRUCTIONS:
Solve the current question.
Provide:
1. A complete and efficient code solution, optimized for both time and space complexity.
2. A detailed explanation of the solution, including:
   - The intuition behind the approach;
   - Time and space complexity;
   - Important considerations about the algorithm.
3. If the language has classes, implement in 'Solution' class. Any language is accepted.
4. Use the similar questions as references to improve the solution, but only if they are relevant.
5. Don't use any external libraries. Don't need to import any libraries.
