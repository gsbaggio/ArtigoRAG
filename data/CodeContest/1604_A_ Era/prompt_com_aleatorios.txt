CURRENT QUESTION:
Shohag has an integer sequence a_1, a_2, …, a_n. He can perform the following operation any number of times (possibly, zero):

  * Select any positive integer k (it can be different in different operations). 
  * Choose any position in the sequence (possibly the beginning or end of the sequence, or in between any two elements) and insert k into the sequence at this position. 
  * This way, the sequence a changes, and the next operation is performed on this changed sequence. 



For example, if a=[3,3,4] and he selects k = 2, then after the operation he can obtain one of the sequences [\underline{2},3,3,4], [3,\underline{2},3,4], [3,3,\underline{2},4], or [3,3,4,\underline{2}].

Shohag wants this sequence to satisfy the following condition: for each 1 ≤ i ≤ |a|, a_i ≤ i. Here, |a| denotes the size of a.

Help him to find the minimum number of operations that he has to perform to achieve this goal. We can show that under the constraints of the problem it's always possible to achieve this goal in a finite number of operations.

Input

The first line contains a single integer t (1 ≤ t ≤ 200) — the number of test cases.

The first line of each test case contains a single integer n (1 ≤ n ≤ 100) — the initial length of the sequence.

The second line of each test case contains n integers a_1, a_2, …, a_n (1 ≤ a_i ≤ 10^9) — the elements of the sequence.

Output

For each test case, print a single integer — the minimum number of operations needed to perform to achieve the goal mentioned in the statement.

Example

Input


4
3
1 3 4
5
1 2 5 7 4
1
1
3
69 6969 696969


Output


1
3
0
696966

Note

In the first test case, we have to perform at least one operation, as a_2=3>2. We can perform the operation [1, 3, 4] → [1, \underline{2}, 3, 4] (the newly inserted element is underlined), now the condition is satisfied.

In the second test case, Shohag can perform the following operations:

[1, 2, 5, 7, 4] → [1, 2, \underline{3}, 5, 7, 4] → [1, 2, 3, \underline{4}, 5, 7, 4] → [1, 2, 3, 4, 5, \underline{3}, 7, 4].

In the third test case, the sequence already satisfies the condition.

EXAMPLE QUESTIONS:
Example question 1:
Name: p02092 Red Black Balloons
Tags: ['']
Description: E: Red Black Balloons

Story

Homura-chan's dream comes true. It means ICPC Asia regional contest 20xx will be held in Sapporo! Homura-chan has been working hard for the preparation. And finally, it's the previous day of the contest. Homura-chan started to stock balloons to be delivered to contestants who get accepted. However, she noticed that there were only two colors of balloons: red and black.

Problem Statement

ICPC Asia regional contest in Sapporo plans to provide N problems to contestants. Homura-chan is a professional of contest preparation, so she already knows how many contestants would get acceptance for each problem (!!), a_i contestants for the i-th problem. You can assume the prediction is perfectly accurate. Ideally, Homura-chan would assign a distinct color of a balloon to each problem respectively. But you know, she has only two colors red and black now. Thus, Homura-chan comes up with the idea to differentiate the size of balloons in K levels, that is, each problem has a balloon with a distinct pair of (color, size).

Homura-chan now has r_i red balloons with size i (1 \leq i \leq K) and b_j black balloons with size j (1 \leq j \leq K). Suppose we assign a pair (c_i, s_i) of a color c_i (red or black) and a size s_i to the i-th problem, for each i. As noted, we have to assign distinct pairs to each problem, more precisely, (c_i, s_i) \neq (c_j, s_j) holds for i \neq j. Moreover, the number of balloons with (c_i, s_i) must be no less than a_i. In the case that there are no such assignments, Homura-chan can change the size of balloons by her magic power. Note that Homura-chan doesn't know magic to change the color of balloons, so it's impossible.

Your task is to write a program computing the minimum number of balloons whose size is changed by Homura-chan's magic to realize an assignment satisfying the above-mentioned conditions. If there is no way to achieve such an assignment even if Homura-chan changes the size of balloons infinitely, output `-1` instead.

Input


N K
a_1 ... a_N
r_1 ... r_K
b_1 ... b_K


Constraints

* 1 \leq N,K \leq 60
* N \leq 2K
* 1 \leq a_i \leq 50 (1 \leq i \leq N)
* 1 \leq r_j,b_j \leq 50 (1 \leq j \leq K)
* Inputs consist only of integers.



Output

Output the minimum number of balloons whose size is changed to achieve an assignment in a line. If there are no ways to achieve assignments, output `-1` instead.

Sample Input 1


3 2
6 5 4
8 1
7 1


Output for Sample Input 1


3

Homura-chan changes the size of three red balloons from 1 to 2. Then she can assign (black,1) to the problem 1, (red,1) to the problem 2, and (red,2) to the problem 3.

Sample Input 2


2 1
50 50
2
3


Output for Sample Input 2


-1

Sample Input 3


4 3
3 10 28 43
40 18 2
26 7 11


Output for Sample Input 3


5





Example

Input

3 2
6 5 4
8 1
7 1


Output

3
Difficulty: 0
Solutions: #include<bits/stdc++.h>
using namespace std;

#define rep(i,n) for(int i=0;i<n;i++)
#define Rep(i,sta,n) for(int i=sta;i<n;i++)

const int mod=1000000007;
int dp[70][70][6100];
void solve(){
    int n,k;cin>>n>>k;
    vector<int> ra(n+1);
    vector<int> rr(k+1);
    vector<int> rb(k+1);
    vector<int> a(n);
    vector<int> r(k),b(k);
    rep(i,n){
        cin>>a[i];
    }
    rep(i,k){
        cin>>r[i];
    }
    rep(i,k){
        cin>>b[i];
    }
    sort(a.begin(),a.end(),greater<int>());
    sort(r.begin(),r.end(),greater<int>());
    sort(b.begin(),b.end(),greater<int>());
    rep(i,n){
        ra[i+1]=ra[i]+a[i];
    }
    rep(i,k){
        rr[i+1]=rr[i]+r[i];
        rb[i+1]=rb[i]+b[i];
    }
    rep(i,n+1){
        rep(j,k+1){
            rep(l,6100){
                dp[i][j][l]=mod;
            }
        }
    }
    dp[0][0][3010]=0;
    rep(i,n){
        rep(j,k+1){
            int rest=i-j;
            if(rest<0||rest>k)continue;
            rep(l,6100){
                if(dp[i][j][l]==mod)continue;
                //take red
                if(j<k){
                    int dif=r[j]-a[i];
                    int cost=max(0,-dif);
                    dp[i+1][j+1][l+dif]=min(dp[i+1][j+1][l+dif],dp[i][j][l]+cost);
                }
                //take blue
                if(rest<k){
                    int dif=b[rest]-a[i];
                    int cost=max(0,-dif);
                    dp[i+1][j][l]=min(dp[i+1][j][l],dp[i][j][l]+cost);
                }
            }
        }
    }
    int ans=mod;
    rep(j,k+1){
        int rest=n-j;
        if(rest<0)continue;
        if(rest>k)continue;
        rep(l,6100){
            int x=l-3010;
            if(x+rr[k]-rr[j]<0)continue;
            int bb=rr[j]-x+rb[rest]-ra[n];
            if(bb+rb[k]-rb[rest]<0)continue;

            ans=min(ans,dp[n][j][l]);

        }
    }
    if(ans==mod)ans=-1;
    cout<<ans<<endl;

}
int main(){
    solve();
    return 0;
}


Example question 2:
Name: 1060_B. Maximum Sum of Digits
Tags: ['greedy']
Description: You are given a positive integer n.

Let S(x) be sum of digits in base 10 representation of x, for example, S(123) = 1 + 2 + 3 = 6, S(0) = 0.

Your task is to find two integers a, b, such that 0 ≤ a, b ≤ n, a + b = n and S(a) + S(b) is the largest possible among all such pairs.

Input

The only line of input contains an integer n (1 ≤ n ≤ 10^{12}).

Output

Print largest S(a) + S(b) among all pairs of integers a, b, such that 0 ≤ a, b ≤ n and a + b = n.

Examples

Input

35


Output

17


Input

10000000000


Output

91

Note

In the first example, you can choose, for example, a = 17 and b = 18, so that S(17) + S(18) = 1 + 7 + 1 + 8 = 17. It can be shown that it is impossible to get a larger answer.

In the second test example, you can choose, for example, a = 5000000001 and b = 4999999999, with S(5000000001) + S(4999999999) = 91. It can be shown that it is impossible to get a larger answer.
Difficulty: 8
Solutions: n=[k for k in raw_input().split(" ")][0]


def sd(n):
    res=0
    while n:
        res+=n%10
        n/=10
    return res

fn=int(n[0])-1
res=str(fn)+"9"*(len(n)-1)
res=int(res)
n=int(n)
print sd(res)+sd(n-res)


Example question 3:
Name: dfs-2
Tags: []
Description: You have some boxes. All of them are assigned a unique positive integer. This number is written on them with a marker. Your task is simple that is to evaluate a number of queries. The description of a single query is 
given below:
The query consists of 2 positive integers L and R. 
You have to report total number of boxes that have the values in the range L and R (inclusive of L and R), written on them.

INPUT 
The first line of input contains a positive integer n, denoting the number of boxes.
The second line contains n space separated integers denoting the positive integer assigned to each box.  (p[1] .... p[n])
The third line contains an integer q, the number of queries.
After this q lines follow, each containing two positive integers L and R, as stated above, for this particular query.

OUTPUT
The output contains q lines. Each line contains a positive integer, the answer for that particular test case.

CONSTRAINTS
1 ≤ n ≤ 100000
1 ≤ p[i] ≤ 10^9
1 ≤ q ≤ 100000

SAMPLE INPUT
5
4 3 2 1 1
4
1 2
2 3
5 6
1 1

SAMPLE OUTPUT
3
2
0
2
Difficulty: 0
Solutions: import bisect;
N=input();  A=map(int,raw_input().split());	A.sort();
for _ in xrange(int(raw_input())):
	L,R=map(int,raw_input().split());
	print bisect.bisect_right(A,R) - bisect.bisect_left(A,L)


INSTRUCTIONS:
Solve the current question.
Provide:
1. A complete and efficient code solution, optimized for both time and space complexity.
2. A detailed explanation of the solution, including:
   - The intuition behind the approach;
   - Time and space complexity;
   - Important considerations about the algorithm.
3. You can use the example questions as general references for coding patterns and structure, but solve the current problem independently.
4. Don't use any external libraries. Any language is accepted.