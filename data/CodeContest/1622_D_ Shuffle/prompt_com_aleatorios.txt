CURRENT QUESTION:
You are given a binary string (i. e. a string consisting of characters 0 and/or 1) s of length n. You can perform the following operation with the string s at most once: choose a substring (a contiguous subsequence) of s having exactly k characters 1 in it, and shuffle it (reorder the characters in the substring as you wish).

Calculate the number of different strings which can be obtained from s by performing this operation at most once.

Input

The first line contains two integers n and k (2 ≤ n ≤ 5000; 0 ≤ k ≤ n).

The second line contains the string s of length n, consisting of characters 0 and/or 1.

Output

Print one integer — the number of different strings which can be obtained from s by performing the described operation at most once. Since the answer can be large, output it modulo 998244353.

Examples

Input


7 2
1100110


Output


16


Input


5 0
10010


Output


1


Input


8 1
10001000


Output


10


Input


10 8
0010011000


Output


1

Note

Some strings you can obtain in the first example:

  * to obtain 0110110, you can take the substring from the 1-st character to the 4-th character, which is 1100, and reorder its characters to get 0110; 
  * to obtain 1111000, you can take the substring from the 3-rd character to the 7-th character, which is 00110, and reorder its characters to get 11000; 
  * to obtain 1100101, you can take the substring from the 5-th character to the 7-th character, which is 110, and reorder its characters to get 101. 



In the second example, k = 0 so you can only choose the substrings consisting only of 0 characters. Reordering them doesn't change the string at all, so the only string you can obtain is 10010.

EXAMPLE QUESTIONS:
Example question 1:
Name: little-stuart-and-evil-hackers-2
Tags: []
Description: Evil hackers are trying to hack the database of HackerEarth.com.
After a lot of work they figure out that the encryption key used by HackerEarth to securely store the data is really just a random large number.
After a bit more work they figure out that the key is in form of a^b( a power b).
So now they call in the evil genius Little Stuart for their help,
now Little Stuart is having some problems evaluating the expression and your job is to help him find the answer.

The values of a and b are:
a = (nC0)^2 + (nC1)^2 +(nC2)^2+..........+(nCn)^2
b = m

As the answer can be too large , you need to print  modulo 10^9+6.

Input:
first line contain a number "t"
next "t" lines contain two number m and n

Output:
Output Contains "t" lines,ith line conatins the answer of the ith test case

Constraints:
1 ≤ m ≤ 10^5
1 ≤ n ≤ 10^5
1 ≤ t ≤ 1000

SAMPLE INPUT
4
1 2
1 1
2 1
2 3

SAMPLE OUTPUT
6
2
4
400
Difficulty: 0
Solutions: # Binomial coefficient with mod inverse of prime.  Calculate binom (n, r) % p.
MAXN = 200005
MOD = 10 ** 9 + 7
f = [0] * MAXN
def binom (n, r, p):
    # print binom (10 ** 18, 2545354543534, 9973)
    if n < 0 or r < 0 or n < r: return 0

    # Precalculate factorial.
    if f [0] != 1:  # Factorial already precalculated.
        f [0] = 1
        for i in range (1, MAXN): f [i] = (i * f [i - 1]) % p

    # Calculate modular inverse using Fermat's little theorum.
    #def inv (n): return  pow (n, p - 2, p)
    def inv (n): return  pow (n, 500000001, p)

    ret = 1
    while n or r:
        # Use Lucas theorum to reduce values into its prime residual.
        n0, r0 = n % p, r % p
        n, r = n / p, r / p
        if n0 < r0: return 0
        # print n0, r0
        ret *= f [n0] * inv (f [r0]) * inv (f [n0 - r0])
        ret %= p

    return ret

T = int (raw_input ())
for t in xrange (T):
	m, n = [int (i) for i in raw_input ().split ()]
	x = binom (2 * n, n, MOD - 1)
	print pow (x, m, MOD - 1)

Example question 2:
Name: 1118_F1. Tree Cutting (Easy Version)
Tags: ['dfs and similar', 'trees']
Description: You are given an undirected tree of n vertices. 

Some vertices are colored blue, some are colored red and some are uncolored. It is guaranteed that the tree contains at least one red vertex and at least one blue vertex.

You choose an edge and remove it from the tree. Tree falls apart into two connected components. Let's call an edge nice if neither of the resulting components contain vertices of both red and blue colors.

How many nice edges are there in the given tree?

Input

The first line contains a single integer n (2 ≤ n ≤ 3 ⋅ 10^5) — the number of vertices in the tree.

The second line contains n integers a_1, a_2, ..., a_n (0 ≤ a_i ≤ 2) — the colors of the vertices. a_i = 1 means that vertex i is colored red, a_i = 2 means that vertex i is colored blue and a_i = 0 means that vertex i is uncolored.

The i-th of the next n - 1 lines contains two integers v_i and u_i (1 ≤ v_i, u_i ≤ n, v_i ≠ u_i) — the edges of the tree. It is guaranteed that the given edges form a tree. It is guaranteed that the tree contains at least one red vertex and at least one blue vertex.

Output

Print a single integer — the number of nice edges in the given tree.

Examples

Input


5
2 0 0 1 2
1 2
2 3
2 4
2 5


Output


1


Input


5
1 0 0 0 2
1 2
2 3
3 4
4 5


Output


4


Input


3
1 1 2
2 3
1 3


Output


0

Note

Here is the tree from the first example:

<image>

The only nice edge is edge (2, 4). Removing it makes the tree fall apart into components \{4\} and \{1, 2, 3, 5\}. The first component only includes a red vertex and the second component includes blue vertices and uncolored vertices.

Here is the tree from the second example:

<image>

Every edge is nice in it.

Here is the tree from the third example:

<image>

Edge (1, 3) splits the into components \{1\} and \{3, 2\}, the latter one includes both red and blue vertex, thus the edge isn't nice. Edge (2, 3) splits the into components \{1, 3\} and \{2\}, the former one includes both red and blue vertex, thus the edge also isn't nice. So the answer is 0.
Difficulty: 12
Solutions: #include <bits/stdc++.h>
using namespace std;
void DEB(istream_iterator<string> it) {}
template <typename T, typename... Args>
void DEB(istream_iterator<string> it, T a, Args... args) {
  cout << *it << " = " << a << '\n';
  DEB(++it, args...);
}
const int N = 3e5 + 5, mod = 1e9 + 7, inf = 1e9 + 7;
int f[N][3];
int n, res;
int a[N];
vector<int> adj[N];
bool ck[N];
void dfs1(int u, int e) {
  if (a[u] == 1) {
    f[u][1]++;
  }
  if (a[u] == 2) {
    f[u][2]++;
  }
  for (auto v : adj[u]) {
    if (v != e) {
      dfs1(v, u);
      f[u][1] += f[v][1];
      f[u][2] += f[v][2];
    }
  }
}
void dfs2(int u, int e) {
  if (e != -1) {
    f[e][1] -= f[u][1];
    f[e][2] -= f[u][2];
    if (!f[u][1] && !f[e][2]) {
      res++;
    } else if (!f[u][2] && !f[e][1]) {
      res++;
    }
    f[u][1] += f[e][1];
    f[u][2] += f[e][2];
  }
  for (auto v : adj[u]) {
    if (v != e) {
      dfs2(v, u);
    }
  }
  if (e != -1) {
    f[u][1] -= f[e][1];
    f[u][2] -= f[e][2];
    f[e][1] += f[u][1];
    f[e][2] += f[u][2];
  }
}
signed main() {
  ios_base::sync_with_stdio(0);
  cin.tie(0);
  cout.tie(0);
  cin >> n;
  for (int i = 1; i <= n; i++) {
    cin >> a[i];
  }
  for (int i = 1; i < n; i++) {
    int x, y;
    cin >> x >> y;
    adj[x].push_back(y);
    adj[y].push_back(x);
  }
  dfs1(1, -1);
  dfs2(1, -1);
  cout << res;
}



INSTRUCTIONS:
Solve the current question.
Provide:
1. A complete and efficient code solution, optimized for both time and space complexity.
2. A detailed explanation of the solution, including:
   - The intuition behind the approach;
   - Time and space complexity;
   - Important considerations about the algorithm.
3. You can use the example questions as general references for coding patterns and structure, but solve the current problem independently.
4. Don't use any external libraries. Any language is accepted.