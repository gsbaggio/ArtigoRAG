CURRENT QUESTION:
You are given a binary string (i. e. a string consisting of characters 0 and/or 1) s of length n. You can perform the following operation with the string s at most once: choose a substring (a contiguous subsequence) of s having exactly k characters 1 in it, and shuffle it (reorder the characters in the substring as you wish).

Calculate the number of different strings which can be obtained from s by performing this operation at most once.

Input

The first line contains two integers n and k (2 ≤ n ≤ 5000; 0 ≤ k ≤ n).

The second line contains the string s of length n, consisting of characters 0 and/or 1.

Output

Print one integer — the number of different strings which can be obtained from s by performing the described operation at most once. Since the answer can be large, output it modulo 998244353.

Examples

Input


7 2
1100110


Output


16


Input


5 0
10010


Output


1


Input


8 1
10001000


Output


10


Input


10 8
0010011000


Output


1

Note

Some strings you can obtain in the first example:

  * to obtain 0110110, you can take the substring from the 1-st character to the 4-th character, which is 1100, and reorder its characters to get 0110; 
  * to obtain 1111000, you can take the substring from the 3-rd character to the 7-th character, which is 00110, and reorder its characters to get 11000; 
  * to obtain 1100101, you can take the substring from the 5-th character to the 7-th character, which is 110, and reorder its characters to get 101. 



In the second example, k = 0 so you can only choose the substrings consisting only of 0 characters. Reordering them doesn't change the string at all, so the only string you can obtain is 10010.

EXAMPLE QUESTIONS:
Example question 1:
Name: 794_D. Labelling Cities
Tags: ['dfs and similar', 'graphs', 'hashing']
Description: Oleg the bank client lives in Bankopolia. There are n cities in Bankopolia and some pair of cities are connected directly by bi-directional roads. The cities are numbered from 1 to n. There are a total of m roads in Bankopolia, the i-th road connects cities ui and vi. It is guaranteed that from each city it is possible to travel to any other city using some of the roads.

Oleg wants to give a label to each city. Suppose the label of city i is equal to xi. Then, it must hold that for all pairs of cities (u, v) the condition |xu - xv| ≤ 1 holds if and only if there is a road connecting u and v.

Oleg wonders if such a labeling is possible. Find an example of such labeling if the task is possible and state that it is impossible otherwise.

Input

The first line of input contains two space-separated integers n and m (2 ≤ n ≤ 3·105, 1 ≤ m ≤ 3·105) — the number of cities and the number of roads.

Next, m lines follow. The i-th line contains two space-separated integers ui and vi (1 ≤ ui, vi ≤ n, ui ≠ vi) — the cities connected by the i-th road. It is guaranteed that there is at most one road between each pair of cities and it is possible to travel from any city to any other city using some roads.

Output

If the required labeling is not possible, output a single line containing the string "NO" (without quotes).

Otherwise, output the string "YES" (without quotes) on the first line. On the next line, output n space-separated integers, x1, x2, ..., xn. The condition 1 ≤ xi ≤ 109 must hold for all i, and for all pairs of cities (u, v) the condition |xu - xv| ≤ 1 must hold if and only if there is a road connecting u and v.

Examples

Input

4 4
1 2
1 3
1 4
3 4


Output

YES
2 3 1 1 


Input

5 10
1 2
1 3
1 4
1 5
2 3
2 4
2 5
3 4
3 5
5 4


Output

YES
1 1 1 1 1 


Input

4 3
1 2
1 3
1 4


Output

NO

Note

For the first sample, x1 = 2, x2 = 3, x3 = x4 = 1 is a valid labeling. Indeed, (3, 4), (1, 2), (1, 3), (1, 4) are the only pairs of cities with difference of labels not greater than 1, and these are precisely the roads of Bankopolia.

For the second sample, all pairs of cities have difference of labels not greater than 1 and all pairs of cities have a road connecting them.

For the last sample, it is impossible to construct a labeling satisfying the given constraints.
Difficulty: 10
Solutions: #include <bits/stdc++.h>
using namespace std;
const int N = 1e6 + 1;
const int M = 1e9 + 7;
const double eps = 1e-6;
const int inf = 1e9;
const long long INF = 1e18;
const double PI(acos(-1.0));
vector<int> g[N];
set<int> G[N];
map<vector<int>, int> mp;
int ans[N];
int n, m;
int t = 1, id[N];
int main() {
  cin >> n >> m;
  for (int i = 0; i < (m); i++) {
    int u, v;
    cin >> u >> v;
    g[u].push_back(v);
    g[v].push_back(u);
  }
  for (int i = (1); i <= (n); i++) {
    g[i].push_back(i);
    sort((g[i]).begin(), (g[i]).end());
    if (!mp[g[i]]) mp[g[i]] = mp.size();
    id[i] = mp[g[i]];
  }
  for (int i = (1); i <= (n); i++)
    for (auto j : g[i])
      if (id[i] != id[j]) G[id[i]].insert(id[j]);
  int s = 0;
  for (int i = (1); i <= (((int)mp.size())); i++) {
    if (((int)G[i].size()) > 2) {
      return cout << "NO\n", 0;
    }
    if (((int)G[i].size()) < 2) s = i;
  }
  for (int i = (1); i <= (((int)mp.size())); i++) {
    ans[s] = i;
    for (auto t : G[s])
      if (!ans[t]) s = t;
  }
  cout << "YES\n";
  for (int i = (1); i <= (n); i++) cout << ans[id[i]] << " ";
  cout << "\n";
}



INSTRUCTIONS:
Solve the current question.
Provide:
1. A complete and efficient code solution, optimized for both time and space complexity.
2. A detailed explanation of the solution, including:
   - The intuition behind the approach;
   - Time and space complexity;
   - Important considerations about the algorithm.
3. If the language has classes, implement in 'Solution' class. Any language is accepted.
4. You can use the example questions as general references for coding patterns and structure, but solve the current problem independently.
5. Don't use any external libraries. Don't need to import any libraries.
