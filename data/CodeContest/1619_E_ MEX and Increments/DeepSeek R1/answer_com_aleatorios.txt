import bisect

t = int(input().strip())
for _ in range(t):
    n = int(input().strip())
    a = list(map(int, input().split()))
    F = [0] * (n + 1)
    for x in a:
        if x <= n:
            F[x] += 1

    S = [0] * (n + 1)
    if n >= 0:
        S[0] = F[0]
    for i in range(1, n + 1):
        S[i] = S[i - 1] + F[i]

    present = [0] * (n + 1)
    for i in range(n + 1):
        if F[i] > 0:
            present[i] = 1

    P = [0] * (n + 1)
    if n >= 0:
        P[0] = present[0]
    for i in range(1, n + 1):
        P[i] = P[i - 1] + present[i]

    M_list = []
    for i in range(n + 1):
        if F[i] == 0:
            M_list.append(i)

    E_list = []
    for i in range(n + 1):
        if F[i] > 0:
            for j in range(F[i] - 1):
                E_list.append(i)
    E_list.sort(reverse=True)
    E_size = len(E_list)

    S_E = [0] * E_size
    if E_size > 0:
        S_E[0] = E_list[0]
        for i in range(1, E_size):
            S_E[i] = S_E[i - 1] + E_list[i]

    M_bad = n + 1
    for m in M_list:
        low = 0
        high = E_size - 1
        count_ge = 0
        while low <= high:
            mid = (low + high) // 2
            if E_list[mid] >= m:
                count_ge = mid + 1
                low = mid + 1
            else:
                high = mid - 1
        count_e = E_size - count_ge
        idx_m = bisect.bisect_left(M_list, m)
        count_m = idx_m
        if count_e < count_m + 1:
            if m < M_bad:
                M_bad = m

    missing_sum = [0] * (n + 2)
    for i in range(1, n + 2):
        k = i - 1
        if k <= n and F[k] == 0:
            missing_sum[i] = missing_sum[i - 1] + k
        else:
            missing_sum[i] = missing_sum[i - 1]

    res = []
    for i in range(0, n + 1):
        if i == 0:
            res.append(str(F[0]))
        else:
            if F[0] == 0:
                res.append("-1")
            elif S[i - 1] < i:
                res.append("-1")
            elif i > M_bad:
                res.append("-1")
            else:
                cost_remove = F[i]
                r = i - P[i - 1]
                if r == 0:
                    total_cost = cost_remove
                    res.append(str(total_cost))
                else:
                    idx = bisect.bisect_right(M_list, i - 1) - 1
                    if idx < 0:
                        cost_cover = 0
                    else:
                        m_max = M_list[idx]
                        low2 = 0
                        high2 = E_size - 1
                        count_ge2 = 0
                        while low2 <= high2:
                            mid2 = (low2 + high2) // 2
                            if E_list[mid2] >= m_max:
                                count_ge2 = mid2 + 1
                                low2 = mid2 + 1
                            else:
                                high2 = mid2 - 1
                        high_index = count_ge2 - 1
                        if high_index == -1:
                            sum_extras = S_E[r - 1]
                        else:
                            if high_index + r < E_size:
                                sum_extras = S_E[high_index + r] - S_E[high_index]
                            else:
                                sum_extras = S_E[-1] - S_E[high_index]
                        cost_cover = missing_sum[i] - sum_extras
                    total_cost = cost_remove + cost_cover
                    res.append(str(total_cost))
    print(" ".join(res))