CURRENT QUESTION:
Dmitry has an array of n non-negative integers a_1, a_2, ..., a_n.

In one operation, Dmitry can choose any index j (1 ≤ j ≤ n) and increase the value of the element a_j by 1. He can choose the same index j multiple times.

For each i from 0 to n, determine whether Dmitry can make the MEX of the array equal to exactly i. If it is possible, then determine the minimum number of operations to do it.

The MEX of the array is equal to the minimum non-negative integer that is not in the array. For example, the MEX of the array [3, 1, 0] is equal to 2, and the array [3, 3, 1, 4] is equal to 0.

Input

The first line of input data contains a single integer t (1 ≤ t ≤ 10^4) — the number of test cases in the input. 

The descriptions of the test cases follow.

The first line of the description of each test case contains a single integer n (1 ≤ n ≤ 2 ⋅ 10^5) — the length of the array a.

The second line of the description of each test case contains n integers a_1, a_2, ..., a_n (0 ≤ a_i ≤ n) — elements of the array a.

It is guaranteed that the sum of the values n over all test cases in the test does not exceed 2⋅10^5.

Output

For each test case, output n + 1 integer — i-th number is equal to the minimum number of operations for which you can make the array MEX equal to i (0 ≤ i ≤ n), or -1 if this cannot be done.

Example

Input


5
3
0 1 3
7
0 1 2 3 4 3 2
4
3 0 0 0
7
4 6 2 3 5 0 5
5
4 0 1 0 4


Output


1 1 0 -1 
1 1 2 2 1 0 2 6 
3 0 1 4 3 
1 0 -1 -1 -1 -1 -1 -1 
2 1 0 2 -1 -1 

Note

In the first set of example inputs, n=3:

  * to get MEX=0, it is enough to perform one increment: a_1++; 
  * to get MEX=1, it is enough to perform one increment: a_2++; 
  * MEX=2 for a given array, so there is no need to perform increments; 
  * it is impossible to get MEX=3 by performing increments. 

SIMILAR QUESTIONS:
Similar question 1 (Similarity score: 0.86):
Name: 1506_D. Epic Transformation
Tags: ['constructive algorithms', 'data structures', 'greedy']
Description: You are given an array a of length n consisting of integers. You can apply the following operation, consisting of several steps, on the array a zero or more times: 

  * you select two different numbers in the array a_i and a_j; 
  * you remove i-th and j-th elements from the array. 



For example, if n=6 and a=[1, 6, 1, 1, 4, 4], then you can perform the following sequence of operations: 

  * select i=1, j=5. The array a becomes equal to [6, 1, 1, 4]; 
  * select i=1, j=2. The array a becomes equal to [1, 4]. 



What can be the minimum size of the array after applying some sequence of operations to it?

Input

The first line contains a single integer t (1 ≤ t ≤ 10^4). Then t test cases follow.

The first line of each test case contains a single integer n (1 ≤ n ≤ 2 ⋅ 10^5) is length of the array a.

The second line of each test case contains n integers a_1, a_2, …, a_n (1 ≤ a_i ≤ 10^9).

It is guaranteed that the sum of n over all test cases does not exceed 2 ⋅ 10^5.

Output

For each test case, output the minimum possible size of the array after applying some sequence of operations to it.

Example

Input


5
6
1 6 1 1 4 4
2
1 2
2
1 1
5
4 5 4 5 4
6
2 3 2 1 3 1


Output


0
0
2
1
0
Difficulty: 10
Solutions: import sys
input=sys.stdin.readline

t = int(input())
 
for i in range(t):
    n=int(input())
    a=[int(x) for x in input().split()]
    a.sort()
    temp=1

    if n==1:
        print(1)
        continue

    count=[]

    for i in range(1,n):
        if a[i]==a[i-1]:
            temp+=1
            if i==n-1:
                count.append(temp)
        else:
            count.append(temp)
            temp=1
            if i==n-1:
                count.append(temp)

    count.sort()

    if len(count)==1:
        print(count[0])
        continue

    if count[-1]<=sum(count[:len(count)-1]):
        print(n%2)
    else:
        print(count[-1]-sum(count[:len(count)-1]))


Similar question 2 (Similarity score: 0.80):
Name: 1416_B. Make Them Equal
Tags: ['constructive algorithms', 'greedy', 'math']
Description: You are given an array a consisting of n positive integers, numbered from 1 to n. You can perform the following operation no more than 3n times:

  1. choose three integers i, j and x (1 ≤ i, j ≤ n; 0 ≤ x ≤ 10^9); 
  2. assign a_i := a_i - x ⋅ i, a_j := a_j + x ⋅ i. 



After each operation, all elements of the array should be non-negative.

Can you find a sequence of no more than 3n operations after which all elements of the array are equal?

Input

The first line contains one integer t (1 ≤ t ≤ 10^4) — the number of test cases. Then t test cases follow.

The first line of each test case contains one integer n (1 ≤ n ≤ 10^4) — the number of elements in the array. The second line contains n integers a_1, a_2, ..., a_n (1 ≤ a_i ≤ 10^5) — the elements of the array.

It is guaranteed that the sum of n over all test cases does not exceed 10^4.

Output

For each test case print the answer to it as follows:

  * if there is no suitable sequence of operations, print -1; 
  * otherwise, print one integer k (0 ≤ k ≤ 3n) — the number of operations in the sequence. Then print k lines, the m-th of which should contain three integers i, j and x (1 ≤ i, j ≤ n; 0 ≤ x ≤ 10^9) for the m-th operation. 



If there are multiple suitable sequences of operations, print any of them. Note that you don't have to minimize k.

Example

Input


3
4
2 16 4 18
6
1 2 3 4 5 6
5
11 19 1 1 3


Output


2
4 1 2
2 3 3
-1
4
1 2 4
2 4 5
2 3 3
4 5 1
Difficulty: 8
Solutions: #include <bits/stdc++.h>
signed main() {
  int t;
  std::cin >> t;
  while (t--) {
    int n;
    std::cin >> n;
    int a[n];
    int sum = 0;
    for (int i = 0; i < n; i++) {
      std::cin >> a[i];
      sum += a[i];
    }
    if (sum % n != 0) {
      std::cout << -1 << std::endl;
      continue;
    }
    std::vector<std::pair<int, std::pair<int, int> > > ans;
    for (int i = 1; i < n; i++) {
      if (a[i] % (i + 1) != 0) {
        ans.push_back({1, {i + 1, i + 1 - (a[i] % (i + 1))}});
        a[i] += i + 1 - (a[i] % (i + 1));
      }
      ans.push_back({i + 1, {1, a[i] / (i + 1)}});
    }
    for (int i = 1; i < n; i++) {
      ans.push_back({1, {i + 1, sum / n}});
    }
    std::cout << ans.size() << std::endl;
    for (int i = 0; i < ans.size(); i++) {
      std::cout << ans[i].first << " " << ans[i].second.first << " "
                << ans[i].second.second << std::endl;
    }
  }
  return 0;
}


Similar question 3 (Similarity score: 0.80):
Name: 1417_D. Make Them Equal
Tags: ['constructive algorithms', 'greedy', 'math']
Description: You are given an array a consisting of n positive integers, numbered from 1 to n. You can perform the following operation no more than 3n times:

  1. choose three integers i, j and x (1 ≤ i, j ≤ n; 0 ≤ x ≤ 10^9); 
  2. assign a_i := a_i - x ⋅ i, a_j := a_j + x ⋅ i. 



After each operation, all elements of the array should be non-negative.

Can you find a sequence of no more than 3n operations after which all elements of the array are equal?

Input

The first line contains one integer t (1 ≤ t ≤ 10^4) — the number of test cases. Then t test cases follow.

The first line of each test case contains one integer n (1 ≤ n ≤ 10^4) — the number of elements in the array. The second line contains n integers a_1, a_2, ..., a_n (1 ≤ a_i ≤ 10^5) — the elements of the array.

It is guaranteed that the sum of n over all test cases does not exceed 10^4.

Output

For each test case print the answer to it as follows:

  * if there is no suitable sequence of operations, print -1; 
  * otherwise, print one integer k (0 ≤ k ≤ 3n) — the number of operations in the sequence. Then print k lines, the m-th of which should contain three integers i, j and x (1 ≤ i, j ≤ n; 0 ≤ x ≤ 10^9) for the m-th operation. 



If there are multiple suitable sequences of operations, print any of them. Note that you don't have to minimize k.

Example

Input


3
4
2 16 4 18
6
1 2 3 4 5 6
5
11 19 1 1 3


Output


2
4 1 2
2 3 3
-1
4
1 2 4
2 4 5
2 3 3
4 5 1
Difficulty: 10
Solutions: # ------------------- fast io --------------------
import os
import sys
from io import BytesIO, IOBase

BUFSIZE = 8192


class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = "x" in file.mode or "r" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b"\n") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)


class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode("ascii"))
        self.read = lambda: self.buffer.read().decode("ascii")
        self.readline = lambda: self.buffer.readline().decode("ascii")


sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip("\r\n")

# ------------------- fast io --------------------
from math import gcd, ceil

def pre(s):
    n = len(s)
    pi = [0] * n
    for i in range(1, n):
        j = pi[i - 1]
        while j and s[i] != s[j]:
            j = pi[j - 1]
        if s[i] == s[j]:
            j += 1
        pi[i] = j
    return pi


def prod(a):
    ans = 1
    for each in a:
        ans = (ans * each)
    return ans

def lcm(a, b): return a * b // gcd(a, b)


def binary(x, length=16):
    y = bin(x)[2:]
    return y if len(y) >= length else "0" * (length - len(y)) + y


for _ in range(int(input()) if True else 1):
    n = int(input())
    #n, k = map(int, input().split())
    #a, b = map(int, input().split())
    #c, d = map(int, input().split())
    a = list(map(int, input().split()))
    #b = list(map(int, input().split()))
    #s = input()
    req = sum(a) / n
    if req != int(req):
        print(-1)
        continue
    req = int(req)
    print((n-1)*3)
    for i in range(1, n):
        next = (i + 1 - a[i]) % (i+1)
        print(1, i+1, next)
        a[0] -= next
        a[i] += next
        print(i+1, 1, a[i]//(i+1))
        a[0] += a[i]
        a[i] = 0

    for i in range(1, n):
        print(1, i+1, req)










INSTRUCTIONS:
Solve the current question.
Provide:
1. A complete and efficient code solution, optimized for both time and space complexity.
2. A detailed explanation of the solution, including:
   - The intuition behind the approach;
   - Time and space complexity;
   - Important considerations about the algorithm.
3. If the language has classes, implement in 'Solution' class. Any language is accepted.
4. Use the similar questions as references to improve the solution, but only if they are relevant.
5. Don't use any external libraries. Don't need to import any libraries.
