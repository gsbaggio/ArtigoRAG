from itertools import combinations
from collections import defaultdict

def find_successful_party(N, M, friendships):
    # Step 1: Build the graph
    graph = defaultdict(set)
    for u, v in friendships:
        graph[u].add(v)
        graph[v].add(u)
    
    # Step 2: Check for a clique of size 5
    for node in range(1, N + 1):
        neighbors = list(graph[node])
        if len(neighbors) >= 4:  # At least 4 neighbors to form a clique of size 5
            for combo in combinations(neighbors, 4):
                if all((combo[i] in graph[combo[j]]) for i in range(4) for j in range(i + 1, 4)):
                    return [node] + list(combo)
    
    # Step 3: Check for an independent set of size 5
    # Complement graph
    complement_graph = defaultdict(set)
    all_nodes = set(range(1, N + 1))
    for node in range(1, N + 1):
        complement_graph[node] = all_nodes - graph[node] - {node}
    
    for node in range(1, N + 1):
        neighbors = list(complement_graph[node])
        if len(neighbors) >= 4:  # At least 4 neighbors to form a clique of size 5 in the complement graph
            for combo in combinations(neighbors, 4):
                if all((combo[i] in complement_graph[combo[j]]) for i in range(4) for j in range(i + 1, 4)):
                    return [node] + list(combo)
    
    # If no successful party is found
    return -1

# Input reading
if __name__ == "__main__":
    import sys
    input = sys.stdin.read
    data = input().splitlines()
    
    N, M = map(int, data[0].split())
    friendships = [tuple(map(int, line.split())) for line in data[1:]]
    
    result = find_successful_party(N, M, friendships)
    if result == -1:
        print(result)
    else:
        print(" ".join(map(str, result)))