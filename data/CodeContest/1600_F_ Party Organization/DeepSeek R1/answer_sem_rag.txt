import bisect
import sys

def main():
    data = sys.stdin.read().split()
    if not data:
        return
    
    n = int(data[0])
    m = int(data[1])
    graph = [[] for _ in range(n+1)]
    index = 2
    for i in range(m):
        u = int(data[index]); v = int(data[index+1]); index += 2
        graph[u].append(v)
        graph[v].append(u)
        
    for i in range(1, n+1):
        graph[i].sort()
        
    if n <= 42:
        # Build an adjacency matrix for nodes 1 to n
        adj_mat = [[False] * (n+1) for _ in range(n+1)]
        for u in range(1, n+1):
            for v in graph[u]:
                adj_mat[u][v] = True
                
        from itertools import combinations
        nodes = list(range(1, n+1))
        for comb in combinations(nodes, 5):
            is_clique = True
            is_independent = True
            for i in range(5):
                for j in range(i+1, 5):
                    u = comb[i]
                    v = comb[j]
                    if adj_mat[u][v]:
                        is_independent = False
                    else:
                        is_clique = False
                    if not is_clique and not is_independent:
                        break
                if not is_clique and not is_independent:
                    break
            if is_clique or is_independent:
                print(f"{comb[0]} {comb[1]} {comb[2]} {comb[3]} {comb[4]}")
                return
        print(-1)
    else:
        deg = [0] * (n+1)
        for i in range(1, n+1):
            deg[i] = len(graph[i])
            
        nodes_list = list(range(1, n+1))
        nodes_list.sort(key=lambda x: deg[x])
        forbidden = [False] * (n+1)
        ind_set = []
        for node in nodes_list:
            if forbidden[node]:
                continue
            ind_set.append(node)
            if len(ind_set) == 5:
                break
            for neighbor in graph[node]:
                forbidden[neighbor] = True
                
        if len(ind_set) == 5:
            print(f"{ind_set[0]} {ind_set[1]} {ind_set[2]} {ind_set[3]} {ind_set[4]}")
            return
            
        nodes_list.sort(key=lambda x: deg[x], reverse=True)
        clique = []
        for node in nodes_list:
            can_add = True
            for member in clique:
                pos = bisect.bisect_left(graph[member], node)
                if pos >= len(graph[member]) or graph[member][pos] != node:
                    can_add = False
                    break
            if can_add:
                clique.append(node)
                if len(clique) == 5:
                    break
                    
        if len(clique) == 5:
            print(f"{clique[0]} {clique[1]} {clique[2]} {clique[3]} {clique[4]}")
        else:
            print(-1)

if __name__ == "__main__":
    main()