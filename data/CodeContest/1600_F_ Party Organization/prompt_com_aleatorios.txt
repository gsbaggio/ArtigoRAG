CURRENT QUESTION:
On the great island of Baltia, there live N people, numbered from 1 to N. There are exactly M pairs of people that are friends with each other. The people of Baltia want to organize a successful party, but they have very strict rules on what a party is and when the party is successful. On the island of Baltia, a party is a gathering of exactly 5 people. The party is considered to be successful if either all the people at the party are friends with each other (so that they can all talk to each other without having to worry about talking to someone they are not friends with) or no two people at the party are friends with each other (so that everyone can just be on their phones without anyone else bothering them). Please help the people of Baltia organize a successful party or tell them that it's impossible to do so.

Input

The first line contains two integer numbers, N (5 ≤ N ≤ 2*10^5) and M (0 ≤ M ≤ 2*10^5) – the number of people that live in Baltia, and the number of friendships. The next M lines each contains two integers U_i and V_i (1 ≤ U_i,V_i ≤ N) – meaning that person U_i is friends with person V_i. Two friends can not be in the list of friends twice (no pairs are repeated) and a person can be friends with themselves (U_i ≠ V_i).

Output

If it's possible to organize a successful party, print 5 numbers indicating which 5 people should be invited to the party. If it's not possible to organize a successful party, print -1 instead. If there are multiple successful parties possible, print any.

Examples

Input


6 3
1 4
4 2
5 4


Output


1 2 3 5 6


Input


5 4
1 2
2 3
3 4
4 5


Output


-1

EXAMPLE QUESTIONS:
Example question 1:
Name: 522_A. Reposts
Tags: ['*special', 'dfs and similar', 'dp', 'graphs', 'trees']
Description: One day Polycarp published a funny picture in a social network making a poll about the color of his handle. Many of his friends started reposting Polycarp's joke to their news feed. Some of them reposted the reposts and so on.

These events are given as a sequence of strings "name1 reposted name2", where name1 is the name of the person who reposted the joke, and name2 is the name of the person from whose news feed the joke was reposted. It is guaranteed that for each string "name1 reposted name2" user "name1" didn't have the joke in his feed yet, and "name2" already had it in his feed by the moment of repost. Polycarp was registered as "Polycarp" and initially the joke was only in his feed.

Polycarp measures the popularity of the joke as the length of the largest repost chain. Print the popularity of Polycarp's joke.

Input

The first line of the input contains integer n (1 ≤ n ≤ 200) — the number of reposts. Next follow the reposts in the order they were made. Each of them is written on a single line and looks as "name1 reposted name2". All the names in the input consist of lowercase or uppercase English letters and/or digits and have lengths from 2 to 24 characters, inclusive.

We know that the user names are case-insensitive, that is, two names that only differ in the letter case correspond to the same social network user.

Output

Print a single integer — the maximum length of a repost chain.

Examples

Input

5
tourist reposted Polycarp
Petr reposted Tourist
WJMZBMR reposted Petr
sdya reposted wjmzbmr
vepifanov reposted sdya


Output

6


Input

6
Mike reposted Polycarp
Max reposted Polycarp
EveryOne reposted Polycarp
111 reposted Polycarp
VkCup reposted Polycarp
Codeforces reposted Polycarp


Output

2


Input

1
SoMeStRaNgEgUe reposted PoLyCaRp


Output

2
Difficulty: 7
Solutions: 
import java.util.*;
import java.io.*;

public class CodeForces {

    static boolean g[][];
    static boolean v[];
    
    public static void main(String[] args) throws IOException {
        Reader.init(System.in);
        int n = Reader.nextInt();
        HashMap<String, Integer> map = new HashMap<>();
    
        g = new boolean[n*2][n*2];
        v = new boolean[n*2];
        
        Integer x, y;
        int cnt = 0;
        
        for(int i = 0; i < n; i++){
            String a = Reader.next().toLowerCase(); Reader.next();
            String b = Reader.next().toLowerCase();
            
            x = map.get(a);
            if(x == null){
                x = cnt++;
                map.put(a, x);
            }
            
            y = map.get(b);
            if(y == null){
                y = cnt++;
                map.put(b, y);
            }
            
            
            g[y][x] = true;
        }
        
        DFS(1, 0);
        System.out.println(max+1);
        
    }
    
    static int max;
    
    static void DFS(int cur, int counter){
        if(v[cur])
            return;
       
        max = Math.max(max, counter);
       
        for(int i = 0; i < g[cur].length; i++){
            if(g[cur][i])
               DFS(i, counter + 1);
        }
    }
    
}

class Reader {

    static BufferedReader reader;
    static StringTokenizer tokenizer;

    public static int pars(String x) {
        int num = 0;
        int i = 0;
        if (x.charAt(0) == '-') {
            i = 1;
        }
        for (; i < x.length(); i++) {
            num = num * 10 + (x.charAt(i) - '0');
        }

        if (x.charAt(0) == '-') {
            return -num;
        }

        return num;
    }

    static void init(InputStream input) {
        reader = new BufferedReader(
                new InputStreamReader(input));
        tokenizer = new StringTokenizer("");
    }

    static void init(FileReader input) {
        reader = new BufferedReader(input);
        tokenizer = new StringTokenizer("");
    }

    static String next() throws IOException {
        while (!tokenizer.hasMoreTokens()) {
            tokenizer = new StringTokenizer(
                    reader.readLine());
        }
        return tokenizer.nextToken();
    }

    static int nextInt() throws IOException {
        return pars(next());
    }

    static long nextLong() throws IOException {
        return Long.parseLong(next());
    }

    static double nextDouble() throws IOException {
        return Double.parseDouble(next());
    }
}


Example question 2:
Name: p02928 Japanese Student Championship 2019 Qualification - Kleene Inversion
Tags: ['']
Description: We have a sequence of N integers A~=~A_0,~A_1,~...,~A_{N - 1}.

Let B be a sequence of K \times N integers obtained by concatenating K copies of A. For example, if A~=~1,~3,~2 and K~=~2, B~=~1,~3,~2,~1,~3,~2.

Find the inversion number of B, modulo 10^9 + 7.

Here the inversion number of B is defined as the number of ordered pairs of integers (i,~j)~(0 \leq i < j \leq K \times N - 1) such that B_i > B_j.

Constraints

* All values in input are integers.
* 1 \leq N \leq 2000
* 1 \leq K \leq 10^9
* 1 \leq A_i \leq 2000

Input

Input is given from Standard Input in the following format:


N K
A_0 A_1 ... A_{N - 1}


Output

Print the inversion number of B, modulo 10^9 + 7.

Examples

Input

2 2
2 1


Output

3


Input

3 5
1 1 1


Output

0


Input

10 998244353
10 9 8 7 5 6 3 4 2 1


Output

185297239
Difficulty: 0
Solutions: #include <bits/stdc++.h>
using namespace std;
int main() {
	long long int mod = 1000000007;
	long long int n, k;
	long long int ans = 0LL;
	//long long int scnt = 0LL;
	//long long int lcnt = 0LL;
	long long int a[2005];
	cin >> n >> k;
	for(int i=0;i<n;i++){
		cin >> a[i];
	}
	for(int i=0;i<n;i++){
		for(int j=i+1;j<n;j++){
			if(a[i]>a[j]){
				ans += k*(k+1)/2;
				ans %= mod;
			}
			if(a[i]<a[j]){
				ans += k*(k-1)/2;
				ans %= mod;
			}
		}
	}
	cout << ans << endl;
	return 0;
}


INSTRUCTIONS:
Solve the current question.
Provide:
1. A complete and efficient code solution, optimized for both time and space complexity.
2. A detailed explanation of the solution, including:
   - The intuition behind the approach;
   - Time and space complexity;
   - Important considerations about the algorithm.
3. You can use the example questions as general references for coding patterns and structure, but solve the current problem independently.
4. Don't use any external libraries. Any language is accepted.