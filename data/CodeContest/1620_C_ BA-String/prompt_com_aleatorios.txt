CURRENT QUESTION:
You are given an integer k and a string s that consists only of characters 'a' (a lowercase Latin letter) and '*' (an asterisk).

Each asterisk should be replaced with several (from 0 to k inclusive) lowercase Latin letters 'b'. Different asterisk can be replaced with different counts of letter 'b'.

The result of the replacement is called a BA-string.

Two strings a and b are different if they either have different lengths or there exists such a position i that a_i ≠ b_i.

A string a is lexicographically smaller than a string b if and only if one of the following holds: 

  * a is a prefix of b, but a ≠ b; 
  * in the first position where a and b differ, the string a has a letter that appears earlier in the alphabet than the corresponding letter in b. 



Now consider all different BA-strings and find the x-th lexicographically smallest of them.

Input

The first line contains a single integer t (1 ≤ t ≤ 2000) — the number of testcases.

The first line of each testcase contains three integers n, k and x (1 ≤ n ≤ 2000; 0 ≤ k ≤ 2000; 1 ≤ x ≤ 10^{18}). n is the length of string s.

The second line of each testcase is a string s. It consists of n characters, each of them is either 'a' (a lowercase Latin letter) or '*' (an asterisk).

The sum of n over all testcases doesn't exceed 2000. For each testcase x doesn't exceed the total number of different BA-strings. String s contains at least one character 'a'.

Output

For each testcase, print a single string, consisting only of characters 'b' and 'a' (lowercase Latin letters) — the x-th lexicographically smallest BA-string.

Example

Input


3
2 4 3
a*
4 1 3
a**a
6 3 20
**a***


Output


abb
abba
babbbbbbbbb

Note

In the first testcase of the example, BA-strings ordered lexicographically are: 

  1. a
  2. ab
  3. abb
  4. abbb
  5. abbbb



In the second testcase of the example, BA-strings ordered lexicographically are: 

  1. aa
  2. aba
  3. abba



Note that string "aba" is only counted once, even though there are two ways to replace asterisks with characters 'b' to get it.

EXAMPLE QUESTIONS:
Example question 1:
Name: 525_D. Arthur and Walls
Tags: ['constructive algorithms', 'data structures', 'graphs', 'greedy', 'shortest paths']
Description: Finally it is a day when Arthur has enough money for buying an apartment. He found a great option close to the center of the city with a nice price.

Plan of the apartment found by Arthur looks like a rectangle n × m consisting of squares of size 1 × 1. Each of those squares contains either a wall (such square is denoted by a symbol "*" on the plan) or a free space (such square is denoted on the plan by a symbol ".").

Room in an apartment is a maximal connected area consisting of free squares. Squares are considered adjacent if they share a common side.

The old Arthur dream is to live in an apartment where all rooms are rectangles. He asks you to calculate minimum number of walls you need to remove in order to achieve this goal. After removing a wall from a square it becomes a free square. While removing the walls it is possible that some rooms unite into a single one.

Input

The first line of the input contains two integers n, m (1 ≤ n, m ≤ 2000) denoting the size of the Arthur apartments.

Following n lines each contain m symbols — the plan of the apartment.

If the cell is denoted by a symbol "*" then it contains a wall.

If the cell is denoted by a symbol "." then it this cell is free from walls and also this cell is contained in some of the rooms.

Output

Output n rows each consisting of m symbols that show how the Arthur apartment plan should look like after deleting the minimum number of walls in order to make each room (maximum connected area free from walls) be a rectangle. 

If there are several possible answers, output any of them.

Examples

Input

5 5
.*.*.
*****
.*.*.
*****
.*.*.


Output

.*.*.
*****
.*.*.
*****
.*.*.


Input

6 7
***.*.*
..*.*.*
*.*.*.*
*.*.*.*
..*...*
*******


Output

***...*
..*...*
..*...*
..*...*
..*...*
*******


Input

4 5
.....
.....
..***
..*..


Output

.....
.....
.....
.....
Difficulty: 10
Solutions: #include <bits/stdc++.h>
using namespace std;
int n, m;
char g[2005][2005];
bool check(int x, int y) {
  if (g[x][y] == '.' || x < 0 || y < 0 || x >= n || y >= m) return 0;
  if (g[x][y - 1] == '.' && g[x - 1][y - 1] == '.' && g[x - 1][y] == '.')
    return 1;
  if (g[x - 1][y] == '.' && g[x - 1][y + 1] == '.' && g[x][y + 1] == '.')
    return 1;
  if (g[x][y + 1] == '.' && g[x + 1][y + 1] == '.' && g[x + 1][y] == '.')
    return 1;
  if (g[x][y - 1] == '.' && g[x + 1][y - 1] == '.' && g[x + 1][y] == '.')
    return 1;
  return 0;
}
int main() {
  while (~scanf("%d%d", &n, &m)) {
    for (int i = 0; i < n; i++) scanf("%s", g[i]);
    queue<pair<int, int> > q;
    for (int i = 0; i < n; i++)
      for (int j = 0; j < m; j++)
        if (check(i, j)) q.push(pair<int, int>(i, j));
    while (!q.empty()) {
      pair<int, int> u = q.front();
      q.pop();
      int i = u.first, j = u.second;
      if (!check(i, j)) continue;
      g[i][j] = '.';
      for (int x = -2; x <= 2; x++)
        for (int y = -2; y <= 2; y++)
          if ((x || y) && check(i + x, j + y))
            q.push(pair<int, int>(i + x, j + y));
    }
    for (int i = 0; i < n; i++) puts(g[i]);
  }
  return 0;
}



INSTRUCTIONS:
Solve the current question.
Provide:
1. A complete and efficient code solution, optimized for both time and space complexity.
2. A detailed explanation of the solution, including:
   - The intuition behind the approach;
   - Time and space complexity;
   - Important considerations about the algorithm.
3. You can use the example questions as general references for coding patterns and structure, but solve the current problem independently.
4. Don't use any external libraries. Any language is accepted.