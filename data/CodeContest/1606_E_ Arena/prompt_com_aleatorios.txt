CURRENT QUESTION:
There are n heroes fighting in the arena. Initially, the i-th hero has a_i health points.

The fight in the arena takes place in several rounds. At the beginning of each round, each alive hero deals 1 damage to all other heroes. Hits of all heroes occur simultaneously. Heroes whose health is less than 1 at the end of the round are considered killed.

If exactly 1 hero remains alive after a certain round, then he is declared the winner. Otherwise, there is no winner.

Your task is to calculate the number of ways to choose the initial health points for each hero a_i, where 1 ≤ a_i ≤ x, so that there is no winner of the fight. The number of ways can be very large, so print it modulo 998244353. Two ways are considered different if at least one hero has a different amount of health. For example, [1, 2, 1] and [2, 1, 1] are different.

Input

The only line contains two integers n and x (2 ≤ n ≤ 500; 1 ≤ x ≤ 500).

Output

Print one integer — the number of ways to choose the initial health points for each hero a_i, where 1 ≤ a_i ≤ x, so that there is no winner of the fight, taken modulo 998244353. 

Examples

Input


2 5


Output


5


Input


3 3


Output


15


Input


5 4


Output


1024


Input


13 37


Output


976890680

EXAMPLE QUESTIONS:
Example question 1:
Name: 626_B. Cards
Tags: ['constructive algorithms', 'dp', 'math']
Description: Catherine has a deck of n cards, each of which is either red, green, or blue. As long as there are at least two cards left, she can do one of two actions: 

  * take any two (not necessarily adjacent) cards with different colors and exchange them for a new card of the third color; 
  * take any two (not necessarily adjacent) cards with the same color and exchange them for a new card with that color. 



She repeats this process until there is only one card left. What are the possible colors for the final card?

Input

The first line of the input contains a single integer n (1 ≤ n ≤ 200) — the total number of cards.

The next line contains a string s of length n — the colors of the cards. s contains only the characters 'B', 'G', and 'R', representing blue, green, and red, respectively.

Output

Print a single string of up to three characters — the possible colors of the final card (using the same symbols as the input) in alphabetical order.

Examples

Input

2
RB


Output

G


Input

3
GRG


Output

BR


Input

5
BBBBB


Output

B

Note

In the first sample, Catherine has one red card and one blue card, which she must exchange for a green card.

In the second sample, Catherine has two green cards and one red card. She has two options: she can exchange the two green cards for a green card, then exchange the new green card and the red card for a blue card. Alternatively, she can exchange a green and a red card for a blue card, then exchange the blue card and remaining green card for a red card.

In the third sample, Catherine only has blue cards, so she can only exchange them for more blue cards.
Difficulty: 8
Solutions: #include <bits/stdc++.h>
using namespace std;
enum { BC = 1, GC = 2, RC = 4 };
char dp[201][201][201];
static int f(int B, int G, int R) {
  if (dp[B][G][R] != -1) return dp[B][G][R];
  if (B == 1 && G == 0 && R == 0) return (dp[B][G][R] = BC);
  if (B == 0 && G == 1 && R == 0) return (dp[B][G][R] = GC);
  if (B == 0 && G == 0 && R == 1) return (dp[B][G][R] = RC);
  char pos = 0;
  if (B >= 2) pos |= f(B - 1, G, R);
  if (G >= 2) pos |= f(B, G - 1, R);
  if (R >= 2) pos |= f(B, G, R - 1);
  if (B >= 1 && G >= 1) pos |= f(B - 1, G - 1, R + 1);
  if (G >= 1 && R >= 1) pos |= f(B + 1, G - 1, R - 1);
  if (R >= 1 && B >= 1) pos |= f(B - 1, G + 1, R - 1);
  dp[B][G][R] = pos;
  return pos;
}
int main() {
  ios::sync_with_stdio(0);
  int n;
  cin >> n;
  int R = 0, G = 0, B = 0;
  for (int i = 0; i < n; i++) {
    char c;
    cin >> c;
    switch (c) {
      case 'R':
        R++;
        break;
      case 'G':
        G++;
        break;
      case 'B':
        B++;
        break;
    }
  }
  memset(dp, -1, sizeof(dp));
  int fr = f(B, G, R);
  if (fr & BC) cout << "B";
  if (fr & GC) cout << "G";
  if (fr & RC) cout << "R";
  cout << endl;
  return 0;
}


Example question 2:
Name: divisibility-test
Tags: []
Description: Rakesh is very good in divisibility. He can easily tell the number is divisible by the given number or not. To make him work harder his teacher changed the question slightly. He will give the number and the other number with which the first number is divisible or not to make it complicated he will mention the range in between he need to tell how many continuous sub numbers are divisible by it or not.

Example:
consider a number 123456
number is 3,
range is 1 to 3. Among all combinations between these ranges there are only 3 sub numbers i.e., 3,123,12 are divisilble. So print 3 as output.

INPUT:
First line consists of T testcases
Evert test case has a number followed by the number in next line and range in the following next line.

OUTPUT:
Print the number of sub numbers divisible by the given number.

Range:
0<T<100
0<number<10^50
0<div<10000

SAMPLE INPUT
2
1254756
4
1 5
54789623
6
2 6

SAMPLE OUTPUT
2
4
Difficulty: 0
Solutions: for _ in range(int(raw_input())):
    li=[]
    m=raw_input()
    div=int(raw_input())
    x,y=map(int,raw_input().split())
    x-=1
    y-=1
    m=m[x:y+1]
    #print(m)
    for i in range(y-x+1):
        for j in range(i+1,y-x+2):
            if int(m[i:j])%div==0:
                li.append(m[i:j])
    print(len(li))


INSTRUCTIONS:
Solve the current question.
Provide:
1. A complete and efficient code solution, optimized for both time and space complexity.
2. A detailed explanation of the solution, including:
   - The intuition behind the approach;
   - Time and space complexity;
   - Important considerations about the algorithm.
3. You can use the example questions as general references for coding patterns and structure, but solve the current problem independently.
4. Don't use any external libraries. Any language is accepted.