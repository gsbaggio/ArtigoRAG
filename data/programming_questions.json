[
    {
        "question_id": "c7512fa1-85fb-4653-afad-95b73a1a31ee",
        "title": "Two Sum",
        "difficulty": "Easy",
        "category": "Array Hash Table",
        "question_text": "Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target.\n\nYou may assume that each input would have exactly one solution, and you may not use the same element twice.\n\nYou can return the answer in any order.\n\n \n\nExample 1:\n\nInput: nums = [2,7,11,15], target = 9\nOutput: [0,1]\nExplanation: Because nums[0] + nums[1] == 9, we return [0, 1].\nExample 2:\n\nInput: nums = [3,2,4], target = 6\nOutput: [1,2]\nExample 3:\n\nInput: nums = [3,3], target = 6\nOutput: [0,1]\n \n\nConstraints:\n\n2 <= nums.length <= 104\n-109 <= nums[i] <= 109\n-109 <= target <= 109\nOnly one valid answer exists.\n \n\nFollow-up: Can you come up with an algorithm that is less than O(n2) time complexity?",
        "solution": "class Solution {\npublic:\n    vector<int> twoSum(vector<int> &nums, int target) {\n        unordered_map<int, int> hash;\n        for (int i = 0; i < nums.size(); i++) {\n            hash[nums[i]] = i;\n        }\n        for (int i = 0; i < nums.size(); i++) {\n            int complement = target - nums[i];\n            if (hash.find(complement) != hash.end() && hash[complement] != i) {\n                return {i, hash[complement]};\n            }\n        }\n        // If no valid pair is found, return an empty vector\n        return {};\n    }\n};",
        "explanation": "Intuition\n\nTo improve our runtime complexity, we need a more efficient way to check if the complement exists in the array. If the complement exists, we need to get its index. What is the best way to maintain a mapping of each element in the array to its index? A hash table.\n\nWe can reduce the lookup time from O(n) to O(1) by trading space for speed. A hash table is well suited for this purpose because it supports fast lookup in near constant time. I say \"near\" because if a collision occurred, a lookup could degenerate to O(n) time. However, lookup in a hash table should be amortized O(1) time as long as the hash function was chosen carefully.\n\nAlgorithm\n\nA simple implementation uses two iterations. In the first iteration, we add each element's value as a key and its index as a value to the hash table. Then, in the second iteration, we check if each element's complement (target−nums[i]) exists in the hash table. If it does exist, we return current element's index and its complement's index. Beware that the complement must not be nums[i] itself!\nComplexity Analysis\n\nTime complexity: O(n).\nWe traverse the list containing n elements exactly twice. Since the hash table reduces the lookup time to O(1), the overall time complexity is O(n).\n\nSpace complexity: O(n).\nThe extra space required depends on the number of items stored in the hash table, which stores exactly n elements."
    },
    {
        "question_id": "8c240482-ae08-472f-b09e-73765133910a",
        "title": "Median of Two Sorted Arrays",
        "difficulty": "Hard",
        "category": "Array Binary Search Divide and Conquer",
        "question_text": "Given two sorted arrays nums1 and nums2 of size m and n respectively, return the median of the two sorted arrays.\n\nThe overall run time complexity should be O(log (m+n)).\n\n \n\nExample 1:\n\nInput: nums1 = [1,3], nums2 = [2]\nOutput: 2.00000\nExplanation: merged array = [1,2,3] and median is 2.\nExample 2:\n\nInput: nums1 = [1,2], nums2 = [3,4]\nOutput: 2.50000\nExplanation: merged array = [1,2,3,4] and median is (2 + 3) / 2 = 2.5.\n \n\nConstraints:\n\nnums1.length == m\nnums2.length == n\n0 <= m <= 1000\n0 <= n <= 1000\n1 <= m + n <= 2000\n-106 <= nums1[i], nums2[i] <= 106",
        "solution": "class Solution {\npublic:\n    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\n        if (nums1.size() > nums2.size()) {\n            return findMedianSortedArrays(nums2, nums1);\n        }\n\n        int m = nums1.size(), n = nums2.size();\n        int left = 0, right = m;\n\n        while (left <= right) {\n            int partitionA = (left + right) / 2;\n            int partitionB = (m + n + 1) / 2 - partitionA;\n\n            int maxLeftA = (partitionA == 0) ? INT_MIN : nums1[partitionA - 1];\n            int minRightA = (partitionA == m) ? INT_MAX : nums1[partitionA];\n            int maxLeftB = (partitionB == 0) ? INT_MIN : nums2[partitionB - 1];\n            int minRightB = (partitionB == n) ? INT_MAX : nums2[partitionB];\n\n            if (maxLeftA <= minRightB && maxLeftB <= minRightA) {\n                if ((m + n) % 2 == 0) {\n                    return (max(maxLeftA, maxLeftB) +\n                            min(minRightA, minRightB)) /\n                           2.0;\n                } else {\n                    return max(maxLeftA, maxLeftB);\n                }\n            } else if (maxLeftA > minRightB) {\n                right = partitionA - 1;\n            } else {\n                left = partitionA + 1;\n            }\n        }\n\n        return 0.0;\n    }\n};",
        "explanation": "Intuition\nRecall the previous approach where we perform a binary search over the 'merged' array consisting of nums1 and nums2, resulting in a time complexity of O(log(m⋅n)). We could further improve the algorithm by performing the binary search only on the smaller array of nums1 and nums2, thus the time complexity is reduced to O(log(min(m,n))).\n\nThe main idea is similar to approach 2, where we need to find a point of partition in both arrays such that the maximum of the smaller half is less than or equal to the minimum of the larger half.\n\nHowever, instead of partitioning over the merged arrays, we can only focus on partitioning the smaller array (let's call this array A). Suppose the partition index is partitionA, we specify that the smaller half contains (m + n + 1) / 2 elements, and we can use this feature to our advantage by directly making partitionB equal to (m + n + 1) / 2 - partitionA, thus the smaller halves of both arrays always contain a total of (m + n + 1) / 2 elements, as shown in the picture below.\n\nAlgorithm\nAssuming nums1 to be the smaller array (If nums2 is smaller, we can swap them). Let m, n represent the size of nums1 and nums2, respectively.\n\nDefine the search space for the partitioning index partitionA by setting boundaries as left = 0 and right = m.\n\nWhile left <= right holds, do the following.\n\nCompute the partition index of nums1 as partitionA = (left + right) / 2. Consequently, the partition index of nums2 is (m + n + 1) / 2 - partitionA.\n\nObtain the edge elements:\n\nDetermine the maximum value of the section A_left as maxLeftA = nums1[partitionA - 1]. If partitionA - 1 < 0, set it as maxLeftA = float(-inf).\nDetermine the minimum value of the section A_right as minRightA = nums1[partitionA]. If partitionA >= m, set it as minRightA = float(inf).\nDetermine the maximum value of the section B_left as maxLeftB = nums2[partitionB - 1]. If partitionB - 1 < 0, set it as maxLeftB = float(-inf).\nDetermine the maximum value of the section B_right as minRightB = nums2[partitionB]. If partitionB >= n, set it as minRightB = float(inf).\nCompare and recalculate: Compare maxLeftA with minRightB and maxLeftB with minRightA.\n\nIf maxLeftA > minRightB, it means the maxLeftA is too large to be in the smaller half, so we update right = partitionA - 1 to move to the left half of the search space.\nIf maxLeftB > minRightA, it means that we are too far on the left side for partitionA and we need to go to the right half of the search space by updating left = partitionA + 1.\nRepeat step 4.\n\nWhen both maxLeftA <= minRightB and maxLeftB <= minRightA are true:\n\nIf (m + n) % 2 = 0, the median value is the average of the maximum value of the smaller half and the minimum value of the larger half, given by answer = (max(maxLeftA, maxLeftB) + min(minRightA, minRightB)) / 2.\nOtherwise, the median value is the maximum value of the smaller half, given by answer = max(maxLeftA, maxLeftB)."
    },
    {
        "question_id": "c2445e51-f884-45f7-857f-d9016a97360c",
        "title": "Pascal's Triangle",
        "difficulty": "Easy",
        "category": "Array Dynamic Programming",
        "question_text": "Given an integer numRows, return the first numRows of Pascal's triangle.\n\nIn Pascal's triangle, each number is the sum of the two numbers directly above it as shown:\nExample 1:\n\nInput: numRows = 5\nOutput: [[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1]]\nExample 2:\n\nInput: numRows = 1\nOutput: [[1]]\n \n\nConstraints:\n\n1 <= numRows <= 30",
        "solution": "class Solution {\npublic:\n    vector<vector<int>> generate(int numRows) {\n        vector<vector<int>> result;\n        vector<int> prevRow;\n        \n        for (int i = 0; i < numRows; i++) {\n            vector<int> currentRow(i + 1, 1);\n            \n            for (int j = 1; j < i; j++) {\n                currentRow[j] = prevRow[j - 1] + prevRow[j];\n            }\n            \n            result.push_back(currentRow);\n            prevRow = currentRow;\n        }\n        \n        return result;\n    }\n};",
        "explanation": "Intuition: We can use a dynamic programming approach with a 1D array to generate Pascal's triangle row by row. Instead of maintaining a 2D array, we can use a single array to store the current row and update it as we iterate through the rows. This approach reduces space complexity.\nInitialize a 1D array to store the current row.\nIterate through numRows and update the array for each row.\ntime complexity of O(numRows^2)\nO(numRows) space"
    },
    {
        "question_id": "c80d62a2-af92-460b-affc-4ddf4d5c1d1c",
        "title": "Best Time to Buy and Sell Stock",
        "difficulty": "Easy",
        "category": "Array Dynamic Programming",
        "question_text": "You are given an array prices where prices[i] is the price of a given stock on the ith day.\n\nYou want to maximize your profit by choosing a single day to buy one stock and choosing a different day in the future to sell that stock.\n\nReturn the maximum profit you can achieve from this transaction. If you cannot achieve any profit, return 0.\n\n \n\nExample 1:\n\nInput: prices = [7,1,5,3,6,4]\nOutput: 5\nExplanation: Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5.\nNote that buying on day 2 and selling on day 1 is not allowed because you must buy before you sell.\nExample 2:\n\nInput: prices = [7,6,4,3,1]\nOutput: 0\nExplanation: In this case, no transactions are done and the max profit = 0.\n \n\nConstraints:\n\n1 <= prices.length <= 105\n0 <= prices[i] <= 104",
        "solution": "class Solution {\npublic:\n    int maxProfit(std::vector<int>& prices) {\n        int buy = prices[0];\n        int profit = 0;\n        for (int i = 1; i < prices.size(); i++) {\n            if (prices[i] < buy) {\n                buy = prices[i];\n            } else if (prices[i] - buy > profit) {\n                profit = prices[i] - buy;\n            }\n        }\n        return profit;\n    }\n};",
        "explanation": "Intuition\nThe problem aims to find the maximum profit that can be obtained by buying and selling a stock. The given solution seems to follow a simple approach of iterating through the prices, keeping track of the minimum buying price, and updating the profit whenever a higher selling price is encountered.\nApproach\nInitialize variables buy with the first element of the prices array and profit as 0.\nIterate through the prices starting from the second element.\nUpdate the buy variable if the current price is lower than the current buying price.\nUpdate the profit if the difference between the current price and the buying price is greater than the current profit.\nReturn the final profit.\nKadane's Algorithm\nKadane's Algorithm is a dynamic programming technique used to find the maximum subarray sum in an array of numbers. The algorithm maintains two variables: max_current represents the maximum sum ending at the current position, and max_global represents the maximum subarray sum encountered so far. At each iteration, it updates max_current to include the current element or start a new subarray if the current element is larger than the accumulated sum. The max_global is updated if max_current surpasses its value.\n\nRelating with the Approach\nIn the provided approach for finding the maximum profit in stock prices, the algorithm can be seen as a variation of Kadane's Algorithm. Instead of finding the maximum subarray sum directly, it focuses on finding the maximum positive difference between consecutive elements (prices) in the array.\n\nHere's how the approach relates to Kadane's Algorithm:\n\nInitialization:\n\nIn Kadane's Algorithm, max_current and max_global are initialized to the first element of the array.\nIn the stock profit approach, buy is initialized with the first element of the prices array, and profit is initialized to 0.\nIteration:\n\nKadane's Algorithm iterates through the array, updating max_current based on the current element's value and deciding whether to start a new subarray.\nThe stock profit approach iterates through the prices array, updating buy when a lower price is encountered and treating the difference between the current price and buy as a potential profit.\nComparison and Update:\n\nKadane's Algorithm compares and updates max_current and max_global at each iteration.\nThe stock profit approach compares and updates profit whenever a positive difference between the current price and buy exceeds the current profit.\nComplexity\nTime complexity: O(n), where n is the length of the prices array. The algorithm iterates through the array once.\nSpace complexity: O(1), as only a constant amount of extra space is used."
    },
    {
        "question_id": "a6e75f42-0cfb-4b52-baef-4f3b8356f888",
        "title": "Best Time to Buy and Sell Stock III",
        "difficulty": "Hard",
        "category": "Array Dynamic Programming",
        "question_text": "You are given an array prices where prices[i] is the price of a given stock on the ith day.\n\nFind the maximum profit you can achieve. You may complete at most two transactions.\n\nNote: You may not engage in multiple transactions simultaneously (i.e., you must sell the stock before you buy again).\n\n \n\nExample 1:\n\nInput: prices = [3,3,5,0,0,3,1,4]\nOutput: 6\nExplanation: Buy on day 4 (price = 0) and sell on day 6 (price = 3), profit = 3-0 = 3.\nThen buy on day 7 (price = 1) and sell on day 8 (price = 4), profit = 4-1 = 3.\nExample 2:\n\nInput: prices = [1,2,3,4,5]\nOutput: 4\nExplanation: Buy on day 1 (price = 1) and sell on day 5 (price = 5), profit = 5-1 = 4.\nNote that you cannot buy on day 1, buy on day 2 and sell them later, as you are engaging multiple transactions at the same time. You must sell before buying again.\nExample 3:\n\nInput: prices = [7,6,4,3,1]\nOutput: 0\nExplanation: In this case, no transaction is done, i.e. max profit = 0.\n \n\nConstraints:\n\n1 <= prices.length <= 105\n0 <= prices[i] <= 105",
        "solution": "public int MaxProfitDpCompactFinal(int[] prices)  {\n            int buy1 = int.MaxValue, buy2 = int.MaxValue;\n            int sell1 = 0, sell2 = 0;\n\n            for (int i = 0; i < prices.Length; i++) {\n                buy1 = Math.Min(buy1, prices[i]);\n                sell1 = Math.Max(sell1, prices[i] - buy1);\n                buy2 = Math.Min(buy2, prices[i] - sell1);\n                sell2 = Math.Max(sell2, prices[i] - buy2);\n            }\n\n            return sell2;\n        }",
        "explanation": "It's not difficult to get the DP recursive formula:\n\ndp[k, i] = max(dp[k, i-1], prices[i] - prices[j] + dp[k-1, j-1]), j=[0..i-1]\nFor k transactions, on i-th day,\nif we don't trade then the profit is same as previous day dp[k, i-1];\nand if we bought the share on j-th day where j=[0..i-1], then sell the share on i-th day then the profit is prices[i] - prices[j] + dp[k-1, j-1] .\nActually j can be i as well. When j is i, the one more extra item prices[i] - prices[j] + dp[k-1, j] = dp[k-1, i] looks like we just lose one chance of transaction.\n\nI see someone else use the formula dp[k, i] = max(dp[k, i-1], prices[i] - prices[j] + dp[k-1, j]), where the last one is dp[k-1, j] instead of dp[k-1, j-1]. It's not the direct sense, as if the share was bought on j-th day, then the total profit of previous transactions should be done on (j-1)th day. However, the result based on that formula is also correct, because if the share was sold on j-th day and then bought again, it is the same if we didn't trade on that day.\n\nSo the straigtforward implementation is:"
    },
    {
        "question_id": "2b0ec068-f123-4ca5-b6df-ae11b28d59b7",
        "title": "Contains Duplicate III",
        "difficulty": "Hard",
        "category": "Array Sliding Window Sorting Bucket Sort Ordered Set",
        "question_text": "You are given an integer array nums and two integers indexDiff and valueDiff.\n\nFind a pair of indices (i, j) such that:\n\ni != j,\nabs(i - j) <= indexDiff.\nabs(nums[i] - nums[j]) <= valueDiff, and\nReturn true if such pair exists or false otherwise.\n\n \n\nExample 1:\n\nInput: nums = [1,2,3,1], indexDiff = 3, valueDiff = 0\nOutput: true\nExplanation: We can choose (i, j) = (0, 3).\nWe satisfy the three conditions:\ni != j --> 0 != 3\nabs(i - j) <= indexDiff --> abs(0 - 3) <= 3\nabs(nums[i] - nums[j]) <= valueDiff --> abs(1 - 1) <= 0\nExample 2:\n\nInput: nums = [1,5,9,1,5,9], indexDiff = 2, valueDiff = 3\nOutput: false\nExplanation: After trying all the possible pairs (i, j), we cannot satisfy the three conditions, so we return false.\n \n\nConstraints:\n\n2 <= nums.length <= 105\n-109 <= nums[i] <= 109\n1 <= indexDiff <= nums.length\n0 <= valueDiff <= 109",
        "solution": "class Solution {\npublic:\n    bool containsNearbyAlmostDuplicate(vector<int>& nums, int k, int t) {\n        int n = nums.size();\n        \n        if(n == 0 || k < 0  || t < 0) return false;\n        \n        unordered_map<int,int> buckets;\n        \n        for(int i=0; i<n; ++i) {\n            int bucket = nums[i] / ((long)t + 1);\n            \n\t\t\t// For negative numbers, we need to decrement bucket by 1\n\t\t\t// to ensure floor division.\n\t\t\t// For example, -1/2 = 0 but -1 should be put in Bucket[-1].\n\t\t\t// Therefore, decrement by 1.\n            if(nums[i] < 0) --bucket;\n            \n            if(buckets.find(bucket) != buckets.end()) return true;\n            else {\n                buckets[bucket] = nums[i];\n                if(buckets.find(bucket-1) != buckets.end() && (long) nums[i] - buckets[bucket-1] <= t) return true;\n                if(buckets.find(bucket+1) != buckets.end() && (long) buckets[bucket+1] - nums[i] <= t) return true;\n                \n                if(buckets.size() > k) {\n                    int key_to_remove = nums[i-k] / ((long)t + 1);\n                    \n                    if(nums[i-k] < 0) --key_to_remove;\n                    \n                    buckets.erase(key_to_remove);\n                }\n            }\n        }\n        \n        return false;\n    }\n};",
        "explanation": "We use the concept of sliding window and buckets together to achieve an optimal solution with O(N) time complexity.\n\nSliding window ensures only those indices are considered whose the absolute difference is at most k. We only consider k indices at a time. This fulfills the second condition.\n\nBuckets are used to ensure that the absolute difference between two numbers is at most t. Let's take a deeper look at them.\nWe (floor) divide each number by t+1 and put it in a bucket with key as the quotient.\nFor example,\n\n[1,5,2,4,3,9,1,5,9], k = 2, t = 3\n\n1 // (3+1) = 0\n5 // (3+1) = 1\n2 // (3+1) = 0\n4 // (3+1) = 1\n3 // (3+1) = 0\n9 // (3+1) = 2\n\nHere, Bucket[0] will contain numbers 0,1,2,3.\nBucket[1] will contain numbers 4,5,6,7.\nBucket[2] will contain numbers 8,9,10,11.\n\nOn observing carefully, we can see that the absolute difference\nbetween any two numbers in any bucket is at most t, which is what we want.\n\nAlso, there can be a case where the neighbouring bucket has some number\nwhose absolute difference with a number in the current bucket is at most t.\nFor instance, 2 lies in Bucket[0] and 4 lies in Bucket[1] and 4 - 2 = 2 < 3 (=t).\nThis can only happen in neighbouring buckets. Therefore, we need to check for this too."
    },
    {
        "question_id": "4469c2bc-41d2-4fd6-a33f-7d2cc51464af",
        "title": "H-Index II",
        "difficulty": "Medium",
        "category": "Array Binary Search",
        "question_text": "Given an array of integers citations where citations[i] is the number of citations a researcher received for their ith paper and citations is sorted in non-descending order, return the researcher's h-index.\n\nAccording to the definition of h-index on Wikipedia: The h-index is defined as the maximum value of h such that the given researcher has published at least h papers that have each been cited at least h times.\n\nYou must write an algorithm that runs in logarithmic time.\n\n \n\nExample 1:\n\nInput: citations = [0,1,3,5,6]\nOutput: 3\nExplanation: [0,1,3,5,6] means the researcher has 5 papers in total and each of them had received 0, 1, 3, 5, 6 citations respectively.\nSince the researcher has 3 papers with at least 3 citations each and the remaining two with no more than 3 citations each, their h-index is 3.\nExample 2:\n\nInput: citations = [1,2,100]\nOutput: 2\n \n\nConstraints:\n\nn == citations.length\n1 <= n <= 105\n0 <= citations[i] <= 1000\ncitations is sorted in ascending order.",
        "solution": "class Solution(object):\n    def hIndex(self, citations):\n        \"\"\"\n        :type citations: List[int]\n        :rtype: int\n        \"\"\"\n        n = len(citations)\n        l = 0\n        r = n\n        while l < r:\n            m = (l + r + 1) // 2\n            [l, r] = [m, r] if citations[n - m] >= m else [l, m - 1]\n        return l",
        "explanation": "Intuition\nTo efficiently determine the H-index, we can leverage binary search on a sorted list of citations. Instead of scanning linearly, we repeatedly narrow down the range by checking how many papers have at least h citations using a binary condition.\n\nSort the citations array.\nApply binary search on the potential H-index values (h) from 0 to n.\nFor a given mid-value m, check if there are at least m papers with m or more citations.\nAdjust the search range based on this condition.\nReturn the maximum m that satisfies the condition.\nComplexity\nTime Complexity:\n\n( O(\\log n) ) for binary search, each with a constant-time check.\n( O(n \\log n) ) overall because of sorting.\nSpace Complexity:\n\n( O(1) ) — constant space for pointers."
    },
    {
        "question_id": "faf01567-c8c3-4b2a-88d5-d844ba9170a4",
        "title": "Super Ugly Number",
        "difficulty": "Medium",
        "category": "Array Math Dynamic Programming",
        "question_text": "A super ugly number is a positive integer whose prime factors are in the array primes.\n\nGiven an integer n and an array of integers primes, return the nth super ugly number.\n\nThe nth super ugly number is guaranteed to fit in a 32-bit signed integer.\n\n \n\nExample 1:\n\nInput: n = 12, primes = [2,7,13,19]\nOutput: 32\nExplanation: [1,2,4,7,8,13,14,16,19,26,28,32] is the sequence of the first 12 super ugly numbers given primes = [2,7,13,19].\nExample 2:\n\nInput: n = 1, primes = [2,3,5]\nOutput: 1\nExplanation: 1 has no prime factors, therefore all of its prime factors are in the array primes = [2,3,5].\n \n\nConstraints:\n\n1 <= n <= 105\n1 <= primes.length <= 100\n2 <= primes[i] <= 1000\nprimes[i] is guaranteed to be a prime number.\nAll the values of primes are unique and sorted in ascending order.",
        "solution": "class Solution {\n    public int nthSuperUglyNumber(int n, int[] primes) {\n        PriorityQueue<int[]> queue=new PriorityQueue<>((a,b)->(a[0]-b[0]));\n        for (int i=0;i<primes.length;i++)\n            queue.offer(new int[]{primes[i], primes[i], 0});\n\n        int[] nums=new int[n+1];\n        nums[0]=1;\n        \n        int i=1;\n        while (i<n){\n            int[] entry=queue.poll();\n            int num=entry[0], prime=entry[1], index=entry[2];\n\t\t\t// remove duplicate\n            if (num!=nums[i-1]){\n                nums[i]=num;\n                i++;\n            }\n            queue.offer(new int[]{prime*nums[index+1], prime, index+1});\n        }\n        return nums[n-1];\n    }\n}",
        "explanation": "It is actually like how we merge k sorted list:\n\nugly number                       k sorted list\n    1                            2     7    13   19     1 * [2,7,13,19]\n    |                            |     |    |    |\n    2                            4     14   26   38     2 * [2,7,13,19]\n    |                            |     |    |    |\n    4                            8     28   52   76     4 * [2,7,13,19]\n    |                            |     |    |    |              \n    7                            14    49   91   133    7 * [2,7,13,19]\n    |                            |     |    |    |\n    8                            16    56   ...   ...   8 * [2,7,13,19]\n    |                            |     |    |     |\n    .                            .     .     .    .\n    .                            .     .     .    .\n    .                            .     .     .    .\nWe can see that each prime number in primes[] form a sorted list, and now our job is to merge them and find the nth minimum.\n\nHere we don't have the next pointer for each node to trace the next potential candidate. But as we can see in the graph, we can make use of the ugly number we have produced so far!\nHere, each entry has three parts: {num, prime, index}, num represents the value of the node, prime means which sorted list this node is in, and index tells us how far we have gone in that list, it works like the next pointer in linkedlist, help us find the next node in that sorted list.\n\nTime: O(nlogk)\nSpace: O(n+k)"
    },
    {
        "question_id": "6fd13fe3-bfc9-4d99-87fe-b92dabbf33c2",
        "title": "Create Maximum Number",
        "difficulty": "Hard",
        "category": "Array Two Pointers Stack Greedy Monotonic Stack",
        "question_text": "You are given two integer arrays nums1 and nums2 of lengths m and n respectively. nums1 and nums2 represent the digits of two numbers. You are also given an integer k.\n\nCreate the maximum number of length k <= m + n from digits of the two numbers. The relative order of the digits from the same array must be preserved.\n\nReturn an array of the k digits representing the answer.\n\n \n\nExample 1:\n\nInput: nums1 = [3,4,6,5], nums2 = [9,1,2,5,8,3], k = 5\nOutput: [9,8,6,5,3]\nExample 2:\n\nInput: nums1 = [6,7], nums2 = [6,0,4], k = 5\nOutput: [6,7,6,0,4]\nExample 3:\n\nInput: nums1 = [3,9], nums2 = [8,9], k = 3\nOutput: [9,8,9]\n \n\nConstraints:\n\nm == nums1.length\nn == nums2.length\n1 <= m, n <= 500\n0 <= nums1[i], nums2[i] <= 9\n1 <= k <= m + n\nnums1 and nums2 do not have leading zeros.",
        "solution": "class Solution {\npublic:\n    #define MIN(a,b) (a<b?a:b)\n    #define MAX(a,b) (a>b?a:b)\n    // create max number of length t from single non-empty vector\n    void getMax(int* num, int& len, int* result, int& t, int& sortedLen)\n    {\n    \tint n, top = 0;\n    \tresult[0] = num[0];\n    \tconst int need2drop = len - t;\n    \tfor (int i = 1; i < len; ++i){\n    \t\tn = num[i];\n    \t\twhile (top >= 0 && result[top] < n && (i - top) <= need2drop) --top; // i - top means already dropped i - top numbers\n    \t\tif (i - top > need2drop){\n    \t\t\tsortedLen = MAX(1,top);\n    \t\t\twhile (++top < t) result[top] = num[i++];\n    \t\t\treturn;\n    \t\t}\n    \t\tif (++top < t) result[top] = n;\n    \t\telse top = t - 1;\n    \t}\n    }\n    // create max number of different length from single vector\n    void dp(int *num, int len, int&sortedLen, int& minL, int& maxL, int *res, int &k){\n    \tint  j, *head, *prevhead = res;\n    \tconst int soi = sizeof(int);\n    \tgetMax(num, len, res, maxL,sortedLen);\n    \tfor (int l = maxL; l > MAX(minL,1); --l){\n    \t\thead = prevhead + k;\n    \t\tmemcpy(head, prevhead, l*soi);\n    \t\tfor (j = sortedLen; j < l; ++j){\n    \t\t\tif (head[j] > head[j - 1]){\n    \t\t\t\tsortedLen = MAX(1, j - 1);\n    \t\t\t\tmemcpy(head + j - 1, prevhead + j, soi*(l - j));\n    \t\t\t\tbreak;\n    \t\t\t}\n    \t\t}\n    \t\tif (j == l) sortedLen = l;\n    \t\tprevhead = head;\n    \t}\n    }\n    // merge max number created from single vector\n    void merge(int* num1,int len1,int* num2,int len2,int* result,int& resSize){\n    \tint i = 0, j = 0, k = 0;\n    \twhile (i < resSize){\n    \t\tif (j < len1 && k < len2){\n    \t\t\tif (num1[j] > num2[k])\n    \t\t\t\tresult[i++] = num1[j++];\n    \t\t\telse if (num1[j] < num2[k])\n    \t\t\t\tresult[i++] = num2[k++];\n    \t\t\telse{\n    \t\t\t\tint remaining1 = len1 - j, remaining2 = len2 - k, tmp = num1[j];\n    \t\t\t\tint flag = memcmp(num1 + j, num2 + k, sizeof(int) * MIN(remaining1, remaining2));\n    \t\t\t\tflag = (flag == 0 ? (remaining1>remaining2 ? 1 : -1) : flag);\n    \t\t\t\tint * num = flag > 0 ? num1 : num2;\n    \t\t\t\tint & cnt = flag > 0 ? j : k;\n    \t\t\t\tint len = flag > 0 ? len1 : len2;\n    \t\t\t\twhile (num[cnt]==tmp && cnt < len && i<resSize) result[i++] = num[cnt++];\n    \t\t\t}\n    \t\t}\n    \t\telse if (j < len1) result[i++] = num1[j++];\n    \t\telse result[i++] = num2[k++];\n    \t}\n    }\n    \n    vector<int> maxNumber(vector<int>& nums1, vector<int>& nums2, int k){\n    \tint soi = sizeof(int), len1 = nums1.size(), len2 = nums2.size(), step = k*soi;\n    \tint minL1 = MAX(0, k - len2), maxL1 = MIN(k, len1), minL2 = k - maxL1, maxL2 = k - minL1, range = maxL1 - minL1 + 1;\n    \tint * res = new int[range * k * 2 + 2 * k], *dp1 = res + k, *dp2 = res + range*k+k, *tmp=res+range*2*k+k;\n    \tmemset(res, 0, step);\n    \tint sortedLen1 = 1, sortedLen2 = 1;\n    \tif (len1 == 0 && len2 > 0) getMax(&nums2[0], len2, res, k, sortedLen2);\n    \telse if (len1 > 0 && len2 == 0) getMax(&nums1[0], len1, res, k, sortedLen2);\n    \telse if (len1 > 0 && len2 > 0){\n    \t\tdp(&nums1[0], len1, sortedLen1, minL1, maxL1, dp1,k);\n    \t\tdp(&nums2[0], len2, sortedLen2, minL2, maxL2, dp2,k);\n    \t\tif (sortedLen1 + sortedLen2 > k){\n    \t\t\tmerge(dp1 + k*(maxL1 - sortedLen1), sortedLen1, dp2 + k*(maxL2 - sortedLen2), sortedLen2, tmp, k);\n    \t\t\tvector<int> resv(tmp, tmp + k);\n    \t\t\tdelete[] res;\n    \t\t\treturn resv;\n    \t\t}\n    \t\tfor (int i = minL1; i <= maxL1; ++i){\n    \t\t\tmerge(dp1+k*(maxL1-i), i, dp2+k*(maxL2-k+i), (k-i), tmp,k);\n    \t\t\tif (memcmp(res, tmp, step) < 0) memcpy(res, tmp, step);\n    \t\t}\n    \t}\n    \tvector<int> resv(res, res + k);\n    \tdelete[] res;\n    \treturn resv;\n    }\n};",
        "explanation": "The basic idea:\n\nTo create max number of length k from two arrays, you need to create max number of length i from array one and max number of length k-i from array two, then combine them together. After trying all possible i, you will get the max number created from two arrays.\n\nOptimization:\n\nSuppose nums1 = [3, 4, 6, 5], nums2 = [9, 1, 2, 5, 8, 3], the maximum number you can create from nums1 is [6, 5] with length 2. For nums2, it's [9, 8, 3] with length 3. Merging the two sequence, we have [9, 8, 6, 5, 3], which is the max number we can create from two arrays without length constraint. If the required length k<=5, we can simply trim the result to required length from front. For instance, if k=3, then [9, 8, 6] is the result.\n\nSuppose we need to create max number with length 2 from num = [4, 5, 3, 2, 1, 6, 0, 8]. The simple way is to use a stack, first we push 4 and have stack [4], then comes 5 > 4, we pop 4 and push 5, stack becomes [5], 3 < 5, we push 3, stack becomes [5, 3]. Now we have the required length 2, but we need to keep going through the array in case a larger number comes, 2 < 3, we discard it instead of pushing it because the stack already grows to required size 2. 1 < 3, we discard it. 6 > 3, we pop 3, since 6 > 5 and there are still elements left, we can continue to pop 5 and push 6, the stack becomes [6], since 0 < 6, we push 0, the stack becomes [6, 0], the stack grows to required length again. Since 8 > 0, we pop 0, although 8 > 6, we can't continue to pop 6 since there is only one number, which is 8, left, if we pop 6 and push 8, we can't get to length 2, so we push 8 directly, the stack becomes [6, 8].\n\nIn the basic idea, we mentioned trying all possible length i. If we create max number for different i from scratch each time, that would be a waste of time. Suppose num = [4, 9, 3, 2, 1, 8, 7, 6], we need to create max number with length from 1 to 8. For i==8, result is the original array. For i==7, we need to drop 1 number from array, since 9 > 4, we drop 4, the result is [9, 3, 2, 1, 8, 7, 6]. For i==6, we need to drop 1 more number, 3 < 9, skip, 2 < 3, skip, 1 < 2, skip, 8 > 1, we drop 1, the result is [9, 3, 2, 8, 7, 6]. For i==5, we need to drop 1 more, but this time, we needn't check from beginning, during last scan, we already know [9, 3, 2] is monotonically non-increasing, so we check 8 directly, since 8 > 2, we drop 2, the result is [9, 3, 8, 7, 6]. For i==4, we start with 8, 8 > 3, we drop 3, the result is [9, 8, 7, 6]. For i==3, we start with 8, 8 < 9, skip, 7 < 8, skip, 6 < 7, skip, by now, we've got maximum number we can create from num without length constraint. So from now on, we can drop a number from the end each time. The result is [9, 8, 7], For i==2, we drop last number 7 and have [9, 8]. For i==1, we drop last number 8 and have [9]."
    },
    {
        "question_id": "aee3702f-6d92-4ddb-a790-b4d793189a86",
        "title": "Coin Change",
        "difficulty": "Medium",
        "category": "Array Two Pointers Stack Greedy Monotonic Stack",
        "question_text": "You are given an integer array coins representing coins of different denominations and an integer amount representing a total amount of money.\n\nReturn the fewest number of coins that you need to make up that amount. If that amount of money cannot be made up by any combination of the coins, return -1.\n\nYou may assume that you have an infinite number of each kind of coin.\n\n \n\nExample 1:\n\nInput: coins = [1,2,5], amount = 11\nOutput: 3\nExplanation: 11 = 5 + 5 + 1\nExample 2:\n\nInput: coins = [2], amount = 3\nOutput: -1\nExample 3:\n\nInput: coins = [1], amount = 0\nOutput: 0\n \n\nConstraints:\n\n1 <= coins.length <= 12\n1 <= coins[i] <= 231 - 1\n0 <= amount <= 104",
        "solution": "class Solution {\npublic:\n    int coinChange(vector<int>& coins, int amount) {\n        vector<int> minCoins(amount + 1, amount + 1);\n        minCoins[0] = 0;\n\n        for (int i = 1; i <= amount; i++) {\n            for (int j = 0; j < coins.size(); j++) {\n                if (i - coins[j] >= 0) {\n                    minCoins[i] = min(minCoins[i], 1 + minCoins[i - coins[j]]);\n                }\n            }\n        }\n\n        return minCoins[amount] != amount + 1 ? minCoins[amount] : -1;        \n    }\n};",
        "explanation": "Step by Step Algorithm\nInitialize min_coins array:\nCreate an array min_coins of length amount + 1, initialized with each element set to amount + 1.\nSet min_coins[0] to 0, as it takes zero coins to make up an amount of zero.\nmin_coins = [amount + 1] * (amount + 1)\nmin_coins[0] = 0\nIterate over each amount:\nStart a loop from 1 to amount (inclusive) to represent each amount from 1 to amount.\nFor each amount i, iterate over each coin denomination c in the coins list.\nfor i in range(1, amount + 1):\n    for c in coins:\nCalculate the minimum number of coins:\nCheck if the current amount i minus the coin denomination c is greater than or equal to 0.\nIf it is, update min_coins[i] to the minimum of its current value and 1 + min_coins[i - c].\n1 + min_coins[i - c] represents taking one coin of denomination c and the minimum number of coins required to make up the remaining amount i - c.\nif i - c >= 0:\n    min_coins[i] = min(min_coins[i], 1 + min_coins[i - c])\nReturn the result:\nAfter updating min_coins for all amounts from 1 to amount, return min_coins[-1] if it's not equal to amount + 1.\nIf min_coins[-1] is still amount + 1, it means the amount cannot be made up by any combination of coins, so return -1.\nreturn min_coins[-1] if min_coins[-1] != amount + 1 else -1\nThis algorithm uses dynamic programming to compute the minimum number of coins required to make up each amount from 1 to amount, ultimately providing the minimum number of coins required to make up the total amount."
    },
    {
        "question_id": "2970c755-4961-48be-b229-7f9c6f572b6e",
        "title": "Wiggle Sort II",
        "difficulty": "Medium",
        "category": "Array Divide and Conquer Greedy Sorting Quickselect",
        "question_text": "Given an integer array nums, reorder it such that nums[0] < nums[1] > nums[2] < nums[3]....\n\nYou may assume the input array always has a valid answer.\n\n \n\nExample 1:\n\nInput: nums = [1,5,1,1,6,4]\nOutput: [1,6,1,5,1,4]\nExplanation: [1,4,1,5,1,6] is also accepted.\nExample 2:\n\nInput: nums = [1,3,2,2,3,1]\nOutput: [2,3,1,3,1,2]\n \n\nConstraints:\n\n1 <= nums.length <= 5 * 104\n0 <= nums[i] <= 5000\nIt is guaranteed that there will be an answer for the given input nums.\n \n\nFollow Up: Can you do it in O(n) time and/or in-place with O(1) extra space?",
        "solution": "void wiggleSort(vector<int>& nums) {\n    int n = nums.size();\n    \n    // Find a median.\n    auto midptr = nums.begin() + n / 2;\n    nth_element(nums.begin(), midptr, nums.end());\n    int mid = *midptr;\n    \n    // Index-rewiring.\n    #define A(i) nums[(1+2*(i)) % (n|1)]\n\n    // 3-way-partition-to-wiggly in O(n) time with O(1) space.\n    int i = 0, j = 0, k = n - 1;\n    while (j <= k) {\n        if (A(j) > mid)\n            swap(A(i++), A(j++));\n        else if (A(j) < mid)\n            swap(A(j), A(k--));\n        else\n            j++;\n    }\n}",
        "explanation": "First I find a median using nth_element. That only guarantees O(n) average time complexity and I don't know about space complexity. I might write this myself using O(n) time and O(1) space, but that's not what I want to show here.\n\nThis post is about what comes after that. We can use three-way partitioning to arrange the numbers so that those larger than the median come first, then those equal to the median come next, and then those smaller than the median come last.\n\nOrdinarily, you'd then use one more phase to bring the numbers to their final positions to reach the overall wiggle-property. But I don't know a nice O(1) space way for this. Instead, I embed this right into the partitioning algorithm. That algorithm simply works with indexes 0 to n-1 as usual, but sneaky as I am, I rewire those indexes where I want the numbers to actually end up. The partitioning-algorithm doesn't even know that I'm doing that, it just works like normal (it just uses A(x) instead of nums[x]).\n\nLet's say nums is [10,11,...,19]. Then after nth_element and ordinary partitioning, we might have this (15 is my median):\n\nindex:     0  1  2  3   4   5  6  7  8  9\nnumber:   18 17 19 16  15  11 14 10 13 12\nI rewire it so that the first spot has index 5, the second spot has index 0, etc, so that I might get this instead:\n\nindex:     5  0  6  1  7  2  8  3  9  4\nnumber:   11 18 14 17 10 19 13 16 12 15\nAnd 11 18 14 17 10 19 13 16 12 15 is perfectly wiggly. And the whole partitioning-to-wiggly-arrangement (everything after finding the median) only takes O(n) time and O(1) space.\n\nIf the above description is unclear, maybe this explicit listing helps:\n\nAccessing A(0) actually accesses nums[1].\nAccessing A(1) actually accesses nums[3].\nAccessing A(2) actually accesses nums[5].\nAccessing A(3) actually accesses nums[7].\nAccessing A(4) actually accesses nums[9].\nAccessing A(5) actually accesses nums[0].\nAccessing A(6) actually accesses nums[2].\nAccessing A(7) actually accesses nums[4].\nAccessing A(8) actually accesses nums[6].\nAccessing A(9) actually accesses nums[8]."
    },
    {
        "question_id": "06b8783e-5cd4-4546-8190-976e9816b964",
        "title": "Count of Range Sum",
        "difficulty": "Hard",
        "category": "Array Binary Search Divide and Conquer Binary Indexed Tree Segment Tree Merge Sort Ordered Set",
        "question_text": "Given an integer array nums and two integers lower and upper, return the number of range sums that lie in [lower, upper] inclusive.\n\nRange sum S(i, j) is defined as the sum of the elements in nums between indices i and j inclusive, where i <= j.\n\n \n\nExample 1:\n\nInput: nums = [-2,5,-1], lower = -2, upper = 2\nOutput: 3\nExplanation: The three ranges are: [0,0], [2,2], and [0,2] and their respective sums are: -2, -1, 2.\nExample 2:\n\nInput: nums = [0], lower = 0, upper = 0\nOutput: 1\n \n\nConstraints:\n\n1 <= nums.length <= 105\n-231 <= nums[i] <= 231 - 1\n-105 <= lower <= upper <= 105\nThe answer is guaranteed to fit in a 32-bit integer.",
        "solution": "public int countRangeSum(int[] nums, int lower, int upper) {\n    int n = nums.length;\n    long[] sums = new long[n + 1];\n    for (int i = 0; i < n; ++i)\n        sums[i + 1] = sums[i] + nums[i];\n    return countWhileMergeSort(sums, 0, n + 1, lower, upper);\n}\n\nprivate int countWhileMergeSort(long[] sums, int start, int end, int lower, int upper) {\n    if (end - start <= 1) return 0;\n    int mid = (start + end) / 2;\n    int count = countWhileMergeSort(sums, start, mid, lower, upper) \n              + countWhileMergeSort(sums, mid, end, lower, upper);\n    int j = mid, k = mid, t = mid;\n    long[] cache = new long[end - start];\n    for (int i = start, r = 0; i < mid; ++i, ++r) {\n        while (k < end && sums[k] - sums[i] < lower) k++;\n        while (j < end && sums[j] - sums[i] <= upper) j++;\n        while (t < end && sums[t] < sums[i]) cache[r++] = sums[t++];\n        cache[r] = sums[i];\n        count += j - k;\n    }\n    System.arraycopy(cache, 0, sums, start, t - start);\n    return count;\n}",
        "explanation": "Recall count smaller number after self where we encountered the problem\n\ncount[i] = count of nums[j] - nums[i] < 0 with j > i\nHere, after we did the preprocess, we need to solve the problem\n\ncount[i] = count of a <= S[j] - S[i] <= b with j > i\nans = sum(count[:])\nTherefore the two problems are almost the same. We can use the same technique used in that problem to solve this problem. One solution is merge sort based; another one is Balanced BST based. The time complexity are both O(n log n).\n\nThe merge sort based solution counts the answer while doing the merge. During the merge stage, we have already sorted the left half [start, mid) and right half [mid, end). We then iterate through the left half with index i. For each i, we need to find two indices k and j in the right half where\n\nj is the first index satisfy sums[j] - sums[i] > upper and\nk is the first index satisfy sums[k] - sums[i] >= lower.\nThen the number of sums in [lower, upper] is j-k. We also use another index t to copy the elements satisfy sums[t] < sums[i] to a cache in order to complete the merge sort.\n\nDespite the nested loops, the time complexity of the \"merge & count\" stage is still linear. Because the indices k, j, t will only increase but not decrease, each of them will only traversal the right half once at most. The total time complexity of this divide and conquer solution is then O(n log n).\n\nOne other concern is that the sums may overflow integer. So we use long instead."
    },
    {
        "question_id": "f5beffad-88ee-494a-ad48-f6eac5c760c2",
        "title": "Russian Doll Envelopes",
        "difficulty": "Hard",
        "category": "Array Binary Search Dynamic Programming Sorting",
        "question_text": "You are given a 2D array of integers envelopes where envelopes[i] = [wi, hi] represents the width and the height of an envelope.\n\nOne envelope can fit into another if and only if both the width and height of one envelope are greater than the other envelope's width and height.\n\nReturn the maximum number of envelopes you can Russian doll (i.e., put one inside the other).\n\nNote: You cannot rotate an envelope.\n\n \n\nExample 1:\n\nInput: envelopes = [[5,4],[6,4],[6,7],[2,3]]\nOutput: 3\nExplanation: The maximum number of envelopes you can Russian doll is 3 ([2,3] => [5,4] => [6,7]).\nExample 2:\n\nInput: envelopes = [[1,1],[1,1],[1,1]]\nOutput: 1\n \n\nConstraints:\n\n1 <= envelopes.length <= 105\nenvelopes[i].length == 2\n1 <= wi, hi <= 105",
        "solution": "public int maxEnvelopes(int[][] envelopes) {\n    if(envelopes == null || envelopes.length == 0 \n       || envelopes[0] == null || envelopes[0].length != 2)\n        return 0;\n    Arrays.sort(envelopes, new Comparator<int[]>(){\n        public int compare(int[] arr1, int[] arr2){\n            if(arr1[0] == arr2[0])\n                return arr2[1] - arr1[1];\n            else\n                return arr1[0] - arr2[0];\n       } \n    });\n    int dp[] = new int[envelopes.length];\n    int len = 0;\n    for(int[] envelope : envelopes){\n        int index = Arrays.binarySearch(dp, 0, len, envelope[1]);\n        if(index < 0)\n            index = -(index + 1);\n        dp[index] = envelope[1];\n        if(index == len)\n            len++;\n    }\n    return len;\n}",
        "explanation": "Sort the array. Ascend on width and descend on height if width are same.\nFind the longest increasing subsequence based on height.\nSince the width is increasing, we only need to consider height.\n[3, 4] cannot contains [3, 3], so we need to put [3, 4] before [3, 3] when sorting otherwise it will be counted as an increasing number if the order is [3, 3], [3, 4]"
    },
    {
        "question_id": "88f8b68a-5005-40a4-ae24-0a0075a1371c",
        "title": "Maximum Product of Subsequences With an Alternating Sum Equal to K",
        "difficulty": "Hard",
        "category": "Array Hash Table Dynamic Programming",
        "question_text": "You are given an integer array nums and two integers, k and limit. Your task is to find a non-empty subsequence of nums that:\n\nHas an alternating sum equal to k.\nMaximizes the product of all its numbers without the product exceeding limit.\nReturn the product of the numbers in such a subsequence. If no subsequence satisfies the requirements, return -1.\n\nThe alternating sum of a 0-indexed array is defined as the sum of the elements at even indices minus the sum of the elements at odd indices.\n\n \n\nExample 1:\n\nInput: nums = [1,2,3], k = 2, limit = 10\n\nOutput: 6\n\nExplanation:\n\nThe subsequences with an alternating sum of 2 are:\n\n[1, 2, 3]\nAlternating Sum: 1 - 2 + 3 = 2\nProduct: 1 * 2 * 3 = 6\n[2]\nAlternating Sum: 2\nProduct: 2\nThe maximum product within the limit is 6.\n\nExample 2:\n\nInput: nums = [0,2,3], k = -5, limit = 12\n\nOutput: -1\n\nExplanation:\n\nA subsequence with an alternating sum of exactly -5 does not exist.\n\nExample 3:\n\nInput: nums = [2,2,3,3], k = 0, limit = 9\n\nOutput: 9\n\nExplanation:\n\nThe subsequences with an alternating sum of 0 are:\n\n[2, 2]\nAlternating Sum: 2 - 2 = 0\nProduct: 2 * 2 = 4\n[3, 3]\nAlternating Sum: 3 - 3 = 0\nProduct: 3 * 3 = 9\n[2, 2, 3, 3]\nAlternating Sum: 2 - 2 + 3 - 3 = 0\nProduct: 2 * 2 * 3 * 3 = 36\nThe subsequence [2, 2, 3, 3] has the greatest product with an alternating sum equal to k, but 36 > 9. The next greatest product is 9, which is within the limit.\n\n \n\nConstraints:\n\n1 <= nums.length <= 150\n0 <= nums[i] <= 12\n-105 <= k <= 105\n1 <= limit <= 5000",
        "solution": "const int MIN = -5000;\n\nclass Solution {\npublic:\n    unordered_map<int, unordered_map<int, unordered_map<int, unordered_map<int, int>>>> dp;\n    int recursion(int pos, int currSum, int product, int isOdd, int k, int n, vector<int> &nums, int limit) {\n        if(pos == n) {\n            return (currSum == k && isOdd != 0 && product <= limit ? product : MIN);\n        }\n        \n        if(dp.count(pos) && dp[pos].count(currSum) && dp[pos][currSum].count(product) && dp[pos][currSum][product].count(isOdd)) {\n            return dp[pos][currSum][product][isOdd];\n        }\n            \n        int ans = recursion(pos + 1, currSum, product, isOdd, k, n, nums, limit);\n        if(isOdd == 0) {\n            ans = max(ans, recursion(pos + 1, currSum + nums[pos], nums[pos], 2, k, n, nums, limit));\n        }\n        if(isOdd == 1) {\n            ans = max(ans, recursion(pos + 1, currSum + nums[pos], min(product * nums[pos], limit + 1), 2, k, n, nums, limit));\n        }\n        if(isOdd == 2) {\n            ans = max(ans, recursion(pos + 1, currSum - nums[pos], min(product * nums[pos], limit + 1), 1, k, n, nums, limit));\n        }\n        \n        return dp[pos][currSum][product][isOdd] = ans;\n    }\n    \n    int maxProduct(vector<int> &nums, int k, int limit) {\n        int n = nums.size();\n        \n        int sum = 0;\n        for(auto &x: nums) sum += x;\n        \n        if(k > sum || k < -sum) return -1;\n            \n        dp.clear();\n        int ans = recursion(0, 0, 0, 0, k, n, nums, limit);\n        return (ans == MIN) ? -1 : ans;\n    }\n};",
        "explanation": "Maximum Product of a Special Subsequence\n Intuition\nThe problem revolves around finding a special subsequence from a given array of positive integers nums, where we need to:\n\nSelect elements in a specific pattern: odd-indexed terms are added, and even-indexed terms are subtracted to form a total sum k.\nThe product of the elements in the subsequence should be maximum but not exceed a given limit.\nSo essentially, it's a dynamic programming problem with multiple states:\n\nThe current index (pos)\nThe current sum (currSum)\nThe product so far (product)\nThe stage or parity (isOdd): whether we're at the start, first number to add, or number to subtract\n Approach\nWe use a recursive function with memoization (unordered_map-based DP) to avoid recalculating overlapping subproblems.\n\nObservation\nOne interesting observation in this problem is sum doesn't exceeds 1800 because the max nums length is 150 and every element isn't greater than 12.\nState Definition\nWe define a DP state as dp[pos][currSum][product][isOdd]:\n\npos: Current index in nums\ncurrSum: Running total based on the subsequence pattern\nproduct: Product formed so far\nisOdd:\n0: Start of subsequence (no elements picked yet)\n1: Last operation was an addition (+a)\n2: Last operation was a subtraction (-b)\nTransition\nAt every step, we either:\n\nSkip the current number and continue (pos + 1).\nInclude the current number:\nIf isOdd == 0: First element, add it and begin product\nIf isOdd == 1: Subtract current number from sum and multiply in product\nIf isOdd == 2: Add current number to sum and multiply in product\nInclusion is only considered if the new product doesn't exceed the limit.\n\nAt base case (pos == n), we check if:\n\ncurrSum == k\nAt least one element should be considered (isOdd != 0)\nproduct <= limit\nIf all these hold, we return the product, else a minimum placeholder value (MIN = -5000).\n\nFinally, we return the best product found or -1 if no valid sequence exists.\n\n Complexity\nTime Complexity:\nO(n⋅sum⋅201⋅3)\n\nn for index\n2 * sum for possible values of currSum (including negatives)\n201 for possible unique product values (we prune above limit + 1)\n3 for possible values of isOdd\nSince we’re memoizing states using hash maps, pruning and skipping invalid states makes this faster than brute force.\n\nSpace Complexity:\nO(n⋅sum⋅201⋅3)\nDue to recursive call stack and DP table (stored in unordered maps), though it's sparsely populated."
    },
    {
        "question_id": "0d1483d9-9fd3-4e75-8200-34c7fb7d04e7",
        "title": "Final Array State After K Multiplication Operations II",
        "difficulty": "Hard",
        "category": "Array Heap (Priority Queue) Simulation",
        "question_text": "You are given an integer array nums, an integer k, and an integer multiplier.\n\nYou need to perform k operations on nums. In each operation:\n\nFind the minimum value x in nums. If there are multiple occurrences of the minimum value, select the one that appears first.\nReplace the selected minimum value x with x * multiplier.\nAfter the k operations, apply modulo 109 + 7 to every value in nums.\n\nReturn an integer array denoting the final state of nums after performing all k operations and then applying the modulo.\n\n \n\nExample 1:\n\nInput: nums = [2,1,3,5,6], k = 5, multiplier = 2\n\nOutput: [8,4,6,5,6]\n\nExplanation:\n\nOperation\tResult\nAfter operation 1\t[2, 2, 3, 5, 6]\nAfter operation 2\t[4, 2, 3, 5, 6]\nAfter operation 3\t[4, 4, 3, 5, 6]\nAfter operation 4\t[4, 4, 6, 5, 6]\nAfter operation 5\t[8, 4, 6, 5, 6]\nAfter applying modulo\t[8, 4, 6, 5, 6]\nExample 2:\n\nInput: nums = [100000,2000], k = 2, multiplier = 1000000\n\nOutput: [999999307,999999993]\n\nExplanation:\n\nOperation\tResult\nAfter operation 1\t[100000, 2000000000]\nAfter operation 2\t[100000000000, 2000000000]\nAfter applying modulo\t[999999307, 999999993]\n \n\nConstraints:\n\n1 <= nums.length <= 104\n1 <= nums[i] <= 109\n1 <= k <= 109\n1 <= multiplier <= 106",
        "solution": "const long long mod = 1000000007;\n\nclass Solution {\npublic:\n    long long power_mod(long long base, long long exp, long long mod) {\n    long long result = 1;\n    \n    while (exp > 0) {\n        if (exp % 2 == 1) {\n            result = (result * base) % mod;\n        }\n        base = (base * base) % mod;\n        exp = exp / 2;\n    }\n    // this function multiplies a number by itself n times in O(logn)\n    return result;\n}\n    vector<int> getFinalState(vector<int>& nums, int k, int multiplier) {\n        if (multiplier == 1) return nums; // do not miss this!!\n        priority_queue <pair<long long,long long>, vector<pair<long long,long long>>, greater<pair<long long,long long>>> pq;\n        int n = nums.size();\n        for (int i = 0; i < n; i++) pq.push({nums[i],i});\n        unordered_map<int,int> m,m1;\n        // m for storing number of operations at each index\n        //m1 to know if all elements have got an operation\n        while (1){\n            if ((int)m1.size() == n || k == 0) break; // no more operations or state achieved\n            long long x = pq.top().first, y = pq.top().second;\n            pq.pop();\n            x *= multiplier; pq.push({x,y});\n            m1[y]++; k--;\n        }\n        vector<long long> v(n); // to avoid integer overflow\n        // This vector will store the elements after ideal state is achieved\n        while (!pq.empty()){\n            long long x = pq.top().first, y = pq.top().second;\n            v[y] = x;\n            pq.pop();\n        }\n        int rep = k/n, md = k%n;\n        for (int i = 0; i < n; i++) pq.push({v[i],i});\n        // I had to push it again because I did not declare v initially due to contest pressure. Better to do that.\n        while (!pq.empty()){\n            int x = pq.top().second;\n            m[x] = rep;\n            if (md > 0)m[x]++,md--;\n            // index x has been assigned its number of operations\n            pq.pop();\n        }\n        // Now just compute every value while calling power_mod funtion\n        for (int i = 0; i < n; i++){\n            long long mlt = power_mod(multiplier, m[i],mod);\n            v[i] = ((v[i]%mod)*(mlt%mod))%mod;\n            nums[i] = v[i];\n        }\n        return nums;\n    }\n};",
        "explanation": "Intuition\nThe general idea is to divide the operations greedily among all indexes.\n\nEvery number after getting an operation should not remain as the smallest. So we will have to achieve that state first.\n\nBY OBSERVATION\nWhen all the elements get atleast an operation, we will achieve the above mentioned state. So we will first greedily assign them operation till all elements get atleast one operation.\n\nUse priority queue min heap or multiset for that.\n\nAfter this we can assign every index a number of operations through our initial general idea.\n\nWhat about such large value of k?\nThe number of operations of each index may be huge due to this. The optimal approach is achieved in log(n) as the multiplier increases exponentially. Check out the function in the code. This is called Exponentiation by Squaring.\n\nComplexity\nTime complexity: O(nlogk)\n\nSpace complexity: O(n)"
    },
    {
        "question_id": "878a31db-8cd5-4979-97d0-487d3796105a",
        "title": "Longest Subsequence With Decreasing Adjacent Difference",
        "difficulty": "Medium",
        "category": "Array Dynamic Programming",
        "question_text": "You are given an array of integers nums.\n\nYour task is to find the length of the longest subsequence seq of nums, such that the absolute differences between consecutive elements form a non-increasing sequence of integers. In other words, for a subsequence seq0, seq1, seq2, ..., seqm of nums, |seq1 - seq0| >= |seq2 - seq1| >= ... >= |seqm - seqm - 1|.\n\nReturn the length of such a subsequence.\n\n \n\nExample 1:\n\nInput: nums = [16,6,3]\n\nOutput: 3\n\nExplanation: \n\nThe longest subsequence is [16, 6, 3] with the absolute adjacent differences [10, 3].\n\nExample 2:\n\nInput: nums = [6,5,3,4,2,1]\n\nOutput: 4\n\nExplanation:\n\nThe longest subsequence is [6, 4, 2, 1] with the absolute adjacent differences [2, 2, 1].\n\nExample 3:\n\nInput: nums = [10,20,10,19,10,20]\n\nOutput: 5\n\nExplanation: \n\nThe longest subsequence is [10, 20, 10, 19, 10] with the absolute adjacent differences [10, 10, 9, 9].\n\n \n\nConstraints:\n\n2 <= nums.length <= 104\n1 <= nums[i] <= 300",
        "solution": "class Solution {\npublic:\n    int longestSubsequence(vector<int>& nums) {\n        vector<vector<int>> dp(302, vector<int>(302));\n\n        for (int i = nums.size() - 1; i >= 0; --i){\n            int num = nums[i];\n    \n            for (int next = 1; next <= 300; ++next){\n                int diff = abs(next - num);\n                dp[num][diff] = max(dp[num][diff], dp[next][diff] + 1);\n            }\n\n            for (int j = 1; j <= 300; ++j){\n                dp[num][j] = max(dp[num][j], dp[num][j - 1]);\n            }\n        }\n\n        int ans = INT_MIN;\n        for (int i = 0; i <= 301; ++i){\n            for (int j = 0; j <= 301; ++j){\n                ans = max(ans, dp[i][j]);\n            }\n        }\n\n        return ans;\n    }\n};",
        "explanation": "Intuition\nSince the range of values is small we can store information about longest subsequences starting from specific values and having differences less than or equal to some value.\n\nApproach\nGoing from back to front, compute for the current number num and for each possible absolute difference d, the maximum length subsequence starting from that number and having differences less than or equal to d between successive elements.\n\nTo do so, we can use information computed earlier. For each other number num2, update dp[num][abs(num−num2)] using dp[num2][abs(num−num2)].\n\nOnce this is done we can compute dp[num][diff] as max \nd≤diff\n​\n dp[num][d]. This is done because we are interested in the longest subsequences whose differences between successive elements are bounded by diff.\n\nComplexity\nTime complexity:\nO(n∗max_value)\n\nSpace complexity:\nO(max_value \n2\n )"
    },
    {
        "question_id": "077f0fd2-8197-4dcd-9948-b57fdd0ba649",
        "title": "Implement Router",
        "difficulty": "Medium",
        "category": "Array Hash Table Binary Search Design Queue Ordered Set",
        "question_text": "Design a data structure that can efficiently manage data packets in a network router. Each data packet consists of the following attributes:\n\nsource: A unique identifier for the machine that generated the packet.\ndestination: A unique identifier for the target machine.\ntimestamp: The time at which the packet arrived at the router.\nImplement the Router class:\n\nRouter(int memoryLimit): Initializes the Router object with a fixed memory limit.\n\nmemoryLimit is the maximum number of packets the router can store at any given time.\nIf adding a new packet would exceed this limit, the oldest packet must be removed to free up space.\nbool addPacket(int source, int destination, int timestamp): Adds a packet with the given attributes to the router.\n\nA packet is considered a duplicate if another packet with the same source, destination, and timestamp already exists in the router.\nReturn true if the packet is successfully added (i.e., it is not a duplicate); otherwise return false.\nint[] forwardPacket(): Forwards the next packet in FIFO (First In First Out) order.\n\nRemove the packet from storage.\nReturn the packet as an array [source, destination, timestamp].\nIf there are no packets to forward, return an empty array.\nint getCount(int destination, int startTime, int endTime):\n\nReturns the number of packets currently stored in the router (i.e., not yet forwarded) that have the specified destination and have timestamps in the inclusive range [startTime, endTime].\nNote that queries for addPacket will be made in increasing order of timestamp.\n\n \n\nExample 1:\n\nInput:\n[\"Router\", \"addPacket\", \"addPacket\", \"addPacket\", \"addPacket\", \"addPacket\", \"forwardPacket\", \"addPacket\", \"getCount\"]\n[[3], [1, 4, 90], [2, 5, 90], [1, 4, 90], [3, 5, 95], [4, 5, 105], [], [5, 2, 110], [5, 100, 110]]\n\nOutput:\n[null, true, true, false, true, true, [2, 5, 90], true, 1]\n\nExplanation\n\nRouter router = new Router(3); // Initialize Router with memoryLimit of 3.\nrouter.addPacket(1, 4, 90); // Packet is added. Return True.\nrouter.addPacket(2, 5, 90); // Packet is added. Return True.\nrouter.addPacket(1, 4, 90); // This is a duplicate packet. Return False.\nrouter.addPacket(3, 5, 95); // Packet is added. Return True\nrouter.addPacket(4, 5, 105); // Packet is added, [1, 4, 90] is removed as number of packets exceeds memoryLimit. Return True.\nrouter.forwardPacket(); // Return [2, 5, 90] and remove it from router.\nrouter.addPacket(5, 2, 110); // Packet is added. Return True.\nrouter.getCount(5, 100, 110); // The only packet with destination 5 and timestamp in the inclusive range [100, 110] is [4, 5, 105]. Return 1.\nExample 2:\n\nInput:\n[\"Router\", \"addPacket\", \"forwardPacket\", \"forwardPacket\"]\n[[2], [7, 4, 90], [], []]\n\nOutput:\n[null, true, [7, 4, 90], []]\n\nExplanation\n\nRouter router = new Router(2); // Initialize Router with memoryLimit of 2.\nrouter.addPacket(7, 4, 90); // Return True.\nrouter.forwardPacket(); // Return [7, 4, 90].\nrouter.forwardPacket(); // There are no packets left, return [].\n \n\nConstraints:\n\n2 <= memoryLimit <= 105\n1 <= source, destination <= 2 * 105\n1 <= timestamp <= 109\n1 <= startTime <= endTime <= 109\nAt most 105 calls will be made to addPacket, forwardPacket, and getCount methods altogether.\nqueries for addPacket will be made in increasing order of timestamp.",
        "solution": "class Router {\npublic:\n    map<vector<int>, int> mpp; // to track duplicates\n    queue<vector<int>> queue; // to store packets in FIFO order\n    unordered_map<int, vector<int>> timestamps; // for timestamps tracking\n    unordered_map<int, int> st; \n    int maxSize = 0; // maxSize allowed\n\n    Router(int memoryLimit) { \n        maxSize = memoryLimit; \n    }\n\n    bool addPacket(int source, int destination, int timestamp) {\n        vector<int> packet = {source, destination, timestamp};\n        // checking for duplicate\n        if (mpp.count(packet))\n            return false;\n        if (queue.size() == maxSize) { // remove the first element if queue is full\n            vector<int> res = queue.front();\n            mpp.erase(res);\n            int temp = res[1];\n            st[temp]++;  \n            queue.pop();\n        }\n        queue.push(packet);\n        mpp[packet]++;\n        timestamps[destination].push_back(timestamp);\n        return true;\n    }\n\n    vector<int> forwardPacket() {\n        if(queue.empty()) return {};\n        vector<int> res = queue.front();\n        queue.pop();\n        mpp.erase(res);\n        int temp = res[1];\n        st[temp]++;\n        return res;\n    }\n\n    int getCount(int destination, int startTime, int endTime) {\n        if(timestamps.find(destination) == timestamps.end())\n            return 0;\n        auto &p = timestamps[destination];\n        int temp = st[destination];\n        auto right = lower_bound(p.begin() + temp, p.end(), startTime);\n        auto left = upper_bound(p.begin() + temp, p.end(), endTime);\n        return int(left - right);\n    }\n};",
        "explanation": "Approach\nLets go over the data structures that we can use here to make our work simpler →\nUse a hashmap to track duplicates.\nUse a queue to store packets in FIFO order as mentioned in the question and pop when needed.\nUse a map of vector to track the timestamps and destinations.\nUse a map to track how many packets we have removed so far.\nNow lets go step by step through the functions,\nRouter → Here we only store the maxSize allowed nothing else.\naddPacket → We firstly check if the packet has already been added, if yes then we simply return false. Else we add it in our ds's.\nforwardPacket → Simply remove the packet from our map and update it in our ds's.\ngetCount → Use binary search functions lower bound and upper bound to return the range [left,right] which consists of elements in the range startTime and endTime."
    },
    {
        "question_id": "c851e74e-5a17-4c4a-92ce-f9c17afeaf80",
        "title": "Number of Unique XOR Triplets I",
        "difficulty": "Medium",
        "category": "Array Math Bit Manipulation",
        "question_text": "You are given an integer array nums of length n, where nums is a permutation of the numbers in the range [1, n].\n\nA XOR triplet is defined as the XOR of three elements nums[i] XOR nums[j] XOR nums[k] where i <= j <= k.\n\nReturn the number of unique XOR triplet values from all possible triplets (i, j, k).\n\n \n\nExample 1:\n\nInput: nums = [1,2]\n\nOutput: 2\n\nExplanation:\n\nThe possible XOR triplet values are:\n\n(0, 0, 0) → 1 XOR 1 XOR 1 = 1\n(0, 0, 1) → 1 XOR 1 XOR 2 = 2\n(0, 1, 1) → 1 XOR 2 XOR 2 = 1\n(1, 1, 1) → 2 XOR 2 XOR 2 = 2\nThe unique XOR values are {1, 2}, so the output is 2.\n\nExample 2:\n\nInput: nums = [3,1,2]\n\nOutput: 4\n\nExplanation:\n\nThe possible XOR triplet values include:\n\n(0, 0, 0) → 3 XOR 3 XOR 3 = 3\n(0, 0, 1) → 3 XOR 3 XOR 1 = 1\n(0, 0, 2) → 3 XOR 3 XOR 2 = 2\n(0, 1, 2) → 3 XOR 1 XOR 2 = 0\nThe unique XOR values are {0, 1, 2, 3}, so the output is 4.\n\n \n\nConstraints:\n\n1 <= n == nums.length <= 105\n1 <= nums[i] <= n\nnums is a permutation of integers from 1 to n.",
        "solution": "class Solution {\npublic:\n    int uniqueXorTriplets(vector<int>& nums) {\n        int n = nums.size();\n\n        if(n < 3) return n;\n\n        // Find the Most Significant Bit\n        int cnt = 0;\n        int temp = n;\n        while(temp > 0){\n            temp >>= 1;\n            cnt++;\n        }\n        \n        return pow(2, cnt);\n    }\n};",
        "explanation": "Problem Summary\nGiven a permutation nums of numbers from 1 to n, you are to find the number of unique values you can get by doing XOR of all triplets (i, j, k) where i <= j <= k.\n\nUnderstanding the Solution\nFor n < 3\nFor n = 1, only one element → 1 unique value.\nFor n = 2, only 2 combinations → 2 unique values.\nFor n >= 3\nThe number of possible XOR values between numbers from 1 to n is bounded by the number of bits required to represent n.\nSince any XOR operation between values in [1, n] gives a result between 0 to (2^cnt - 1), the maximum number of unique values is 2^cnt.\nComplexity\nTime complexity: O(log n)\nSpace complexity: O(1)"
    },
    {
        "question_id": "a01553b9-4b6f-42c6-9b94-a5214d3db43b",
        "title": "Non-decreasing Array",
        "difficulty": "Medium",
        "category": "Array",
        "question_text": "Given an array nums with n integers, your task is to check if it could become non-decreasing by modifying at most one element.\n\nWe define an array is non-decreasing if nums[i] <= nums[i + 1] holds for every i (0-based) such that (0 <= i <= n - 2).\n\n \n\nExample 1:\n\nInput: nums = [4,2,3]\nOutput: true\nExplanation: You could modify the first 4 to 1 to get a non-decreasing array.\nExample 2:\n\nInput: nums = [4,2,1]\nOutput: false\nExplanation: You cannot get a non-decreasing array by modifying at most one element.\n \n\nConstraints:\n\nn == nums.length\n1 <= n <= 104\n-105 <= nums[i] <= 105",
        "solution": "bool checkPossibility(vector<int>& nums) {\n        int cnt = 0;                                                                    //the number of changes\n        for(int i = 1; i < nums.size() && cnt<=1 ; i++){\n            if(nums[i-1] > nums[i]){\n                cnt++;\n                if(i-2<0 || nums[i-2] <= nums[i])nums[i-1] = nums[i];                    //modify nums[i-1] of a priority\n                else nums[i] = nums[i-1];                                                //have to modify nums[i]\n            }\n        }\n        return cnt<=1;\n    }",
        "explanation": "This problem is like a greedy problem. When you find nums[i-1] > nums[i] for some i, you will prefer to change nums[i-1]'s value, since a larger nums[i] will give you more risks that you get inversion errors after position i. But, if you also find nums[i-2] > nums[i], then you have to change nums[i]'s value instead, or else you need to change both of nums[i-2]'s and nums[i-1]'s values."
    },
    {
        "question_id": "5fffdee6-ccef-466e-93a2-0cb7307d811f",
        "title": "Split Array With Same Average",
        "difficulty": "Hard",
        "category": "Array Math Dynamic Programming Bit Manipulation Bitmask",
        "question_text": "You are given an integer array nums.\n\nYou should move each element of nums into one of the two arrays A and B such that A and B are non-empty, and average(A) == average(B).\n\nReturn true if it is possible to achieve that and false otherwise.\n\nNote that for an array arr, average(arr) is the sum of all the elements of arr over the length of arr.\n\n \n\nExample 1:\n\nInput: nums = [1,2,3,4,5,6,7,8]\nOutput: true\nExplanation: We can split the array into [1,4,5,8] and [2,3,6,7], and both of them have an average of 4.5.\nExample 2:\n\nInput: nums = [3,1]\nOutput: false\n \n\nConstraints:\n\n1 <= nums.length <= 30\n0 <= nums[i] <= 104",
        "solution": "class Solution(object):\n    def splitArraySameAverage(self, A):\n        from fractions import Fraction\n        N = len(A)\n        S = sum(A)\n        A = [z - Fraction(S, N) for z in A]\n\n        if N == 1: return False\n\n        #Want zero subset sum\n        left = {A[0]}\n        for i in xrange(1, N/2):\n            left = {z + A[i] for z in left} | left | {A[i]}\n        if 0 in left: return True\n\n        right = {A[-1]}\n        for i in xrange(N/2, N-1):\n            right = {z + A[i] for z in right} | right | {A[i]}\n        if 0 in right: return True\n\n        sleft = sum(A[i] for i in xrange(N/2))\n        sright = sum(A[i] for i in xrange(N/2, N))\n\n        return any(-ha in right and (ha, -ha) != (sleft, sright) for ha in left)",
        "explanation": "Intuition and Algorithm\n\nFirst, let's get a sense of the condition that average(B) = average(C), where B, C are defined in the problem statement.\n\nSay A (the input array) has N elements which sum to S, and B (one of the splitting sets) has K elements which sum to X. Then the equation for average(B) = average(C) becomes  \nK\nX\n​\n = \nN−K\nS−X\n​\n . This reduces to X(N−K)=(S−X)K which is  \nK\nX\n​\n = \nN\nS\n​\n . That is, average(B) = average(A).\n\nNow, we could delete average(A) from each element A[i] without changing our choice for B. (A[i] -= mu, where mu = average(A)). This means we just want to choose a set B that sums to 0.\n\nTrying all 2 \nN\n  sets is still too many choices, so we will create sets of sums left, right of the approximately 2 \nN/2\n  choices on the left and on the right separately. (That is, left is a set of sums of every powerset in the first half of A, and right is the set of sums of every powerset in the second half of A). Then, it is true if we find 0 in these powersets, or if two sums in different halves cancel out (-x in right for x in left), except for one minor detail below.\n\nCare must be taken that we do not specify sets that would make the original B or C empty. If sleft = A[0] + A[1] + ... + A[N/2 - 1], and sright = A[N/2] + ... + A[N-1], (where A[i] was transformed to the new A[i] - average(A)) then we cannot choose both (sleft, sright). This is correct because if for example sleft was a sum reached by a strictly smaller powerset than {A[0], A[1], ..., A[N/2 - 1]}, then the difference between these sets would be non-empty and have sum 0.\nComplexity Analysis\n\nTime Complexity: O(2 N/2 ), where N is the length of A.\n\nSpace Complexity: O(2 N/2 )."
    },
    {
        "question_id": "cb60a672-8727-40fb-b49b-a3a153e87182",
        "title": "Maximum Unique Subarray Sum After Deletion",
        "difficulty": "Easy",
        "category": "Array Hash Table Greedy",
        "question_text": "You are given an integer array nums.\n\nYou are allowed to delete any number of elements from nums without making it empty. After performing the deletions, select a subarray of nums such that:\n\nAll elements in the subarray are unique.\nThe sum of the elements in the subarray is maximized.\nReturn the maximum sum of such a subarray.\n\n \n\nExample 1:\n\nInput: nums = [1,2,3,4,5]\n\nOutput: 15\n\nExplanation:\n\nSelect the entire array without deleting any element to obtain the maximum sum.\n\nExample 2:\n\nInput: nums = [1,1,0,1,1]\n\nOutput: 1\n\nExplanation:\n\nDelete the element nums[0] == 1, nums[1] == 1, nums[2] == 0, and nums[3] == 1. Select the entire array [1] to obtain the maximum sum.\n\nExample 3:\n\nInput: nums = [1,2,-1,-2,1,0,-1]\n\nOutput: 3\n\nExplanation:\n\nDelete the elements nums[2] == -1 and nums[3] == -2, and select the subarray [2, 1] from [1, 2, 1, 0, -1] to obtain the maximum sum.\n\n \n\nConstraints:\n\n1 <= nums.length <= 100\n-100 <= nums[i] <= 100",
        "solution": "class Solution {\npublic:\n    int maxSum(vector<int>& nums) {\n        int sum = 0;\n        set<int> st;\n        int mxNeg = INT_MIN;\n        for (int i = 0; i < nums.size(); i++) {\n            if (nums[i] > 0)\n                st.insert(nums[i]);\n            else\n                mxNeg = max(mxNeg, nums[i]);\n        }\n        for (auto val : st) {\n            sum += val;\n        }\n        if (st.size())\n            return sum;\n        else\n            return mxNeg;\n    }\n};",
        "explanation": "Intuition\nThe problem is asking for the maximum sum of a subarray with unique elements. We need to maximize the sum while ensuring that no duplicates are included in the subarray. This means we will need to track positive numbers and handle cases where no positive numbers exist.\n\nApproach\nTraverse through the array and store positive numbers in a set (which ensures uniqueness).\nKeep track of the maximum negative number in case there are no positive numbers.\nThe result will either be the sum of unique positive numbers or the largest negative number.\nComplexity\nTime complexity: (O(n))\nWe process each element of the array exactly once, either inserting it into a set or comparing it to the current maximum negative value.\n\nSpace complexity: (O(n))\nThe space is used by the set to store unique positive numbers, which may be up to (n) elements in the worst case."
    },
    {
        "question_id": "c5d24e1a-0ff0-4c81-9f34-05b2439b5e92",
        "title": "Max Points on a Line",
        "difficulty": "Hard",
        "category": "Array Hash Table Math Geometry",
        "question_text": "Given an array of points where points[i] = [xi, yi] represents a point on the X-Y plane, return the maximum number of points that lie on the same straight line.\nExample 1:\nInput: points = [[1,1],[2,2],[3,3]]\nOutput: 3\nExample 2:\nInput: points = [[1,1],[3,2],[5,3],[4,1],[2,3],[1,4]]\nOutput: 4\nConstraints:\n\n1 <= points.length <= 300\npoints[i].length == 2\n-104 <= xi, yi <= 104\nAll the points are unique.",
        "solution": "class Solution {\npublic:\n    int maxPoints(vector<vector<int>>& pt) {\n        int ans=1; \n        int n=pt.size();\n       // slope of every point with selected point\n        for(int i=0;i<n-1;i++){\n            map<double,int> mp;\n            for(int j=i+1;j<n;j++){\n                //calculating the slope\n                double x = (double)(pt[j][1]-pt[i][1])/(double)(pt[j][0]-pt[i][0]);\n                if(pt[j][1]-pt[i][1]<0 &&(pt[j][0]-pt[i][0])==0 ) //infinite slop for Perpendicular line\n                mp[abs(x)]++; \n                else\n               //storing the slop into map\n                    mp[x]++;\n            }\n            // same slope w.r.t.that selected point\n            int temp = 0;\n            for(auto it:mp)\n                temp = max(temp, it.second+1);    // +1 for the current point(point itself)\n            ans = max(temp, ans);\n        }\n        return ans;\n    }\n};",
        "explanation": "Intuition\nHere we will calculate the slope\nApproach\nIdea is very simple\n\nWe will select point and for every selected point we will calculate the slope wr.t to another point and store into the map\nIn map we will store <slope,that selected point>\nfor example we have point :-[[1,1],[2,2],[3,3]......\nwe pick point [1,1]and for that [1,1] we will calculate the slope\nw.r.t [2,2] ,[3,3]....... and store like this-\nfor understanding purpose i'm writing\nmp[slope1,[1,1]]\nmp[slope2,[1,1]]\nmp[slope1,[1,1]].........\nThis type we will store the slope for [2,2] , [3,3],....\nAter storing the slope into map we will calculate the max point for that slope\nFor example after storing the slope map can look like this\n[2/3,3]\n[INF,1]//for perpendicular case\n[1/3,2]...\nfind the max number of points having the same slope w.r.t. that selected point :-means which slope have maximum point\n:- here 2/3 have 3 point so our answer will be 3+1(we are adding that point as well)"
    },
    {
        "question_id": "7a15a0a1-23da-4914-996f-52d9168ab758",
        "title": "X of a Kind in a Deck of Cards",
        "difficulty": "Easy",
        "category": "Array Hash Table Math Counting Number Theory",
        "question_text": "You are given an integer array deck where deck[i] represents the number written on the ith card.\n\nPartition the cards into one or more groups such that:\n\nEach group has exactly x cards where x > 1, and\nAll the cards in one group have the same integer written on them.\nReturn true if such partition is possible, or false otherwise.\n\n \n\nExample 1:\n\nInput: deck = [1,2,3,4,4,3,2,1]\nOutput: true\nExplanation: Possible partition [1,1],[2,2],[3,3],[4,4].\nExample 2:\n\nInput: deck = [1,1,1,2,2,2,3,3]\nOutput: false\nExplanation: No possible partition.\n \n\nConstraints:\n\n1 <= deck.length <= 104\n0 <= deck[i] < 104",
        "solution": "class Solution(object):\n    def hasGroupsSizeX(self, deck):\n        from fractions import gcd\n        vals = collections.Counter(deck).values()\n        return reduce(gcd, vals) >= 2",
        "explanation": "Greatest Common Divisor\nIntuition and Algorithm\n\nAgain, say there are C_i cards of number i. These must be broken down into piles of X cards each, ie. C_i % X == 0 for all i.\n\nThus, X must divide the greatest common divisor of C_i. If this greatest common divisor g is greater than 1, then X = g will satisfy. Otherwise, it won't.\nComplexity Analysis\n\nTime Complexity: O(Nlog \n2\n N), where N is the number of votes. If there are C \ni\n​\n  cards with number i, then each gcd operation is naively O(log \n2\n C \ni\n​\n ). Better bounds exist, but are outside the scope of this article to develop.\n\nSpace Complexity: O(N)."
    },
    {
        "question_id": "effa6fd6-4f6a-4d5d-91a7-de295dd8fb7c",
        "title": "Longest Substring Without Repeating Characters",
        "difficulty": "Medium",
        "category": "Hash Table String Sliding Window",
        "question_text": "Given a string s, find the length of the longest substring without duplicate characters.\n\n \n\nExample 1:\n\nInput: s = \"abcabcbb\"\nOutput: 3\nExplanation: The answer is \"abc\", with the length of 3.\nExample 2:\n\nInput: s = \"bbbbb\"\nOutput: 1\nExplanation: The answer is \"b\", with the length of 1.\nExample 3:\n\nInput: s = \"pwwkew\"\nOutput: 3\nExplanation: The answer is \"wke\", with the length of 3.\nNotice that the answer must be a substring, \"pwke\" is a subsequence and not a substring.\n \n\nConstraints:\n\n0 <= s.length <= 5 * 104\ns consists of English letters, digits, symbols and spaces.",
        "solution": "class Solution {\npublic:\n    int lengthOfLongestSubstring(string s) {\n        int n = s.length();\n        int maxLength = 0;\n        unordered_set<char> charSet;\n        int left = 0;\n        \n        for (int right = 0; right < n; right++) {\n            if (charSet.count(s[right]) == 0) {\n                charSet.insert(s[right]);\n                maxLength = max(maxLength, right - left + 1);\n            } else {\n                while (charSet.count(s[right])) {\n                    charSet.erase(s[left]);\n                    left++;\n                }\n                charSet.insert(s[right]);\n            }\n        }\n        \n        return maxLength;\n    }\n};",
        "explanation": "Intuition\nThe intuition behind the 3 solutions is to iteratively find the longest substring without repeating characters by maintaining a sliding window approach. We use two pointers (left and right) to represent the boundaries of the current substring. As we iterate through the string, we update the pointers and adjust the window to accommodate new unique characters and eliminate repeating characters.\n\nApproach 1 - Set\nWe use a set (charSet) to keep track of unique characters in the current substring.\nWe maintain two pointers, left and right, to represent the boundaries of the current substring.\nThe maxLength variable keeps track of the length of the longest substring encountered so far.\nWe iterate through the string using the right pointer.\nIf the current character is not in the set (charSet), it means we have a new unique character.\nWe insert the character into the set and update the maxLength if necessary.\nIf the character is already present in the set, it indicates a repeating character within the current substring.\nIn this case, we move the left pointer forward, removing characters from the set until the repeating character is no longer present.\nWe insert the current character into the set and continue the iteration.\nFinally, we return the maxLength as the length of the longest substring without repeating characters."
    },
    {
        "question_id": "bcaf91f0-8bef-48e0-816e-9eeef44b8f73",
        "title": "String to Integer (atoi)",
        "difficulty": "Medium",
        "category": "String",
        "question_text": "Implement the myAtoi(string s) function, which converts a string to a 32-bit signed integer.\n\nThe algorithm for myAtoi(string s) is as follows:\n\nWhitespace: Ignore any leading whitespace (\" \").\nSignedness: Determine the sign by checking if the next character is '-' or '+', assuming positivity if neither present.\nConversion: Read the integer by skipping leading zeros until a non-digit character is encountered or the end of the string is reached. If no digits were read, then the result is 0.\nRounding: If the integer is out of the 32-bit signed integer range [-231, 231 - 1], then round the integer to remain in the range. Specifically, integers less than -231 should be rounded to -231, and integers greater than 231 - 1 should be rounded to 231 - 1.\nReturn the integer as the final result.\n\n \n\nExample 1:\n\nInput: s = \"42\"\n\nOutput: 42\n\nExplanation:\n\nThe underlined characters are what is read in and the caret is the current reader position.\nStep 1: \"42\" (no characters read because there is no leading whitespace)\n         ^\nStep 2: \"42\" (no characters read because there is neither a '-' nor '+')\n         ^\nStep 3: \"42\" (\"42\" is read in)\n           ^\nExample 2:\n\nInput: s = \" -042\"\n\nOutput: -42\n\nExplanation:\n\nStep 1: \"   -042\" (leading whitespace is read and ignored)\n            ^\nStep 2: \"   -042\" ('-' is read, so the result should be negative)\n             ^\nStep 3: \"   -042\" (\"042\" is read in, leading zeros ignored in the result)\n               ^\nExample 3:\n\nInput: s = \"1337c0d3\"\n\nOutput: 1337\n\nExplanation:\n\nStep 1: \"1337c0d3\" (no characters read because there is no leading whitespace)\n         ^\nStep 2: \"1337c0d3\" (no characters read because there is neither a '-' nor '+')\n         ^\nStep 3: \"1337c0d3\" (\"1337\" is read in; reading stops because the next character is a non-digit)\n             ^\nExample 4:\n\nInput: s = \"0-1\"\n\nOutput: 0\n\nExplanation:\n\nStep 1: \"0-1\" (no characters read because there is no leading whitespace)\n         ^\nStep 2: \"0-1\" (no characters read because there is neither a '-' nor '+')\n         ^\nStep 3: \"0-1\" (\"0\" is read in; reading stops because the next character is a non-digit)\n          ^\nExample 5:\n\nInput: s = \"words and 987\"\n\nOutput: 0\n\nExplanation:\n\nReading stops at the first non-digit character 'w'.\n\n \n\nConstraints:\n\n0 <= s.length <= 200\ns consists of English letters (lower-case and upper-case), digits (0-9), ' ', '+', '-', and '.'.",
        "solution": "#include <iostream>\n#include <string>\nusing namespace std;\n\nclass Solution {\npublic:\n    int myAtoi(string s) {\n        int i = 0, sign = 1;\n        long res = 0; // Using long to handle overflow cases\n\n        // Trim leading spaces\n        while (i < s.size() && s[i] == ' ') i++;\n        if (i == s.size()) return 0;\n\n        // Check for sign\n        if (s[i] == '-') { sign = -1; i++; }\n        else if (s[i] == '+') i++;\n\n        // Process numerical characters\n        while (i < s.size() && isdigit(s[i])) {\n            res = res * 10 + (s[i] - '0');\n\n            // Handle overflow\n            if (sign * res > INT_MAX) return INT_MAX;\n            if (sign * res < INT_MIN) return INT_MIN;\n\n            i++;\n        }\n\n        return (int)(sign * res);\n    }\n};",
        "explanation": "Intuition\nThe problem requires converting a given string into an integer while following specific rules. Key challenges include handling whitespace, signs (+ and -), non-numeric characters, and integer overflow.\n\nA simple string parsing approach can be used:\n\nIgnore leading whitespace.\nDetermine the sign (+ or -).\nConvert valid numeric characters to an integer.\nStop conversion when a non-numeric character appears.\nHandle integer overflow by capping the value at INT_MAX or INT_MIN.\nApproach\nTrim leading spaces using trim().\nCheck for sign at the beginning (+ or -).\nIterate through characters while they are numeric:\nConvert each character to a digit.\nMultiply the existing result by 10 and add the new digit.\nCheck for integer overflow conditions.\nReturn the final computed integer with the correct sign.\nThis approach ensures we efficiently extract and convert the number in O(n) time complexity.\n\nComplexity\nTime Complexity: O(n) (where n is the length of the string)\nSpace Complexity: O(1) (constant extra space used)"
    },
    {
        "question_id": "5b6a36eb-a3f6-4746-91a8-c2c6ed29ed07",
        "title": "Regular Expression Matching",
        "difficulty": "Hard",
        "category": "String Dynamic Programming Recursion",
        "question_text": "Given an input string s and a pattern p, implement regular expression matching with support for '.' and '*' where:\n\n'.' Matches any single character.​​​​\n'*' Matches zero or more of the preceding element.\nThe matching should cover the entire input string (not partial).\n\n \n\nExample 1:\n\nInput: s = \"aa\", p = \"a\"\nOutput: false\nExplanation: \"a\" does not match the entire string \"aa\".\nExample 2:\n\nInput: s = \"aa\", p = \"a*\"\nOutput: true\nExplanation: '*' means zero or more of the preceding element, 'a'. Therefore, by repeating 'a' once, it becomes \"aa\".\nExample 3:\n\nInput: s = \"ab\", p = \".*\"\nOutput: true\nExplanation: \".*\" means \"zero or more (*) of any character (.)\".\n \n\nConstraints:\n\n1 <= s.length <= 20\n1 <= p.length <= 20\ns contains only lowercase English letters.\np contains only lowercase English letters, '.', and '*'.\nIt is guaranteed for each appearance of the character '*', there will be a previous valid character to match.",
        "solution": "class Solution(object):\n    def isMatch(self, text: str, pattern: str) -> bool:\n        memo = {}\n\n        def dp(i: int, j: int) -> bool:\n            if (i, j) not in memo:\n                if j == len(pattern):\n                    ans = i == len(text)\n                else:\n                    first_match = i < len(text) and pattern[j] in {text[i], \".\"}\n                    if j + 1 < len(pattern) and pattern[j + 1] == \"*\":\n                        ans = dp(i, j + 2) or first_match and dp(i + 1, j)\n                    else:\n                        ans = first_match and dp(i + 1, j + 1)\n\n                memo[i, j] = ans\n            return memo[i, j]\n\n        return dp(0, 0)",
        "explanation": "Intuition\n\nAs the problem has an optimal substructure, it is natural to cache intermediate results. We ask the question dp(i, j): does text[i:] and pattern[j:] match? We can describe our answer in terms of answers to questions involving smaller strings.\n\nAlgorithm\n\nWe proceed with the same recursion as in Approach 1, except because calls will only ever be made to match(text[i:], pattern[j:]), we use dp(i, j) to handle those calls instead, saving us expensive string-building operations and allowing us to cache the intermediate results."
    },
    {
        "question_id": "85555f11-af97-4365-85e3-4dc8715405e4",
        "title": "Roman to Integer",
        "difficulty": "Easy",
        "category": "Hash Table Math String",
        "question_text": "Roman numerals are represented by seven different symbols: I, V, X, L, C, D and M.\n\nSymbol       Value\nI             1\nV             5\nX             10\nL             50\nC             100\nD             500\nM             1000\nFor example, 2 is written as II in Roman numeral, just two ones added together. 12 is written as XII, which is simply X + II. The number 27 is written as XXVII, which is XX + V + II.\n\nRoman numerals are usually written largest to smallest from left to right. However, the numeral for four is not IIII. Instead, the number four is written as IV. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as IX. There are six instances where subtraction is used:\n\nI can be placed before V (5) and X (10) to make 4 and 9. \nX can be placed before L (50) and C (100) to make 40 and 90. \nC can be placed before D (500) and M (1000) to make 400 and 900.\nGiven a roman numeral, convert it to an integer.\n\n \n\nExample 1:\n\nInput: s = \"III\"\nOutput: 3\nExplanation: III = 3.\nExample 2:\n\nInput: s = \"LVIII\"\nOutput: 58\nExplanation: L = 50, V= 5, III = 3.\nExample 3:\n\nInput: s = \"MCMXCIV\"\nOutput: 1994\nExplanation: M = 1000, CM = 900, XC = 90 and IV = 4.\n \n\nConstraints:\n\n1 <= s.length <= 15\ns contains only the characters ('I', 'V', 'X', 'L', 'C', 'D', 'M').\nIt is guaranteed that s is a valid roman numeral in the range [1, 3999].",
        "solution": "class Solution {\npublic:\n    int romanToInt(string s) {\n        int res = 0;\n        unordered_map<char, int> roman = {\n            {'I', 1},\n            {'V', 5},\n            {'X', 10}, \n            {'L', 50},\n            {'C', 100},\n            {'D', 500},\n            {'M', 1000}\n        };\n\n        for (int i = 0; i < s.size() - 1; i++) {\n            if (roman[s[i]] < roman[s[i + 1]]) {\n                res -= roman[s[i]];\n            } else {\n                res += roman[s[i]];\n            }\n        }\n\n        return res + roman[s[s.size() - 1]];        \n    }\n};",
        "explanation": "Approach\nThe description includes the example of 27. If the values are written from left to right in descending order, simply adding each number one by one will give the result.\n\nXXVII\n↓\n10(X) + 10(X) + 5(V) + 1(I) + 1(I) = 27\nLVIII\n↓\n50(L) + 5(V) + 1(I) + 1(I) + 1(I) = 58\nBut numbers like 4 and 9 are represented as a single number using two Roman numerals.\n\nIV = 4\nIX = 9\n Points\n\nBasically, you just need to convert either one or two characters into a number to get the answer.\n\nHow do we determine if it’s one or two characters?\nSince a single number can use up to two Roman characters, we loop through the string two characters at a time, shifting by one each time.\n\nLet’s take a look at this example.\n\nInput: s = \"XIV\"\nIn the first loop, we use X and I. In this case, the second character I is less than X. I is 1 and X is 10. That means we can simply add X to result variable, because 10 → 1 is a descending order. It's the same as 27 or 58 above.\n\nres = 10\nNext, we use I and V. In this case, the second character V is greater than I, because V is 5 and I is 1.\n\nThe description says \"there are six instances where subtraction is used.\"\n\nIV = 4\nIX = 9\nXL = 40\nXC = 90\nCD = 400\nCM = 900\nLook at all the first characters and the second characters. The first characters are less than the second characters.\n\nI(1) + V(5) = 4\nI(1) + X(10) = 9\nX(10) + L(50) = 40\nX(10) + C(100) = 90\nC(100) + D(500) = 400\nC(100) + M(1000) = 900\nThe current first character is I and the second character is V, so we are using two Roman characters to form a single number.\n\nIn this case, we subtract I(= 1) from result variable, because in the next loop, we will add V(= 5), so the total of I and V will be 4 in the end.\n\nres = 9\nThe next two number is V and nothing(= out of bounds), so we stop iteration.\n\nThe last point is that as I told you, we should add V before return the answer, because one of values was out of bounds, that's why we couldn't add the last Roman chartacter which is V.\n\nreturn res + 5\nBefore we start looping, we have HashMap to combine Roman and Integer, so that we can convert Roman to Integer easily.\n\nIn the solution code,\n\nreturn res + roman[s[-1]]\n\ns is input string\nroman is HashMap"
    },
    {
        "question_id": "9a9b9b8c-7fee-47c4-b970-5a888a40f529",
        "title": "Longest Common Prefix",
        "difficulty": "Easy",
        "category": "String Trie",
        "question_text": "Write a function to find the longest common prefix string amongst an array of strings.\n\nIf there is no common prefix, return an empty string \"\".\n\n \n\nExample 1:\n\nInput: strs = [\"flower\",\"flow\",\"flight\"]\nOutput: \"fl\"\nExample 2:\n\nInput: strs = [\"dog\",\"racecar\",\"car\"]\nOutput: \"\"\nExplanation: There is no common prefix among the input strings.\n \n\nConstraints:\n\n1 <= strs.length <= 200\n0 <= strs[i].length <= 200\nstrs[i] consists of only lowercase English letters if it is non-empty.",
        "solution": "class Solution {\npublic:\n    string longestCommonPrefix(vector<string>& strs) {\n        if (strs.empty()) return \"\";\n        return longestCommonPrefix(strs, 0, strs.size() - 1);\n    }\n\nprivate:\n    string longestCommonPrefix(vector<string>& strs, int l, int r) {\n        if (l == r) {\n            return strs[l];\n        } else {\n            int mid = (l + r) / 2;\n            string lcpLeft = longestCommonPrefix(strs, l, mid);\n            string lcpRight = longestCommonPrefix(strs, mid + 1, r);\n            return commonPrefix(lcpLeft, lcpRight);\n        }\n    }\n\n    string commonPrefix(string left, string right) {\n        int min = std::min(left.length(), right.length());\n        for (int i = 0; i < min; i++) {\n            if (left[i] != right[i]) return left.substr(0, i);\n        }\n        return left.substr(0, min);\n    }\n};",
        "explanation": "Divide and conquer\nIntuition\nThe idea of the algorithm comes from the associative property of LCP operation. We notice that :\nLCP(S 1 …S n )=LCP(LCP(S 1 …S k ),LCP(S k+1 …S n )), where LCP(​ …S n ) is the longest common prefix in set of strings [S 1 …S n ] ,1<k<n\nAlgorithm\nTo apply the observation above, we use divide and conquer technique, where we split the LCP(S \ni\n​\n …S \nj\n​\n ) problem into two subproblems LCP(S \ni\n​\n …S \nmid\n​\n ) and LCP(S \nmid+1\n​\n …S \nj\n​\n ), where mid is  \n2\ni+j\n​\n . We use their solutions lcpLeft and lcpRight to construct the solution of the main problem LCP(S \ni\n​\n …S \nj\n​\n ). To accomplish this we compare one by one the characters of lcpLeft and lcpRight till there is no character match. The found common prefix of lcpLeft and lcpRight is the solution of the LCP(S \ni\n​\n …S \nj\n​\n ).\n\n Complexity Analysis\nIn the worst case we have n equal strings with length m\n\nTime complexity : O(S), where S is the number of all characters in the array, S=m⋅n\nTime complexity is 2⋅T( \n2\nn\n​\n )+O(m). Therefore time complexity is O(S).\nIn the best case this algorithm performs O(minLen⋅n) comparisons, where minLen is the shortest string of the array\n\nSpace complexity : O(m⋅logn)\n\nThere is a memory overhead since we store recursive calls in the execution stack. There are logn recursive calls, each store need m space to store the result, so space complexity is O(m⋅logn)"
    },
    {
        "question_id": "4612d5a3-b44d-4345-9af3-40ac6d214dd6",
        "title": "Wildcard Matching",
        "difficulty": "Hard",
        "category": "String Dynamic Programming Greedy Recursion",
        "question_text": "Given an input string (s) and a pattern (p), implement wildcard pattern matching with support for '?' and '*' where:\n\n'?' Matches any single character.\n'*' Matches any sequence of characters (including the empty sequence).\nThe matching should cover the entire input string (not partial).\n\n \n\nExample 1:\n\nInput: s = \"aa\", p = \"a\"\nOutput: false\nExplanation: \"a\" does not match the entire string \"aa\".\nExample 2:\n\nInput: s = \"aa\", p = \"*\"\nOutput: true\nExplanation: '*' matches any sequence.\nExample 3:\n\nInput: s = \"cb\", p = \"?a\"\nOutput: false\nExplanation: '?' matches 'c', but the second letter is 'a', which does not match 'b'.\n \n\nConstraints:\n\n0 <= s.length, p.length <= 2000\ns contains only lowercase English letters.\np contains only lowercase English letters, '?' or '*'.",
        "solution": "bool isMatch(const char *s, const char *p) {\n        const char* star=NULL;\n        const char* ss=s;\n        while (*s){\n            //advancing both pointers when (both characters match) or ('?' found in pattern)\n            //note that *p will not advance beyond its length \n            if ((*p=='?')||(*p==*s)){s++;p++;continue;} \n\n            // * found in pattern, track index of *, only advancing pattern pointer \n            if (*p=='*'){star=p++; ss=s;continue;} \n\n            //current characters didn't match, last pattern pointer was *, current pattern pointer is not *\n            //only advancing pattern pointer\n            if (star){ p = star+1; s=++ss;continue;} \n\n           //current pattern pointer is not star, last patter pointer was not *\n           //characters do not match\n            return false;\n        }\n\n       //check for remaining characters in pattern\n        while (*p=='*'){p++;}\n\n        return !*p;  \n    }",
        "explanation": "The basic idea is to have one pointer for the string and one pointer for the pattern. This algorithm iterates at most length(string) + length(pattern) times, for each iteration, at least one pointer advance one step."
    },
    {
        "question_id": "9b7427e5-d04d-4606-ba13-e2b79456333a",
        "title": "Fraction to Recurring Decimal",
        "difficulty": "Medium",
        "category": "Hash Table Math String",
        "question_text": "Given two integers representing the numerator and denominator of a fraction, return the fraction in string format.\n\nIf the fractional part is repeating, enclose the repeating part in parentheses.\n\nIf multiple answers are possible, return any of them.\n\nIt is guaranteed that the length of the answer string is less than 104 for all the given inputs.\n\n \n\nExample 1:\n\nInput: numerator = 1, denominator = 2\nOutput: \"0.5\"\nExample 2:\n\nInput: numerator = 2, denominator = 1\nOutput: \"2\"\nExample 3:\n\nInput: numerator = 4, denominator = 333\nOutput: \"0.(012)\"\n \n\nConstraints:\n\n-231 <= numerator, denominator <= 231 - 1\ndenominator != 0",
        "solution": "public class Solution {\n    public String fractionToDecimal(int numerator, int denominator) {\n        if (numerator == 0) {\n            return \"0\";\n        }\n        StringBuilder res = new StringBuilder();\n        // \"+\" or \"-\"\n        res.append(((numerator > 0) ^ (denominator > 0)) ? \"-\" : \"\");\n        long num = Math.abs((long)numerator);\n        long den = Math.abs((long)denominator);\n        \n        // integral part\n        res.append(num / den);\n        num %= den;\n        if (num == 0) {\n            return res.toString();\n        }\n        \n        // fractional part\n        res.append(\".\");\n        HashMap<Long, Integer> map = new HashMap<Long, Integer>();\n        map.put(num, res.length());\n        while (num != 0) {\n            num *= 10;\n            res.append(num / den);\n            num %= den;\n            if (map.containsKey(num)) {\n                int index = map.get(num);\n                res.insert(index, \"(\");\n                res.append(\")\");\n                break;\n            }\n            else {\n                map.put(num, res.length());\n            }\n        }\n        return res.toString();\n    }\n}",
        "explanation": "The important thing is to consider all edge cases while thinking this problem through, including: negative integer, possible overflow, etc.\n\nUse HashMap to store a remainder and its associated index while doing the division so that whenever a same remainder comes up, we know there is a repeating fractional part."
    },
    {
        "question_id": "0cffb6fd-d7d8-406c-be67-ec6cf8bbecab",
        "title": "Basic Calculator",
        "difficulty": "Hard",
        "category": "Math String Stack Recursion",
        "question_text": "Given a string s representing a valid expression, implement a basic calculator to evaluate it, and return the result of the evaluation.\n\nNote: You are not allowed to use any built-in function which evaluates strings as mathematical expressions, such as eval().\n\n \n\nExample 1:\n\nInput: s = \"1 + 1\"\nOutput: 2\nExample 2:\n\nInput: s = \" 2-1 + 2 \"\nOutput: 3\nExample 3:\n\nInput: s = \"(1+(4+5+2)-3)+(6+8)\"\nOutput: 23\n \n\nConstraints:\n\n1 <= s.length <= 3 * 105\ns consists of digits, '+', '-', '(', ')', and ' '.\ns represents a valid expression.\n'+' is not used as a unary operation (i.e., \"+1\" and \"+(2 + 3)\" is invalid).\n'-' could be used as a unary operation (i.e., \"-1\" and \"-(2 + 3)\" is valid).\nThere will be no two consecutive operators in the input.\nEvery number and running calculation will fit in a signed 32-bit integer.",
        "solution": "public int calculate(String s) {\n    Stack<Integer> stack = new Stack<Integer>();\n    int result = 0;\n    int number = 0;\n    int sign = 1;\n    for(int i = 0; i < s.length(); i++){\n        char c = s.charAt(i);\n        if(Character.isDigit(c)){\n            number = 10 * number + (int)(c - '0');\n        }else if(c == '+'){\n            result += sign * number;\n            number = 0;\n            sign = 1;\n        }else if(c == '-'){\n            result += sign * number;\n            number = 0;\n            sign = -1;\n        }else if(c == '('){\n            //we push the result first, then sign;\n            stack.push(result);\n            stack.push(sign);\n            //reset the sign and result for the value in the parenthesis\n            sign = 1;   \n            result = 0;\n        }else if(c == ')'){\n            result += sign * number;  \n            number = 0;\n            result *= stack.pop();    //stack.pop() is the sign before the parenthesis\n            result += stack.pop();   //stack.pop() now is the result calculated before the parenthesis\n            \n        }\n    }\n    if(number != 0) result += sign * number;\n    return result;\n}",
        "explanation": "Simple iterative solution by identifying characters one by one. One important thing is that the input is valid, which means the parentheses are always paired and in order.\nOnly 5 possible input we need to pay attention:\n\ndigit: it should be one digit from the current number\n\n'+': number is over, we can add the previous number and start a new number\n\n'-': same as above\n\n'(': push the previous result and the sign into the stack, set result to 0, just calculate the new result within the parenthesis.\n\n')': pop out the top two numbers from stack, first one is the sign before this pair of parenthesis, second is the temporary result before this pair of parenthesis. We add them together.\n\nFinally if there is only one number, from the above solution, we haven't add the number to the result, so we do a check see if the number is zero."
    },
    {
        "question_id": "a46cfe35-3aa8-4876-b29c-e3b83ca9e6a7",
        "title": "Binary Tree Paths",
        "difficulty": "Easy",
        "category": "Math String Stack Recursion",
        "question_text": "Given the root of a binary tree, return all root-to-leaf paths in any order.\n\nA leaf is a node with no children.\n\n \n\nExample 1:\n\n\nInput: root = [1,2,3,null,5]\nOutput: [\"1->2->5\",\"1->3\"]\nExample 2:\n\nInput: root = [1]\nOutput: [\"1\"]\n \n\nConstraints:\n\nThe number of nodes in the tree is in the range [1, 100].\n-100 <= Node.val <= 100",
        "solution": "class Solution(object):\n    def binaryTreePaths(self, root):\n        res = []\n        if not root:\n            return res\n        stack = [(root, str(root.val))]\n        while stack:\n            node, path = stack.pop()\n            if not node.left and not node.right:\n                res.append(path)\n            if node.right:\n                stack.append((node.right, path + \"->\" + str(node.right.val)))\n            if node.left:\n                stack.append((node.left, path + \"->\" + str(node.left.val)))\n        return res",
        "explanation": "Intuition\nTo collect all root-to-leaf paths in a binary tree, we use DFS traversal. At every node, we build a path string. Once we reach a leaf, we save the full path.\nUse a stack to simulate DFS. At each step, track both the node and the current path string. When a leaf is reached, push the path to the result array. If children exist, extend the path and continue traversing.\n\nComplexity\nTime complexity: (O(n)), where (n) is the number of nodes.\nSpace complexity: (O(n)), for recursion stack or explicit stack and result storage."
    },
    {
        "question_id": "6ac240b7-38cd-4c39-a53a-613838ac801e",
        "title": "Reverse Vowels of a String",
        "difficulty": "Easy",
        "category": "Two Pointers String",
        "question_text": "Given a string s, reverse only all the vowels in the string and return it.\n\nThe vowels are 'a', 'e', 'i', 'o', and 'u', and they can appear in both lower and upper cases, more than once.\n\n \n\nExample 1:\n\nInput: s = \"IceCreAm\"\n\nOutput: \"AceCreIm\"\n\nExplanation:\n\nThe vowels in s are ['I', 'e', 'e', 'A']. On reversing the vowels, s becomes \"AceCreIm\".\n\nExample 2:\n\nInput: s = \"leetcode\"\n\nOutput: \"leotcede\"\n\n \n\nConstraints:\n\n1 <= s.length <= 3 * 105\ns consist of printable ASCII characters.",
        "solution": "class Solution {\npublic:\n    string reverseVowels(string s) {\n        // Convert the input string to a character array.\n        string word = s;\n        int start = 0;\n        int end = s.length() - 1;\n        string vowels = \"aeiouAEIOU\";\n        \n        // Loop until the start pointer is no longer less than the end pointer.\n        while (start < end) {\n            // Move the start pointer towards the end until it points to a vowel.\n            while (start < end && vowels.find(word[start]) == string::npos) {\n                start++;\n            }\n            \n            // Move the end pointer towards the start until it points to a vowel.\n            while (start < end && vowels.find(word[end]) == string::npos) {\n                end--;\n            }\n            \n            // Swap the vowels found at the start and end positions.\n            swap(word[start], word[end]);\n            \n            // Move the pointers towards each other for the next iteration.\n            start++;\n            end--;\n        }\n        \n        // Return the modified string.\n        return word;\n    }\n};",
        "explanation": "Intuition\nThe goal of the problem is to reverse the order of vowels in a given string while keeping the non-vowel characters in their original positions. To achieve this, we can use two pointers technique: one pointer starting from the beginning of the string and another starting from the end. We will move these pointers towards each other, swapping the vowels they point to until they meet in the middle of the string.\n\nApproach\nConvert the input string s to an array of characters word. This step is necessary because strings are immutable in Java, and we need to modify the vowels' positions.\n\nInitialize two pointers, start and end, to the first and last characters of the string, respectively.\n\nCreate a String variable vowels containing all the vowel characters (both lowercase and uppercase).\n\nUse a while loop to iterate until start is no longer less than end. This loop ensures that the pointers will not cross each other, and we process the characters in the middle of the string only once.\n\nInside the loop:\n\nMove the start pointer towards the end of the string until it points to a vowel character. We do this by using the indexOf method to find the index of the character in the vowels string. If the character is not a vowel, we keep moving the start pointer.\n\nSimilarly, move the end pointer towards the beginning of the string until it points to a vowel character. Again, we use the indexOf method to check if the character is a vowel and keep moving the end pointer if it is not.\n\nSwap the vowels found at the start and end positions in the word array.\n\nMove the start pointer one step ahead and the end pointer one step back to continue searching for more vowels.\n\nAfter the loop finishes, the word array will contain the string with the reversed vowels. Convert the character array back to a String and return the result.\n\nComplexity\nTime complexity:\nThe time complexity of this solution is O(n), where n is the length of the input string s. The two pointers start and end move towards each other, and each character is processed once.\n\nSpace complexity:\nThe space complexity of this solution is O(n) because we create a character array word to store the characters of the input string. The space used is proportional to the length of the input string. Other than that, we use a constant amount of extra space for the vowels string and a few integer variables, which doesn't depend on the input size."
    }
]