[
    {
        "question_id": "c7512fa1-85fb-4653-afad-95b73a1a31ee",
        "title": "Two Sum",
        "difficulty": "Easy",
        "category": "Array Hash Table",
        "question_text": "Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target.\n\nYou may assume that each input would have exactly one solution, and you may not use the same element twice.\n\nYou can return the answer in any order.\n\n \n\nExample 1:\n\nInput: nums = [2,7,11,15], target = 9\nOutput: [0,1]\nExplanation: Because nums[0] + nums[1] == 9, we return [0, 1].\nExample 2:\n\nInput: nums = [3,2,4], target = 6\nOutput: [1,2]\nExample 3:\n\nInput: nums = [3,3], target = 6\nOutput: [0,1]\n \n\nConstraints:\n\n2 <= nums.length <= 104\n-109 <= nums[i] <= 109\n-109 <= target <= 109\nOnly one valid answer exists.\n \n\nFollow-up: Can you come up with an algorithm that is less than O(n2) time complexity?",
        "solution": "class Solution {\npublic:\n    vector<int> twoSum(vector<int> &nums, int target) {\n        unordered_map<int, int> hash;\n        for (int i = 0; i < nums.size(); i++) {\n            hash[nums[i]] = i;\n        }\n        for (int i = 0; i < nums.size(); i++) {\n            int complement = target - nums[i];\n            if (hash.find(complement) != hash.end() && hash[complement] != i) {\n                return {i, hash[complement]};\n            }\n        }\n        // If no valid pair is found, return an empty vector\n        return {};\n    }\n};",
        "explanation": "Intuition\n\nTo improve our runtime complexity, we need a more efficient way to check if the complement exists in the array. If the complement exists, we need to get its index. What is the best way to maintain a mapping of each element in the array to its index? A hash table.\n\nWe can reduce the lookup time from O(n) to O(1) by trading space for speed. A hash table is well suited for this purpose because it supports fast lookup in near constant time. I say \"near\" because if a collision occurred, a lookup could degenerate to O(n) time. However, lookup in a hash table should be amortized O(1) time as long as the hash function was chosen carefully.\n\nAlgorithm\n\nA simple implementation uses two iterations. In the first iteration, we add each element's value as a key and its index as a value to the hash table. Then, in the second iteration, we check if each element's complement (target−nums[i]) exists in the hash table. If it does exist, we return current element's index and its complement's index. Beware that the complement must not be nums[i] itself!\nComplexity Analysis\n\nTime complexity: O(n).\nWe traverse the list containing n elements exactly twice. Since the hash table reduces the lookup time to O(1), the overall time complexity is O(n).\n\nSpace complexity: O(n).\nThe extra space required depends on the number of items stored in the hash table, which stores exactly n elements."
    },
    {
        "question_id": "8c240482-ae08-472f-b09e-73765133910a",
        "title": "Median of Two Sorted Arrays",
        "difficulty": "Hard",
        "category": "Array Binary Search Divide and Conquer",
        "question_text": "Given two sorted arrays nums1 and nums2 of size m and n respectively, return the median of the two sorted arrays.\n\nThe overall run time complexity should be O(log (m+n)).\n\n \n\nExample 1:\n\nInput: nums1 = [1,3], nums2 = [2]\nOutput: 2.00000\nExplanation: merged array = [1,2,3] and median is 2.\nExample 2:\n\nInput: nums1 = [1,2], nums2 = [3,4]\nOutput: 2.50000\nExplanation: merged array = [1,2,3,4] and median is (2 + 3) / 2 = 2.5.\n \n\nConstraints:\n\nnums1.length == m\nnums2.length == n\n0 <= m <= 1000\n0 <= n <= 1000\n1 <= m + n <= 2000\n-106 <= nums1[i], nums2[i] <= 106",
        "solution": "class Solution {\npublic:\n    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\n        if (nums1.size() > nums2.size()) {\n            return findMedianSortedArrays(nums2, nums1);\n        }\n\n        int m = nums1.size(), n = nums2.size();\n        int left = 0, right = m;\n\n        while (left <= right) {\n            int partitionA = (left + right) / 2;\n            int partitionB = (m + n + 1) / 2 - partitionA;\n\n            int maxLeftA = (partitionA == 0) ? INT_MIN : nums1[partitionA - 1];\n            int minRightA = (partitionA == m) ? INT_MAX : nums1[partitionA];\n            int maxLeftB = (partitionB == 0) ? INT_MIN : nums2[partitionB - 1];\n            int minRightB = (partitionB == n) ? INT_MAX : nums2[partitionB];\n\n            if (maxLeftA <= minRightB && maxLeftB <= minRightA) {\n                if ((m + n) % 2 == 0) {\n                    return (max(maxLeftA, maxLeftB) +\n                            min(minRightA, minRightB)) /\n                           2.0;\n                } else {\n                    return max(maxLeftA, maxLeftB);\n                }\n            } else if (maxLeftA > minRightB) {\n                right = partitionA - 1;\n            } else {\n                left = partitionA + 1;\n            }\n        }\n\n        return 0.0;\n    }\n};",
        "explanation": "Intuition\nRecall the previous approach where we perform a binary search over the 'merged' array consisting of nums1 and nums2, resulting in a time complexity of O(log(m⋅n)). We could further improve the algorithm by performing the binary search only on the smaller array of nums1 and nums2, thus the time complexity is reduced to O(log(min(m,n))).\n\nThe main idea is similar to approach 2, where we need to find a point of partition in both arrays such that the maximum of the smaller half is less than or equal to the minimum of the larger half.\n\nHowever, instead of partitioning over the merged arrays, we can only focus on partitioning the smaller array (let's call this array A). Suppose the partition index is partitionA, we specify that the smaller half contains (m + n + 1) / 2 elements, and we can use this feature to our advantage by directly making partitionB equal to (m + n + 1) / 2 - partitionA, thus the smaller halves of both arrays always contain a total of (m + n + 1) / 2 elements, as shown in the picture below.\n\nAlgorithm\nAssuming nums1 to be the smaller array (If nums2 is smaller, we can swap them). Let m, n represent the size of nums1 and nums2, respectively.\n\nDefine the search space for the partitioning index partitionA by setting boundaries as left = 0 and right = m.\n\nWhile left <= right holds, do the following.\n\nCompute the partition index of nums1 as partitionA = (left + right) / 2. Consequently, the partition index of nums2 is (m + n + 1) / 2 - partitionA.\n\nObtain the edge elements:\n\nDetermine the maximum value of the section A_left as maxLeftA = nums1[partitionA - 1]. If partitionA - 1 < 0, set it as maxLeftA = float(-inf).\nDetermine the minimum value of the section A_right as minRightA = nums1[partitionA]. If partitionA >= m, set it as minRightA = float(inf).\nDetermine the maximum value of the section B_left as maxLeftB = nums2[partitionB - 1]. If partitionB - 1 < 0, set it as maxLeftB = float(-inf).\nDetermine the maximum value of the section B_right as minRightB = nums2[partitionB]. If partitionB >= n, set it as minRightB = float(inf).\nCompare and recalculate: Compare maxLeftA with minRightB and maxLeftB with minRightA.\n\nIf maxLeftA > minRightB, it means the maxLeftA is too large to be in the smaller half, so we update right = partitionA - 1 to move to the left half of the search space.\nIf maxLeftB > minRightA, it means that we are too far on the left side for partitionA and we need to go to the right half of the search space by updating left = partitionA + 1.\nRepeat step 4.\n\nWhen both maxLeftA <= minRightB and maxLeftB <= minRightA are true:\n\nIf (m + n) % 2 = 0, the median value is the average of the maximum value of the smaller half and the minimum value of the larger half, given by answer = (max(maxLeftA, maxLeftB) + min(minRightA, minRightB)) / 2.\nOtherwise, the median value is the maximum value of the smaller half, given by answer = max(maxLeftA, maxLeftB)."
    },
    {
        "question_id": "c2445e51-f884-45f7-857f-d9016a97360c",
        "title": "Pascal's Triangle",
        "difficulty": "Easy",
        "category": "Array Dynamic Programming",
        "question_text": "Given an integer numRows, return the first numRows of Pascal's triangle.\n\nIn Pascal's triangle, each number is the sum of the two numbers directly above it as shown:\nExample 1:\n\nInput: numRows = 5\nOutput: [[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1]]\nExample 2:\n\nInput: numRows = 1\nOutput: [[1]]\n \n\nConstraints:\n\n1 <= numRows <= 30",
        "solution": "class Solution {\npublic:\n    vector<vector<int>> generate(int numRows) {\n        vector<vector<int>> result;\n        vector<int> prevRow;\n        \n        for (int i = 0; i < numRows; i++) {\n            vector<int> currentRow(i + 1, 1);\n            \n            for (int j = 1; j < i; j++) {\n                currentRow[j] = prevRow[j - 1] + prevRow[j];\n            }\n            \n            result.push_back(currentRow);\n            prevRow = currentRow;\n        }\n        \n        return result;\n    }\n};",
        "explanation": "Intuition: We can use a dynamic programming approach with a 1D array to generate Pascal's triangle row by row. Instead of maintaining a 2D array, we can use a single array to store the current row and update it as we iterate through the rows. This approach reduces space complexity.\nInitialize a 1D array to store the current row.\nIterate through numRows and update the array for each row.\ntime complexity of O(numRows^2)\nO(numRows) space"
    },
    {
        "question_id": "c80d62a2-af92-460b-affc-4ddf4d5c1d1c",
        "title": "Best Time to Buy and Sell Stock",
        "difficulty": "Easy",
        "category": "Array Dynamic Programming",
        "question_text": "You are given an array prices where prices[i] is the price of a given stock on the ith day.\n\nYou want to maximize your profit by choosing a single day to buy one stock and choosing a different day in the future to sell that stock.\n\nReturn the maximum profit you can achieve from this transaction. If you cannot achieve any profit, return 0.\n\n \n\nExample 1:\n\nInput: prices = [7,1,5,3,6,4]\nOutput: 5\nExplanation: Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5.\nNote that buying on day 2 and selling on day 1 is not allowed because you must buy before you sell.\nExample 2:\n\nInput: prices = [7,6,4,3,1]\nOutput: 0\nExplanation: In this case, no transactions are done and the max profit = 0.\n \n\nConstraints:\n\n1 <= prices.length <= 105\n0 <= prices[i] <= 104",
        "solution": "class Solution {\npublic:\n    int maxProfit(std::vector<int>& prices) {\n        int buy = prices[0];\n        int profit = 0;\n        for (int i = 1; i < prices.size(); i++) {\n            if (prices[i] < buy) {\n                buy = prices[i];\n            } else if (prices[i] - buy > profit) {\n                profit = prices[i] - buy;\n            }\n        }\n        return profit;\n    }\n};",
        "explanation": "Intuition\nThe problem aims to find the maximum profit that can be obtained by buying and selling a stock. The given solution seems to follow a simple approach of iterating through the prices, keeping track of the minimum buying price, and updating the profit whenever a higher selling price is encountered.\nApproach\nInitialize variables buy with the first element of the prices array and profit as 0.\nIterate through the prices starting from the second element.\nUpdate the buy variable if the current price is lower than the current buying price.\nUpdate the profit if the difference between the current price and the buying price is greater than the current profit.\nReturn the final profit.\nKadane's Algorithm\nKadane's Algorithm is a dynamic programming technique used to find the maximum subarray sum in an array of numbers. The algorithm maintains two variables: max_current represents the maximum sum ending at the current position, and max_global represents the maximum subarray sum encountered so far. At each iteration, it updates max_current to include the current element or start a new subarray if the current element is larger than the accumulated sum. The max_global is updated if max_current surpasses its value.\n\nRelating with the Approach\nIn the provided approach for finding the maximum profit in stock prices, the algorithm can be seen as a variation of Kadane's Algorithm. Instead of finding the maximum subarray sum directly, it focuses on finding the maximum positive difference between consecutive elements (prices) in the array.\n\nHere's how the approach relates to Kadane's Algorithm:\n\nInitialization:\n\nIn Kadane's Algorithm, max_current and max_global are initialized to the first element of the array.\nIn the stock profit approach, buy is initialized with the first element of the prices array, and profit is initialized to 0.\nIteration:\n\nKadane's Algorithm iterates through the array, updating max_current based on the current element's value and deciding whether to start a new subarray.\nThe stock profit approach iterates through the prices array, updating buy when a lower price is encountered and treating the difference between the current price and buy as a potential profit.\nComparison and Update:\n\nKadane's Algorithm compares and updates max_current and max_global at each iteration.\nThe stock profit approach compares and updates profit whenever a positive difference between the current price and buy exceeds the current profit.\nComplexity\nTime complexity: O(n), where n is the length of the prices array. The algorithm iterates through the array once.\nSpace complexity: O(1), as only a constant amount of extra space is used."
    },
    {
        "question_id": "a6e75f42-0cfb-4b52-baef-4f3b8356f888",
        "title": "Best Time to Buy and Sell Stock III",
        "difficulty": "Hard",
        "category": "Array Dynamic Programming",
        "question_text": "You are given an array prices where prices[i] is the price of a given stock on the ith day.\n\nFind the maximum profit you can achieve. You may complete at most two transactions.\n\nNote: You may not engage in multiple transactions simultaneously (i.e., you must sell the stock before you buy again).\n\n \n\nExample 1:\n\nInput: prices = [3,3,5,0,0,3,1,4]\nOutput: 6\nExplanation: Buy on day 4 (price = 0) and sell on day 6 (price = 3), profit = 3-0 = 3.\nThen buy on day 7 (price = 1) and sell on day 8 (price = 4), profit = 4-1 = 3.\nExample 2:\n\nInput: prices = [1,2,3,4,5]\nOutput: 4\nExplanation: Buy on day 1 (price = 1) and sell on day 5 (price = 5), profit = 5-1 = 4.\nNote that you cannot buy on day 1, buy on day 2 and sell them later, as you are engaging multiple transactions at the same time. You must sell before buying again.\nExample 3:\n\nInput: prices = [7,6,4,3,1]\nOutput: 0\nExplanation: In this case, no transaction is done, i.e. max profit = 0.\n \n\nConstraints:\n\n1 <= prices.length <= 105\n0 <= prices[i] <= 105",
        "solution": "public int MaxProfitDpCompactFinal(int[] prices)  {\n            int buy1 = int.MaxValue, buy2 = int.MaxValue;\n            int sell1 = 0, sell2 = 0;\n\n            for (int i = 0; i < prices.Length; i++) {\n                buy1 = Math.Min(buy1, prices[i]);\n                sell1 = Math.Max(sell1, prices[i] - buy1);\n                buy2 = Math.Min(buy2, prices[i] - sell1);\n                sell2 = Math.Max(sell2, prices[i] - buy2);\n            }\n\n            return sell2;\n        }",
        "explanation": "It's not difficult to get the DP recursive formula:\n\ndp[k, i] = max(dp[k, i-1], prices[i] - prices[j] + dp[k-1, j-1]), j=[0..i-1]\nFor k transactions, on i-th day,\nif we don't trade then the profit is same as previous day dp[k, i-1];\nand if we bought the share on j-th day where j=[0..i-1], then sell the share on i-th day then the profit is prices[i] - prices[j] + dp[k-1, j-1] .\nActually j can be i as well. When j is i, the one more extra item prices[i] - prices[j] + dp[k-1, j] = dp[k-1, i] looks like we just lose one chance of transaction.\n\nI see someone else use the formula dp[k, i] = max(dp[k, i-1], prices[i] - prices[j] + dp[k-1, j]), where the last one is dp[k-1, j] instead of dp[k-1, j-1]. It's not the direct sense, as if the share was bought on j-th day, then the total profit of previous transactions should be done on (j-1)th day. However, the result based on that formula is also correct, because if the share was sold on j-th day and then bought again, it is the same if we didn't trade on that day.\n\nSo the straigtforward implementation is:"
    },
    {
        "question_id": "2b0ec068-f123-4ca5-b6df-ae11b28d59b7",
        "title": "Contains Duplicate III",
        "difficulty": "Hard",
        "category": "Array Sliding Window Sorting Bucket Sort Ordered Set",
        "question_text": "You are given an integer array nums and two integers indexDiff and valueDiff.\n\nFind a pair of indices (i, j) such that:\n\ni != j,\nabs(i - j) <= indexDiff.\nabs(nums[i] - nums[j]) <= valueDiff, and\nReturn true if such pair exists or false otherwise.\n\n \n\nExample 1:\n\nInput: nums = [1,2,3,1], indexDiff = 3, valueDiff = 0\nOutput: true\nExplanation: We can choose (i, j) = (0, 3).\nWe satisfy the three conditions:\ni != j --> 0 != 3\nabs(i - j) <= indexDiff --> abs(0 - 3) <= 3\nabs(nums[i] - nums[j]) <= valueDiff --> abs(1 - 1) <= 0\nExample 2:\n\nInput: nums = [1,5,9,1,5,9], indexDiff = 2, valueDiff = 3\nOutput: false\nExplanation: After trying all the possible pairs (i, j), we cannot satisfy the three conditions, so we return false.\n \n\nConstraints:\n\n2 <= nums.length <= 105\n-109 <= nums[i] <= 109\n1 <= indexDiff <= nums.length\n0 <= valueDiff <= 109",
        "solution": "class Solution {\npublic:\n    bool containsNearbyAlmostDuplicate(vector<int>& nums, int k, int t) {\n        int n = nums.size();\n        \n        if(n == 0 || k < 0  || t < 0) return false;\n        \n        unordered_map<int,int> buckets;\n        \n        for(int i=0; i<n; ++i) {\n            int bucket = nums[i] / ((long)t + 1);\n            \n\t\t\t// For negative numbers, we need to decrement bucket by 1\n\t\t\t// to ensure floor division.\n\t\t\t// For example, -1/2 = 0 but -1 should be put in Bucket[-1].\n\t\t\t// Therefore, decrement by 1.\n            if(nums[i] < 0) --bucket;\n            \n            if(buckets.find(bucket) != buckets.end()) return true;\n            else {\n                buckets[bucket] = nums[i];\n                if(buckets.find(bucket-1) != buckets.end() && (long) nums[i] - buckets[bucket-1] <= t) return true;\n                if(buckets.find(bucket+1) != buckets.end() && (long) buckets[bucket+1] - nums[i] <= t) return true;\n                \n                if(buckets.size() > k) {\n                    int key_to_remove = nums[i-k] / ((long)t + 1);\n                    \n                    if(nums[i-k] < 0) --key_to_remove;\n                    \n                    buckets.erase(key_to_remove);\n                }\n            }\n        }\n        \n        return false;\n    }\n};",
        "explanation": "We use the concept of sliding window and buckets together to achieve an optimal solution with O(N) time complexity.\n\nSliding window ensures only those indices are considered whose the absolute difference is at most k. We only consider k indices at a time. This fulfills the second condition.\n\nBuckets are used to ensure that the absolute difference between two numbers is at most t. Let's take a deeper look at them.\nWe (floor) divide each number by t+1 and put it in a bucket with key as the quotient.\nFor example,\n\n[1,5,2,4,3,9,1,5,9], k = 2, t = 3\n\n1 // (3+1) = 0\n5 // (3+1) = 1\n2 // (3+1) = 0\n4 // (3+1) = 1\n3 // (3+1) = 0\n9 // (3+1) = 2\n\nHere, Bucket[0] will contain numbers 0,1,2,3.\nBucket[1] will contain numbers 4,5,6,7.\nBucket[2] will contain numbers 8,9,10,11.\n\nOn observing carefully, we can see that the absolute difference\nbetween any two numbers in any bucket is at most t, which is what we want.\n\nAlso, there can be a case where the neighbouring bucket has some number\nwhose absolute difference with a number in the current bucket is at most t.\nFor instance, 2 lies in Bucket[0] and 4 lies in Bucket[1] and 4 - 2 = 2 < 3 (=t).\nThis can only happen in neighbouring buckets. Therefore, we need to check for this too."
    },
    {
        "question_id": "4469c2bc-41d2-4fd6-a33f-7d2cc51464af",
        "title": "H-Index II",
        "difficulty": "Medium",
        "category": "Array Binary Search",
        "question_text": "Given an array of integers citations where citations[i] is the number of citations a researcher received for their ith paper and citations is sorted in non-descending order, return the researcher's h-index.\n\nAccording to the definition of h-index on Wikipedia: The h-index is defined as the maximum value of h such that the given researcher has published at least h papers that have each been cited at least h times.\n\nYou must write an algorithm that runs in logarithmic time.\n\n \n\nExample 1:\n\nInput: citations = [0,1,3,5,6]\nOutput: 3\nExplanation: [0,1,3,5,6] means the researcher has 5 papers in total and each of them had received 0, 1, 3, 5, 6 citations respectively.\nSince the researcher has 3 papers with at least 3 citations each and the remaining two with no more than 3 citations each, their h-index is 3.\nExample 2:\n\nInput: citations = [1,2,100]\nOutput: 2\n \n\nConstraints:\n\nn == citations.length\n1 <= n <= 105\n0 <= citations[i] <= 1000\ncitations is sorted in ascending order.",
        "solution": "class Solution(object):\n    def hIndex(self, citations):\n        \"\"\"\n        :type citations: List[int]\n        :rtype: int\n        \"\"\"\n        n = len(citations)\n        l = 0\n        r = n\n        while l < r:\n            m = (l + r + 1) // 2\n            [l, r] = [m, r] if citations[n - m] >= m else [l, m - 1]\n        return l",
        "explanation": "Intuition\nTo efficiently determine the H-index, we can leverage binary search on a sorted list of citations. Instead of scanning linearly, we repeatedly narrow down the range by checking how many papers have at least h citations using a binary condition.\n\nSort the citations array.\nApply binary search on the potential H-index values (h) from 0 to n.\nFor a given mid-value m, check if there are at least m papers with m or more citations.\nAdjust the search range based on this condition.\nReturn the maximum m that satisfies the condition.\nComplexity\nTime Complexity:\n\n( O(\\log n) ) for binary search, each with a constant-time check.\n( O(n \\log n) ) overall because of sorting.\nSpace Complexity:\n\n( O(1) ) — constant space for pointers."
    },
    {
        "question_id": "faf01567-c8c3-4b2a-88d5-d844ba9170a4",
        "title": "Super Ugly Number",
        "difficulty": "Medium",
        "category": "Array Math Dynamic Programming",
        "question_text": "A super ugly number is a positive integer whose prime factors are in the array primes.\n\nGiven an integer n and an array of integers primes, return the nth super ugly number.\n\nThe nth super ugly number is guaranteed to fit in a 32-bit signed integer.\n\n \n\nExample 1:\n\nInput: n = 12, primes = [2,7,13,19]\nOutput: 32\nExplanation: [1,2,4,7,8,13,14,16,19,26,28,32] is the sequence of the first 12 super ugly numbers given primes = [2,7,13,19].\nExample 2:\n\nInput: n = 1, primes = [2,3,5]\nOutput: 1\nExplanation: 1 has no prime factors, therefore all of its prime factors are in the array primes = [2,3,5].\n \n\nConstraints:\n\n1 <= n <= 105\n1 <= primes.length <= 100\n2 <= primes[i] <= 1000\nprimes[i] is guaranteed to be a prime number.\nAll the values of primes are unique and sorted in ascending order.",
        "solution": "class Solution {\n    public int nthSuperUglyNumber(int n, int[] primes) {\n        PriorityQueue<int[]> queue=new PriorityQueue<>((a,b)->(a[0]-b[0]));\n        for (int i=0;i<primes.length;i++)\n            queue.offer(new int[]{primes[i], primes[i], 0});\n\n        int[] nums=new int[n+1];\n        nums[0]=1;\n        \n        int i=1;\n        while (i<n){\n            int[] entry=queue.poll();\n            int num=entry[0], prime=entry[1], index=entry[2];\n\t\t\t// remove duplicate\n            if (num!=nums[i-1]){\n                nums[i]=num;\n                i++;\n            }\n            queue.offer(new int[]{prime*nums[index+1], prime, index+1});\n        }\n        return nums[n-1];\n    }\n}",
        "explanation": "It is actually like how we merge k sorted list:\n\nugly number                       k sorted list\n    1                            2     7    13   19     1 * [2,7,13,19]\n    |                            |     |    |    |\n    2                            4     14   26   38     2 * [2,7,13,19]\n    |                            |     |    |    |\n    4                            8     28   52   76     4 * [2,7,13,19]\n    |                            |     |    |    |              \n    7                            14    49   91   133    7 * [2,7,13,19]\n    |                            |     |    |    |\n    8                            16    56   ...   ...   8 * [2,7,13,19]\n    |                            |     |    |     |\n    .                            .     .     .    .\n    .                            .     .     .    .\n    .                            .     .     .    .\nWe can see that each prime number in primes[] form a sorted list, and now our job is to merge them and find the nth minimum.\n\nHere we don't have the next pointer for each node to trace the next potential candidate. But as we can see in the graph, we can make use of the ugly number we have produced so far!\nHere, each entry has three parts: {num, prime, index}, num represents the value of the node, prime means which sorted list this node is in, and index tells us how far we have gone in that list, it works like the next pointer in linkedlist, help us find the next node in that sorted list.\n\nTime: O(nlogk)\nSpace: O(n+k)"
    },
    {
        "question_id": "6fd13fe3-bfc9-4d99-87fe-b92dabbf33c2",
        "title": "Create Maximum Number",
        "difficulty": "Hard",
        "category": "Array Two Pointers Stack Greedy Monotonic Stack",
        "question_text": "You are given two integer arrays nums1 and nums2 of lengths m and n respectively. nums1 and nums2 represent the digits of two numbers. You are also given an integer k.\n\nCreate the maximum number of length k <= m + n from digits of the two numbers. The relative order of the digits from the same array must be preserved.\n\nReturn an array of the k digits representing the answer.\n\n \n\nExample 1:\n\nInput: nums1 = [3,4,6,5], nums2 = [9,1,2,5,8,3], k = 5\nOutput: [9,8,6,5,3]\nExample 2:\n\nInput: nums1 = [6,7], nums2 = [6,0,4], k = 5\nOutput: [6,7,6,0,4]\nExample 3:\n\nInput: nums1 = [3,9], nums2 = [8,9], k = 3\nOutput: [9,8,9]\n \n\nConstraints:\n\nm == nums1.length\nn == nums2.length\n1 <= m, n <= 500\n0 <= nums1[i], nums2[i] <= 9\n1 <= k <= m + n\nnums1 and nums2 do not have leading zeros.",
        "solution": "class Solution {\npublic:\n    #define MIN(a,b) (a<b?a:b)\n    #define MAX(a,b) (a>b?a:b)\n    // create max number of length t from single non-empty vector\n    void getMax(int* num, int& len, int* result, int& t, int& sortedLen)\n    {\n    \tint n, top = 0;\n    \tresult[0] = num[0];\n    \tconst int need2drop = len - t;\n    \tfor (int i = 1; i < len; ++i){\n    \t\tn = num[i];\n    \t\twhile (top >= 0 && result[top] < n && (i - top) <= need2drop) --top; // i - top means already dropped i - top numbers\n    \t\tif (i - top > need2drop){\n    \t\t\tsortedLen = MAX(1,top);\n    \t\t\twhile (++top < t) result[top] = num[i++];\n    \t\t\treturn;\n    \t\t}\n    \t\tif (++top < t) result[top] = n;\n    \t\telse top = t - 1;\n    \t}\n    }\n    // create max number of different length from single vector\n    void dp(int *num, int len, int&sortedLen, int& minL, int& maxL, int *res, int &k){\n    \tint  j, *head, *prevhead = res;\n    \tconst int soi = sizeof(int);\n    \tgetMax(num, len, res, maxL,sortedLen);\n    \tfor (int l = maxL; l > MAX(minL,1); --l){\n    \t\thead = prevhead + k;\n    \t\tmemcpy(head, prevhead, l*soi);\n    \t\tfor (j = sortedLen; j < l; ++j){\n    \t\t\tif (head[j] > head[j - 1]){\n    \t\t\t\tsortedLen = MAX(1, j - 1);\n    \t\t\t\tmemcpy(head + j - 1, prevhead + j, soi*(l - j));\n    \t\t\t\tbreak;\n    \t\t\t}\n    \t\t}\n    \t\tif (j == l) sortedLen = l;\n    \t\tprevhead = head;\n    \t}\n    }\n    // merge max number created from single vector\n    void merge(int* num1,int len1,int* num2,int len2,int* result,int& resSize){\n    \tint i = 0, j = 0, k = 0;\n    \twhile (i < resSize){\n    \t\tif (j < len1 && k < len2){\n    \t\t\tif (num1[j] > num2[k])\n    \t\t\t\tresult[i++] = num1[j++];\n    \t\t\telse if (num1[j] < num2[k])\n    \t\t\t\tresult[i++] = num2[k++];\n    \t\t\telse{\n    \t\t\t\tint remaining1 = len1 - j, remaining2 = len2 - k, tmp = num1[j];\n    \t\t\t\tint flag = memcmp(num1 + j, num2 + k, sizeof(int) * MIN(remaining1, remaining2));\n    \t\t\t\tflag = (flag == 0 ? (remaining1>remaining2 ? 1 : -1) : flag);\n    \t\t\t\tint * num = flag > 0 ? num1 : num2;\n    \t\t\t\tint & cnt = flag > 0 ? j : k;\n    \t\t\t\tint len = flag > 0 ? len1 : len2;\n    \t\t\t\twhile (num[cnt]==tmp && cnt < len && i<resSize) result[i++] = num[cnt++];\n    \t\t\t}\n    \t\t}\n    \t\telse if (j < len1) result[i++] = num1[j++];\n    \t\telse result[i++] = num2[k++];\n    \t}\n    }\n    \n    vector<int> maxNumber(vector<int>& nums1, vector<int>& nums2, int k){\n    \tint soi = sizeof(int), len1 = nums1.size(), len2 = nums2.size(), step = k*soi;\n    \tint minL1 = MAX(0, k - len2), maxL1 = MIN(k, len1), minL2 = k - maxL1, maxL2 = k - minL1, range = maxL1 - minL1 + 1;\n    \tint * res = new int[range * k * 2 + 2 * k], *dp1 = res + k, *dp2 = res + range*k+k, *tmp=res+range*2*k+k;\n    \tmemset(res, 0, step);\n    \tint sortedLen1 = 1, sortedLen2 = 1;\n    \tif (len1 == 0 && len2 > 0) getMax(&nums2[0], len2, res, k, sortedLen2);\n    \telse if (len1 > 0 && len2 == 0) getMax(&nums1[0], len1, res, k, sortedLen2);\n    \telse if (len1 > 0 && len2 > 0){\n    \t\tdp(&nums1[0], len1, sortedLen1, minL1, maxL1, dp1,k);\n    \t\tdp(&nums2[0], len2, sortedLen2, minL2, maxL2, dp2,k);\n    \t\tif (sortedLen1 + sortedLen2 > k){\n    \t\t\tmerge(dp1 + k*(maxL1 - sortedLen1), sortedLen1, dp2 + k*(maxL2 - sortedLen2), sortedLen2, tmp, k);\n    \t\t\tvector<int> resv(tmp, tmp + k);\n    \t\t\tdelete[] res;\n    \t\t\treturn resv;\n    \t\t}\n    \t\tfor (int i = minL1; i <= maxL1; ++i){\n    \t\t\tmerge(dp1+k*(maxL1-i), i, dp2+k*(maxL2-k+i), (k-i), tmp,k);\n    \t\t\tif (memcmp(res, tmp, step) < 0) memcpy(res, tmp, step);\n    \t\t}\n    \t}\n    \tvector<int> resv(res, res + k);\n    \tdelete[] res;\n    \treturn resv;\n    }\n};",
        "explanation": "The basic idea:\n\nTo create max number of length k from two arrays, you need to create max number of length i from array one and max number of length k-i from array two, then combine them together. After trying all possible i, you will get the max number created from two arrays.\n\nOptimization:\n\nSuppose nums1 = [3, 4, 6, 5], nums2 = [9, 1, 2, 5, 8, 3], the maximum number you can create from nums1 is [6, 5] with length 2. For nums2, it's [9, 8, 3] with length 3. Merging the two sequence, we have [9, 8, 6, 5, 3], which is the max number we can create from two arrays without length constraint. If the required length k<=5, we can simply trim the result to required length from front. For instance, if k=3, then [9, 8, 6] is the result.\n\nSuppose we need to create max number with length 2 from num = [4, 5, 3, 2, 1, 6, 0, 8]. The simple way is to use a stack, first we push 4 and have stack [4], then comes 5 > 4, we pop 4 and push 5, stack becomes [5], 3 < 5, we push 3, stack becomes [5, 3]. Now we have the required length 2, but we need to keep going through the array in case a larger number comes, 2 < 3, we discard it instead of pushing it because the stack already grows to required size 2. 1 < 3, we discard it. 6 > 3, we pop 3, since 6 > 5 and there are still elements left, we can continue to pop 5 and push 6, the stack becomes [6], since 0 < 6, we push 0, the stack becomes [6, 0], the stack grows to required length again. Since 8 > 0, we pop 0, although 8 > 6, we can't continue to pop 6 since there is only one number, which is 8, left, if we pop 6 and push 8, we can't get to length 2, so we push 8 directly, the stack becomes [6, 8].\n\nIn the basic idea, we mentioned trying all possible length i. If we create max number for different i from scratch each time, that would be a waste of time. Suppose num = [4, 9, 3, 2, 1, 8, 7, 6], we need to create max number with length from 1 to 8. For i==8, result is the original array. For i==7, we need to drop 1 number from array, since 9 > 4, we drop 4, the result is [9, 3, 2, 1, 8, 7, 6]. For i==6, we need to drop 1 more number, 3 < 9, skip, 2 < 3, skip, 1 < 2, skip, 8 > 1, we drop 1, the result is [9, 3, 2, 8, 7, 6]. For i==5, we need to drop 1 more, but this time, we needn't check from beginning, during last scan, we already know [9, 3, 2] is monotonically non-increasing, so we check 8 directly, since 8 > 2, we drop 2, the result is [9, 3, 8, 7, 6]. For i==4, we start with 8, 8 > 3, we drop 3, the result is [9, 8, 7, 6]. For i==3, we start with 8, 8 < 9, skip, 7 < 8, skip, 6 < 7, skip, by now, we've got maximum number we can create from num without length constraint. So from now on, we can drop a number from the end each time. The result is [9, 8, 7], For i==2, we drop last number 7 and have [9, 8]. For i==1, we drop last number 8 and have [9]."
    },
    {
        "question_id": "aee3702f-6d92-4ddb-a790-b4d793189a86",
        "title": "Coin Change",
        "difficulty": "Medium",
        "category": "Array Two Pointers Stack Greedy Monotonic Stack",
        "question_text": "You are given an integer array coins representing coins of different denominations and an integer amount representing a total amount of money.\n\nReturn the fewest number of coins that you need to make up that amount. If that amount of money cannot be made up by any combination of the coins, return -1.\n\nYou may assume that you have an infinite number of each kind of coin.\n\n \n\nExample 1:\n\nInput: coins = [1,2,5], amount = 11\nOutput: 3\nExplanation: 11 = 5 + 5 + 1\nExample 2:\n\nInput: coins = [2], amount = 3\nOutput: -1\nExample 3:\n\nInput: coins = [1], amount = 0\nOutput: 0\n \n\nConstraints:\n\n1 <= coins.length <= 12\n1 <= coins[i] <= 231 - 1\n0 <= amount <= 104",
        "solution": "class Solution {\npublic:\n    int coinChange(vector<int>& coins, int amount) {\n        vector<int> minCoins(amount + 1, amount + 1);\n        minCoins[0] = 0;\n\n        for (int i = 1; i <= amount; i++) {\n            for (int j = 0; j < coins.size(); j++) {\n                if (i - coins[j] >= 0) {\n                    minCoins[i] = min(minCoins[i], 1 + minCoins[i - coins[j]]);\n                }\n            }\n        }\n\n        return minCoins[amount] != amount + 1 ? minCoins[amount] : -1;        \n    }\n};",
        "explanation": "Step by Step Algorithm\nInitialize min_coins array:\nCreate an array min_coins of length amount + 1, initialized with each element set to amount + 1.\nSet min_coins[0] to 0, as it takes zero coins to make up an amount of zero.\nmin_coins = [amount + 1] * (amount + 1)\nmin_coins[0] = 0\nIterate over each amount:\nStart a loop from 1 to amount (inclusive) to represent each amount from 1 to amount.\nFor each amount i, iterate over each coin denomination c in the coins list.\nfor i in range(1, amount + 1):\n    for c in coins:\nCalculate the minimum number of coins:\nCheck if the current amount i minus the coin denomination c is greater than or equal to 0.\nIf it is, update min_coins[i] to the minimum of its current value and 1 + min_coins[i - c].\n1 + min_coins[i - c] represents taking one coin of denomination c and the minimum number of coins required to make up the remaining amount i - c.\nif i - c >= 0:\n    min_coins[i] = min(min_coins[i], 1 + min_coins[i - c])\nReturn the result:\nAfter updating min_coins for all amounts from 1 to amount, return min_coins[-1] if it's not equal to amount + 1.\nIf min_coins[-1] is still amount + 1, it means the amount cannot be made up by any combination of coins, so return -1.\nreturn min_coins[-1] if min_coins[-1] != amount + 1 else -1\nThis algorithm uses dynamic programming to compute the minimum number of coins required to make up each amount from 1 to amount, ultimately providing the minimum number of coins required to make up the total amount."
    },
    {
        "question_id": "2970c755-4961-48be-b229-7f9c6f572b6e",
        "title": "Wiggle Sort II",
        "difficulty": "Medium",
        "category": "Array Divide and Conquer Greedy Sorting Quickselect",
        "question_text": "Given an integer array nums, reorder it such that nums[0] < nums[1] > nums[2] < nums[3]....\n\nYou may assume the input array always has a valid answer.\n\n \n\nExample 1:\n\nInput: nums = [1,5,1,1,6,4]\nOutput: [1,6,1,5,1,4]\nExplanation: [1,4,1,5,1,6] is also accepted.\nExample 2:\n\nInput: nums = [1,3,2,2,3,1]\nOutput: [2,3,1,3,1,2]\n \n\nConstraints:\n\n1 <= nums.length <= 5 * 104\n0 <= nums[i] <= 5000\nIt is guaranteed that there will be an answer for the given input nums.\n \n\nFollow Up: Can you do it in O(n) time and/or in-place with O(1) extra space?",
        "solution": "void wiggleSort(vector<int>& nums) {\n    int n = nums.size();\n    \n    // Find a median.\n    auto midptr = nums.begin() + n / 2;\n    nth_element(nums.begin(), midptr, nums.end());\n    int mid = *midptr;\n    \n    // Index-rewiring.\n    #define A(i) nums[(1+2*(i)) % (n|1)]\n\n    // 3-way-partition-to-wiggly in O(n) time with O(1) space.\n    int i = 0, j = 0, k = n - 1;\n    while (j <= k) {\n        if (A(j) > mid)\n            swap(A(i++), A(j++));\n        else if (A(j) < mid)\n            swap(A(j), A(k--));\n        else\n            j++;\n    }\n}",
        "explanation": "First I find a median using nth_element. That only guarantees O(n) average time complexity and I don't know about space complexity. I might write this myself using O(n) time and O(1) space, but that's not what I want to show here.\n\nThis post is about what comes after that. We can use three-way partitioning to arrange the numbers so that those larger than the median come first, then those equal to the median come next, and then those smaller than the median come last.\n\nOrdinarily, you'd then use one more phase to bring the numbers to their final positions to reach the overall wiggle-property. But I don't know a nice O(1) space way for this. Instead, I embed this right into the partitioning algorithm. That algorithm simply works with indexes 0 to n-1 as usual, but sneaky as I am, I rewire those indexes where I want the numbers to actually end up. The partitioning-algorithm doesn't even know that I'm doing that, it just works like normal (it just uses A(x) instead of nums[x]).\n\nLet's say nums is [10,11,...,19]. Then after nth_element and ordinary partitioning, we might have this (15 is my median):\n\nindex:     0  1  2  3   4   5  6  7  8  9\nnumber:   18 17 19 16  15  11 14 10 13 12\nI rewire it so that the first spot has index 5, the second spot has index 0, etc, so that I might get this instead:\n\nindex:     5  0  6  1  7  2  8  3  9  4\nnumber:   11 18 14 17 10 19 13 16 12 15\nAnd 11 18 14 17 10 19 13 16 12 15 is perfectly wiggly. And the whole partitioning-to-wiggly-arrangement (everything after finding the median) only takes O(n) time and O(1) space.\n\nIf the above description is unclear, maybe this explicit listing helps:\n\nAccessing A(0) actually accesses nums[1].\nAccessing A(1) actually accesses nums[3].\nAccessing A(2) actually accesses nums[5].\nAccessing A(3) actually accesses nums[7].\nAccessing A(4) actually accesses nums[9].\nAccessing A(5) actually accesses nums[0].\nAccessing A(6) actually accesses nums[2].\nAccessing A(7) actually accesses nums[4].\nAccessing A(8) actually accesses nums[6].\nAccessing A(9) actually accesses nums[8]."
    },
    {
        "question_id": "06b8783e-5cd4-4546-8190-976e9816b964",
        "title": "Count of Range Sum",
        "difficulty": "Hard",
        "category": "Array Binary Search Divide and Conquer Binary Indexed Tree Segment Tree Merge Sort Ordered Set",
        "question_text": "Given an integer array nums and two integers lower and upper, return the number of range sums that lie in [lower, upper] inclusive.\n\nRange sum S(i, j) is defined as the sum of the elements in nums between indices i and j inclusive, where i <= j.\n\n \n\nExample 1:\n\nInput: nums = [-2,5,-1], lower = -2, upper = 2\nOutput: 3\nExplanation: The three ranges are: [0,0], [2,2], and [0,2] and their respective sums are: -2, -1, 2.\nExample 2:\n\nInput: nums = [0], lower = 0, upper = 0\nOutput: 1\n \n\nConstraints:\n\n1 <= nums.length <= 105\n-231 <= nums[i] <= 231 - 1\n-105 <= lower <= upper <= 105\nThe answer is guaranteed to fit in a 32-bit integer.",
        "solution": "public int countRangeSum(int[] nums, int lower, int upper) {\n    int n = nums.length;\n    long[] sums = new long[n + 1];\n    for (int i = 0; i < n; ++i)\n        sums[i + 1] = sums[i] + nums[i];\n    return countWhileMergeSort(sums, 0, n + 1, lower, upper);\n}\n\nprivate int countWhileMergeSort(long[] sums, int start, int end, int lower, int upper) {\n    if (end - start <= 1) return 0;\n    int mid = (start + end) / 2;\n    int count = countWhileMergeSort(sums, start, mid, lower, upper) \n              + countWhileMergeSort(sums, mid, end, lower, upper);\n    int j = mid, k = mid, t = mid;\n    long[] cache = new long[end - start];\n    for (int i = start, r = 0; i < mid; ++i, ++r) {\n        while (k < end && sums[k] - sums[i] < lower) k++;\n        while (j < end && sums[j] - sums[i] <= upper) j++;\n        while (t < end && sums[t] < sums[i]) cache[r++] = sums[t++];\n        cache[r] = sums[i];\n        count += j - k;\n    }\n    System.arraycopy(cache, 0, sums, start, t - start);\n    return count;\n}",
        "explanation": "Recall count smaller number after self where we encountered the problem\n\ncount[i] = count of nums[j] - nums[i] < 0 with j > i\nHere, after we did the preprocess, we need to solve the problem\n\ncount[i] = count of a <= S[j] - S[i] <= b with j > i\nans = sum(count[:])\nTherefore the two problems are almost the same. We can use the same technique used in that problem to solve this problem. One solution is merge sort based; another one is Balanced BST based. The time complexity are both O(n log n).\n\nThe merge sort based solution counts the answer while doing the merge. During the merge stage, we have already sorted the left half [start, mid) and right half [mid, end). We then iterate through the left half with index i. For each i, we need to find two indices k and j in the right half where\n\nj is the first index satisfy sums[j] - sums[i] > upper and\nk is the first index satisfy sums[k] - sums[i] >= lower.\nThen the number of sums in [lower, upper] is j-k. We also use another index t to copy the elements satisfy sums[t] < sums[i] to a cache in order to complete the merge sort.\n\nDespite the nested loops, the time complexity of the \"merge & count\" stage is still linear. Because the indices k, j, t will only increase but not decrease, each of them will only traversal the right half once at most. The total time complexity of this divide and conquer solution is then O(n log n).\n\nOne other concern is that the sums may overflow integer. So we use long instead."
    },
    {
        "question_id": "f5beffad-88ee-494a-ad48-f6eac5c760c2",
        "title": "Russian Doll Envelopes",
        "difficulty": "Hard",
        "category": "Array Binary Search Dynamic Programming Sorting",
        "question_text": "You are given a 2D array of integers envelopes where envelopes[i] = [wi, hi] represents the width and the height of an envelope.\n\nOne envelope can fit into another if and only if both the width and height of one envelope are greater than the other envelope's width and height.\n\nReturn the maximum number of envelopes you can Russian doll (i.e., put one inside the other).\n\nNote: You cannot rotate an envelope.\n\n \n\nExample 1:\n\nInput: envelopes = [[5,4],[6,4],[6,7],[2,3]]\nOutput: 3\nExplanation: The maximum number of envelopes you can Russian doll is 3 ([2,3] => [5,4] => [6,7]).\nExample 2:\n\nInput: envelopes = [[1,1],[1,1],[1,1]]\nOutput: 1\n \n\nConstraints:\n\n1 <= envelopes.length <= 105\nenvelopes[i].length == 2\n1 <= wi, hi <= 105",
        "solution": "public int maxEnvelopes(int[][] envelopes) {\n    if(envelopes == null || envelopes.length == 0 \n       || envelopes[0] == null || envelopes[0].length != 2)\n        return 0;\n    Arrays.sort(envelopes, new Comparator<int[]>(){\n        public int compare(int[] arr1, int[] arr2){\n            if(arr1[0] == arr2[0])\n                return arr2[1] - arr1[1];\n            else\n                return arr1[0] - arr2[0];\n       } \n    });\n    int dp[] = new int[envelopes.length];\n    int len = 0;\n    for(int[] envelope : envelopes){\n        int index = Arrays.binarySearch(dp, 0, len, envelope[1]);\n        if(index < 0)\n            index = -(index + 1);\n        dp[index] = envelope[1];\n        if(index == len)\n            len++;\n    }\n    return len;\n}",
        "explanation": "Sort the array. Ascend on width and descend on height if width are same.\nFind the longest increasing subsequence based on height.\nSince the width is increasing, we only need to consider height.\n[3, 4] cannot contains [3, 3], so we need to put [3, 4] before [3, 3] when sorting otherwise it will be counted as an increasing number if the order is [3, 3], [3, 4]"
    },
    {
        "question_id": "88f8b68a-5005-40a4-ae24-0a0075a1371c",
        "title": "Maximum Product of Subsequences With an Alternating Sum Equal to K",
        "difficulty": "Hard",
        "category": "Array Hash Table Dynamic Programming",
        "question_text": "You are given an integer array nums and two integers, k and limit. Your task is to find a non-empty subsequence of nums that:\n\nHas an alternating sum equal to k.\nMaximizes the product of all its numbers without the product exceeding limit.\nReturn the product of the numbers in such a subsequence. If no subsequence satisfies the requirements, return -1.\n\nThe alternating sum of a 0-indexed array is defined as the sum of the elements at even indices minus the sum of the elements at odd indices.\n\n \n\nExample 1:\n\nInput: nums = [1,2,3], k = 2, limit = 10\n\nOutput: 6\n\nExplanation:\n\nThe subsequences with an alternating sum of 2 are:\n\n[1, 2, 3]\nAlternating Sum: 1 - 2 + 3 = 2\nProduct: 1 * 2 * 3 = 6\n[2]\nAlternating Sum: 2\nProduct: 2\nThe maximum product within the limit is 6.\n\nExample 2:\n\nInput: nums = [0,2,3], k = -5, limit = 12\n\nOutput: -1\n\nExplanation:\n\nA subsequence with an alternating sum of exactly -5 does not exist.\n\nExample 3:\n\nInput: nums = [2,2,3,3], k = 0, limit = 9\n\nOutput: 9\n\nExplanation:\n\nThe subsequences with an alternating sum of 0 are:\n\n[2, 2]\nAlternating Sum: 2 - 2 = 0\nProduct: 2 * 2 = 4\n[3, 3]\nAlternating Sum: 3 - 3 = 0\nProduct: 3 * 3 = 9\n[2, 2, 3, 3]\nAlternating Sum: 2 - 2 + 3 - 3 = 0\nProduct: 2 * 2 * 3 * 3 = 36\nThe subsequence [2, 2, 3, 3] has the greatest product with an alternating sum equal to k, but 36 > 9. The next greatest product is 9, which is within the limit.\n\n \n\nConstraints:\n\n1 <= nums.length <= 150\n0 <= nums[i] <= 12\n-105 <= k <= 105\n1 <= limit <= 5000",
        "solution": "const int MIN = -5000;\n\nclass Solution {\npublic:\n    unordered_map<int, unordered_map<int, unordered_map<int, unordered_map<int, int>>>> dp;\n    int recursion(int pos, int currSum, int product, int isOdd, int k, int n, vector<int> &nums, int limit) {\n        if(pos == n) {\n            return (currSum == k && isOdd != 0 && product <= limit ? product : MIN);\n        }\n        \n        if(dp.count(pos) && dp[pos].count(currSum) && dp[pos][currSum].count(product) && dp[pos][currSum][product].count(isOdd)) {\n            return dp[pos][currSum][product][isOdd];\n        }\n            \n        int ans = recursion(pos + 1, currSum, product, isOdd, k, n, nums, limit);\n        if(isOdd == 0) {\n            ans = max(ans, recursion(pos + 1, currSum + nums[pos], nums[pos], 2, k, n, nums, limit));\n        }\n        if(isOdd == 1) {\n            ans = max(ans, recursion(pos + 1, currSum + nums[pos], min(product * nums[pos], limit + 1), 2, k, n, nums, limit));\n        }\n        if(isOdd == 2) {\n            ans = max(ans, recursion(pos + 1, currSum - nums[pos], min(product * nums[pos], limit + 1), 1, k, n, nums, limit));\n        }\n        \n        return dp[pos][currSum][product][isOdd] = ans;\n    }\n    \n    int maxProduct(vector<int> &nums, int k, int limit) {\n        int n = nums.size();\n        \n        int sum = 0;\n        for(auto &x: nums) sum += x;\n        \n        if(k > sum || k < -sum) return -1;\n            \n        dp.clear();\n        int ans = recursion(0, 0, 0, 0, k, n, nums, limit);\n        return (ans == MIN) ? -1 : ans;\n    }\n};",
        "explanation": "Maximum Product of a Special Subsequence\n Intuition\nThe problem revolves around finding a special subsequence from a given array of positive integers nums, where we need to:\n\nSelect elements in a specific pattern: odd-indexed terms are added, and even-indexed terms are subtracted to form a total sum k.\nThe product of the elements in the subsequence should be maximum but not exceed a given limit.\nSo essentially, it's a dynamic programming problem with multiple states:\n\nThe current index (pos)\nThe current sum (currSum)\nThe product so far (product)\nThe stage or parity (isOdd): whether we're at the start, first number to add, or number to subtract\n Approach\nWe use a recursive function with memoization (unordered_map-based DP) to avoid recalculating overlapping subproblems.\n\nObservation\nOne interesting observation in this problem is sum doesn't exceeds 1800 because the max nums length is 150 and every element isn't greater than 12.\nState Definition\nWe define a DP state as dp[pos][currSum][product][isOdd]:\n\npos: Current index in nums\ncurrSum: Running total based on the subsequence pattern\nproduct: Product formed so far\nisOdd:\n0: Start of subsequence (no elements picked yet)\n1: Last operation was an addition (+a)\n2: Last operation was a subtraction (-b)\nTransition\nAt every step, we either:\n\nSkip the current number and continue (pos + 1).\nInclude the current number:\nIf isOdd == 0: First element, add it and begin product\nIf isOdd == 1: Subtract current number from sum and multiply in product\nIf isOdd == 2: Add current number to sum and multiply in product\nInclusion is only considered if the new product doesn't exceed the limit.\n\nAt base case (pos == n), we check if:\n\ncurrSum == k\nAt least one element should be considered (isOdd != 0)\nproduct <= limit\nIf all these hold, we return the product, else a minimum placeholder value (MIN = -5000).\n\nFinally, we return the best product found or -1 if no valid sequence exists.\n\n Complexity\nTime Complexity:\nO(n⋅sum⋅201⋅3)\n\nn for index\n2 * sum for possible values of currSum (including negatives)\n201 for possible unique product values (we prune above limit + 1)\n3 for possible values of isOdd\nSince we’re memoizing states using hash maps, pruning and skipping invalid states makes this faster than brute force.\n\nSpace Complexity:\nO(n⋅sum⋅201⋅3)\nDue to recursive call stack and DP table (stored in unordered maps), though it's sparsely populated."
    },
    {
        "question_id": "0d1483d9-9fd3-4e75-8200-34c7fb7d04e7",
        "title": "Final Array State After K Multiplication Operations II",
        "difficulty": "Hard",
        "category": "Array Heap (Priority Queue) Simulation",
        "question_text": "You are given an integer array nums, an integer k, and an integer multiplier.\n\nYou need to perform k operations on nums. In each operation:\n\nFind the minimum value x in nums. If there are multiple occurrences of the minimum value, select the one that appears first.\nReplace the selected minimum value x with x * multiplier.\nAfter the k operations, apply modulo 109 + 7 to every value in nums.\n\nReturn an integer array denoting the final state of nums after performing all k operations and then applying the modulo.\n\n \n\nExample 1:\n\nInput: nums = [2,1,3,5,6], k = 5, multiplier = 2\n\nOutput: [8,4,6,5,6]\n\nExplanation:\n\nOperation\tResult\nAfter operation 1\t[2, 2, 3, 5, 6]\nAfter operation 2\t[4, 2, 3, 5, 6]\nAfter operation 3\t[4, 4, 3, 5, 6]\nAfter operation 4\t[4, 4, 6, 5, 6]\nAfter operation 5\t[8, 4, 6, 5, 6]\nAfter applying modulo\t[8, 4, 6, 5, 6]\nExample 2:\n\nInput: nums = [100000,2000], k = 2, multiplier = 1000000\n\nOutput: [999999307,999999993]\n\nExplanation:\n\nOperation\tResult\nAfter operation 1\t[100000, 2000000000]\nAfter operation 2\t[100000000000, 2000000000]\nAfter applying modulo\t[999999307, 999999993]\n \n\nConstraints:\n\n1 <= nums.length <= 104\n1 <= nums[i] <= 109\n1 <= k <= 109\n1 <= multiplier <= 106",
        "solution": "const long long mod = 1000000007;\n\nclass Solution {\npublic:\n    long long power_mod(long long base, long long exp, long long mod) {\n    long long result = 1;\n    \n    while (exp > 0) {\n        if (exp % 2 == 1) {\n            result = (result * base) % mod;\n        }\n        base = (base * base) % mod;\n        exp = exp / 2;\n    }\n    // this function multiplies a number by itself n times in O(logn)\n    return result;\n}\n    vector<int> getFinalState(vector<int>& nums, int k, int multiplier) {\n        if (multiplier == 1) return nums; // do not miss this!!\n        priority_queue <pair<long long,long long>, vector<pair<long long,long long>>, greater<pair<long long,long long>>> pq;\n        int n = nums.size();\n        for (int i = 0; i < n; i++) pq.push({nums[i],i});\n        unordered_map<int,int> m,m1;\n        // m for storing number of operations at each index\n        //m1 to know if all elements have got an operation\n        while (1){\n            if ((int)m1.size() == n || k == 0) break; // no more operations or state achieved\n            long long x = pq.top().first, y = pq.top().second;\n            pq.pop();\n            x *= multiplier; pq.push({x,y});\n            m1[y]++; k--;\n        }\n        vector<long long> v(n); // to avoid integer overflow\n        // This vector will store the elements after ideal state is achieved\n        while (!pq.empty()){\n            long long x = pq.top().first, y = pq.top().second;\n            v[y] = x;\n            pq.pop();\n        }\n        int rep = k/n, md = k%n;\n        for (int i = 0; i < n; i++) pq.push({v[i],i});\n        // I had to push it again because I did not declare v initially due to contest pressure. Better to do that.\n        while (!pq.empty()){\n            int x = pq.top().second;\n            m[x] = rep;\n            if (md > 0)m[x]++,md--;\n            // index x has been assigned its number of operations\n            pq.pop();\n        }\n        // Now just compute every value while calling power_mod funtion\n        for (int i = 0; i < n; i++){\n            long long mlt = power_mod(multiplier, m[i],mod);\n            v[i] = ((v[i]%mod)*(mlt%mod))%mod;\n            nums[i] = v[i];\n        }\n        return nums;\n    }\n};",
        "explanation": "Intuition\nThe general idea is to divide the operations greedily among all indexes.\n\nEvery number after getting an operation should not remain as the smallest. So we will have to achieve that state first.\n\nBY OBSERVATION\nWhen all the elements get atleast an operation, we will achieve the above mentioned state. So we will first greedily assign them operation till all elements get atleast one operation.\n\nUse priority queue min heap or multiset for that.\n\nAfter this we can assign every index a number of operations through our initial general idea.\n\nWhat about such large value of k?\nThe number of operations of each index may be huge due to this. The optimal approach is achieved in log(n) as the multiplier increases exponentially. Check out the function in the code. This is called Exponentiation by Squaring.\n\nComplexity\nTime complexity: O(nlogk)\n\nSpace complexity: O(n)"
    },
    {
        "question_id": "878a31db-8cd5-4979-97d0-487d3796105a",
        "title": "Longest Subsequence With Decreasing Adjacent Difference",
        "difficulty": "Medium",
        "category": "Array Dynamic Programming",
        "question_text": "You are given an array of integers nums.\n\nYour task is to find the length of the longest subsequence seq of nums, such that the absolute differences between consecutive elements form a non-increasing sequence of integers. In other words, for a subsequence seq0, seq1, seq2, ..., seqm of nums, |seq1 - seq0| >= |seq2 - seq1| >= ... >= |seqm - seqm - 1|.\n\nReturn the length of such a subsequence.\n\n \n\nExample 1:\n\nInput: nums = [16,6,3]\n\nOutput: 3\n\nExplanation: \n\nThe longest subsequence is [16, 6, 3] with the absolute adjacent differences [10, 3].\n\nExample 2:\n\nInput: nums = [6,5,3,4,2,1]\n\nOutput: 4\n\nExplanation:\n\nThe longest subsequence is [6, 4, 2, 1] with the absolute adjacent differences [2, 2, 1].\n\nExample 3:\n\nInput: nums = [10,20,10,19,10,20]\n\nOutput: 5\n\nExplanation: \n\nThe longest subsequence is [10, 20, 10, 19, 10] with the absolute adjacent differences [10, 10, 9, 9].\n\n \n\nConstraints:\n\n2 <= nums.length <= 104\n1 <= nums[i] <= 300",
        "solution": "class Solution {\npublic:\n    int longestSubsequence(vector<int>& nums) {\n        vector<vector<int>> dp(302, vector<int>(302));\n\n        for (int i = nums.size() - 1; i >= 0; --i){\n            int num = nums[i];\n    \n            for (int next = 1; next <= 300; ++next){\n                int diff = abs(next - num);\n                dp[num][diff] = max(dp[num][diff], dp[next][diff] + 1);\n            }\n\n            for (int j = 1; j <= 300; ++j){\n                dp[num][j] = max(dp[num][j], dp[num][j - 1]);\n            }\n        }\n\n        int ans = INT_MIN;\n        for (int i = 0; i <= 301; ++i){\n            for (int j = 0; j <= 301; ++j){\n                ans = max(ans, dp[i][j]);\n            }\n        }\n\n        return ans;\n    }\n};",
        "explanation": "Intuition\nSince the range of values is small we can store information about longest subsequences starting from specific values and having differences less than or equal to some value.\n\nApproach\nGoing from back to front, compute for the current number num and for each possible absolute difference d, the maximum length subsequence starting from that number and having differences less than or equal to d between successive elements.\n\nTo do so, we can use information computed earlier. For each other number num2, update dp[num][abs(num−num2)] using dp[num2][abs(num−num2)].\n\nOnce this is done we can compute dp[num][diff] as max \nd≤diff\n​\n dp[num][d]. This is done because we are interested in the longest subsequences whose differences between successive elements are bounded by diff.\n\nComplexity\nTime complexity:\nO(n∗max_value)\n\nSpace complexity:\nO(max_value \n2\n )"
    },
    {
        "question_id": "077f0fd2-8197-4dcd-9948-b57fdd0ba649",
        "title": "Implement Router",
        "difficulty": "Medium",
        "category": "Array Hash Table Binary Search Design Queue Ordered Set",
        "question_text": "Design a data structure that can efficiently manage data packets in a network router. Each data packet consists of the following attributes:\n\nsource: A unique identifier for the machine that generated the packet.\ndestination: A unique identifier for the target machine.\ntimestamp: The time at which the packet arrived at the router.\nImplement the Router class:\n\nRouter(int memoryLimit): Initializes the Router object with a fixed memory limit.\n\nmemoryLimit is the maximum number of packets the router can store at any given time.\nIf adding a new packet would exceed this limit, the oldest packet must be removed to free up space.\nbool addPacket(int source, int destination, int timestamp): Adds a packet with the given attributes to the router.\n\nA packet is considered a duplicate if another packet with the same source, destination, and timestamp already exists in the router.\nReturn true if the packet is successfully added (i.e., it is not a duplicate); otherwise return false.\nint[] forwardPacket(): Forwards the next packet in FIFO (First In First Out) order.\n\nRemove the packet from storage.\nReturn the packet as an array [source, destination, timestamp].\nIf there are no packets to forward, return an empty array.\nint getCount(int destination, int startTime, int endTime):\n\nReturns the number of packets currently stored in the router (i.e., not yet forwarded) that have the specified destination and have timestamps in the inclusive range [startTime, endTime].\nNote that queries for addPacket will be made in increasing order of timestamp.\n\n \n\nExample 1:\n\nInput:\n[\"Router\", \"addPacket\", \"addPacket\", \"addPacket\", \"addPacket\", \"addPacket\", \"forwardPacket\", \"addPacket\", \"getCount\"]\n[[3], [1, 4, 90], [2, 5, 90], [1, 4, 90], [3, 5, 95], [4, 5, 105], [], [5, 2, 110], [5, 100, 110]]\n\nOutput:\n[null, true, true, false, true, true, [2, 5, 90], true, 1]\n\nExplanation\n\nRouter router = new Router(3); // Initialize Router with memoryLimit of 3.\nrouter.addPacket(1, 4, 90); // Packet is added. Return True.\nrouter.addPacket(2, 5, 90); // Packet is added. Return True.\nrouter.addPacket(1, 4, 90); // This is a duplicate packet. Return False.\nrouter.addPacket(3, 5, 95); // Packet is added. Return True\nrouter.addPacket(4, 5, 105); // Packet is added, [1, 4, 90] is removed as number of packets exceeds memoryLimit. Return True.\nrouter.forwardPacket(); // Return [2, 5, 90] and remove it from router.\nrouter.addPacket(5, 2, 110); // Packet is added. Return True.\nrouter.getCount(5, 100, 110); // The only packet with destination 5 and timestamp in the inclusive range [100, 110] is [4, 5, 105]. Return 1.\nExample 2:\n\nInput:\n[\"Router\", \"addPacket\", \"forwardPacket\", \"forwardPacket\"]\n[[2], [7, 4, 90], [], []]\n\nOutput:\n[null, true, [7, 4, 90], []]\n\nExplanation\n\nRouter router = new Router(2); // Initialize Router with memoryLimit of 2.\nrouter.addPacket(7, 4, 90); // Return True.\nrouter.forwardPacket(); // Return [7, 4, 90].\nrouter.forwardPacket(); // There are no packets left, return [].\n \n\nConstraints:\n\n2 <= memoryLimit <= 105\n1 <= source, destination <= 2 * 105\n1 <= timestamp <= 109\n1 <= startTime <= endTime <= 109\nAt most 105 calls will be made to addPacket, forwardPacket, and getCount methods altogether.\nqueries for addPacket will be made in increasing order of timestamp.",
        "solution": "class Router {\npublic:\n    map<vector<int>, int> mpp; // to track duplicates\n    queue<vector<int>> queue; // to store packets in FIFO order\n    unordered_map<int, vector<int>> timestamps; // for timestamps tracking\n    unordered_map<int, int> st; \n    int maxSize = 0; // maxSize allowed\n\n    Router(int memoryLimit) { \n        maxSize = memoryLimit; \n    }\n\n    bool addPacket(int source, int destination, int timestamp) {\n        vector<int> packet = {source, destination, timestamp};\n        // checking for duplicate\n        if (mpp.count(packet))\n            return false;\n        if (queue.size() == maxSize) { // remove the first element if queue is full\n            vector<int> res = queue.front();\n            mpp.erase(res);\n            int temp = res[1];\n            st[temp]++;  \n            queue.pop();\n        }\n        queue.push(packet);\n        mpp[packet]++;\n        timestamps[destination].push_back(timestamp);\n        return true;\n    }\n\n    vector<int> forwardPacket() {\n        if(queue.empty()) return {};\n        vector<int> res = queue.front();\n        queue.pop();\n        mpp.erase(res);\n        int temp = res[1];\n        st[temp]++;\n        return res;\n    }\n\n    int getCount(int destination, int startTime, int endTime) {\n        if(timestamps.find(destination) == timestamps.end())\n            return 0;\n        auto &p = timestamps[destination];\n        int temp = st[destination];\n        auto right = lower_bound(p.begin() + temp, p.end(), startTime);\n        auto left = upper_bound(p.begin() + temp, p.end(), endTime);\n        return int(left - right);\n    }\n};",
        "explanation": "Approach\nLets go over the data structures that we can use here to make our work simpler →\nUse a hashmap to track duplicates.\nUse a queue to store packets in FIFO order as mentioned in the question and pop when needed.\nUse a map of vector to track the timestamps and destinations.\nUse a map to track how many packets we have removed so far.\nNow lets go step by step through the functions,\nRouter → Here we only store the maxSize allowed nothing else.\naddPacket → We firstly check if the packet has already been added, if yes then we simply return false. Else we add it in our ds's.\nforwardPacket → Simply remove the packet from our map and update it in our ds's.\ngetCount → Use binary search functions lower bound and upper bound to return the range [left,right] which consists of elements in the range startTime and endTime."
    },
    {
        "question_id": "c851e74e-5a17-4c4a-92ce-f9c17afeaf80",
        "title": "Number of Unique XOR Triplets I",
        "difficulty": "Medium",
        "category": "Array Math Bit Manipulation",
        "question_text": "You are given an integer array nums of length n, where nums is a permutation of the numbers in the range [1, n].\n\nA XOR triplet is defined as the XOR of three elements nums[i] XOR nums[j] XOR nums[k] where i <= j <= k.\n\nReturn the number of unique XOR triplet values from all possible triplets (i, j, k).\n\n \n\nExample 1:\n\nInput: nums = [1,2]\n\nOutput: 2\n\nExplanation:\n\nThe possible XOR triplet values are:\n\n(0, 0, 0) → 1 XOR 1 XOR 1 = 1\n(0, 0, 1) → 1 XOR 1 XOR 2 = 2\n(0, 1, 1) → 1 XOR 2 XOR 2 = 1\n(1, 1, 1) → 2 XOR 2 XOR 2 = 2\nThe unique XOR values are {1, 2}, so the output is 2.\n\nExample 2:\n\nInput: nums = [3,1,2]\n\nOutput: 4\n\nExplanation:\n\nThe possible XOR triplet values include:\n\n(0, 0, 0) → 3 XOR 3 XOR 3 = 3\n(0, 0, 1) → 3 XOR 3 XOR 1 = 1\n(0, 0, 2) → 3 XOR 3 XOR 2 = 2\n(0, 1, 2) → 3 XOR 1 XOR 2 = 0\nThe unique XOR values are {0, 1, 2, 3}, so the output is 4.\n\n \n\nConstraints:\n\n1 <= n == nums.length <= 105\n1 <= nums[i] <= n\nnums is a permutation of integers from 1 to n.",
        "solution": "class Solution {\npublic:\n    int uniqueXorTriplets(vector<int>& nums) {\n        int n = nums.size();\n\n        if(n < 3) return n;\n\n        // Find the Most Significant Bit\n        int cnt = 0;\n        int temp = n;\n        while(temp > 0){\n            temp >>= 1;\n            cnt++;\n        }\n        \n        return pow(2, cnt);\n    }\n};",
        "explanation": "Problem Summary\nGiven a permutation nums of numbers from 1 to n, you are to find the number of unique values you can get by doing XOR of all triplets (i, j, k) where i <= j <= k.\n\nUnderstanding the Solution\nFor n < 3\nFor n = 1, only one element → 1 unique value.\nFor n = 2, only 2 combinations → 2 unique values.\nFor n >= 3\nThe number of possible XOR values between numbers from 1 to n is bounded by the number of bits required to represent n.\nSince any XOR operation between values in [1, n] gives a result between 0 to (2^cnt - 1), the maximum number of unique values is 2^cnt.\nComplexity\nTime complexity: O(log n)\nSpace complexity: O(1)"
    },
    {
        "question_id": "a01553b9-4b6f-42c6-9b94-a5214d3db43b",
        "title": "Non-decreasing Array",
        "difficulty": "Medium",
        "category": "Array",
        "question_text": "Given an array nums with n integers, your task is to check if it could become non-decreasing by modifying at most one element.\n\nWe define an array is non-decreasing if nums[i] <= nums[i + 1] holds for every i (0-based) such that (0 <= i <= n - 2).\n\n \n\nExample 1:\n\nInput: nums = [4,2,3]\nOutput: true\nExplanation: You could modify the first 4 to 1 to get a non-decreasing array.\nExample 2:\n\nInput: nums = [4,2,1]\nOutput: false\nExplanation: You cannot get a non-decreasing array by modifying at most one element.\n \n\nConstraints:\n\nn == nums.length\n1 <= n <= 104\n-105 <= nums[i] <= 105",
        "solution": "bool checkPossibility(vector<int>& nums) {\n        int cnt = 0;                                                                    //the number of changes\n        for(int i = 1; i < nums.size() && cnt<=1 ; i++){\n            if(nums[i-1] > nums[i]){\n                cnt++;\n                if(i-2<0 || nums[i-2] <= nums[i])nums[i-1] = nums[i];                    //modify nums[i-1] of a priority\n                else nums[i] = nums[i-1];                                                //have to modify nums[i]\n            }\n        }\n        return cnt<=1;\n    }",
        "explanation": "This problem is like a greedy problem. When you find nums[i-1] > nums[i] for some i, you will prefer to change nums[i-1]'s value, since a larger nums[i] will give you more risks that you get inversion errors after position i. But, if you also find nums[i-2] > nums[i], then you have to change nums[i]'s value instead, or else you need to change both of nums[i-2]'s and nums[i-1]'s values."
    },
    {
        "question_id": "5fffdee6-ccef-466e-93a2-0cb7307d811f",
        "title": "Split Array With Same Average",
        "difficulty": "Hard",
        "category": "Array Math Dynamic Programming Bit Manipulation Bitmask",
        "question_text": "You are given an integer array nums.\n\nYou should move each element of nums into one of the two arrays A and B such that A and B are non-empty, and average(A) == average(B).\n\nReturn true if it is possible to achieve that and false otherwise.\n\nNote that for an array arr, average(arr) is the sum of all the elements of arr over the length of arr.\n\n \n\nExample 1:\n\nInput: nums = [1,2,3,4,5,6,7,8]\nOutput: true\nExplanation: We can split the array into [1,4,5,8] and [2,3,6,7], and both of them have an average of 4.5.\nExample 2:\n\nInput: nums = [3,1]\nOutput: false\n \n\nConstraints:\n\n1 <= nums.length <= 30\n0 <= nums[i] <= 104",
        "solution": "class Solution(object):\n    def splitArraySameAverage(self, A):\n        from fractions import Fraction\n        N = len(A)\n        S = sum(A)\n        A = [z - Fraction(S, N) for z in A]\n\n        if N == 1: return False\n\n        #Want zero subset sum\n        left = {A[0]}\n        for i in xrange(1, N/2):\n            left = {z + A[i] for z in left} | left | {A[i]}\n        if 0 in left: return True\n\n        right = {A[-1]}\n        for i in xrange(N/2, N-1):\n            right = {z + A[i] for z in right} | right | {A[i]}\n        if 0 in right: return True\n\n        sleft = sum(A[i] for i in xrange(N/2))\n        sright = sum(A[i] for i in xrange(N/2, N))\n\n        return any(-ha in right and (ha, -ha) != (sleft, sright) for ha in left)",
        "explanation": "Intuition and Algorithm\n\nFirst, let's get a sense of the condition that average(B) = average(C), where B, C are defined in the problem statement.\n\nSay A (the input array) has N elements which sum to S, and B (one of the splitting sets) has K elements which sum to X. Then the equation for average(B) = average(C) becomes  \nK\nX\n​\n = \nN−K\nS−X\n​\n . This reduces to X(N−K)=(S−X)K which is  \nK\nX\n​\n = \nN\nS\n​\n . That is, average(B) = average(A).\n\nNow, we could delete average(A) from each element A[i] without changing our choice for B. (A[i] -= mu, where mu = average(A)). This means we just want to choose a set B that sums to 0.\n\nTrying all 2 \nN\n  sets is still too many choices, so we will create sets of sums left, right of the approximately 2 \nN/2\n  choices on the left and on the right separately. (That is, left is a set of sums of every powerset in the first half of A, and right is the set of sums of every powerset in the second half of A). Then, it is true if we find 0 in these powersets, or if two sums in different halves cancel out (-x in right for x in left), except for one minor detail below.\n\nCare must be taken that we do not specify sets that would make the original B or C empty. If sleft = A[0] + A[1] + ... + A[N/2 - 1], and sright = A[N/2] + ... + A[N-1], (where A[i] was transformed to the new A[i] - average(A)) then we cannot choose both (sleft, sright). This is correct because if for example sleft was a sum reached by a strictly smaller powerset than {A[0], A[1], ..., A[N/2 - 1]}, then the difference between these sets would be non-empty and have sum 0.\nComplexity Analysis\n\nTime Complexity: O(2 N/2 ), where N is the length of A.\n\nSpace Complexity: O(2 N/2 )."
    },
    {
        "question_id": "cb60a672-8727-40fb-b49b-a3a153e87182",
        "title": "Maximum Unique Subarray Sum After Deletion",
        "difficulty": "Easy",
        "category": "Array Hash Table Greedy",
        "question_text": "You are given an integer array nums.\n\nYou are allowed to delete any number of elements from nums without making it empty. After performing the deletions, select a subarray of nums such that:\n\nAll elements in the subarray are unique.\nThe sum of the elements in the subarray is maximized.\nReturn the maximum sum of such a subarray.\n\n \n\nExample 1:\n\nInput: nums = [1,2,3,4,5]\n\nOutput: 15\n\nExplanation:\n\nSelect the entire array without deleting any element to obtain the maximum sum.\n\nExample 2:\n\nInput: nums = [1,1,0,1,1]\n\nOutput: 1\n\nExplanation:\n\nDelete the element nums[0] == 1, nums[1] == 1, nums[2] == 0, and nums[3] == 1. Select the entire array [1] to obtain the maximum sum.\n\nExample 3:\n\nInput: nums = [1,2,-1,-2,1,0,-1]\n\nOutput: 3\n\nExplanation:\n\nDelete the elements nums[2] == -1 and nums[3] == -2, and select the subarray [2, 1] from [1, 2, 1, 0, -1] to obtain the maximum sum.\n\n \n\nConstraints:\n\n1 <= nums.length <= 100\n-100 <= nums[i] <= 100",
        "solution": "class Solution {\npublic:\n    int maxSum(vector<int>& nums) {\n        int sum = 0;\n        set<int> st;\n        int mxNeg = INT_MIN;\n        for (int i = 0; i < nums.size(); i++) {\n            if (nums[i] > 0)\n                st.insert(nums[i]);\n            else\n                mxNeg = max(mxNeg, nums[i]);\n        }\n        for (auto val : st) {\n            sum += val;\n        }\n        if (st.size())\n            return sum;\n        else\n            return mxNeg;\n    }\n};",
        "explanation": "Intuition\nThe problem is asking for the maximum sum of a subarray with unique elements. We need to maximize the sum while ensuring that no duplicates are included in the subarray. This means we will need to track positive numbers and handle cases where no positive numbers exist.\n\nApproach\nTraverse through the array and store positive numbers in a set (which ensures uniqueness).\nKeep track of the maximum negative number in case there are no positive numbers.\nThe result will either be the sum of unique positive numbers or the largest negative number.\nComplexity\nTime complexity: (O(n))\nWe process each element of the array exactly once, either inserting it into a set or comparing it to the current maximum negative value.\n\nSpace complexity: (O(n))\nThe space is used by the set to store unique positive numbers, which may be up to (n) elements in the worst case."
    },
    {
        "question_id": "c5d24e1a-0ff0-4c81-9f34-05b2439b5e92",
        "title": "Max Points on a Line",
        "difficulty": "Hard",
        "category": "Array Hash Table Math Geometry",
        "question_text": "Given an array of points where points[i] = [xi, yi] represents a point on the X-Y plane, return the maximum number of points that lie on the same straight line.\nExample 1:\nInput: points = [[1,1],[2,2],[3,3]]\nOutput: 3\nExample 2:\nInput: points = [[1,1],[3,2],[5,3],[4,1],[2,3],[1,4]]\nOutput: 4\nConstraints:\n\n1 <= points.length <= 300\npoints[i].length == 2\n-104 <= xi, yi <= 104\nAll the points are unique.",
        "solution": "class Solution {\npublic:\n    int maxPoints(vector<vector<int>>& pt) {\n        int ans=1; \n        int n=pt.size();\n       // slope of every point with selected point\n        for(int i=0;i<n-1;i++){\n            map<double,int> mp;\n            for(int j=i+1;j<n;j++){\n                //calculating the slope\n                double x = (double)(pt[j][1]-pt[i][1])/(double)(pt[j][0]-pt[i][0]);\n                if(pt[j][1]-pt[i][1]<0 &&(pt[j][0]-pt[i][0])==0 ) //infinite slop for Perpendicular line\n                mp[abs(x)]++; \n                else\n               //storing the slop into map\n                    mp[x]++;\n            }\n            // same slope w.r.t.that selected point\n            int temp = 0;\n            for(auto it:mp)\n                temp = max(temp, it.second+1);    // +1 for the current point(point itself)\n            ans = max(temp, ans);\n        }\n        return ans;\n    }\n};",
        "explanation": "Intuition\nHere we will calculate the slope\nApproach\nIdea is very simple\n\nWe will select point and for every selected point we will calculate the slope wr.t to another point and store into the map\nIn map we will store <slope,that selected point>\nfor example we have point :-[[1,1],[2,2],[3,3]......\nwe pick point [1,1]and for that [1,1] we will calculate the slope\nw.r.t [2,2] ,[3,3]....... and store like this-\nfor understanding purpose i'm writing\nmp[slope1,[1,1]]\nmp[slope2,[1,1]]\nmp[slope1,[1,1]].........\nThis type we will store the slope for [2,2] , [3,3],....\nAter storing the slope into map we will calculate the max point for that slope\nFor example after storing the slope map can look like this\n[2/3,3]\n[INF,1]//for perpendicular case\n[1/3,2]...\nfind the max number of points having the same slope w.r.t. that selected point :-means which slope have maximum point\n:- here 2/3 have 3 point so our answer will be 3+1(we are adding that point as well)"
    },
    {
        "question_id": "7a15a0a1-23da-4914-996f-52d9168ab758",
        "title": "X of a Kind in a Deck of Cards",
        "difficulty": "Easy",
        "category": "Array Hash Table Math Counting Number Theory",
        "question_text": "You are given an integer array deck where deck[i] represents the number written on the ith card.\n\nPartition the cards into one or more groups such that:\n\nEach group has exactly x cards where x > 1, and\nAll the cards in one group have the same integer written on them.\nReturn true if such partition is possible, or false otherwise.\n\n \n\nExample 1:\n\nInput: deck = [1,2,3,4,4,3,2,1]\nOutput: true\nExplanation: Possible partition [1,1],[2,2],[3,3],[4,4].\nExample 2:\n\nInput: deck = [1,1,1,2,2,2,3,3]\nOutput: false\nExplanation: No possible partition.\n \n\nConstraints:\n\n1 <= deck.length <= 104\n0 <= deck[i] < 104",
        "solution": "class Solution(object):\n    def hasGroupsSizeX(self, deck):\n        from fractions import gcd\n        vals = collections.Counter(deck).values()\n        return reduce(gcd, vals) >= 2",
        "explanation": "Greatest Common Divisor\nIntuition and Algorithm\n\nAgain, say there are C_i cards of number i. These must be broken down into piles of X cards each, ie. C_i % X == 0 for all i.\n\nThus, X must divide the greatest common divisor of C_i. If this greatest common divisor g is greater than 1, then X = g will satisfy. Otherwise, it won't.\nComplexity Analysis\n\nTime Complexity: O(Nlog \n2\n N), where N is the number of votes. If there are C \ni\n​\n  cards with number i, then each gcd operation is naively O(log \n2\n C \ni\n​\n ). Better bounds exist, but are outside the scope of this article to develop.\n\nSpace Complexity: O(N)."
    },
    {
        "question_id": "effa6fd6-4f6a-4d5d-91a7-de295dd8fb7c",
        "title": "Longest Substring Without Repeating Characters",
        "difficulty": "Medium",
        "category": "Hash Table String Sliding Window",
        "question_text": "Given a string s, find the length of the longest substring without duplicate characters.\n\n \n\nExample 1:\n\nInput: s = \"abcabcbb\"\nOutput: 3\nExplanation: The answer is \"abc\", with the length of 3.\nExample 2:\n\nInput: s = \"bbbbb\"\nOutput: 1\nExplanation: The answer is \"b\", with the length of 1.\nExample 3:\n\nInput: s = \"pwwkew\"\nOutput: 3\nExplanation: The answer is \"wke\", with the length of 3.\nNotice that the answer must be a substring, \"pwke\" is a subsequence and not a substring.\n \n\nConstraints:\n\n0 <= s.length <= 5 * 104\ns consists of English letters, digits, symbols and spaces.",
        "solution": "class Solution {\npublic:\n    int lengthOfLongestSubstring(string s) {\n        int n = s.length();\n        int maxLength = 0;\n        unordered_set<char> charSet;\n        int left = 0;\n        \n        for (int right = 0; right < n; right++) {\n            if (charSet.count(s[right]) == 0) {\n                charSet.insert(s[right]);\n                maxLength = max(maxLength, right - left + 1);\n            } else {\n                while (charSet.count(s[right])) {\n                    charSet.erase(s[left]);\n                    left++;\n                }\n                charSet.insert(s[right]);\n            }\n        }\n        \n        return maxLength;\n    }\n};",
        "explanation": "Intuition\nThe intuition behind the 3 solutions is to iteratively find the longest substring without repeating characters by maintaining a sliding window approach. We use two pointers (left and right) to represent the boundaries of the current substring. As we iterate through the string, we update the pointers and adjust the window to accommodate new unique characters and eliminate repeating characters.\n\nApproach 1 - Set\nWe use a set (charSet) to keep track of unique characters in the current substring.\nWe maintain two pointers, left and right, to represent the boundaries of the current substring.\nThe maxLength variable keeps track of the length of the longest substring encountered so far.\nWe iterate through the string using the right pointer.\nIf the current character is not in the set (charSet), it means we have a new unique character.\nWe insert the character into the set and update the maxLength if necessary.\nIf the character is already present in the set, it indicates a repeating character within the current substring.\nIn this case, we move the left pointer forward, removing characters from the set until the repeating character is no longer present.\nWe insert the current character into the set and continue the iteration.\nFinally, we return the maxLength as the length of the longest substring without repeating characters."
    },
    {
        "question_id": "bcaf91f0-8bef-48e0-816e-9eeef44b8f73",
        "title": "String to Integer (atoi)",
        "difficulty": "Medium",
        "category": "String",
        "question_text": "Implement the myAtoi(string s) function, which converts a string to a 32-bit signed integer.\n\nThe algorithm for myAtoi(string s) is as follows:\n\nWhitespace: Ignore any leading whitespace (\" \").\nSignedness: Determine the sign by checking if the next character is '-' or '+', assuming positivity if neither present.\nConversion: Read the integer by skipping leading zeros until a non-digit character is encountered or the end of the string is reached. If no digits were read, then the result is 0.\nRounding: If the integer is out of the 32-bit signed integer range [-231, 231 - 1], then round the integer to remain in the range. Specifically, integers less than -231 should be rounded to -231, and integers greater than 231 - 1 should be rounded to 231 - 1.\nReturn the integer as the final result.\n\n \n\nExample 1:\n\nInput: s = \"42\"\n\nOutput: 42\n\nExplanation:\n\nThe underlined characters are what is read in and the caret is the current reader position.\nStep 1: \"42\" (no characters read because there is no leading whitespace)\n         ^\nStep 2: \"42\" (no characters read because there is neither a '-' nor '+')\n         ^\nStep 3: \"42\" (\"42\" is read in)\n           ^\nExample 2:\n\nInput: s = \" -042\"\n\nOutput: -42\n\nExplanation:\n\nStep 1: \"   -042\" (leading whitespace is read and ignored)\n            ^\nStep 2: \"   -042\" ('-' is read, so the result should be negative)\n             ^\nStep 3: \"   -042\" (\"042\" is read in, leading zeros ignored in the result)\n               ^\nExample 3:\n\nInput: s = \"1337c0d3\"\n\nOutput: 1337\n\nExplanation:\n\nStep 1: \"1337c0d3\" (no characters read because there is no leading whitespace)\n         ^\nStep 2: \"1337c0d3\" (no characters read because there is neither a '-' nor '+')\n         ^\nStep 3: \"1337c0d3\" (\"1337\" is read in; reading stops because the next character is a non-digit)\n             ^\nExample 4:\n\nInput: s = \"0-1\"\n\nOutput: 0\n\nExplanation:\n\nStep 1: \"0-1\" (no characters read because there is no leading whitespace)\n         ^\nStep 2: \"0-1\" (no characters read because there is neither a '-' nor '+')\n         ^\nStep 3: \"0-1\" (\"0\" is read in; reading stops because the next character is a non-digit)\n          ^\nExample 5:\n\nInput: s = \"words and 987\"\n\nOutput: 0\n\nExplanation:\n\nReading stops at the first non-digit character 'w'.\n\n \n\nConstraints:\n\n0 <= s.length <= 200\ns consists of English letters (lower-case and upper-case), digits (0-9), ' ', '+', '-', and '.'.",
        "solution": "#include <iostream>\n#include <string>\nusing namespace std;\n\nclass Solution {\npublic:\n    int myAtoi(string s) {\n        int i = 0, sign = 1;\n        long res = 0; // Using long to handle overflow cases\n\n        // Trim leading spaces\n        while (i < s.size() && s[i] == ' ') i++;\n        if (i == s.size()) return 0;\n\n        // Check for sign\n        if (s[i] == '-') { sign = -1; i++; }\n        else if (s[i] == '+') i++;\n\n        // Process numerical characters\n        while (i < s.size() && isdigit(s[i])) {\n            res = res * 10 + (s[i] - '0');\n\n            // Handle overflow\n            if (sign * res > INT_MAX) return INT_MAX;\n            if (sign * res < INT_MIN) return INT_MIN;\n\n            i++;\n        }\n\n        return (int)(sign * res);\n    }\n};",
        "explanation": "Intuition\nThe problem requires converting a given string into an integer while following specific rules. Key challenges include handling whitespace, signs (+ and -), non-numeric characters, and integer overflow.\n\nA simple string parsing approach can be used:\n\nIgnore leading whitespace.\nDetermine the sign (+ or -).\nConvert valid numeric characters to an integer.\nStop conversion when a non-numeric character appears.\nHandle integer overflow by capping the value at INT_MAX or INT_MIN.\nApproach\nTrim leading spaces using trim().\nCheck for sign at the beginning (+ or -).\nIterate through characters while they are numeric:\nConvert each character to a digit.\nMultiply the existing result by 10 and add the new digit.\nCheck for integer overflow conditions.\nReturn the final computed integer with the correct sign.\nThis approach ensures we efficiently extract and convert the number in O(n) time complexity.\n\nComplexity\nTime Complexity: O(n) (where n is the length of the string)\nSpace Complexity: O(1) (constant extra space used)"
    },
    {
        "question_id": "5b6a36eb-a3f6-4746-91a8-c2c6ed29ed07",
        "title": "Regular Expression Matching",
        "difficulty": "Hard",
        "category": "String Dynamic Programming Recursion",
        "question_text": "Given an input string s and a pattern p, implement regular expression matching with support for '.' and '*' where:\n\n'.' Matches any single character.​​​​\n'*' Matches zero or more of the preceding element.\nThe matching should cover the entire input string (not partial).\n\n \n\nExample 1:\n\nInput: s = \"aa\", p = \"a\"\nOutput: false\nExplanation: \"a\" does not match the entire string \"aa\".\nExample 2:\n\nInput: s = \"aa\", p = \"a*\"\nOutput: true\nExplanation: '*' means zero or more of the preceding element, 'a'. Therefore, by repeating 'a' once, it becomes \"aa\".\nExample 3:\n\nInput: s = \"ab\", p = \".*\"\nOutput: true\nExplanation: \".*\" means \"zero or more (*) of any character (.)\".\n \n\nConstraints:\n\n1 <= s.length <= 20\n1 <= p.length <= 20\ns contains only lowercase English letters.\np contains only lowercase English letters, '.', and '*'.\nIt is guaranteed for each appearance of the character '*', there will be a previous valid character to match.",
        "solution": "class Solution(object):\n    def isMatch(self, text: str, pattern: str) -> bool:\n        memo = {}\n\n        def dp(i: int, j: int) -> bool:\n            if (i, j) not in memo:\n                if j == len(pattern):\n                    ans = i == len(text)\n                else:\n                    first_match = i < len(text) and pattern[j] in {text[i], \".\"}\n                    if j + 1 < len(pattern) and pattern[j + 1] == \"*\":\n                        ans = dp(i, j + 2) or first_match and dp(i + 1, j)\n                    else:\n                        ans = first_match and dp(i + 1, j + 1)\n\n                memo[i, j] = ans\n            return memo[i, j]\n\n        return dp(0, 0)",
        "explanation": "Intuition\n\nAs the problem has an optimal substructure, it is natural to cache intermediate results. We ask the question dp(i, j): does text[i:] and pattern[j:] match? We can describe our answer in terms of answers to questions involving smaller strings.\n\nAlgorithm\n\nWe proceed with the same recursion as in Approach 1, except because calls will only ever be made to match(text[i:], pattern[j:]), we use dp(i, j) to handle those calls instead, saving us expensive string-building operations and allowing us to cache the intermediate results."
    },
    {
        "question_id": "85555f11-af97-4365-85e3-4dc8715405e4",
        "title": "Roman to Integer",
        "difficulty": "Easy",
        "category": "Hash Table Math String",
        "question_text": "Roman numerals are represented by seven different symbols: I, V, X, L, C, D and M.\n\nSymbol       Value\nI             1\nV             5\nX             10\nL             50\nC             100\nD             500\nM             1000\nFor example, 2 is written as II in Roman numeral, just two ones added together. 12 is written as XII, which is simply X + II. The number 27 is written as XXVII, which is XX + V + II.\n\nRoman numerals are usually written largest to smallest from left to right. However, the numeral for four is not IIII. Instead, the number four is written as IV. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as IX. There are six instances where subtraction is used:\n\nI can be placed before V (5) and X (10) to make 4 and 9. \nX can be placed before L (50) and C (100) to make 40 and 90. \nC can be placed before D (500) and M (1000) to make 400 and 900.\nGiven a roman numeral, convert it to an integer.\n\n \n\nExample 1:\n\nInput: s = \"III\"\nOutput: 3\nExplanation: III = 3.\nExample 2:\n\nInput: s = \"LVIII\"\nOutput: 58\nExplanation: L = 50, V= 5, III = 3.\nExample 3:\n\nInput: s = \"MCMXCIV\"\nOutput: 1994\nExplanation: M = 1000, CM = 900, XC = 90 and IV = 4.\n \n\nConstraints:\n\n1 <= s.length <= 15\ns contains only the characters ('I', 'V', 'X', 'L', 'C', 'D', 'M').\nIt is guaranteed that s is a valid roman numeral in the range [1, 3999].",
        "solution": "class Solution {\npublic:\n    int romanToInt(string s) {\n        int res = 0;\n        unordered_map<char, int> roman = {\n            {'I', 1},\n            {'V', 5},\n            {'X', 10}, \n            {'L', 50},\n            {'C', 100},\n            {'D', 500},\n            {'M', 1000}\n        };\n\n        for (int i = 0; i < s.size() - 1; i++) {\n            if (roman[s[i]] < roman[s[i + 1]]) {\n                res -= roman[s[i]];\n            } else {\n                res += roman[s[i]];\n            }\n        }\n\n        return res + roman[s[s.size() - 1]];        \n    }\n};",
        "explanation": "Approach\nThe description includes the example of 27. If the values are written from left to right in descending order, simply adding each number one by one will give the result.\n\nXXVII\n↓\n10(X) + 10(X) + 5(V) + 1(I) + 1(I) = 27\nLVIII\n↓\n50(L) + 5(V) + 1(I) + 1(I) + 1(I) = 58\nBut numbers like 4 and 9 are represented as a single number using two Roman numerals.\n\nIV = 4\nIX = 9\n Points\n\nBasically, you just need to convert either one or two characters into a number to get the answer.\n\nHow do we determine if it’s one or two characters?\nSince a single number can use up to two Roman characters, we loop through the string two characters at a time, shifting by one each time.\n\nLet’s take a look at this example.\n\nInput: s = \"XIV\"\nIn the first loop, we use X and I. In this case, the second character I is less than X. I is 1 and X is 10. That means we can simply add X to result variable, because 10 → 1 is a descending order. It's the same as 27 or 58 above.\n\nres = 10\nNext, we use I and V. In this case, the second character V is greater than I, because V is 5 and I is 1.\n\nThe description says \"there are six instances where subtraction is used.\"\n\nIV = 4\nIX = 9\nXL = 40\nXC = 90\nCD = 400\nCM = 900\nLook at all the first characters and the second characters. The first characters are less than the second characters.\n\nI(1) + V(5) = 4\nI(1) + X(10) = 9\nX(10) + L(50) = 40\nX(10) + C(100) = 90\nC(100) + D(500) = 400\nC(100) + M(1000) = 900\nThe current first character is I and the second character is V, so we are using two Roman characters to form a single number.\n\nIn this case, we subtract I(= 1) from result variable, because in the next loop, we will add V(= 5), so the total of I and V will be 4 in the end.\n\nres = 9\nThe next two number is V and nothing(= out of bounds), so we stop iteration.\n\nThe last point is that as I told you, we should add V before return the answer, because one of values was out of bounds, that's why we couldn't add the last Roman chartacter which is V.\n\nreturn res + 5\nBefore we start looping, we have HashMap to combine Roman and Integer, so that we can convert Roman to Integer easily.\n\nIn the solution code,\n\nreturn res + roman[s[-1]]\n\ns is input string\nroman is HashMap"
    },
    {
        "question_id": "9a9b9b8c-7fee-47c4-b970-5a888a40f529",
        "title": "Longest Common Prefix",
        "difficulty": "Easy",
        "category": "String Trie",
        "question_text": "Write a function to find the longest common prefix string amongst an array of strings.\n\nIf there is no common prefix, return an empty string \"\".\n\n \n\nExample 1:\n\nInput: strs = [\"flower\",\"flow\",\"flight\"]\nOutput: \"fl\"\nExample 2:\n\nInput: strs = [\"dog\",\"racecar\",\"car\"]\nOutput: \"\"\nExplanation: There is no common prefix among the input strings.\n \n\nConstraints:\n\n1 <= strs.length <= 200\n0 <= strs[i].length <= 200\nstrs[i] consists of only lowercase English letters if it is non-empty.",
        "solution": "class Solution {\npublic:\n    string longestCommonPrefix(vector<string>& strs) {\n        if (strs.empty()) return \"\";\n        return longestCommonPrefix(strs, 0, strs.size() - 1);\n    }\n\nprivate:\n    string longestCommonPrefix(vector<string>& strs, int l, int r) {\n        if (l == r) {\n            return strs[l];\n        } else {\n            int mid = (l + r) / 2;\n            string lcpLeft = longestCommonPrefix(strs, l, mid);\n            string lcpRight = longestCommonPrefix(strs, mid + 1, r);\n            return commonPrefix(lcpLeft, lcpRight);\n        }\n    }\n\n    string commonPrefix(string left, string right) {\n        int min = std::min(left.length(), right.length());\n        for (int i = 0; i < min; i++) {\n            if (left[i] != right[i]) return left.substr(0, i);\n        }\n        return left.substr(0, min);\n    }\n};",
        "explanation": "Divide and conquer\nIntuition\nThe idea of the algorithm comes from the associative property of LCP operation. We notice that :\nLCP(S 1 …S n )=LCP(LCP(S 1 …S k ),LCP(S k+1 …S n )), where LCP(​ …S n ) is the longest common prefix in set of strings [S 1 …S n ] ,1<k<n\nAlgorithm\nTo apply the observation above, we use divide and conquer technique, where we split the LCP(S \ni\n​\n …S \nj\n​\n ) problem into two subproblems LCP(S \ni\n​\n …S \nmid\n​\n ) and LCP(S \nmid+1\n​\n …S \nj\n​\n ), where mid is  \n2\ni+j\n​\n . We use their solutions lcpLeft and lcpRight to construct the solution of the main problem LCP(S \ni\n​\n …S \nj\n​\n ). To accomplish this we compare one by one the characters of lcpLeft and lcpRight till there is no character match. The found common prefix of lcpLeft and lcpRight is the solution of the LCP(S \ni\n​\n …S \nj\n​\n ).\n\n Complexity Analysis\nIn the worst case we have n equal strings with length m\n\nTime complexity : O(S), where S is the number of all characters in the array, S=m⋅n\nTime complexity is 2⋅T( \n2\nn\n​\n )+O(m). Therefore time complexity is O(S).\nIn the best case this algorithm performs O(minLen⋅n) comparisons, where minLen is the shortest string of the array\n\nSpace complexity : O(m⋅logn)\n\nThere is a memory overhead since we store recursive calls in the execution stack. There are logn recursive calls, each store need m space to store the result, so space complexity is O(m⋅logn)"
    },
    {
        "question_id": "4612d5a3-b44d-4345-9af3-40ac6d214dd6",
        "title": "Wildcard Matching",
        "difficulty": "Hard",
        "category": "String Dynamic Programming Greedy Recursion",
        "question_text": "Given an input string (s) and a pattern (p), implement wildcard pattern matching with support for '?' and '*' where:\n\n'?' Matches any single character.\n'*' Matches any sequence of characters (including the empty sequence).\nThe matching should cover the entire input string (not partial).\n\n \n\nExample 1:\n\nInput: s = \"aa\", p = \"a\"\nOutput: false\nExplanation: \"a\" does not match the entire string \"aa\".\nExample 2:\n\nInput: s = \"aa\", p = \"*\"\nOutput: true\nExplanation: '*' matches any sequence.\nExample 3:\n\nInput: s = \"cb\", p = \"?a\"\nOutput: false\nExplanation: '?' matches 'c', but the second letter is 'a', which does not match 'b'.\n \n\nConstraints:\n\n0 <= s.length, p.length <= 2000\ns contains only lowercase English letters.\np contains only lowercase English letters, '?' or '*'.",
        "solution": "bool isMatch(const char *s, const char *p) {\n        const char* star=NULL;\n        const char* ss=s;\n        while (*s){\n            //advancing both pointers when (both characters match) or ('?' found in pattern)\n            //note that *p will not advance beyond its length \n            if ((*p=='?')||(*p==*s)){s++;p++;continue;} \n\n            // * found in pattern, track index of *, only advancing pattern pointer \n            if (*p=='*'){star=p++; ss=s;continue;} \n\n            //current characters didn't match, last pattern pointer was *, current pattern pointer is not *\n            //only advancing pattern pointer\n            if (star){ p = star+1; s=++ss;continue;} \n\n           //current pattern pointer is not star, last patter pointer was not *\n           //characters do not match\n            return false;\n        }\n\n       //check for remaining characters in pattern\n        while (*p=='*'){p++;}\n\n        return !*p;  \n    }",
        "explanation": "The basic idea is to have one pointer for the string and one pointer for the pattern. This algorithm iterates at most length(string) + length(pattern) times, for each iteration, at least one pointer advance one step."
    },
    {
        "question_id": "9b7427e5-d04d-4606-ba13-e2b79456333a",
        "title": "Fraction to Recurring Decimal",
        "difficulty": "Medium",
        "category": "Hash Table Math String",
        "question_text": "Given two integers representing the numerator and denominator of a fraction, return the fraction in string format.\n\nIf the fractional part is repeating, enclose the repeating part in parentheses.\n\nIf multiple answers are possible, return any of them.\n\nIt is guaranteed that the length of the answer string is less than 104 for all the given inputs.\n\n \n\nExample 1:\n\nInput: numerator = 1, denominator = 2\nOutput: \"0.5\"\nExample 2:\n\nInput: numerator = 2, denominator = 1\nOutput: \"2\"\nExample 3:\n\nInput: numerator = 4, denominator = 333\nOutput: \"0.(012)\"\n \n\nConstraints:\n\n-231 <= numerator, denominator <= 231 - 1\ndenominator != 0",
        "solution": "public class Solution {\n    public String fractionToDecimal(int numerator, int denominator) {\n        if (numerator == 0) {\n            return \"0\";\n        }\n        StringBuilder res = new StringBuilder();\n        // \"+\" or \"-\"\n        res.append(((numerator > 0) ^ (denominator > 0)) ? \"-\" : \"\");\n        long num = Math.abs((long)numerator);\n        long den = Math.abs((long)denominator);\n        \n        // integral part\n        res.append(num / den);\n        num %= den;\n        if (num == 0) {\n            return res.toString();\n        }\n        \n        // fractional part\n        res.append(\".\");\n        HashMap<Long, Integer> map = new HashMap<Long, Integer>();\n        map.put(num, res.length());\n        while (num != 0) {\n            num *= 10;\n            res.append(num / den);\n            num %= den;\n            if (map.containsKey(num)) {\n                int index = map.get(num);\n                res.insert(index, \"(\");\n                res.append(\")\");\n                break;\n            }\n            else {\n                map.put(num, res.length());\n            }\n        }\n        return res.toString();\n    }\n}",
        "explanation": "The important thing is to consider all edge cases while thinking this problem through, including: negative integer, possible overflow, etc.\n\nUse HashMap to store a remainder and its associated index while doing the division so that whenever a same remainder comes up, we know there is a repeating fractional part."
    },
    {
        "question_id": "0cffb6fd-d7d8-406c-be67-ec6cf8bbecab",
        "title": "Basic Calculator",
        "difficulty": "Hard",
        "category": "Math String Stack Recursion",
        "question_text": "Given a string s representing a valid expression, implement a basic calculator to evaluate it, and return the result of the evaluation.\n\nNote: You are not allowed to use any built-in function which evaluates strings as mathematical expressions, such as eval().\n\n \n\nExample 1:\n\nInput: s = \"1 + 1\"\nOutput: 2\nExample 2:\n\nInput: s = \" 2-1 + 2 \"\nOutput: 3\nExample 3:\n\nInput: s = \"(1+(4+5+2)-3)+(6+8)\"\nOutput: 23\n \n\nConstraints:\n\n1 <= s.length <= 3 * 105\ns consists of digits, '+', '-', '(', ')', and ' '.\ns represents a valid expression.\n'+' is not used as a unary operation (i.e., \"+1\" and \"+(2 + 3)\" is invalid).\n'-' could be used as a unary operation (i.e., \"-1\" and \"-(2 + 3)\" is valid).\nThere will be no two consecutive operators in the input.\nEvery number and running calculation will fit in a signed 32-bit integer.",
        "solution": "public int calculate(String s) {\n    Stack<Integer> stack = new Stack<Integer>();\n    int result = 0;\n    int number = 0;\n    int sign = 1;\n    for(int i = 0; i < s.length(); i++){\n        char c = s.charAt(i);\n        if(Character.isDigit(c)){\n            number = 10 * number + (int)(c - '0');\n        }else if(c == '+'){\n            result += sign * number;\n            number = 0;\n            sign = 1;\n        }else if(c == '-'){\n            result += sign * number;\n            number = 0;\n            sign = -1;\n        }else if(c == '('){\n            //we push the result first, then sign;\n            stack.push(result);\n            stack.push(sign);\n            //reset the sign and result for the value in the parenthesis\n            sign = 1;   \n            result = 0;\n        }else if(c == ')'){\n            result += sign * number;  \n            number = 0;\n            result *= stack.pop();    //stack.pop() is the sign before the parenthesis\n            result += stack.pop();   //stack.pop() now is the result calculated before the parenthesis\n            \n        }\n    }\n    if(number != 0) result += sign * number;\n    return result;\n}",
        "explanation": "Simple iterative solution by identifying characters one by one. One important thing is that the input is valid, which means the parentheses are always paired and in order.\nOnly 5 possible input we need to pay attention:\n\ndigit: it should be one digit from the current number\n\n'+': number is over, we can add the previous number and start a new number\n\n'-': same as above\n\n'(': push the previous result and the sign into the stack, set result to 0, just calculate the new result within the parenthesis.\n\n')': pop out the top two numbers from stack, first one is the sign before this pair of parenthesis, second is the temporary result before this pair of parenthesis. We add them together.\n\nFinally if there is only one number, from the above solution, we haven't add the number to the result, so we do a check see if the number is zero."
    },
    {
        "question_id": "a46cfe35-3aa8-4876-b29c-e3b83ca9e6a7",
        "title": "Binary Tree Paths",
        "difficulty": "Easy",
        "category": "Math String Stack Recursion",
        "question_text": "Given the root of a binary tree, return all root-to-leaf paths in any order.\n\nA leaf is a node with no children.\n\n \n\nExample 1:\n\n\nInput: root = [1,2,3,null,5]\nOutput: [\"1->2->5\",\"1->3\"]\nExample 2:\n\nInput: root = [1]\nOutput: [\"1\"]\n \n\nConstraints:\n\nThe number of nodes in the tree is in the range [1, 100].\n-100 <= Node.val <= 100",
        "solution": "class Solution(object):\n    def binaryTreePaths(self, root):\n        res = []\n        if not root:\n            return res\n        stack = [(root, str(root.val))]\n        while stack:\n            node, path = stack.pop()\n            if not node.left and not node.right:\n                res.append(path)\n            if node.right:\n                stack.append((node.right, path + \"->\" + str(node.right.val)))\n            if node.left:\n                stack.append((node.left, path + \"->\" + str(node.left.val)))\n        return res",
        "explanation": "Intuition\nTo collect all root-to-leaf paths in a binary tree, we use DFS traversal. At every node, we build a path string. Once we reach a leaf, we save the full path.\nUse a stack to simulate DFS. At each step, track both the node and the current path string. When a leaf is reached, push the path to the result array. If children exist, extend the path and continue traversing.\n\nComplexity\nTime complexity: (O(n)), where (n) is the number of nodes.\nSpace complexity: (O(n)), for recursion stack or explicit stack and result storage."
    },
    {
        "question_id": "6ac240b7-38cd-4c39-a53a-613838ac801e",
        "title": "Reverse Vowels of a String",
        "difficulty": "Easy",
        "category": "Two Pointers String",
        "question_text": "Given a string s, reverse only all the vowels in the string and return it.\n\nThe vowels are 'a', 'e', 'i', 'o', and 'u', and they can appear in both lower and upper cases, more than once.\n\n \n\nExample 1:\n\nInput: s = \"IceCreAm\"\n\nOutput: \"AceCreIm\"\n\nExplanation:\n\nThe vowels in s are ['I', 'e', 'e', 'A']. On reversing the vowels, s becomes \"AceCreIm\".\n\nExample 2:\n\nInput: s = \"leetcode\"\n\nOutput: \"leotcede\"\n\n \n\nConstraints:\n\n1 <= s.length <= 3 * 105\ns consist of printable ASCII characters.",
        "solution": "class Solution {\npublic:\n    string reverseVowels(string s) {\n        // Convert the input string to a character array.\n        string word = s;\n        int start = 0;\n        int end = s.length() - 1;\n        string vowels = \"aeiouAEIOU\";\n        \n        // Loop until the start pointer is no longer less than the end pointer.\n        while (start < end) {\n            // Move the start pointer towards the end until it points to a vowel.\n            while (start < end && vowels.find(word[start]) == string::npos) {\n                start++;\n            }\n            \n            // Move the end pointer towards the start until it points to a vowel.\n            while (start < end && vowels.find(word[end]) == string::npos) {\n                end--;\n            }\n            \n            // Swap the vowels found at the start and end positions.\n            swap(word[start], word[end]);\n            \n            // Move the pointers towards each other for the next iteration.\n            start++;\n            end--;\n        }\n        \n        // Return the modified string.\n        return word;\n    }\n};",
        "explanation": "Intuition\nThe goal of the problem is to reverse the order of vowels in a given string while keeping the non-vowel characters in their original positions. To achieve this, we can use two pointers technique: one pointer starting from the beginning of the string and another starting from the end. We will move these pointers towards each other, swapping the vowels they point to until they meet in the middle of the string.\n\nApproach\nConvert the input string s to an array of characters word. This step is necessary because strings are immutable in Java, and we need to modify the vowels' positions.\n\nInitialize two pointers, start and end, to the first and last characters of the string, respectively.\n\nCreate a String variable vowels containing all the vowel characters (both lowercase and uppercase).\n\nUse a while loop to iterate until start is no longer less than end. This loop ensures that the pointers will not cross each other, and we process the characters in the middle of the string only once.\n\nInside the loop:\n\nMove the start pointer towards the end of the string until it points to a vowel character. We do this by using the indexOf method to find the index of the character in the vowels string. If the character is not a vowel, we keep moving the start pointer.\n\nSimilarly, move the end pointer towards the beginning of the string until it points to a vowel character. Again, we use the indexOf method to check if the character is a vowel and keep moving the end pointer if it is not.\n\nSwap the vowels found at the start and end positions in the word array.\n\nMove the start pointer one step ahead and the end pointer one step back to continue searching for more vowels.\n\nAfter the loop finishes, the word array will contain the string with the reversed vowels. Convert the character array back to a String and return the result.\n\nComplexity\nTime complexity:\nThe time complexity of this solution is O(n), where n is the length of the input string s. The two pointers start and end move towards each other, and each character is processed once.\n\nSpace complexity:\nThe space complexity of this solution is O(n) because we create a character array word to store the characters of the input string. The space used is proportional to the length of the input string. Other than that, we use a constant amount of extra space for the vowels string and a few integer variables, which doesn't depend on the input size."
    },
    {
        "question_id": "4a0dcadd-efa6-4e30-8d31-0a0edb117ec2",
        "title": "Word Break II",
        "difficulty": "Hard",
        "category": "Array Hash Table String Dynamic Programming Backtracking Trie Memoization",
        "question_text": "Given a string s and a dictionary of strings wordDict, add spaces in s to construct a sentence where each word is a valid dictionary word. Return all such possible sentences in any order.\n\nNote that the same word in the dictionary may be reused multiple times in the segmentation.\n\n \n\nExample 1:\n\nInput: s = \"catsanddog\", wordDict = [\"cat\",\"cats\",\"and\",\"sand\",\"dog\"]\nOutput: [\"cats and dog\",\"cat sand dog\"]\nExample 2:\n\nInput: s = \"pineapplepenapple\", wordDict = [\"apple\",\"pen\",\"applepen\",\"pine\",\"pineapple\"]\nOutput: [\"pine apple pen apple\",\"pineapple pen apple\",\"pine applepen apple\"]\nExplanation: Note that you are allowed to reuse a dictionary word.\nExample 3:\n\nInput: s = \"catsandog\", wordDict = [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]\nOutput: []\n \n\nConstraints:\n\n1 <= s.length <= 20\n1 <= wordDict.length <= 1000\n1 <= wordDict[i].length <= 10\ns and wordDict[i] consist of only lowercase English letters.\nAll the strings of wordDict are unique.\nInput is generated in a way that the length of the answer doesn't exceed 105.",
        "solution": "class Solution {\npublic:\n    vector<string> wordBreak(string s, vector<string>& wordDict) {\n        unordered_set<string> wordSet(wordDict.begin(), wordDict.end());\n        unordered_map<string, vector<string>> memoization;\n        return dfs(s, wordSet, memoization);\n    }\n\nprivate:\n    // Depth-first search function to find all possible word break combinations\n    vector<string> dfs(const string& remainingStr,\n                       const unordered_set<string>& wordSet,\n                       unordered_map<string, vector<string>>& memoization) {\n        // Check if result for this substring is already memoized\n        if (memoization.count(remainingStr)) return memoization[remainingStr];\n        // Base case: when the string is empty, return a list containing an\n        // empty string\n        if (remainingStr.empty()) return {\"\"};\n        vector<string> results;\n        for (int i = 1; i <= remainingStr.length(); ++i) {\n            string currentWord = remainingStr.substr(0, i);\n            // If the current substring is a valid word\n            if (wordSet.count(currentWord)) {\n                for (const string& nextWord :\n                     dfs(remainingStr.substr(i), wordSet, memoization)) {\n                    // Append current word and next word with space in between\n                    // if next word exists\n                    results.push_back(currentWord +\n                                      (nextWord.empty() ? \"\" : \" \") + nextWord);\n                }\n            }\n        }\n        // Memoize the results for the current substring\n        memoization[remainingStr] = results;\n        return results;\n    }\n};",
        "explanation": "Intuition\nWe can improve the efficiency of the backtracking method by using Memoization, which stores the results of subproblems to avoid recalculating them.\n\nWe use a depth-first search (DFS) function that recursively breaks the string into words. However, before performing a recursive call, we check if the results for the current substring have already been computed and stored in a memoization map (typically a dictionary or hash table).\n\nIf the results of the current substring are found in the memoization map, we can directly return them without further computation. If not, we proceed with the recursive call, computing the results and storing them in the memoization map before returning them.\n\nBy memoizing the results, we can reduce the number of computations by ensuring that each substring is processed only once in average cases.\n\nAlgorithm\nwordBreak Function:\n\nConvert the wordDict array into an unordered set wordSet for efficient lookups.\nInitialize an empty unordered map memoization to store the results of subproblems.\nCall the dfs function with the input string s, wordSet, and memoization.\ndfs Function:\n\nCheck if the answer for the current remainingStr(the remaining part of the string to be processed) are already in memoization. If so, return them.\nBase Case: If remainingStr is empty, it means that all characters have been processed. An empty string represents a valid sentence so return an array containing the empty string.\nInitialize an empty array results.\nIterate from 1 to the length of remainingStr:\nExtract the substring currentWord from 0 to i to check if it is a valid word.\nIf currentWord is found in wordSet:\nRecursively call dfs with remainingStr.substr(i), wordSet, and memoization.\nAppend currentWord and the recursive results to results(with a space if needed) to form valid sentences.\nStore the results for remainingStr in memoization.\nReturn results."
    },
    {
        "question_id": "6f72755d-22e3-4386-a430-8811419fd470",
        "title": "Remove K Digits",
        "difficulty": "Medium",
        "category": "String Stack Greedy Monotonic Stack",
        "question_text": "Given string num representing a non-negative integer num, and an integer k, return the smallest possible integer after removing k digits from num.\n\n \n\nExample 1:\n\nInput: num = \"1432219\", k = 3\nOutput: \"1219\"\nExplanation: Remove the three digits 4, 3, and 2 to form the new number 1219 which is the smallest.\nExample 2:\n\nInput: num = \"10200\", k = 1\nOutput: \"200\"\nExplanation: Remove the leading 1 and the number is 200. Note that the output must not contain leading zeroes.\nExample 3:\n\nInput: num = \"10\", k = 2\nOutput: \"0\"\nExplanation: Remove all the digits from the number and it is left with nothing which is 0.\n \n\nConstraints:\n\n1 <= k <= num.length <= 105\nnum consists of only digits.\nnum does not have any leading zeros except for the zero itself.",
        "solution": "class Solution {\npublic:\n    std::string removeKdigits(std::string num, int k) {\n        std::stack<char> stack;\n        \n        for (char digit : num) {\n            while (!stack.empty() && k > 0 && stack.top() > digit) {\n                stack.pop();\n                k--;\n            }\n            stack.push(digit);\n        }\n        \n        // Remove remaining k digits from the end of the stack\n        while (k > 0 && !stack.empty()) {\n            stack.pop();\n            k--;\n        }\n        \n        // Construct the resulting string from the stack\n        std::string result;\n        while (!stack.empty()) {\n            result += stack.top();\n            stack.pop();\n        }\n        std::reverse(result.begin(), result.end()); // Reverse to get the correct order\n        \n        // Remove leading zeros\n        size_t pos = result.find_first_not_of('0');\n        result = (pos == std::string::npos) ? \"0\" : result.substr(pos);\n        \n        return result;\n    }\n};",
        "explanation": "Greedy Approach:\nThe problem requires us to minimize the resulting number by removing k digits from the given number num.\nA greedy approach is suitable because at each step (processing each digit), we make a locally optimal choice (keeping the smallest possible digit) with the aim of achieving the overall optimal solution (smallest resulting number).\nBy prioritizing smaller digits for the most significant places (leftmost positions), we ensure that the resulting number is minimized.\nUse of Stack:\nA stack is employed to facilitate the greedy decision-making process:\nWe traverse each digit of num and compare it with the top of the stack (the most recent digit we've chosen to keep).\nIf the current digit is smaller than the top of the stack and we still have removals (k > 0) remaining, we pop digits from the stack until a suitable position for the current digit is found.\nThis stack-based approach allows us to maintain the order of digits while dynamically removing larger, less significant digits to form the smallest possible number.\nApproach:\nInitialize an empty stack.\nTraverse each digit of num.\nFor each digit, while the stack is not empty and k is greater than zero, check if the current digit is smaller than the top of the stack. If so, pop from the stack (remove the top digit) and decrement k.\nPush the current digit onto the stack.\nAfter processing all digits, handle remaining k (if any) by popping from the stack.\nConstruct the resulting number from the stack and remove any leading zeros.\nReturn the smallest possible number as a string."
    },
    {
        "question_id": "6f3ca429-0138-4f12-b44d-304fd5438ad8",
        "title": "Strong Password Checker",
        "difficulty": "Hard",
        "category": "String Greedy Heap (Priority Queue)",
        "question_text": "A password is considered strong if the below conditions are all met:\n\nIt has at least 6 characters and at most 20 characters.\nIt contains at least one lowercase letter, at least one uppercase letter, and at least one digit.\nIt does not contain three repeating characters in a row (i.e., \"Baaabb0\" is weak, but \"Baaba0\" is strong).\nGiven a string password, return the minimum number of steps required to make password strong. if password is already strong, return 0.\n\nIn one step, you can:\n\nInsert one character to password,\nDelete one character from password, or\nReplace one character of password with another character.\n \n\nExample 1:\n\nInput: password = \"a\"\nOutput: 5\nExample 2:\n\nInput: password = \"aA1\"\nOutput: 3\nExample 3:\n\nInput: password = \"1337C0d3\"\nOutput: 0\n \n\nConstraints:\n\n1 <= password.length <= 50\npassword consists of letters, digits, dot '.' or exclamation mark '!'.",
        "solution": "class Solution(object):\n    def strongPasswordChecker(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        missing_type = 3\n        if any('a' <= c <= 'z' for c in s): missing_type -= 1\n        if any('A' <= c <= 'Z' for c in s): missing_type -= 1\n        if any(c.isdigit() for c in s): missing_type -= 1\n\n        change = 0\n        one = two = 0\n        p = 2\n        while p < len(s):\n            if s[p] == s[p-1] == s[p-2]:\n                length = 2\n                while p < len(s) and s[p] == s[p-1]:\n                    length += 1\n                    p += 1\n                    \n                change += length / 3\n                if length % 3 == 0: one += 1\n                elif length % 3 == 1: two += 1\n            else:\n                p += 1\n        \n        if len(s) < 6:\n            return max(missing_type, 6 - len(s))\n        elif len(s) <= 20:\n            return max(missing_type, change)\n        else:\n            delete = len(s) - 20\n            \n            change -= min(delete, one)\n            change -= min(max(delete - one, 0), two * 2) / 2\n            change -= max(delete - one - 2 * two, 0) / 3\n                \n            return delete + max(missing_type, change)",
        "explanation": "The len < 6 and 6 <= len <= 20 cases are easy. When len > 20, we need to do len - 20 times deletion. Also we need to do a change for every three repeating characters.\n\nFor any repeating sequences with len % 3 == 0, we can reduce one replacement by deleting one character. For any repeating sequences with len % 3 == 1, we can reduce one replacement by deleting two character. For the remaining sequences, we can reduce every replacement by deleting three character."
    },
    {
        "question_id": "efbc59c7-0c2f-499f-bfba-f49a51762e64",
        "title": "Number of Segments in a String",
        "difficulty": "Easy",
        "category": "String",
        "question_text": "Given a string s, return the number of segments in the string.\n\nA segment is defined to be a contiguous sequence of non-space characters.\n\n \n\nExample 1:\n\nInput: s = \"Hello, my name is John\"\nOutput: 5\nExplanation: The five segments are [\"Hello,\", \"my\", \"name\", \"is\", \"John\"]\nExample 2:\n\nInput: s = \"Hello\"\nOutput: 1\n \n\nConstraints:\n\n0 <= s.length <= 300\ns consists of lowercase and uppercase English letters, digits, or one of the following characters \"!@#$%^&*()_+-=',.:\".\nThe only space character in s is ' '.",
        "solution": "class Solution:\n    def countSegments(self, s):\n        segment_count = 0\n\n        for i in range(len(s)):\n            if (i == 0 or s[i-1] == ' ') and s[i] != ' ':\n                segment_count += 1\n\n        return segment_count",
        "explanation": "Intuition\n\nIf we cannot afford to allocate linear additional space, a fairly simple\nalgorithm can deduce the number of segments in linear time and constant\nspace.\n\nAlgorithm\n\nTo count the number of segments, it is equivalent to count the number of\nstring indices at which a segment begins. Therefore, by formally defining the\ncharacteristics of such an index, we can simply iterate over the string and\ntest each index in turn. Such a definition is as follows: a string index\nbegins a segment if it is preceded by whitespace (or is the first index) and\nis not whitespace itself, which can be checked in constant time. Finally, we\nsimply return the number of indices for which the condition is satisfied.\n\nComplexity Analysis\n\nTime complexity : O(n)\n\nWe do a constant time check for each of the string's n indices, so the\nruntime is overall linear.\n\nSpace complexity : O(1)\n\nThere are only a few integers allocated, so the memory footprint is\nconstant."
    },
    {
        "question_id": "a5dae9ee-b542-4a38-8529-fa3173cde53f",
        "title": "Count The Repetitions",
        "difficulty": "Hard",
        "category": "String Dynamic Programming",
        "question_text": "We define str = [s, n] as the string str which consists of the string s concatenated n times.\n\nFor example, str == [\"abc\", 3] ==\"abcabcabc\".\nWe define that string s1 can be obtained from string s2 if we can remove some characters from s2 such that it becomes s1.\n\nFor example, s1 = \"abc\" can be obtained from s2 = \"abdbec\" based on our definition by removing the bolded underlined characters.\nYou are given two strings s1 and s2 and two integers n1 and n2. You have the two strings str1 = [s1, n1] and str2 = [s2, n2].\n\nReturn the maximum integer m such that str = [str2, m] can be obtained from str1.\n\n \n\nExample 1:\n\nInput: s1 = \"acb\", n1 = 4, s2 = \"ab\", n2 = 2\nOutput: 2\nExample 2:\n\nInput: s1 = \"acb\", n1 = 1, s2 = \"acb\", n2 = 1\nOutput: 1\n \n\nConstraints:\n\n1 <= s1.length, s2.length <= 100\ns1 and s2 consist of lowercase English letters.\n1 <= n1, n2 <= 106",
        "solution": "int getMaxRepetitions(string s1, int n1, string s2, int n2)\n{\n    if (n1 == 0)\n        return 0;\n    int indexr[s2.size() + 1] = { 0 }; // index at start of each s1 block\n    int countr[s2.size() + 1] = { 0 }; // count of repititions till the present s1 block\n    int index = 0, count = 0;\n    for (int i = 0; i < n1; i++) {\n        for (int j = 0; j < s1.size(); j++) {\n            if (s1[j] == s2[index])\n                ++index;\n            if (index == s2.size()) {\n                index = 0;\n                ++count;\n            }\n        }\n        countr[i] = count;\n        indexr[i] = index;\n        for (int k = 0; k < i; k++) {\n            if (indexr[k] == index) {\n                int prev_count = countr[k];\n                int pattern_count = (countr[i] - countr[k]) * (n1 - 1 - k) / (i - k);\n                int remain_count = countr[k + (n1 - 1 - k) % (i - k)] - countr[k];\n                return (prev_count + pattern_count + remain_count) / n2;\n            }\n        }\n    }\n    return countr[n1 - 1] / n2;\n}",
        "explanation": "After finding the repitition pattern, we can calculate the sum of repeating pattern, part before repitition and part left after repitition as the result in O(1).\n\nBut will this repitition always take place?\n\nYes! By Pigeonhole principle, which states that if n items are put into m containers, with n>m, then at least one container must contain more than one item. So, according to this, we are sure to find 2 same index after scanning at max size(s2) blocks of s1.\n\nAlgorithm\n\nIntialize count=0 nd index=0, which are same as in Approach #1.\nInitialize 2 arrays, say indexr and countr of size (size(s2)+1), initialized with 0. The size (size(s2)+1) is based on the Pigeonhole principle as discussed above. The 2 arrays specifies the index and count at the start of each s1 block.\nIterate over i from 0 to n1−1:\nIterate over j from 0 to size(s1)−1:\n\nIf s1[j]==s2[index], increment index.\nIf index is equal to size(s2), set index=0 and increment count.\nSet countr[i]=count and indexr[i]=index\n\nIterate over k from 0 to i−1:\n\nIf we find the repitition, i.e. current index=indexr[k], we calculate the count for block before the repitition starts, the repeating block and the block left after repitition pattern, which can be calculated as:\nprev_count\npattern_count\nremain_count\n​\n  \n=countr[k]\n=(countr[i]−countr[k])∗ \ni−k\nn1−1−k\n​\n \n=countr[k+(n1−1−k)%(i−k)]−countr[k]\n​\n \nSum the 3 counts and return the sum divided by n2, since S2 = [s2,n2]\nIf no repetition is found, return countr[n1-1]/n2.\n\nComplexity analysis\n\nTime complexity: O(size(s1)*size(s2)).\n\nAccording to the Pigeonhole principle, we need to iterate over s1 only (size(s2)+1) times at max.\nSpace complexity: O(size(s2)) extra space for indexr and countr string."
    },
    {
        "question_id": "93034d0b-6361-47f5-8343-dc93b3cfd58d",
        "title": "Validate IP Address",
        "difficulty": "Medium",
        "category": "String Dynamic Programming",
        "question_text": "Given a string queryIP, return \"IPv4\" if IP is a valid IPv4 address, \"IPv6\" if IP is a valid IPv6 address or \"Neither\" if IP is not a correct IP of any type.\n\nA valid IPv4 address is an IP in the form \"x1.x2.x3.x4\" where 0 <= xi <= 255 and xi cannot contain leading zeros. For example, \"192.168.1.1\" and \"192.168.1.0\" are valid IPv4 addresses while \"192.168.01.1\", \"192.168.1.00\", and \"192.168@1.1\" are invalid IPv4 addresses.\n\nA valid IPv6 address is an IP in the form \"x1:x2:x3:x4:x5:x6:x7:x8\" where:\n\n1 <= xi.length <= 4\nxi is a hexadecimal string which may contain digits, lowercase English letter ('a' to 'f') and upper-case English letters ('A' to 'F').\nLeading zeros are allowed in xi.\nFor example, \"2001:0db8:85a3:0000:0000:8a2e:0370:7334\" and \"2001:db8:85a3:0:0:8A2E:0370:7334\" are valid IPv6 addresses, while \"2001:0db8:85a3::8A2E:037j:7334\" and \"02001:0db8:85a3:0000:0000:8a2e:0370:7334\" are invalid IPv6 addresses.\n\n \n\nExample 1:\n\nInput: queryIP = \"172.16.254.1\"\nOutput: \"IPv4\"\nExplanation: This is a valid IPv4 address, return \"IPv4\".\nExample 2:\n\nInput: queryIP = \"2001:0db8:85a3:0:0:8A2E:0370:7334\"\nOutput: \"IPv6\"\nExplanation: This is a valid IPv6 address, return \"IPv6\".\nExample 3:\n\nInput: queryIP = \"256.256.256.256\"\nOutput: \"Neither\"\nExplanation: This is neither a IPv4 address nor a IPv6 address.\n \n\nConstraints:\n\nqueryIP consists only of English letters, digits and the characters '.' and ':'.",
        "solution": "class Solution {\npublic:\n    string validIPAddress(string IP) {\n        const string chunkIPv4 =\n            \"([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\";\n        regex patternIPv4(\"^(\" + chunkIPv4 + \"\\\\.){3}\" + chunkIPv4 + \"$\");\n\n        const string chunkIPv6 = \"([0-9a-fA-F]{1,4})\";\n        regex patternIPv6(\"^(\" + chunkIPv6 + \"\\\\:){7}\" + chunkIPv6 + \"$\");\n\n        if (regex_match(IP, patternIPv4)) return \"IPv4\";\n        return regex_match(IP, patternIPv6) ? \"IPv6\" : \"Neither\";\n    }\n};",
        "explanation": "Let's construct step by step regex for \"IPv4\"\nas it's described in the problem description. Note, that it's not\na real-life IPv4 because of leading zeros problem as we've discussed above.\n\nAnyway, we start to construct regex pattern by using raw string in Python\nr'' and standard string \"\" in Java. Here is how its skeleton looks like for Python\n\nNow the problem is reduced to the construction of pattern to match each chunk.\nIt's an integer in range (0, 255), and the leading zeros are not allowed.\nThat results in five possible situations:\n\nChunk contains only one digit, from 0 to 9.\n\nChunk contains two digits. The first one could be from 1 to 9, and the second\none from 0 to 9.\n\nChunk contains three digits, and the first one is 1. The second and the third ones\ncould be from 0 to 9.\n\nChunk contains three digits, the first one is 2 and the second one is from 0 to 4.\nThen the third one could be from 0 to 9.\n\nChunk contains three digits, the first one is 2, and the second one is 5.\nThen the third one could be from 0 to 5.\n\nLet's use pipe to create a regular expression that will match either case 1, or\ncase 2, ..., or case 5.\n\nThe job is done. The same logic could be used to construct \"IPv6\" regex pattern.\n\nComplexity Analysis\n\nTime complexity: O(1) because the patterns to match have\nconstant length.\n\nSpace complexity: O(1)."
    },
    {
        "question_id": "b6360a6a-06f0-47b0-830e-e32831b0e34c",
        "title": "Ones and Zeroes",
        "difficulty": "Medium",
        "category": "String Dynamic Programming",
        "question_text": "You are given an array of binary strings strs and two integers m and n.\n\nReturn the size of the largest subset of strs such that there are at most m 0's and n 1's in the subset.\n\nA set x is a subset of a set y if all elements of x are also elements of y.\n\n \n\nExample 1:\n\nInput: strs = [\"10\",\"0001\",\"111001\",\"1\",\"0\"], m = 5, n = 3\nOutput: 4\nExplanation: The largest subset with at most 5 0's and 3 1's is {\"10\", \"0001\", \"1\", \"0\"}, so the answer is 4.\nOther valid but smaller subsets include {\"0001\", \"1\"} and {\"10\", \"1\", \"0\"}.\n{\"111001\"} is an invalid subset because it contains 4 1's, greater than the maximum of 3.\nExample 2:\n\nInput: strs = [\"10\",\"0\",\"1\"], m = 1, n = 1\nOutput: 2\nExplanation: The largest subset is {\"0\", \"1\"}, so the answer is 2.\n \n\nConstraints:\n\n1 <= strs.length <= 600\n1 <= strs[i].length <= 100\nstrs[i] consists only of digits '0' and '1'.\n1 <= m, n <= 100",
        "solution": "int findMaxForm(vector<string>& strs, int m, int n) {\n\t// dp[i][j] will store Max subset size possible with zeros_limit = i, ones_limit = j\n\tvector<vector<int> > dp(m + 1, vector<int>(n + 1));\n\tfor(auto& str : strs) {\n\t\t// count zeros & ones frequency in current string            \n\t\tint zeros = count(begin(str), end(str), '0'), ones = size(str) - zeros; \n\t\t// which positions of dp will be updated ?\n\t\t// Only those having atleast `zeros` 0s(i >= zeros) and `ones` 1s(j >= ones)\n\t\tfor(int i = m; i >= zeros; i--)\n\t\t\tfor(int j = n; j >= ones; j--)                    \n\t\t\t\tdp[i][j] = max(dp[i][j], // either leave the current string\n\t\t\t\t\t\t\t   dp[i - zeros][j - ones] + 1); // or take it by adding 1 to optimal solution of remaining balance\n\t\t// at this point each dp[i][j] will store optimal value for items considered till now & having constraints i and j respectively\n\t}\n\treturn dp[m][n];\n}",
        "explanation": "This problem looks a lot like the knapsack just that we have two constraints here m and n instead of just W in the knapsack problem. Here, a set of items(strings) are given and we have to choose a subset satisfying given constraints. We can apply DP here. We can maintain a 2d dp array, where dp[i][j] will maintain the optimal solution when zeros_limit = i & ones_limit = j.\n\nFor each string, some number of 0s(lets call zeros) and 1s (lets call ones) are required. Obviously, if our balance of zeros and ones is less than what is required by current string, we can't choose it. But in the case where our balance of zeros and ones is greater than the required, we have two cases -\n\nEither take the current string into our subset. The resultant count would be 1 + optimal solution that we had when our balance was i - zeros & j - ones.\nOr leave the current string meaning the resultant count will remain the same.\nFor each string in strs, we will update the dp matrix as per the above two cases.\n\nTime Complexity : O(L*m*n), where L is the length of strs\nSpace Complexity : O(m*n)"
    },
    {
        "question_id": "7a665462-05d1-4cfd-8c28-28ba12435fbf",
        "title": "Zuma Game",
        "difficulty": "Hard",
        "category": "String Dynamic Programming Stack Breadth-First Search Memoization",
        "question_text": "You are playing a variation of the game Zuma.\n\nIn this variation of Zuma, there is a single row of colored balls on a board, where each ball can be colored red 'R', yellow 'Y', blue 'B', green 'G', or white 'W'. You also have several colored balls in your hand.\n\nYour goal is to clear all of the balls from the board. On each turn:\n\nPick any ball from your hand and insert it in between two balls in the row or on either end of the row.\nIf there is a group of three or more consecutive balls of the same color, remove the group of balls from the board.\nIf this removal causes more groups of three or more of the same color to form, then continue removing each group until there are none left.\nIf there are no more balls on the board, then you win the game.\nRepeat this process until you either win or do not have any more balls in your hand.\nGiven a string board, representing the row of balls on the board, and a string hand, representing the balls in your hand, return the minimum number of balls you have to insert to clear all the balls from the board. If you cannot clear all the balls from the board using the balls in your hand, return -1.\n\n \n\nExample 1:\n\nInput: board = \"WRRBBW\", hand = \"RB\"\nOutput: -1\nExplanation: It is impossible to clear all the balls. The best you can do is:\n- Insert 'R' so the board becomes WRRRBBW. WRRRBBW -> WBBW.\n- Insert 'B' so the board becomes WBBBW. WBBBW -> WW.\nThere are still balls remaining on the board, and you are out of balls to insert.\nExample 2:\n\nInput: board = \"WWRRBBWW\", hand = \"WRBRW\"\nOutput: 2\nExplanation: To make the board empty:\n- Insert 'R' so the board becomes WWRRRBBWW. WWRRRBBWW -> WWBBWW.\n- Insert 'B' so the board becomes WWBBBWW. WWBBBWW -> WWWW -> empty.\n2 balls from your hand were needed to clear the board.\nExample 3:\n\nInput: board = \"G\", hand = \"GGGGG\"\nOutput: 2\nExplanation: To make the board empty:\n- Insert 'G' so the board becomes GG.\n- Insert 'G' so the board becomes GGG. GGG -> empty.\n2 balls from your hand were needed to clear the board.\n \n\nConstraints:\n\n1 <= board.length <= 16\n1 <= hand.length <= 5\nboard and hand consist of the characters 'R', 'Y', 'B', 'G', and 'W'.\nThe initial row of balls on the board will not have any groups of three or more consecutive balls of the same color.",
        "solution": "int MAXCOUNT = 6;   // the max balls you need will not exceed 6 since \"The number of balls in your hand won't exceed 5\"\n\npublic int findMinStep(String board, String hand) {\n    int[] handCount = new int[26];\n    for (int i = 0; i < hand.length(); ++i) ++handCount[hand.charAt(i) - 'A'];\n    int rs = helper(board + \"#\", handCount);  // append a \"#\" to avoid special process while j==board.length, make the code shorter.\n    return rs == MAXCOUNT ? -1 : rs;\n}\nprivate int helper(String s, int[] h) {\n    s = removeConsecutive(s);     \n    if (s.equals(\"#\")) return 0;\n    int  rs = MAXCOUNT, need = 0;\n    for (int i = 0, j = 0 ; j < s.length(); ++j) {\n        if (s.charAt(j) == s.charAt(i)) continue;\n        need = 3 - (j - i);     //balls need to remove current consecutive balls.\n        if (h[s.charAt(i) - 'A'] >= need) {\n            h[s.charAt(i) - 'A'] -= need;\n            rs = Math.min(rs, need + helper(s.substring(0, i) + s.substring(j), h));\n            h[s.charAt(i) - 'A'] += need;\n        }\n        i = j;\n    }\n    return rs;\n}\n//remove consecutive balls longer than 3\nprivate String removeConsecutive(String board) {\n    for (int i = 0, j = 0; j < board.length(); ++j) {\n        if (board.charAt(j) == board.charAt(i)) continue;\n        if (j - i >= 3) return removeConsecutive(board.substring(0, i) + board.substring(j));\n        else i = j;\n    }\n    return board;\n}",
        "explanation": "My idea is simple and clear. it's just like a DFS or a Backtracking solution. word is poor, just look the code."
    },
    {
        "question_id": "048c8b98-6c0c-4690-b6f2-ba477ac11b7d",
        "title": "Largest Component Size by Common Factor",
        "difficulty": "Hard",
        "category": "Array Hash Table Math Union Find Number Theory",
        "question_text": "You are given an integer array of unique positive integers nums. Consider the following graph:\n\nThere are nums.length nodes, labeled nums[0] to nums[nums.length - 1],\nThere is an undirected edge between nums[i] and nums[j] if nums[i] and nums[j] share a common factor greater than 1.\nReturn the size of the largest connected component in the graph.\n\n \n\nExample 1:\nInput: nums = [4,6,15,35]\nOutput: 4\nExample 2:\nInput: nums = [20,50,9,63]\nOutput: 2\nExample 3:\nInput: nums = [2,3,6,7,4,12,21,39]\nOutput: 8\n \n\nConstraints:\n\n1 <= nums.length <= 2 * 104\n1 <= nums[i] <= 105\nAll the values of nums are unique.",
        "solution": "class UnionFind {\n    public:\n    vector<int> par, sz;\n    UnionFind(int n) : par(n), sz(n,1) {\n        iota(begin(par), end(par), 0);\n    }\n    int find(int x) {\n        if(par[x] == x) return x;\n        return par[x] = find(par[x]);\n    }\n    bool Union(int x, int y) {\n        int xp = find(x), yp = find(y);\n        if(xp == yp) return false;\n        if(sz[xp] > sz[yp]) par[yp] = par[xp], sz[xp] += sz[yp];\n        else par[xp] = par[yp], sz[yp] += sz[xp];\n        return true;\n    }\n};\nclass Solution {\npublic:\n    int largestComponentSize(vector<int>& nums) {\n        int n = size(nums), ans = 1;\n        UnionFind uf(n + 1);\n        unordered_map<int, int> mp;                    // stores {p : 1st found index i such that nums[i] % p == 0}\n        auto putOrUnion = [&](int p, int i){           // puts 1st found index of element that p divides into hashmap\n            if(mp.count(p)) uf.Union(mp[p], i);        // and if already exists, directly union them\n            else mp[p] = i;\n        };\n        for(int i = 0; i < n; i++) {                   // prime factorize nums[i]\n            int cur = nums[i];\n            if(cur % 2 == 0) {                        \n                putOrUnion(2, i);\n                while(cur % 2 == 0) cur >>= 1;\n            }\n            for(int p = 3; p <= sqrt(cur); p += 2)   \n                if(cur % p == 0) {                 \n                    putOrUnion(p, i);\n                    while(cur % p == 0) cur /= p;\n                }\n            if(cur > 1) putOrUnion(cur, i);            // nums[i] itself is prime   \n        }\n        return *max_element(begin(uf.sz), end(uf.sz)); // return largest component\n    }\n};",
        "explanation": "(Union-Find w/ Prime Factorization)\n\nWe can see that if two numbers belong to the same group due to some common factor, they should also have some common prime factor. This allows us to use slightly different approach where we find all prime factors of a number and union the elements based on the common prime factors amongst them. This can reduce the space used by DSU to O(N) down from O(M) by allowing us to perform union on indices of elements instead of elements & its factors, although we do incur a cost of storing primes and elements in nums that it divides.\nHowever, we can add another small optimization for space. Instead of storing all the primes as a vector in the hashmap and then performing union on the indices of element that each prime divides, we can just put the 1st index of element we find that a prime p divides and then for every subsequent indices, we just union them there itself. This saves space and also eliminate the last step of iterating over each prime and then unioning the indices."
    },
    {
        "question_id": "875f8b83-c677-458e-80be-1031f2c1349e",
        "title": "Minimum Area Rectangle",
        "difficulty": "Medium",
        "category": "Array Hash Table Math Union Find Number Theory",
        "question_text": "You are given an array of points in the X-Y plane points where points[i] = [xi, yi].\n\nReturn the minimum area of a rectangle formed from these points, with sides parallel to the X and Y axes. If there is not any such rectangle, return 0.\n\n \n\nExample 1:\nInput: points = [[1,1],[1,3],[3,1],[3,3],[2,2]]\nOutput: 4\nExample 2:\nInput: points = [[1,1],[1,3],[3,1],[3,3],[4,1],[4,3]]\nOutput: 2\n \n\nConstraints:\n\n1 <= points.length <= 500\npoints[i].length == 2\n0 <= xi, yi <= 4 * 104\nAll the given points are unique.",
        "solution": "class Solution(object):\n    def minAreaRect(self, points):\n        S = set(map(tuple, points))\n        ans = float('inf')\n        for j, p2 in enumerate(points):\n            for i in xrange(j):\n                p1 = points[i]\n                if (p1[0] != p2[0] and p1[1] != p2[1] and\n                        (p1[0], p2[1]) in S and (p2[0], p1[1]) in S):\n                    ans = min(ans, abs(p2[0] - p1[0]) * abs(p2[1] - p1[1]))\n        return ans if ans < float('inf') else 0",
        "explanation": "Intuition\n\nFor each pair of points in the array, consider them to be the long diagonal of a potential rectangle. We can check if all 4 points are there using a Set.\n\nFor example, if the points are (1, 1) and (5, 5), we check if we also have (1, 5) and (5, 1). If we do, we have a candidate rectangle.\n\nAlgorithm\n\nPut all the points in a set. For each pair of points, if the associated rectangle are 4 distinct points all in the set, then take the area of this rectangle as a candidate answer.\nComplexity Analysis\n\nTime Complexity: O(N \n2\n ), where N is the length of points.\n\nSpace Complexity: O(N)."
    },
    {
        "question_id": "3b085e25-b785-4729-9d0c-ebc73cd2f37c",
        "title": "Delete and Earn",
        "difficulty": "Medium",
        "category": "Array Hash Table Dynamic Programming",
        "question_text": "You are given an integer array nums. You want to maximize the number of points you get by performing the following operation any number of times:\n\nPick any nums[i] and delete it to earn nums[i] points. Afterwards, you must delete every element equal to nums[i] - 1 and every element equal to nums[i] + 1.\nReturn the maximum number of points you can earn by applying the above operation some number of times.\n\n \n\nExample 1:\n\nInput: nums = [3,4,2]\nOutput: 6\nExplanation: You can perform the following operations:\n- Delete 4 to earn 4 points. Consequently, 3 is also deleted. nums = [2].\n- Delete 2 to earn 2 points. nums = [].\nYou earn a total of 6 points.\nExample 2:\n\nInput: nums = [2,2,3,3,3,4]\nOutput: 9\nExplanation: You can perform the following operations:\n- Delete a 3 to earn 3 points. All 2's and 4's are also deleted. nums = [3,3].\n- Delete a 3 again to earn 3 points. nums = [3].\n- Delete a 3 once more to earn 3 points. nums = [].\nYou earn a total of 9 points.\n \n\nConstraints:\n\n1 <= nums.length <= 2 * 104\n1 <= nums[i] <= 104",
        "solution": "class Solution {\npublic:\n    int t[20001]; // declaring 1 d array, to store some already computed results\n    int solve(vector<int> &arr, int i)\n    {\n        if(i >= arr.size()) // if i is greater than size of array\n        {\n            return 0; // then simply returnn zero\n        }\n        \n         // if result is already computed, then return from here\n        // this one line which we say to add\n        if(t[i] != -1)\n        {\n            return t[i];\n        }\n        \n        // current 'i' on which we are standing\n        int currValue = arr[i];  // current value\n        int currSum = arr[i]; // intial make sum as same as value\n        int index = i + 1; // index to take elemets, so  i + 1\n        \n        // while it is the same as the current value, include in our sum\n        while(index < arr.size() && arr[index] == currValue)\n        {\n            currSum += arr[i];\n            index++;\n        }\n        \n        // Now, we have to skip all the elements, whose value is equal to\n        // currValue + 1\n        while(index < arr.size() && arr[index] == currValue + 1)\n        {\n            index++;\n        }\n        \n        //And lastly, we have two choices-\n        //whether to include the sum of this current element in our answer\n        // or not include the sum of current element in our answer\n        // so we explore all possibility and take maximum of them\n        \n        return t[i] = max(currSum + solve(arr, index), solve(arr, i + 1));\n        \n        // If we decide to take the curr element in our answer, then upto the elemet we skip the next value, we paas that index\n        // but if decided no to make this vurrent element then simply paas\n        // i + 1\n    }\n    int deleteAndEarn(vector<int>& arr) {\n        int n = arr.size(); // take the size of the array\n        \n        memset(t, -1, sizeof(t));\n        \n        // sort the array to get rid of all arr[i] - 1 elements\n        sort(arr.begin(), arr.end());\n        \n        // solve function which give us our final answer\n        return solve(arr, 0);\n        //                ↑\n        //                we start from zero index\n    }\n};",
        "explanation": "For the memoziation part, we use a 1 d array to store some already computed results.\nThat's all about dp, nothing much.\nWe have to add just one line (see below)."
    },
    {
        "question_id": "67a2c24b-ead9-43cf-8b80-4313d2a4d5d6",
        "title": "Random Pick with Blacklist",
        "difficulty": "Hard",
        "category": "Array Hash Table Math Binary Search Sorting Randomized",
        "question_text": "You are given an integer n and an array of unique integers blacklist. Design an algorithm to pick a random integer in the range [0, n - 1] that is not in blacklist. Any integer that is in the mentioned range and not in blacklist should be equally likely to be returned.\n\nOptimize your algorithm such that it minimizes the number of calls to the built-in random function of your language.\n\nImplement the Solution class:\n\nSolution(int n, int[] blacklist) Initializes the object with the integer n and the blacklisted integers blacklist.\nint pick() Returns a random integer in the range [0, n - 1] and not in blacklist.\n \n\nExample 1:\n\nInput\n[\"Solution\", \"pick\", \"pick\", \"pick\", \"pick\", \"pick\", \"pick\", \"pick\"]\n[[7, [2, 3, 5]], [], [], [], [], [], [], []]\nOutput\n[null, 0, 4, 1, 6, 1, 0, 4]\n\nExplanation\nSolution solution = new Solution(7, [2, 3, 5]);\nsolution.pick(); // return 0, any integer from [0,1,4,6] should be ok. Note that for every call of pick,\n                 // 0, 1, 4, and 6 must be equally likely to be returned (i.e., with probability 1/4).\nsolution.pick(); // return 4\nsolution.pick(); // return 1\nsolution.pick(); // return 6\nsolution.pick(); // return 1\nsolution.pick(); // return 0\nsolution.pick(); // return 4\n \n\nConstraints:\n\n1 <= n <= 109\n0 <= blacklist.length <= min(105, n - 1)\n0 <= blacklist[i] < n\nAll the values of blacklist are unique.\nAt most 2 * 104 calls will be made to pick.",
        "solution": "class Solution {\n    \n    // N: [0, N)\n    // B: blacklist\n    // B1: < N\n    // B2: >= N\n    // M: N - B1\n    int M;\n    Random r;\n    Map<Integer, Integer> map;\n\n    public Solution(int N, int[] blacklist) {\n        map = new HashMap();\n        for (int b : blacklist) // O(B)\n            map.put(b, -1);\n        M = N - map.size();\n        \n        for (int b : blacklist) { // O(B)\n            if (b < M) { // re-mapping\n                while (map.containsKey(N - 1))\n                    N--;\n                map.put(b, N - 1);\n                N--;\n            }\n        }\n        \n        r = new Random();\n    }\n    \n    public int pick() {\n        int p = r.nextInt(M);\n        if (map.containsKey(p))\n            return map.get(p);\n        return p;\n    }\n}",
        "explanation": "Suppose N=10, blacklist=[3, 5, 8, 9], re-map 3 and 5 to 7 and 6."
    },
    {
        "question_id": "b9456589-f1fa-4c77-b736-f791e20ab9e8",
        "title": "Find Duplicate Subtrees",
        "difficulty": "Medium",
        "category": "Hash Table Tree Depth-First Search Binary Tree",
        "question_text": "For each kind of duplicate subtrees, you only need to return the root node of any one of them.\n\nTwo trees are duplicate if they have the same structure with the same node values.\n\n \n\nExample 1:\nInput: root = [1,2,3,4,null,2,4,null,null,4]\nOutput: [[2,4],[4]]\nExample 2:\nInput: root = [2,1,1]\nOutput: [[1]]\nExample 3:\nInput: root = [2,2,2,3,null,3,null]\nOutput: [[2,3],[3]]\n \n\nConstraints:\n\nThe number of the nodes in the tree will be in the range [1, 5000]\n-200 <= Node.val <= 200",
        "solution": "class Solution {\n   int curId = 1;\n\n    public List<TreeNode> findDuplicateSubtrees(TreeNode root) {\n        Map<String, Integer> serialToId = new HashMap<>();\n        Map<Integer, Integer> idToCount = new HashMap<>();\n        List<TreeNode> res = new LinkedList<>();\n        postorder(root, serialToId, idToCount, res);\n        return res;\n    }\n    \n    private int postorder(TreeNode root, Map<String, Integer> serialToId, Map<Integer, Integer> idToCount, List<TreeNode> res) {\n        if (root == null) return 0;\n        int leftId = postorder(root.left, serialToId, idToCount, res);\n        int rightId = postorder(root.right, serialToId, idToCount, res);\n        String curSerial = leftId + \",\" + root.val + \",\" + rightId;\n        int serialId = serialToId.getOrDefault(curSerial, curId);\n        if (serialId == curId) curId++;\n        serialToId.put(curSerial, serialId);\n        idToCount.put(serialId, idToCount.getOrDefault(serialId, 0) + 1);\n        if (idToCount.get(serialId) == 2) res.add(root);\n        return serialId;\n    }\n    \n}",
        "explanation": "We perform postorder traversal, serializing and hashing the serials of subtrees in the process. We can recognize a duplicate subtree by its serialization.\n\nThe above time complexity is O(n^2). We can improve this to O(n) by replacing full serializations with serial ids instead."
    },
    {
        "question_id": "6e846c2a-231c-4aad-89e0-964a63c9f753",
        "title": "Encode and Decode TinyURL",
        "difficulty": "Medium",
        "category": "Hash Table String Design Hash Function",
        "question_text": "TinyURL is a URL shortening service where you enter a URL such as https://leetcode.com/problems/design-tinyurl and it returns a short URL such as http://tinyurl.com/4e9iAk. Design a class to encode a URL and decode a tiny URL.\n\nThere is no restriction on how your encode/decode algorithm should work. You just need to ensure that a URL can be encoded to a tiny URL and the tiny URL can be decoded to the original URL.\n\nImplement the Solution class:\n\nSolution() Initializes the object of the system.\nString encode(String longUrl) Returns a tiny URL for the given longUrl.\nString decode(String shortUrl) Returns the original long URL for the given shortUrl. It is guaranteed that the given shortUrl was encoded by the same object.\n \n\nExample 1:\n\nInput: url = \"https://leetcode.com/problems/design-tinyurl\"\nOutput: \"https://leetcode.com/problems/design-tinyurl\"\n\nExplanation:\nSolution obj = new Solution();\nstring tiny = obj.encode(url); // returns the encoded tiny url.\nstring ans = obj.decode(tiny); // returns the original url after decoding it.\n \n\nConstraints:\n\n1 <= url.length <= 104\nurl is guranteed to be a valid URL.",
        "solution": "class Codec:\n\n    alphabet = string.ascii_letters + '0123456789'\n\n    def __init__(self):\n        self.url2code = {}\n        self.code2url = {}\n\n    def encode(self, longUrl):\n        while longUrl not in self.url2code:\n            code = ''.join(random.choice(Codec.alphabet) for _ in range(6))\n            if code not in self.code2url:\n                self.code2url[code] = longUrl\n                self.url2code[longUrl] = code\n        return 'http://tinyurl.com/' + self.url2code[longUrl]\n\n    def decode(self, shortUrl):\n        return self.code2url[shortUrl[-6:]]",
        "explanation": "Using increasing numbers as codes like that is simple but has some disadvantages, which the below solution fixes:\n\nIf I'm asked to encode the same long URL several times, it will get several entries. That wastes codes and memory.\nPeople can find out how many URLs have already been encoded. Not sure I want them to know.\nPeople might try to get special numbers by spamming me with repeated requests shortly before their desired number comes up.\nOnly using digits means the codes can grow unnecessarily large. Only offers a million codes with length 6 (or smaller). Using six digits or lower or upper case letters would offer (10+26*2)6 = 56,800,235,584 codes with length 6.\nThe following solution doesn't have these problems. It produces short URLs like http://tinyurl.com/KtLa2U, using a random code of six digits or letters. If a long URL is already known, the existing short URL is used and no new entry is generated."
    },
    {
        "question_id": "70041bd1-a55a-4f8f-8415-99fbd4440c8e",
        "title": "All O`one Data Structure",
        "difficulty": "Hard",
        "category": "Hash Table Linked List Design Doubly-Linked List",
        "question_text": "Design a data structure to store the strings' count with the ability to return the strings with minimum and maximum counts.\n\nImplement the AllOne class:\n\nAllOne() Initializes the object of the data structure.\ninc(String key) Increments the count of the string key by 1. If key does not exist in the data structure, insert it with count 1.\ndec(String key) Decrements the count of the string key by 1. If the count of key is 0 after the decrement, remove it from the data structure. It is guaranteed that key exists in the data structure before the decrement.\ngetMaxKey() Returns one of the keys with the maximal count. If no element exists, return an empty string \"\".\ngetMinKey() Returns one of the keys with the minimum count. If no element exists, return an empty string \"\".\nNote that each function must run in O(1) average time complexity.\n\n \n\nExample 1:\n\nInput\n[\"AllOne\", \"inc\", \"inc\", \"getMaxKey\", \"getMinKey\", \"inc\", \"getMaxKey\", \"getMinKey\"]\n[[], [\"hello\"], [\"hello\"], [], [], [\"leet\"], [], []]\nOutput\n[null, null, null, \"hello\", \"hello\", null, \"hello\", \"leet\"]\n\nExplanation\nAllOne allOne = new AllOne();\nallOne.inc(\"hello\");\nallOne.inc(\"hello\");\nallOne.getMaxKey(); // return \"hello\"\nallOne.getMinKey(); // return \"hello\"\nallOne.inc(\"leet\");\nallOne.getMaxKey(); // return \"hello\"\nallOne.getMinKey(); // return \"leet\"\n \n\nConstraints:\n\n1 <= key.length <= 10\nkey consists of lowercase English letters.\nIt is guaranteed that for each call to dec, key is existing in the data structure.\nAt most 5 * 104 calls will be made to inc, dec, getMaxKey, and getMinKey.",
        "solution": "class Node {\npublic:\n    int freq;\n    Node* prev;\n    Node* next;\n    unordered_set<string> keys;\n\n    Node(int freq) : freq(freq), prev(nullptr), next(nullptr) {}\n};\n\nclass AllOne {\nprivate:\n    Node* head;                        // Dummy head\n    Node* tail;                        // Dummy tail\n    unordered_map<string, Node*> map;  // Mapping from key to its node\n\npublic:\n    // Initialize your data structure here.\n    AllOne() {\n        head = new Node(0);  // Create dummy head\n        tail = new Node(0);  // Create dummy tail\n        head->next = tail;   // Link dummy head to dummy tail\n        tail->prev = head;   // Link dummy tail to dummy head\n    }\n\n    // Inserts a new key <Key> with value 1. Or increments an existing key by 1.\n    void inc(string key) {\n        if (map.find(key) != map.end()) {\n            Node* node = map[key];\n            int freq = node->freq;\n            node->keys.erase(key);  // Remove key from current node\n\n            Node* nextNode = node->next;\n            if (nextNode == tail || nextNode->freq != freq + 1) {\n                // Create a new node if next node does not exist or freq is not\n                // freq + 1\n                Node* newNode = new Node(freq + 1);\n                newNode->keys.insert(key);\n                newNode->prev = node;\n                newNode->next = nextNode;\n                node->next = newNode;\n                nextNode->prev = newNode;\n                map[key] = newNode;\n            } else {\n                // Increment the existing next node\n                nextNode->keys.insert(key);\n                map[key] = nextNode;\n            }\n\n            // Remove the current node if it has no keys left\n            if (node->keys.empty()) {\n                removeNode(node);\n            }\n        } else {  // Key does not exist\n            Node* firstNode = head->next;\n            if (firstNode == tail || firstNode->freq > 1) {\n                // Create a new node\n                Node* newNode = new Node(1);\n                newNode->keys.insert(key);\n                newNode->prev = head;\n                newNode->next = firstNode;\n                head->next = newNode;\n                firstNode->prev = newNode;\n                map[key] = newNode;\n            } else {\n                firstNode->keys.insert(key);\n                map[key] = firstNode;\n            }\n        }\n    }\n\n    // Decrements an existing key by 1. If Key's value is 1, remove it from the\n    // data structure.\n    void dec(string key) {\n        if (map.find(key) == map.end()) {\n            return;  // Key does not exist\n        }\n\n        Node* node = map[key];\n        node->keys.erase(key);\n        int freq = node->freq;\n\n        if (freq == 1) {\n            // Remove the key from the map if freq is 1\n            map.erase(key);\n        } else {\n            Node* prevNode = node->prev;\n            if (prevNode == head || prevNode->freq != freq - 1) {\n                // Create a new node if the previous node does not exist or freq\n                // is not freq - 1\n                Node* newNode = new Node(freq - 1);\n                newNode->keys.insert(key);\n                newNode->prev = prevNode;\n                newNode->next = node;\n                prevNode->next = newNode;\n                node->prev = newNode;\n                map[key] = newNode;\n            } else {\n                // Decrement the existing previous node\n                prevNode->keys.insert(key);\n                map[key] = prevNode;\n            }\n        }\n\n        // Remove the node if it has no keys left\n        if (node->keys.empty()) {\n            removeNode(node);\n        }\n    }\n\n    // Returns one of the keys with maximal value.\n    string getMaxKey() {\n        if (tail->prev == head) {\n            return \"\";  // No keys exist\n        }\n        return *(tail->prev->keys.begin());  // Return one of the keys from the\n                                             // tail's previous node\n    }\n\n    // Returns one of the keys with minimal value.\n    string getMinKey() {\n        if (head->next == tail) {\n            return \"\";  // No keys exist\n        }\n        return *(\n            head->next->keys\n                .begin());  // Return one of the keys from the head's next node\n    }\n\nprivate:\n    void removeNode(Node* node) {\n        Node* prevNode = node->prev;\n        Node* nextNode = node->next;\n\n        prevNode->next = nextNode;  // Link previous node to next node\n        nextNode->prev = prevNode;  // Link next node to previous node\n\n        delete node;  // Free the memory of the removed node\n    }\n};",
        "explanation": "Using Doubly Linked List\nIntuition\nTo manage a collection of keys and their frequencies, we need a structure that updates easily and provides quick access to maximum and minimum frequencies. We start with a hashmap to look up each key’s frequency quickly.\n\nHowever, a hashmap alone does not track frequencies well. We need a way to group keys by their frequencies and find keys with the same frequency. We use a doubly linked list for this. Each node represents a frequency and holds all keys linked to that frequency. This setup allows us to add and remove keys efficiently as their frequencies change.\n\nTo handle edge cases better, we include dummy head and tail nodes in the list. These nodes make it easier to manage operations when the list is empty or when we add or remove nodes at the ends.\n\nWhen we increment a key, we first check if it exists in the hashmap. If the key is new, we look at the node after the dummy head. If that node does not have a frequency of 1, we create a new node for frequency 1. We add the key to this node and update the hashmap. If the key already exists, we find its current frequency node and check the next node, which shows the next higher frequency. If that next node is the tail or does not have the expected frequency, we create a new node with the increased frequency. We then move the key to the right node, remove it from the old node, and delete the old node if it becomes empty.\n\nWhen we decrement a key, we first check if it is in the hashmap. If it is, we remove it from its current node. If the key’s frequency is greater than one, we check the previous node. If needed, we create a new node for the decreased frequency and add the key to the appropriate previous node, updating the hashmap. If the frequency is one, we remove the key from the hashmap completely.\n\nTo find the key with the maximum frequency, we return one of the keys from the last node in the list. For the minimum frequency key, we get a key from the first node after the dummy head. If there are no keys, we return an empty string."
    },
    {
        "question_id": "a9554ee0-ae3b-41cc-baf9-b1c15f11ddad",
        "title": "Insert Delete GetRandom O(1) - Duplicates allowed",
        "difficulty": "Hard",
        "category": "Array Hash Table Math Design Randomized",
        "question_text": "RandomizedCollection is a data structure that contains a collection of numbers, possibly duplicates (i.e., a multiset). It should support inserting and removing specific elements and also reporting a random element.\n\nImplement the RandomizedCollection class:\n\nRandomizedCollection() Initializes the empty RandomizedCollection object.\nbool insert(int val) Inserts an item val into the multiset, even if the item is already present. Returns true if the item is not present, false otherwise.\nbool remove(int val) Removes an item val from the multiset if present. Returns true if the item is present, false otherwise. Note that if val has multiple occurrences in the multiset, we only remove one of them.\nint getRandom() Returns a random element from the current multiset of elements. The probability of each element being returned is linearly related to the number of the same values the multiset contains.\nYou must implement the functions of the class such that each function works on average O(1) time complexity.\n\nNote: The test cases are generated such that getRandom will only be called if there is at least one item in the RandomizedCollection.\n\n \n\nExample 1:\n\nInput\n[\"RandomizedCollection\", \"insert\", \"insert\", \"insert\", \"getRandom\", \"remove\", \"getRandom\"]\n[[], [1], [1], [2], [], [1], []]\nOutput\n[null, true, false, true, 2, true, 1]\n\nExplanation\nRandomizedCollection randomizedCollection = new RandomizedCollection();\nrandomizedCollection.insert(1);   // return true since the collection does not contain 1.\n                                  // Inserts 1 into the collection.\nrandomizedCollection.insert(1);   // return false since the collection contains 1.\n                                  // Inserts another 1 into the collection. Collection now contains [1,1].\nrandomizedCollection.insert(2);   // return true since the collection does not contain 2.\n                                  // Inserts 2 into the collection. Collection now contains [1,1,2].\nrandomizedCollection.getRandom(); // getRandom should:\n                                  // - return 1 with probability 2/3, or\n                                  // - return 2 with probability 1/3.\nrandomizedCollection.remove(1);   // return true since the collection contains 1.\n                                  // Removes 1 from the collection. Collection now contains [1,2].\nrandomizedCollection.getRandom(); // getRandom should return 1 or 2, both equally likely.\n \n\nConstraints:\n\n-231 <= val <= 231 - 1\nAt most 2 * 105 calls in total will be made to insert, remove, and getRandom.\nThere will be at least one element in the data structure when getRandom is called.",
        "solution": "from collections import defaultdict\nfrom random import choice\n\nclass RandomizedCollection:\n\n    def __init__(self):\n        \"\"\"\n        Initialize your data structure here.\n        \"\"\"\n        self.lst = []\n        self.idx = defaultdict(set)\n\n\n    def insert(self, val: int) -> bool:\n        \"\"\"\n        Inserts a value to the collection. Returns true if the collection did not already contain the specified element.\n        \"\"\"\n        self.idx[val].add(len(self.lst))\n        self.lst.append(val)\n        return len(self.idx[val]) == 1\n\n\n    def remove(self, val: int) -> bool:\n        \"\"\"\n        Removes a value from the collection. Returns true if the collection contained the specified element.\n        \"\"\"\n        if not self.idx[val]: return False\n        remove, last = self.idx[val].pop(), self.lst[-1]\n        self.lst[remove] = last\n        self.idx[last].add(remove)\n        self.idx[last].discard(len(self.lst) - 1)\n\n        self.lst.pop()\n        return True\n\n\n    def getRandom(self) -> int:\n        \"\"\"\n        Get a random element from the collection.\n        \"\"\"\n        return choice(self.lst)",
        "explanation": "ArrayList + HashMap\nAlgorithm\n\nWe will keep a list to store all our elements. In order to make finding the index of elements we want to remove O(1), we will use a HashMap or dictionary to map values to all indices that have those values. To make this work each value will be mapped to a set of indices. The tricky part is properly updating the HashMap as we modify the list.\n\ninsert: Append the element to the list and add the index to HashMap[element].\nremove: This is the tricky part. We find the index of the element using the HashMap. We use the trick discussed in the intuition to remove the element from the list in O(1). Since the last element in the list gets moved around, we have to update its value in the HashMap. We also have to get rid of the index of the element we removed from the HashMap.\ngetRandom: Sample a random element from the list.\n\nComplexity Analysis\n\nTime complexity : O(N), with N being the number of operations. All of our operations are O(1), giving N∗O(1)=O(N).\n\nSpace complexity : O(N), with N being the number of operations. The worst case scenario is if we get N add operations, in which case our ArrayList and our HashMap grow to size N."
    },
    {
        "question_id": "63592949-5b5f-4783-8cfe-e9023e6df924",
        "title": "Repeated DNA Sequences",
        "difficulty": "Medium",
        "category": "Hash Table String Bit Manipulation Sliding Window Rolling Hash Hash Function",
        "question_text": "The DNA sequence is composed of a series of nucleotides abbreviated as 'A', 'C', 'G', and 'T'.\n\nFor example, \"ACGAATTCCG\" is a DNA sequence.\nWhen studying DNA, it is useful to identify repeated sequences within the DNA.\n\nGiven a string s that represents a DNA sequence, return all the 10-letter-long sequences (substrings) that occur more than once in a DNA molecule. You may return the answer in any order.\n\n \n\nExample 1:\n\nInput: s = \"AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT\"\nOutput: [\"AAAAACCCCC\",\"CCCCCAAAAA\"]\nExample 2:\n\nInput: s = \"AAAAAAAAAAAAA\"\nOutput: [\"AAAAAAAAAA\"]\n \n\nConstraints:\n\n1 <= s.length <= 105\ns[i] is either 'A', 'C', 'G', or 'T'.",
        "solution": "class Solution {\n\tpublic List<String> findRepeatedDnaSequences(String s) {\n\t\tif(s == null || s.length() < 10) {\n\t\t\treturn Collections.emptyList();\n\t\t}\n\t\tint start = 0;\n\t\tint end = 10;\n\t\tSet<String> set = new HashSet<>();\n\t\tSet<String> result = new HashSet<>();\n\t\tStringBuilder builder = new StringBuilder(s);\n\t\twhile(end <= s.length()) {            \n\t\t\t//String curr = s.substring(start,end);   \n\t\t\t//builder is faster, so using builder below\n\t\t\tString curr = builder.substring(start,end);   \n\t\t\tif(set.contains(curr)) {\n\t\t\t\tresult.add(curr);\n\t\t\t}\n\t\t\tset.add(curr);\n\t\t\tstart++;\n\t\t\tend++;\n\t\t}\n\t\treturn new ArrayList<>(result);\n\t}\n}",
        "explanation": "Time complexity is O(n) where n is length of input string s\nwhile loop runs O(n) times and substring method O(m) where is m is length of substring\nit is not O(n^2) as you think, because the subString method is O(1) because m = 10 is constant\nSpace is O(p) where p is total number of subSequences"
    },
    {
        "question_id": "9b3a21b2-a8c2-4587-bbfc-16f19a162b79",
        "title": "Majority Element",
        "difficulty": "Easy",
        "category": "Array Hash Table Divide and Conquer Sorting Counting",
        "question_text": "The DNA sequence is composed of a series of nucleotides abbreviated as 'A', 'C', 'G', and 'T'.\n\nFor example, \"ACGAATTCCG\" is a DNA sequence.\nWhen studying DNA, it is useful to identify repeated sequences within the DNA.\n\nGiven a string s that represents a DNA sequence, return all the 10-letter-long sequences (substrings) that occur more than once in a DNA molecule. You may return the answer in any order.\n\n \n\nExample 1:\n\nInput: s = \"AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT\"\nOutput: [\"AAAAACCCCC\",\"CCCCCAAAAA\"]\nExample 2:\n\nInput: s = \"AAAAAAAAAAAAA\"\nOutput: [\"AAAAAAAAAA\"]\n \n\nConstraints:\n\n1 <= s.length <= 105\ns[i] is either 'A', 'C', 'G', or 'T'.",
        "solution": "class Solution {\npublic:\n    int majorityElement(vector<int>& nums) {\n        int count = 0;\n        int candidate = 0;\n        \n        for (int num : nums) {\n            if (count == 0) {\n                candidate = num;\n            }\n            \n            if (num == candidate) {\n                count++;\n            } else {\n                count--;\n            }\n        }\n        \n        return candidate;\n    }\n};",
        "explanation": "Intuition:\nThe intuition behind the Moore's Voting Algorithm is based on the fact that if there is a majority element in an array, it will always remain in the lead, even after encountering other elements.\n\nExplanation:\nAlgorithm:\n\nInitialize two variables: count and candidate. Set count to 0 and candidate to an arbitrary value.\nIterate through the array nums:\na. If count is 0, assign the current element as the new candidate and increment count by 1.\nb. If the current element is the same as the candidate, increment count by 1.\nc. If the current element is different from the candidate, decrement count by 1.\nAfter the iteration, the candidate variable will hold the majority element.\nExplanation:\n\nThe algorithm starts by assuming the first element as the majority candidate and sets the count to 1.\nAs it iterates through the array, it compares each element with the candidate:\na. If the current element matches the candidate, it suggests that it reinforces the majority element because it appears again. Therefore, the count is incremented by 1.\nb. If the current element is different from the candidate, it suggests that there might be an equal number of occurrences of the majority element and other elements. Therefore, the count is decremented by 1.\nNote that decrementing the count doesn't change the fact that the majority element occurs more than n/2 times.\nIf the count becomes 0, it means that the current candidate is no longer a potential majority element. In this case, a new candidate is chosen from the remaining elements.\nThe algorithm continues this process until it has traversed the entire array.\nThe final value of the candidate variable will hold the majority element.\nExplanation of Correctness:\nThe algorithm works on the basis of the assumption that the majority element occurs more than n/2 times in the array. This assumption guarantees that even if the count is reset to 0 by other elements, the majority element will eventually regain the lead.\n\nLet's consider two cases:\n\nIf the majority element has more than n/2 occurrences:\n\nThe algorithm will ensure that the count remains positive for the majority element throughout the traversal, guaranteeing that it will be selected as the final candidate.\nIf the majority element has exactly n/2 occurrences:\n\nIn this case, there will be an equal number of occurrences for the majority element and the remaining elements combined.\nHowever, the majority element will still be selected as the final candidate because it will always have a lead over any other element.\nIn both cases, the algorithm will correctly identify the majority element.\n\nThe time complexity of the Moore's Voting Algorithm is O(n) since it traverses the array once.\n\nThis approach is efficient compared to sorting as it requires only a single pass through the array and does not change the original order of the elements."
    },
    {
        "question_id": "0b41ec80-41e7-43ee-9d52-73537691625e",
        "title": "Sudoku Solver",
        "difficulty": "Hard",
        "category": "Array Hash Table Backtracking Matrix",
        "question_text": "Write a program to solve a Sudoku puzzle by filling the empty cells.\n\nA sudoku solution must satisfy all of the following rules:\n\nEach of the digits 1-9 must occur exactly once in each row.\nEach of the digits 1-9 must occur exactly once in each column.\nEach of the digits 1-9 must occur exactly once in each of the 9 3x3 sub-boxes of the grid.\nThe '.' character indicates empty cells.\n\n \n\nExample 1:\nInput: board = [[\"5\",\"3\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\"],[\"6\",\".\",\".\",\"1\",\"9\",\"5\",\".\",\".\",\".\"],[\".\",\"9\",\"8\",\".\",\".\",\".\",\".\",\"6\",\".\"],[\"8\",\".\",\".\",\".\",\"6\",\".\",\".\",\".\",\"3\"],[\"4\",\".\",\".\",\"8\",\".\",\"3\",\".\",\".\",\"1\"],[\"7\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\",\"6\"],[\".\",\"6\",\".\",\".\",\".\",\".\",\"2\",\"8\",\".\"],[\".\",\".\",\".\",\"4\",\"1\",\"9\",\".\",\".\",\"5\"],[\".\",\".\",\".\",\".\",\"8\",\".\",\".\",\"7\",\"9\"]]\nOutput: [[\"5\",\"3\",\"4\",\"6\",\"7\",\"8\",\"9\",\"1\",\"2\"],[\"6\",\"7\",\"2\",\"1\",\"9\",\"5\",\"3\",\"4\",\"8\"],[\"1\",\"9\",\"8\",\"3\",\"4\",\"2\",\"5\",\"6\",\"7\"],[\"8\",\"5\",\"9\",\"7\",\"6\",\"1\",\"4\",\"2\",\"3\"],[\"4\",\"2\",\"6\",\"8\",\"5\",\"3\",\"7\",\"9\",\"1\"],[\"7\",\"1\",\"3\",\"9\",\"2\",\"4\",\"8\",\"5\",\"6\"],[\"9\",\"6\",\"1\",\"5\",\"3\",\"7\",\"2\",\"8\",\"4\"],[\"2\",\"8\",\"7\",\"4\",\"1\",\"9\",\"6\",\"3\",\"5\"],[\"3\",\"4\",\"5\",\"2\",\"8\",\"6\",\"1\",\"7\",\"9\"]]\nExplanation: The input board is shown above and the only valid solution is shown below:\n\nConstraints:\n\nboard.length == 9\nboard[i].length == 9\nboard[i][j] is a digit or '.'.\nIt is guaranteed that the input board has only one solution.",
        "solution": "class Solution {\npublic:\n    void solveSudoku(vector<vector<char>>& board) {\n        solve(board);\n    }\n\nprivate:\n    bool solve(vector<vector<char>>& board) {\n        for (int row = 0; row < 9; row++) {\n            for (int col = 0; col < 9; col++) {\n                if (board[row][col] == '.') {\n                    for (char num = '1'; num <= '9'; num++) {\n                        if (isValid(board, row, col, num)) {\n                            board[row][col] = num;\n                            if (solve(board)) return true;\n                            board[row][col] = '.';\n                        }\n                    }\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n\n    bool isValid(vector<vector<char>>& board, int row, int col, char num) {\n        for (int i = 0; i < 9; i++) {\n            if (board[row][i] == num || board[i][col] == num) return false;\n        }\n        int startRow = (row / 3) * 3, startCol = (col / 3) * 3;\n        for (int i = startRow; i < startRow + 3; i++) {\n            for (int j = startCol; j < startCol + 3; j++) {\n                if (board[i][j] == num) return false;\n            }\n        }\n        return true;\n    }\n};",
        "explanation": "Intuition\nTo solve a Sudoku puzzle, try to place numbers one by one in each cell, ensuring that the number placement obeys the Sudoku rules. If placing a number leads to a valid board configuration, continue; otherwise, backtrack by removing the number.\n\nApproach\nTraverse the board cell by cell:\nIf a cell is empty, try placing each number from 1 to 9.\nAfter placing a number, check if the board remains valid.\nRecursively attempt to solve the remaining board with the current placement.\nIf the placement fails, reset the cell and try the next number.\nUse backtracking to explore all possible configurations until the board is solved.\nComplexity\nTime complexity:\nO(9 \n(n×n)\n ) where ( n = 9 ), due to backtracking over each cell and number combination.\n\nSpace complexity:\nO(n \n2\n ) due to recursive stack usage in backtracking."
    },
    {
        "question_id": "83dd40cf-ebad-4a5b-add2-ee4699adb157",
        "title": "Rotate Image",
        "difficulty": "Medium",
        "category": "Array Math Matrix",
        "question_text": "You are given an n x n 2D matrix representing an image, rotate the image by 90 degrees (clockwise).\n\nYou have to rotate the image in-place, which means you have to modify the input 2D matrix directly. DO NOT allocate another 2D matrix and do the rotation.\n\n \n\nExample 1:\nInput: matrix = [[1,2,3],[4,5,6],[7,8,9]]\nOutput: [[7,4,1],[8,5,2],[9,6,3]]\nExample 2:\nInput: matrix = [[5,1,9,11],[2,4,8,10],[13,3,6,7],[15,14,12,16]]\nOutput: [[15,13,2,5],[14,3,4,1],[12,6,8,9],[16,7,10,11]]\n \n\nConstraints:\n\nn == matrix.length == matrix[i].length\n1 <= n <= 20\n-1000 <= matrix[i][j] <= 1000",
        "solution": "class Solution {\npublic:\n    void rotate(vector<vector<int>>& matrix) {\n        int row = matrix.size();\n        for(int i=0;i<row; i++){\n            for(int j=0; j<=i;j++){\n                swap(matrix[i][j], matrix[j][i]);\n            }\n        }\n        for(int i=0;i<row;i++){\n            reverse(matrix[i].begin(), matrix[i].end());\n        }\n    }\n};",
        "explanation": "Approach\n2 Steps to rotate image\n\nTranspose the matrix\nSwap the columns"
    },
    {
        "question_id": "b9fd67df-a486-4ec6-8f13-571c860b63f5",
        "title": "Pow(x, n)",
        "difficulty": "Medium",
        "category": "Math Recursion",
        "question_text": "Implement pow(x, n), which calculates x raised to the power n (i.e., xn).\n\n \n\nExample 1:\n\nInput: x = 2.00000, n = 10\nOutput: 1024.00000\nExample 2:\n\nInput: x = 2.10000, n = 3\nOutput: 9.26100\nExample 3:\n\nInput: x = 2.00000, n = -2\nOutput: 0.25000\nExplanation: 2-2 = 1/22 = 1/4 = 0.25\n \n\nConstraints:\n\n-100.0 < x < 100.0\n-231 <= n <= 231-1\nn is an integer.\nEither x is not zero or n > 0.\n-104 <= xn <= 104",
        "solution": "class Solution {\npublic:\n    double myPow(double x, int n) {\n        return binaryExp(x, static_cast<long>(n));\n    }\n\nprivate:\n    double binaryExp(double x, long n) {\n        if (n == 0) {\n            return 1;\n        }\n       \n        if (n < 0) {\n            return 1.0 / binaryExp(x, -n);\n        }\n       \n        if (n % 2 == 1) {\n            return x * binaryExp(x * x, (n - 1) / 2);\n        } else {\n            return binaryExp(x * x, n / 2);\n        }\n    }\n};",
        "explanation": "Approach\nThis is based on Python Code. Other language might be different a bit.\n\nDefine the myPow function that takes two parameters: x (the base) and n (the exponent). The function returns the value of x raised to the power of n.\n\nDefine a helper function calc_power(x, n) that will be used for the recursive calculation. This function takes two parameters: x (the base) and n (the exponent).\n\nIn the calc_power function:\n\nCheck the base case: If x is 0, return 0 (as anything raised to the power of 0 is 1).\nCheck another base case: If n is 0, return 1 (as anything raised to the power of 0 is 1).\nIf n is even, recursively calculate res by calling calc_power(x, n // 2) and then square res (res = res * res).\nIf n is odd, recursively calculate res by calling calc_power(x, (n - 1) // 2) and then square res, finally multiply it with x (res = res * res * x).\nNow, in the myPow function:\n\nGet the absolute value of n using abs(n) and store it in a variable abs_n.\nCalculate ans by calling calc_power(x, abs_n), which gives us the value of x raised to the power of abs_n.\nIf n is non-negative (n >= 0), return ans.\n\nIf n is negative (n < 0), return 1 / ans (which gives us the result of x raised to the power of -n, i.e., the reciprocal).\nThe algorithm takes advantage of the properties of exponents and the concept that x^(n) can be calculated using x^(n/2) to avoid redundant calculations and improve the efficiency of the power calculation."
    },
    {
        "question_id": "95d1d8d9-d995-41e9-8e5f-68e84e984cb1",
        "title": "Add Binary",
        "difficulty": "Easy",
        "category": "Math String Bit Manipulation Simulation",
        "question_text": "Given two binary strings a and b, return their sum as a binary string.\n\n \n\nExample 1:\n\nInput: a = \"11\", b = \"1\"\nOutput: \"100\"\nExample 2:\n\nInput: a = \"1010\", b = \"1011\"\nOutput: \"10101\"\n \n\nConstraints:\n\n1 <= a.length, b.length <= 104\na and b consist only of '0' or '1' characters.\nEach string does not contain leading zeros except for the zero itself.",
        "solution": "class Solution {\n public:\n  string addBinary(string a, string b) {\n    string ans;\n    int carry = 0;\n    int i = a.length() - 1;\n    int j = b.length() - 1;\n\n    while (i >= 0 || j >= 0 || carry) {\n      if (i >= 0)\n        carry += a[i--] - '0';\n      if (j >= 0)\n        carry += b[j--] - '0';\n      ans += carry % 2 + '0';\n      carry /= 2;\n    }\n\n    reverse(begin(ans), end(ans));\n    return ans;\n  }\n};",
        "explanation": "Intuition :\nWe have to add two binary numbers (made up of 0's and 1's) and returns the result in binary.\nApproach :\nWe start at the right end of each binary number, adding the digits and any carry-over value, and storing the result in a new string.\nNow we move to the next digit on the left and repeats the process until it has gone through all the digits in both binary numbers.\nIf there is any carry-over value after adding all the digits, append it to the end of the new string.\nFinally, the new string is reversed and returned as the sum of the two binary numbers."
    },
    {
        "question_id": "c6444c79-5b50-4da1-bc91-8ec6b6c09633",
        "title": "Can I Win",
        "difficulty": "Medium",
        "category": "Math Dynamic Programming Bit Manipulation Memoization Game Theory Bitmask",
        "question_text": "In the \"100 game\" two players take turns adding, to a running total, any integer from 1 to 10. The player who first causes the running total to reach or exceed 100 wins.\n\nWhat if we change the game so that players cannot re-use integers?\n\nFor example, two players might take turns drawing from a common pool of numbers from 1 to 15 without replacement until they reach a total >= 100.\n\nGiven two integers maxChoosableInteger and desiredTotal, return true if the first player to move can force a win, otherwise, return false. Assume both players play optimally.\n\n \n\nExample 1:\n\nInput: maxChoosableInteger = 10, desiredTotal = 11\nOutput: false\nExplanation:\nNo matter which integer the first player choose, the first player will lose.\nThe first player can choose an integer from 1 up to 10.\nIf the first player choose 1, the second player can only choose integers from 2 up to 10.\nThe second player will win by choosing 10 and get a total = 11, which is >= desiredTotal.\nSame with other integers chosen by the first player, the second player will always win.\nExample 2:\n\nInput: maxChoosableInteger = 10, desiredTotal = 0\nOutput: true\nExample 3:\n\nInput: maxChoosableInteger = 10, desiredTotal = 1\nOutput: true\n \n\nConstraints:\n\n1 <= maxChoosableInteger <= 20\n0 <= desiredTotal <= 300",
        "solution": "class Solution:\n    def canIWin(self, maxChoosableInteger, desiredTotal):\n        \"\"\"\n        :type maxChoosableInteger: int\n        :type desiredTotal: int\n        :rtype: bool\n        \"\"\"\n        seen = {}\n\n        def can_win(choices, remainder):\n            # if the largest choice exceeds the remainder, then we can win!\n            if choices[-1] >= remainder:\n                return True\n\n            # if we have seen this exact scenario play out, then we know the outcome\n            seen_key = tuple(choices)\n            if seen_key in seen:\n                return seen[seen_key]\n\n            # we haven't won yet.. it's the next player's turn.\n            for index in range(len(choices)):\n                if not can_win(choices[:index] + choices[index + 1:], remainder - choices[index]):\n                    seen[seen_key] = True\n                    return True\n\n            # uh-oh if we got here then next player won all permutations, we can't force their hand\n            # actually, they were able to force our hand :(\n            seen[seen_key] = False\n            return False\n\n        # let's do some quick checks before we journey through the tree of permutations\n        summed_choices = (maxChoosableInteger + 1) * maxChoosableInteger / 2\n\n        # if all the choices added up are less then the total, no-one can win\n        if summed_choices < desiredTotal:\n            return False\n\n        # if the sum matches desiredTotal exactly then you win if there's an odd number of turns\n        if summed_choices == desiredTotal:\n\t\t    return maxChoosableInteger % 2\n\n        # slow: time to go through the tree of permutations\n\t\tchoices = list(range(1, maxChoosableInteger + 1))\n        return can_win(choices, desiredTotal)",
        "explanation": "no explanation"
    },
    {
        "question_id": "67675ff0-b820-4c0b-9823-d47af128c715",
        "title": "Arranging Coins",
        "difficulty": "Easy",
        "category": "Math Binary Search",
        "question_text": "You have n coins and you want to build a staircase with these coins. The staircase consists of k rows where the ith row has exactly i coins. The last row of the staircase may be incomplete.\n\nGiven the integer n, return the number of complete rows of the staircase you will build.\n\n \n\nExample 1:\nInput: n = 5\nOutput: 2\nExplanation: Because the 3rd row is incomplete, we return 2.\nExample 2:\nInput: n = 8\nOutput: 3\nExplanation: Because the 4th row is incomplete, we return 3.\n \n\nConstraints:\n\n1 <= n <= 231 - 1",
        "solution": "import math\n\nclass Solution(object):\n    def arrangeCoins(self, n):\n        return int((math.sqrt(8 * n + 1) - 1) // 2)",
        "explanation": "Intuition\nThis is about forming full staircase rows with coins: row i needs i coins. The total coins used for k full rows is the sum of 1 + 2 + ... + k = k(k+1)/2. Solve this inequality for k.\n\nApproach\nUse the quadratic formula to solve:\n\nk(k + 1)/2 <= n\n=> k² + k - 2n <= 0\nUsing the positive root of the quadratic equation, compute:\n\nk = (sqrt(8n + 1) - 1) / 2\nThen return the floor of k.\n\nComplexity\nTime Complexity: ( O(1) ) — single math operation.\nSpace Complexity: ( O(1) ) — no extra space."
    },
    {
        "question_id": "4fb7fb94-b0fc-4618-83ae-2c48fac22884",
        "title": "Generate Random Point in a Circle",
        "difficulty": "Medium",
        "category": "Math Geometry Rejection Sampling Randomized",
        "question_text": "Given the radius and the position of the center of a circle, implement the function randPoint which generates a uniform random point inside the circle.\n\nImplement the Solution class:\n\nSolution(double radius, double x_center, double y_center) initializes the object with the radius of the circle radius and the position of the center (x_center, y_center).\nrandPoint() returns a random point inside the circle. A point on the circumference of the circle is considered to be in the circle. The answer is returned as an array [x, y].\n \n\nExample 1:\n\nInput\n[\"Solution\", \"randPoint\", \"randPoint\", \"randPoint\"]\n[[1.0, 0.0, 0.0], [], [], []]\nOutput\n[null, [-0.02493, -0.38077], [0.82314, 0.38945], [0.36572, 0.17248]]\n\nExplanation\nSolution solution = new Solution(1.0, 0.0, 0.0);\nsolution.randPoint(); // return [-0.02493, -0.38077]\nsolution.randPoint(); // return [0.82314, 0.38945]\nsolution.randPoint(); // return [0.36572, 0.17248]\n \n\nConstraints:\n\n0 < radius <= 108\n-107 <= x_center, y_center <= 107\nAt most 3 * 104 calls will be made to randPoint.",
        "solution": "class Solution:\n    def __init__(self, radius, x_center, y_center):\n        self.r, self.x, self.y = radius, x_center, y_center\n\n    def randPoint(self):\n        theta = uniform(0,2*pi)\n        R = self.r*sqrt(uniform(0,1))\n        return [self.x + R*cos(theta), self.y + R*sin(theta)]",
        "explanation": "Imagine first special case for this problem: we have circle with radius equal to 1 and coordinates of center is (0, 0). Let us use polar coordinates:\nx = R * cos(theta)\ny = R * sin(theta).\nHere R is distance between our point (call it A) and the origin (call it O). theta is angle between OA and axis OX.\nWhy it is good idea to go to polar coordinates here? Because in polar coordiantes unity circle can be written as:\nR <= 1\n0 <= theta <= 2*pi.\n\nNow we need to answer two qustions: how to generate R and how to generate theta.\n\nAbout theta it is quite obvious: we do it uniformly.\nAbout R it is not obvious: if we do it uniformly, there will be more points closer if we generate it in uniform way. Look at this intuition: let us fix R = 1 and generate 10 points, then fix R = 0.5 and generate 10 more points. What you can see? Distance between points on the big circle is in average 2 times bigger, than between 2 points on smaller circle. It actually means, that for small circle you need to generate only 5 points, not 10, and by this logic if you have x points for circle with R = 1, you need x*R points for smaller radius.\nThis was intuition, now let go into mathematics: what does uniform distribution means, that if we choose small element inside our circle, than probability to get inside this element should be proportional to area of this element. Let us define F(R) cumulative distribution function (cdf) for radius. Then by definition probability to get between R and R + dR is equal to F(R + dR) - F(R) = f(R)*dR, where f(R) is probability density function (pdf), so probability to get into this small region is f(R)* dR * dTheta. From other point of view, area of this region can be calclated as [(R+dR)^2 - R^2]*dTheta = 2*R*dR*dTheta. From here we get, that f(R) = c*R for some constant c (because we say it is proportional, not equal). Now, F'(R) = f(R), so F(R) = c*R^2 (here c is another conatant). Now the question is how you generate data such that cumulative function is proportional to R^2. The answer is Inverse transform sampling (check wikipedia), where idea is given uniform distribution generate data from any distribution F(R): we need to generate R from uniform distrubution and than apply inverse function, that is we have sqrt(uniform(0,1)) in the end."
    },
    {
        "question_id": "71ab2f20-49bb-4d58-ad4a-df2761c6f2a3",
        "title": "Base 7",
        "difficulty": "Easy",
        "category": "Math",
        "question_text": "Given an integer num, return a string of its base 7 representation.\n\n \n\nExample 1:\n\nInput: num = 100\nOutput: \"202\"\nExample 2:\n\nInput: num = -7\nOutput: \"-10\"\n \n\nConstraints:\n\n-107 <= num <= 107",
        "solution": "class Solution {\npublic:\n    string convertToBase7(int num) {\n        if (num == 0) return \"0\";\n        string res;\n        bool neg = num < 0;\n        num = abs(num);\n        while (num > 0) {\n            res = to_string(num % 7) + res;\n            num /= 7;\n        }\n        return neg ? \"-\" + res : res;\n    }\n};",
        "explanation": "Intuition\nThe simplest way to convert a number to base 7 is by leveraging built-in conversion functions. Many languages have direct methods to convert a number to a different base.\n\nApproach\nUse a built-in function (if available) to convert num to a base 7 string.\n\nIf not available, manually implement base conversion by repeatedly dividing the number by 7 and collecting remainders.\n\nComplexity\nTime complexity: O(log n)\nSince the number is divided by 7 in each step\n\nSpace complexity: O(1)\nConstant space usage"
    },
    {
        "question_id": "96cd0883-7761-4a3c-9ac9-ef643a84aa65",
        "title": "Self Dividing Numbers",
        "difficulty": "Easy",
        "category": "Math",
        "question_text": "A self-dividing number is a number that is divisible by every digit it contains.\n\nFor example, 128 is a self-dividing number because 128 % 1 == 0, 128 % 2 == 0, and 128 % 8 == 0.\nA self-dividing number is not allowed to contain the digit zero.\n\nGiven two integers left and right, return a list of all the self-dividing numbers in the range [left, right] (both inclusive).\n\n \n\nExample 1:\n\nInput: left = 1, right = 22\nOutput: [1,2,3,4,5,6,7,8,9,11,12,15,22]\nExample 2:\n\nInput: left = 47, right = 85\nOutput: [48,55,66,77]\n \n\nConstraints:\n\n1 <= left <= right <= 104",
        "solution": "class Solution:\n    def selfDividingNumbers(self, left: int, right: int) -> List[int]:\n        # Helper function to check if a number is self-dividing\n        def self_dividing(n: int) -> bool:\n            for d in str(n):\n                if d == \"0\" or n % int(d) > 0:\n                    return False\n            return True\n\n        \"\"\"\n        def self_dividing(n: int) -> bool:\n            x = n\n            while x > 0:\n                d = x % 10\n                if d == 0 or (n % d) > 0:\n                    return False\n                x //= 10\n            return True\n        \"\"\"\n\n        # List to store self-dividing numbers\n        ans = []\n\n        # Iterate over the range and find self-dividing numbers\n        for n in range(left, right + 1):\n            if self_dividing(n):\n                ans.append(n)\n\n        # Alternatively: return list(filter(self_dividing, range(left, right + 1)))\n        return ans",
        "explanation": "Brute Force [Accepted]\nIntuition and Algorithm\n\nFor each number in the given range, we will directly test if that number is self-dividing.\n\nBy definition, we want to test each whether each digit is non-zero and divide the number. For example, with 128, we want to test d != 0 && 128 % d == 0 for d = 1, 2, 8. To do that, we need to iterate over each digit of the number.\n\nA straightforward approach to that problem would be to convert the number into a character array (string in Python), and then convert it back to an integer to perform the modulo operation when checking n % d == 0.\n\nWe could also continually divide the number by 10 and peek at the last digit. That is shown as a variation in a comment.\nComplexity Analysis\n\nTime Complexity: We iterate through each digit in the given number; therefore, the time complexity is O(D), where D represents the number of digits in the number.\n\nSpace Complexity: O(1), since we do not include the output size in space complexity calculations and only consider the intermediate variables or references used during the computation."
    },
    {
        "question_id": "356d0648-1285-47d1-8f66-a2aa7b46c5d3",
        "title": "Reach a Number",
        "difficulty": "Medium",
        "category": "Math Binary Search",
        "question_text": "You are standing at position 0 on an infinite number line. There is a destination at position target.\n\nYou can make some number of moves numMoves so that:\n\nOn each move, you can either go left or right.\nDuring the ith move (starting from i == 1 to i == numMoves), you take i steps in the chosen direction.\nGiven the integer target, return the minimum number of moves required (i.e., the minimum numMoves) to reach the destination.\n\n \n\nExample 1:\n\nInput: target = 2\nOutput: 3\nExplanation:\nOn the 1st move, we step from 0 to 1 (1 step).\nOn the 2nd move, we step from 1 to -1 (2 steps).\nOn the 3rd move, we step from -1 to 2 (3 steps).\nExample 2:\n\nInput: target = 3\nOutput: 2\nExplanation:\nOn the 1st move, we step from 0 to 1 (1 step).\nOn the 2nd move, we step from 1 to 3 (2 steps).\n \n\nConstraints:\n\n-109 <= target <= 109\ntarget != 0",
        "solution": "class Solution(object):\n    def reachNumber(self, target):\n        target = abs(target)\n        k = 0\n        while target > 0:\n            k += 1\n            target -= k\n\n        return k if target % 2 == 0 else k + 1 + k%2",
        "explanation": "Intuition\n\nThe crux of the problem is to put + and - signs on the numbers 1, 2, 3, ..., k so that the sum is target.\n\nWhen target < 0 and we made a sum of target, we could switch the signs of all the numbers so that it equals Math.abs(target). Thus, the answer for target is the same as Math.abs(target), and so without loss of generality, we can consider only target > 0.\n\nNow let's say k is the smallest number with S = 1 + 2 + ... + k >= target. If S == target, the answer is clearly k.\n\nIf S > target, we need to change some number signs. If delta = S - target is even, then we can always find a subset of {1, 2, ..., k} equal to delta / 2 and switch the signs, so the answer is k. (This depends on T = delta / 2 being at most S.) [The proof is simple: either T <= k and we choose it, or we choose k in our subset and try to solve the same instance of the problem for T -= k and the set {1, 2, ..., k-1}.]\n\nOtherwise, if delta is odd, we can't do it, as every sign change from positive to negative changes the sum by an even number. So let's consider a candidate answer of k+1, which changes delta by k+1. If this is odd, then delta will be even and we can have an answer of k+1. Otherwise, delta will be odd, and we will have an answer of k+2.\n\nFor concrete examples of the above four cases, consider the following:\n\nIf target = 3, then k = 2, delta = 0 and the answer is k = 2.\nIf target = 4, then k = 3, delta = 2, delta is even and the answer is k = 3.\nIf target = 7, then k = 4, delta = 3, delta is odd and adding k+1 makes delta even. The answer is k+1 = 5.\nIf target = 5, then k = 3, delta = 1, delta is odd and adding k+1 keeps delta odd. The answer is k+2 = 5.\nAlgorithm\n\nSubtract ++k from target until it goes non-positive. Then k will be as described, and target will be delta as described. We can output the four cases above: if delta is even then the answer is k, if delta is odd then the answer is k+1 or k+2 depending on the parity of k."
    },
    {
        "question_id": "ead2e9a9-ae35-47f1-9ae1-ad538c0ffb6d",
        "title": "Magic Squares In Grid",
        "difficulty": "Medium",
        "category": "Array Hash Table Math Matrix",
        "question_text": "A 3 x 3 magic square is a 3 x 3 grid filled with distinct numbers from 1 to 9 such that each row, column, and both diagonals all have the same sum.\n\nGiven a row x col grid of integers, how many 3 x 3 magic square subgrids are there?\n\nNote: while a magic square can only contain numbers from 1 to 9, grid may contain numbers up to 15.\n\n \n\nExample 1:\nInput: grid = [[4,3,8,4],[9,5,1,9],[2,7,6,2]]\nOutput: 1\nExplanation: \nThe following subgrid is a 3 x 3 magic square:\nwhile this one is not:\nIn total, there is only one magic square inside the given grid.\nExample 2:\n\nInput: grid = [[8]]\nOutput: 0\n \n\nConstraints:\n\nrow == grid.length\ncol == grid[i].length\n1 <= row, col <= 10\n0 <= grid[i][j] <= 15",
        "solution": "class Solution {\npublic:\n    int numMagicSquaresInside(vector<vector<int>>& grid) {\n        int ans = 0;\n        int m = grid.size();\n        int n = grid[0].size();\n        for (int row = 0; row + 2 < m; row++) {\n            for (int col = 0; col + 2 < n; col++) {\n                if (isMagicSquare(grid, row, col)) {\n                    ans++;\n                }\n            }\n        }\n        return ans;\n    }\n\nprivate:\n    bool isMagicSquare(vector<vector<int>>& grid, int row, int col) {\n        // The sequences are each repeated twice to account for\n        // the different possible starting points of the sequence\n        // in the magic square\n        string sequence = \"2943816729438167\";\n        string sequenceReversed = \"7618349276183492\";\n\n        string border = \"\";\n        // Flattened indices for bordering elements of 3x3 grid\n        vector<int> borderIndices = {0, 1, 2, 5, 8, 7, 6, 3};\n        for (int i : borderIndices) {\n            int num = grid[row + i / 3][col + (i % 3)];\n            border += to_string(num);\n        }\n\n        // Make sure the sequence starts at one of the corners\n        return (grid[row][col] % 2 == 0 && grid[row + 1][col + 1] == 5 &&\n                (sequence.find(border) != string::npos ||\n                 sequenceReversed.find(border) != string::npos));\n    }\n};",
        "explanation": "Intuition\nIn Approach 1, we determined whether each subarray of grid is a magic square by explicitly checking each criterion of the magic square definition given in the problem statement.\n\nWe can dive deeper into the definition of a 3 x 3 magic square to find additional properties that can help us simplify the logic for determining if a subarray is a magic square:\n\nConstant Sum\n\nBy definition, every row has the same sum S. Furthermore, the definition states that a magic grid can only contain values 1 to 9 and each value must be distinct. Since every 3 x 3 magic grid will contain exactly 9 squares, we can see that every magic grid will have exactly one of each allowed value. Thus, we can see that the total sum of an entire 3 x 3 magic square is 1+2+3+...+9=45.\n\nBecause each magic square consists of 3 rows, we can say that 3S=45 and thus S=15. This means that every row sum, and in turn every column sum and diagonal sum, equals 15.\n\nLimited Number of Arrangements\n\nIf every row, column, and diagonal has to sum up to 15 and can only contain distinct values from 1 to 9, then there are only a limited number of arrangements to form a magic square. Listed below are all possible combinations of 3-part sums that add up to 15, where each value is between 1 and 9:\n\n1+5+9\n\n1+6+8\n\n2+4+9\n\n2+5+8\n\n2+6+7\n\n3+4+8\n\n3+5+7\n\n4+5+6\n\nWe can see that there are 8 different ways, which map directly to the 8 3-part sums in the magic square (3 rows + 3 columns + 2 diagonals = 8 total sums). We can explore further constraints on arranging the possible magic squares.\n\nConstraint 1 - Middle element\n\n5 appears in exactly 4 of these sums. The only element that would appear in 4 sums is the middle element of the magic square. Specifically, the middle element appears in the sums for the middle row, the middle column, and both diagonals. Thus, we know that for a subarray to be a magic square, its middle element has to be 5.\nConstraint 2 - Even numbers\n\nMoreover, the even numbers (2, 4, 6, and 8) each appear in exactly 3 of the sums. Only the corner elements of the grid can appear in exactly 3 sums. Specifically, they appear in the sum for one row, one column, and one diagonal. Thus, we know the corner elements have to be even numbers.\nConstraint 3 - Odd numbers\n\nFinally, the only numbers remaining are the odd numbers (1, 3, 7, and 9). They each appear in exactly 2 of the sums. The remaining elements on the edges of the grid also appear in exactly 2 sums: the sums for one row and one column. Thus, we know the remaining edge elements have to be odd numbers.\nWe observe that for all possible arrangements, the elements around the border (the even/odd numbers from constraints 2/3 above) all follow the ordered sequence\n\n2,9,4,3,8,1,6,7\n\neither moving clockwise or counter-clockwise around the border, starting at a corner element.\n\nThus, we know that a subarray is a magic square if and only if it satisfies the 2 following properties:\n\nThe middle element is 5\nThe bordering elements follow the 2,9,4,3,8,1,6,7 sequence, starting at some corner element and going either clockwise or counter-clockwise."
    },
    {
        "question_id": "9b99b6df-586d-4622-bf91-2bbb8af54af5",
        "title": "Balanced Binary Tree",
        "difficulty": "Easy",
        "category": "Tree Depth-First Search Binary Tree",
        "question_text": "iven a binary tree, determine if it is height-balanced.\n\n \n\nExample 1:\n\nInput: root = [3,9,20,null,null,15,7]\nOutput: true\nExample 2:\nInput: root = [1,2,2,3,3,null,null,4,4]\nOutput: false\nExample 3:\n\nInput: root = []\nOutput: true\n \n\nConstraints:\n\nThe number of nodes in the tree is in the range [0, 5000].\n-104 <= Node.val <= 104",
        "solution": "class Solution {\npublic:\n    bool isBalanced(TreeNode* root) {\n        return dfs(root).first;        \n    }\n\nprivate:\n    pair<bool, int> dfs(TreeNode* node) {\n        if (!node) return {true, 0};\n        \n        auto [leftBalanced, leftHeight] = dfs(node->left);\n        auto [rightBalanced, rightHeight] = dfs(node->right);\n        \n        bool isBalanced = leftBalanced && rightBalanced && abs(leftHeight - rightHeight) <= 1;\n        \n        return {isBalanced, 1 + max(leftHeight, rightHeight)};\n    }    \n};",
        "explanation": "Approach\nFirst of all, what is the points to solve this question?\n\nHow do you handle null?\nHow do you calculate height difference?\nWhat do you keep for the next recursive process?\nHow do you handle null?\nSimply, we consider null as balanced. null is nothing at current position and both side. That means the fact that nothing exists makes the left and right sides balanced.\n\nHow do you calculate height difference?\nThe description says \"A height-balanced binary tree is a binary tree in which the depth of the two subtrees of every node never differs by more than one.\"\n\nSince we need to know the height difference, we have to subtract the left and right heights.\n\nFor example,\n\nleft height is 5.\nright height is 4.\nIn this case, difference is 1. But one problem here is that if we calculate\n\nleft height - right height\n= 5 - 4\n= 1(= true)\nWe will get 1, but these is a case where left height is 4 and right height is 5. left height is not always higher than right height. In that case,\n\nleft height - right height\n= 4 - 5\n= -1\nDifference should be 1 for both cases. You could handle this with an if statement, but it might not be the most elegant solution. There’s probably a simpler and smarter way—any ideas?\n\nMy answer is to use absolute values, so that we can handle 1 and -1 as 1.\n\nabs(left height - right height)\n= abs(4 - 5)\n= 1\nComplexity\nTime complexity: O(n)\nSpace complexity: O(n)\nIn the worst case (a skewed tree), the recursion depth is O(n)."
    },
    {
        "question_id": "b01dde81-3317-4192-a426-b711b371821b",
        "title": "Validate Binary Search Tree",
        "difficulty": "Medium",
        "category": "Tree Depth-First Search Binary Search Tree Binary Tree",
        "question_text": "Given the root of a binary tree, determine if it is a valid binary search tree (BST).\n\nA valid BST is defined as follows:\n\nThe left subtree of a node contains only nodes with keys less than the node's key.\nThe right subtree of a node contains only nodes with keys greater than the node's key.\nBoth the left and right subtrees must also be binary search trees.\n \n\nExample 1:\nInput: root = [2,1,3]\nOutput: true\nExample 2:\nInput: root = [5,1,4,null,null,3,6]\nOutput: false\nExplanation: The root node's value is 5 but its right child's value is 4.\n \n\nConstraints:\n\nThe number of nodes in the tree is in the range [1, 104].\n-231 <= Node.val <= 231 - 1",
        "solution": "class Solution {\npublic:\n    bool isValidBST(TreeNode* root) {\n        return valid(root, LONG_MIN, LONG_MAX);        \n    }\n\nprivate:\n    bool valid(TreeNode* node, long minimum, long maximum) {\n        if (!node) return true;\n\n        if (!(node->val > minimum && node->val < maximum)) return false;\n\n        return valid(node->left, minimum, node->val) && valid(node->right, node->val, maximum);\n    }    \n};",
        "explanation": "Approach\n        10\n       /  \\\n      8    15\n          /  \\\n         12  18\nLet's think about possible range of root value. It's easy right?\n\n8 < root(= 10) < 15\nBut problem is we don't konw what number is minimum and maximum in algorithm, so my strategy is to put infinity numbers.\n\nnegative infinity < root < infinity\nIn that case, we can put any number at root node.\n\nLet's think about range of each node.\n\n10 → -i < 10 < i\n 8 → -i <  8 < 10\n15 → 10 < 15 < i\n12 → 10 < 12 < 15\n18 → 15 < 18 < i\n\ni is infinity\nIf we meet all condition, we can say this is valid binary search tree.\n\nLet's separate like this.\n\nGo Left\n 8 → -i <  8 < 10\n12 → 10 < 12 < 15\n\nGo Right\n15 → 10 < 15 < i\n18 → 15 < 18 < i\n Points\n\nWhen we go left, update maxinum value only. A minimum number will be the same number from parent.\n\nOn the other hand, when we go right, update minimum number only. A maxinum number will be the same number from parent."
    },
    {
        "question_id": "c2811532-1830-4a8d-8965-7389e0519e23",
        "title": "Same Tree",
        "difficulty": "Easy",
        "category": "Tree Depth-First Search Breadth-First Search Binary Tree",
        "question_text": "Given the roots of two binary trees p and q, write a function to check if they are the same or not.\n\nTwo binary trees are considered the same if they are structurally identical, and the nodes have the same value.\n\n \n\nExample 1:\nInput: p = [1,2,3], q = [1,2,3]\nOutput: true\nExample 2:\nInput: p = [1,2], q = [1,null,2]\nOutput: false\nExample 3:\nInput: p = [1,2,1], q = [1,1,2]\nOutput: false\n \n\nConstraints:\n\nThe number of nodes in both trees is in the range [0, 100].\n-104 <= Node.val <= 104",
        "solution": "class Solution {\npublic:\n    bool isSameTree(TreeNode* p, TreeNode* q) {\n        // If both nodes are NULL, they are identical\n        if (p == NULL && q == NULL) {\n            return true;\n        }\n        // If only one of the nodes is NULL, they are not identical\n        if (p == NULL || q == NULL) {\n            return false;\n        }\n        // Check if values are equal and recursively check left and right subtrees\n        if (p->val == q->val) {\n            return isSameTree(p->left, q->left) && isSameTree(p->right, q->right);\n        }\n        // Values are not equal, they are not identical\n        return false;\n    }\n};",
        "explanation": "Intuition\nThe intuition behind the solution is to recursively check if two binary trees are identical. If both trees are empty (null), they are considered identical. If only one tree is empty or the values of the current nodes are different, the trees are not identical. Otherwise, we recursively check if the left and right subtrees of both trees are identical.\n\nApproach\nCheck the base case: if both trees are null, return true.\nCheck if only one tree is null or the values of the current nodes are different, return false.\nRecursively check if the left subtrees of both trees are identical.\nRecursively check if the right subtrees of both trees are identical.\nReturn the logical AND of the results from steps 3 and 4.\nComplexity\n\nTime complexity:\nThe time complexity of the solution is O(min(N,M)), where N and M are the number of nodes in the two trees, respectively. This is because we need to visit each node once in order to compare their values. In the worst case, where both trees have the same number of nodes, the time complexity would be O(N).\n\nSpace complexity:\nThe space complexity of the solution isO(min(H1,H2)), where H1 and H2 are the heights of the two trees, respectively. This is because the space used by the recursive stack is determined by the height of the smaller tree. In the worst case, where one tree is significantly larger than the other, the space complexity would be closer to O(N) or O(M), depending on which tree is larger."
    },
    {
        "question_id": "7b712ef6-27c3-475a-8bef-be783d2a9898",
        "title": "Symmetric Tree",
        "difficulty": "Easy",
        "category": "Tree Depth-First Search Breadth-First Search Binary Tree",
        "question_text": "Given the root of a binary tree, check whether it is a mirror of itself (i.e., symmetric around its center).\n\n \n\nExample 1:\nInput: root = [1,2,2,3,4,4,3]\nOutput: true\nExample 2:\nInput: root = [1,2,2,null,3,null,3]\nOutput: false\n \n\nConstraints:\n\nThe number of nodes in the tree is in the range [1, 1000].\n-100 <= Node.val <= 100",
        "solution": "class Solution {\npublic:\n    bool isMirror(TreeNode* left, TreeNode* right) {\n    if (!left && !right) return true;\n    if (!left || !right) return false;\n    return (left->val == right->val) && isMirror(left->left, right->right) && isMirror(left->right, right->left);\n}\n\nbool isSymmetric(TreeNode* root) {\n    if (!root) return true;\n    return isMirror(root->left, root->right);\n}\n\n};",
        "explanation": "Intuition\nTo check if a binary tree is symmetric, we need to compare its left subtree and right subtree. To do this, we can traverse the tree recursively and compare the left and right subtrees at each level. If they are symmetric, we continue the traversal. Otherwise, we can immediately return false.\n\nApproach\nWe can define a recursive helper function that takes two nodes as input, one from the left subtree and one from the right subtree. The helper function returns true if both nodes are null, or if their values are equal and their subtrees are symmetric.\n\nComplexity\nTime complexity:The time complexity of the algorithm is O(n), where n is the number of nodes in the binary tree. We need to visit each node once to check if the tree is symmetric.\nSpace complexity:\nThe space complexity of the algorithm is O(h), where h is the height of the binary tree. In the worst case, the tree can be completely unbalanced, and the recursion stack can go as deep as the height of the tree"
    },
    {
        "question_id": "13284f7a-1600-46d7-b091-d3383f8fb55d",
        "title": "Clone Graph",
        "difficulty": "Medium",
        "category": "Hash Table Depth-First Search Breadth-First Search Graph",
        "question_text": "Given a reference of a node in a connected undirected graph.\n\nReturn a deep copy (clone) of the graph.\n\nEach node in the graph contains a value (int) and a list (List[Node]) of its neighbors.\n\nclass Node {\n    public int val;\n    public List<Node> neighbors;\n}\n \n\nTest case format:\n\nFor simplicity, each node's value is the same as the node's index (1-indexed). For example, the first node with val == 1, the second node with val == 2, and so on. The graph is represented in the test case using an adjacency list.\n\nAn adjacency list is a collection of unordered lists used to represent a finite graph. Each list describes the set of neighbors of a node in the graph.\n\nThe given node will always be the first node with val = 1. You must return the copy of the given node as a reference to the cloned graph.\n\n \n\nExample 1:\nInput: adjList = [[2,4],[1,3],[2,4],[1,3]]\nOutput: [[2,4],[1,3],[2,4],[1,3]]\nExplanation: There are 4 nodes in the graph.\n1st node (val = 1)'s neighbors are 2nd node (val = 2) and 4th node (val = 4).\n2nd node (val = 2)'s neighbors are 1st node (val = 1) and 3rd node (val = 3).\n3rd node (val = 3)'s neighbors are 2nd node (val = 2) and 4th node (val = 4).\n4th node (val = 4)'s neighbors are 1st node (val = 1) and 3rd node (val = 3).\nExample 2:\nInput: adjList = [[]]\nOutput: [[]]\nExplanation: Note that the input contains one empty list. The graph consists of only one node with val = 1 and it does not have any neighbors.\nExample 3:\n\nInput: adjList = []\nOutput: []\nExplanation: This an empty graph, it does not have any nodes.\n \n\nConstraints:\n\nThe number of nodes in the graph is in the range [0, 100].\n1 <= Node.val <= 100\nNode.val is unique for each node.\nThere are no repeated edges and no self-loops in the graph.\nThe Graph is connected and all nodes can be visited starting from the given node.",
        "solution": "class Solution {\n    public:\n    Node* dfs(Node* cur,unordered_map<Node*,Node*>& mp)\n    {\n        vector<Node*> neighbour;\n        Node* clone=new Node(cur->val);\n        mp[cur]=clone;\n            for(auto it:cur->neighbors)\n            {\n                if(mp.find(it)!=mp.end())   //already clone and stored in map\n                {\n                    neighbour.push_back(mp[it]);    //directly push back the clone node from map to neigh\n                }\n                else\n                    neighbour.push_back(dfs(it,mp));\n            }\n            clone->neighbors=neighbour;\n            return clone;\n    }\n    Node* cloneGraph(Node* node) {\n        unordered_map<Node*,Node*> mp;\n        if(node==NULL)\n            return NULL;\n        if(node->neighbors.size()==0)   //if only one node present no neighbors\n        {\n            Node* clone= new Node(node->val);\n            return clone; \n        }\n        return dfs(node,mp);\n    }\n};",
        "explanation": "1. We use HashMap to solve it and using DFS.\n2. Initially our hash map will be empty and we try to map the old node with the new node or the copy node.\n3. We start with any entry point.\n4. I am using '1' as my entry point.\n\nNow lets see how its going i am starting with 1 and whenever i visited a new node i coloned it and put in there.\nWe are using DFS so algorithm is like 'it starts at the root node (select some arbitrary node as root node in the case of a graph) and explores as far as possible along each branch before backtracking.\nSo the basic idea is to start from the root or any arbitrary node and mark the node and move to the adjacentunmarked node and continue this loop until there is no unmarked adjacent node. \nThen backtrack and check for other unmarked nodes and traverse them. Finally, print the nodes in the path.'\nSo we are using HashMap to put all the visited node or old node there with clone one to.\n _________\n| HashMap |\n ----------\n|Old|Clone| \n| 1  | 1 |\n|  2 | 2 |\n|  3 | 3 |                                                     \n|  4 | 4 |                                                                                                            \n---------\n\nNow i started with 1 so i cloned it and from 1 can go to 2 and 4 so i go 2 and when i visited 2 i cloned 2 and now fro  i have two choices either go to previous one that is 1 or discover 3 i.e new node\nso accordingly to dfs i go to 3 and from 3 i can go to 4 i go there and cloned it. Now if we see fro each node we have viisted to a new node but what about 4. So here half part of Dfs is completed,\nand now its time for recursive call to go back and now from here we check from current node i can go where and where.\nAnd follow the same rules over there.\n\nBUT BEFORE STARTING ANY CLONING WE HAVE TO CHECK THAT IF WE HAVE CLONED THAT NODE ALREADY THERE OR NOT. IF NOT THAN ONLY WE CLONED IT. \n\nThats the only reason we are using hash map so that we don't need to clone again and again.\nFor every uncloned node we make a clone and iterate over the neighbors of original node using dfs traversal or bfs traversal."
    },
    {
        "question_id": "2c27c82b-f5a1-4557-9613-967595339a68",
        "title": "Invert Binary Tree",
        "difficulty": "Easy",
        "category": "Tree Depth-First Search Breadth-First Search Binary Tree",
        "question_text": "Given the root of a binary tree, invert the tree, and return its root.\n\n \n\nExample 1:\nInput: root = [4,2,7,1,3,6,9]\nOutput: [4,7,2,9,6,3,1]\nExample 2:\nInput: root = [2,1,3]\nOutput: [2,3,1]\nExample 3:\n\nInput: root = []\nOutput: []\n \n\nConstraints:\n\nThe number of nodes in the tree is in the range [0, 100].\n-100 <= Node.val <= 100",
        "solution": "class Solution {\npublic:\n    TreeNode* invertTree(TreeNode* root) {\n        // Base Case\n        if(root==NULL)\n            return NULL;\n        invertTree(root->left); //Call the left substree\n        invertTree(root->right); //Call the right substree\n        // Swap the nodes\n        TreeNode* temp = root->left;\n        root->left = root->right;\n        root->right = temp;\n        return root; // Return the root\n    }\n};",
        "explanation": "Intuition\nIn this question we have to Invert the binary tree.\nSo we use Post Order Treversal in which first we go in Left subtree and then in Right subtree then we return back to Parent node.\nWhen we come back to the parent node we swap it's Left subtree and Right subtree.\nComplexity\nTime complexity: O(N)\nSpace complexity: O(N) Recursive stack space"
    },
    {
        "question_id": "bcfdc828-cd20-4b51-94df-4448ed81ffd2",
        "title": "Path Sum III",
        "difficulty": "Medium",
        "category": "Tree Depth-First Search Binary Tree",
        "question_text": "Given the root of a binary tree and an integer targetSum, return the number of paths where the sum of the values along the path equals targetSum.\n\nThe path does not need to start or end at the root or a leaf, but it must go downwards (i.e., traveling only from parent nodes to child nodes).\n\n \n\nExample 1:\nInput: root = [10,5,-3,3,2,null,11,3,-2,null,1], targetSum = 8\nOutput: 3\nExplanation: The paths that sum to 8 are shown.\nExample 2:\n\nInput: root = [5,4,8,11,null,13,4,7,2,null,null,5,1], targetSum = 22\nOutput: 3\n \n\nConstraints:\n\nThe number of nodes in the tree is in the range [0, 1000].\n-109 <= Node.val <= 109\n-1000 <= targetSum <= 1000",
        "solution": "class Solution(object):\n    def pathSum(self, root, target):\n        # define global result and path\n        self.result = 0\n        cache = {0:1}\n        \n        # recursive to get result\n        self.dfs(root, target, 0, cache)\n        \n        # return result\n        return self.result\n    \n    def dfs(self, root, target, currPathSum, cache):\n        # exit condition\n        if root is None:\n            return  \n        # calculate currPathSum and required oldPathSum\n        currPathSum += root.val\n        oldPathSum = currPathSum - target\n        # update result and cache\n        self.result += cache.get(oldPathSum, 0)\n        cache[currPathSum] = cache.get(currPathSum, 0) + 1\n        \n        # dfs breakdown\n        self.dfs(root.left, target, currPathSum, cache)\n        self.dfs(root.right, target, currPathSum, cache)\n        # when move to a different branch, the currPathSum is no longer available, hence remove one. \n        cache[currPathSum] -= 1",
        "explanation": "Memorization of path sum: O(n)\n2.1 High level walk through\nIn order to optimize from the brutal force solution, we will have to think of a clear way to memorize the intermediate result. Namely in the brutal force solution, we did a lot repeated calculation. For example 1->3->5, we calculated: 1, 1+3, 1+3+5, 3, 3+5, 5.\nThis is a classical 'space and time tradeoff': we can create a dictionary (named cache) which saves all the path sum (from root to current node) and their frequency.\nAgain, we traverse through the tree, at each node, we can get the currPathSum (from root to current node). If within this path, there is a valid solution, then there must be a oldPathSum such that currPathSum - oldPathSum = target.\nWe just need to add the frequency of the oldPathSum to the result.\nDuring the DFS break down, we need to -1 in cache[currPathSum], because this path is not available in later traverse.\nCheck the graph below for easy visualization."
    },
    {
        "question_id": "0662bccf-1951-497e-9593-9cb3cbd5f0ca",
        "title": "Second Minimum Node In a Binary Tree",
        "difficulty": "Easy",
        "category": "Tree Depth-First Search Binary Tree",
        "question_text": "Given a non-empty special binary tree consisting of nodes with the non-negative value, where each node in this tree has exactly two or zero sub-node. If the node has two sub-nodes, then this node's value is the smaller value among its two sub-nodes. More formally, the property root.val = min(root.left.val, root.right.val) always holds.\n\nGiven such a binary tree, you need to output the second minimum value in the set made of all the nodes' value in the whole tree.\n\nIf no such second minimum value exists, output -1 instead.\n\n \n\n \n\nExample 1:\n\nInput: root = [2,2,5,null,null,5,7]\nOutput: 5\nExplanation: The smallest value is 2, the second smallest value is 5.\nExample 2:\nInput: root = [2,2,2]\nOutput: -1\nExplanation: The smallest value is 2, but there isn't any second smallest value.\n \n\nConstraints:\n\nThe number of nodes in the tree is in the range [1, 25].\n1 <= Node.val <= 231 - 1\nroot.val == min(root.left.val, root.right.val) for each internal node of the tree.",
        "solution": "class Solution {\n    int min1;\n    long ans = Long.MAX_VALUE;\n\n    public void dfs(TreeNode root) {\n        if (root != null) {\n            if (min1 < root.val && root.val < ans) {\n                ans = root.val;\n            } else if (min1 == root.val) {\n                dfs(root.left);\n                dfs(root.right);\n            }\n        }\n    }\n    public int findSecondMinimumValue(TreeNode root) {\n        min1 = root.val;\n        dfs(root);\n        return ans < Long.MAX_VALUE ? (int) ans : -1;\n    }\n}",
        "explanation": "Intuition and Algorithm\n\nLet min1 = root.val. When traversing the tree at some node, node, if node.val > min1, we know all values in the subtree at node are at least node.val, so there cannot be a better candidate for the second minimum in this subtree. Thus, we do not need to search this subtree.\n\nAlso, as we only care about the second minimum ans, we do not need to record any values that are larger than our current candidate for the second minimum, so unlike Approach #1, we can skip maintaining a Set of values(uniques) entirely.\nComplexity Analysis\n\nTime Complexity: O(N), where N is the total number of nodes in the given tree. We visit each node at most once.\n\nSpace Complexity: O(N). The information stored in ans and min1 is O(1), but our depth-first search may store up to O(h)=O(N) information in the call stack, where h is the height of the tree."
    }
]