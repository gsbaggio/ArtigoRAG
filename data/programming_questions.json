[
    {
        "question_id": "c7512fa1-85fb-4653-afad-95b73a1a31ee",
        "title": "Two Sum",
        "difficulty": "Easy",
        "category": "Array Hash Table",
        "question_text": "Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target.\n\nYou may assume that each input would have exactly one solution, and you may not use the same element twice.\n\nYou can return the answer in any order.\n\n \n\nExample 1:\n\nInput: nums = [2,7,11,15], target = 9\nOutput: [0,1]\nExplanation: Because nums[0] + nums[1] == 9, we return [0, 1].\nExample 2:\n\nInput: nums = [3,2,4], target = 6\nOutput: [1,2]\nExample 3:\n\nInput: nums = [3,3], target = 6\nOutput: [0,1]\n \n\nConstraints:\n\n2 <= nums.length <= 104\n-109 <= nums[i] <= 109\n-109 <= target <= 109\nOnly one valid answer exists.\n \n\nFollow-up: Can you come up with an algorithm that is less than O(n2) time complexity?",
        "solution": "class Solution {\npublic:\n    vector<int> twoSum(vector<int> &nums, int target) {\n        unordered_map<int, int> hash;\n        for (int i = 0; i < nums.size(); i++) {\n            hash[nums[i]] = i;\n        }\n        for (int i = 0; i < nums.size(); i++) {\n            int complement = target - nums[i];\n            if (hash.find(complement) != hash.end() && hash[complement] != i) {\n                return {i, hash[complement]};\n            }\n        }\n        // If no valid pair is found, return an empty vector\n        return {};\n    }\n};",
        "explanation": "Intuition\n\nTo improve our runtime complexity, we need a more efficient way to check if the complement exists in the array. If the complement exists, we need to get its index. What is the best way to maintain a mapping of each element in the array to its index? A hash table.\n\nWe can reduce the lookup time from O(n) to O(1) by trading space for speed. A hash table is well suited for this purpose because it supports fast lookup in near constant time. I say \"near\" because if a collision occurred, a lookup could degenerate to O(n) time. However, lookup in a hash table should be amortized O(1) time as long as the hash function was chosen carefully.\n\nAlgorithm\n\nA simple implementation uses two iterations. In the first iteration, we add each element's value as a key and its index as a value to the hash table. Then, in the second iteration, we check if each element's complement (target−nums[i]) exists in the hash table. If it does exist, we return current element's index and its complement's index. Beware that the complement must not be nums[i] itself!\nComplexity Analysis\n\nTime complexity: O(n).\nWe traverse the list containing n elements exactly twice. Since the hash table reduces the lookup time to O(1), the overall time complexity is O(n).\n\nSpace complexity: O(n).\nThe extra space required depends on the number of items stored in the hash table, which stores exactly n elements."
    },
    {
        "question_id": "8c240482-ae08-472f-b09e-73765133910a",
        "title": "Median of Two Sorted Arrays",
        "difficulty": "Hard",
        "category": "Array Binary Search Divide and Conquer",
        "question_text": "Given two sorted arrays nums1 and nums2 of size m and n respectively, return the median of the two sorted arrays.\n\nThe overall run time complexity should be O(log (m+n)).\n\n \n\nExample 1:\n\nInput: nums1 = [1,3], nums2 = [2]\nOutput: 2.00000\nExplanation: merged array = [1,2,3] and median is 2.\nExample 2:\n\nInput: nums1 = [1,2], nums2 = [3,4]\nOutput: 2.50000\nExplanation: merged array = [1,2,3,4] and median is (2 + 3) / 2 = 2.5.\n \n\nConstraints:\n\nnums1.length == m\nnums2.length == n\n0 <= m <= 1000\n0 <= n <= 1000\n1 <= m + n <= 2000\n-106 <= nums1[i], nums2[i] <= 106",
        "solution": "class Solution {\npublic:\n    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\n        if (nums1.size() > nums2.size()) {\n            return findMedianSortedArrays(nums2, nums1);\n        }\n\n        int m = nums1.size(), n = nums2.size();\n        int left = 0, right = m;\n\n        while (left <= right) {\n            int partitionA = (left + right) / 2;\n            int partitionB = (m + n + 1) / 2 - partitionA;\n\n            int maxLeftA = (partitionA == 0) ? INT_MIN : nums1[partitionA - 1];\n            int minRightA = (partitionA == m) ? INT_MAX : nums1[partitionA];\n            int maxLeftB = (partitionB == 0) ? INT_MIN : nums2[partitionB - 1];\n            int minRightB = (partitionB == n) ? INT_MAX : nums2[partitionB];\n\n            if (maxLeftA <= minRightB && maxLeftB <= minRightA) {\n                if ((m + n) % 2 == 0) {\n                    return (max(maxLeftA, maxLeftB) +\n                            min(minRightA, minRightB)) /\n                           2.0;\n                } else {\n                    return max(maxLeftA, maxLeftB);\n                }\n            } else if (maxLeftA > minRightB) {\n                right = partitionA - 1;\n            } else {\n                left = partitionA + 1;\n            }\n        }\n\n        return 0.0;\n    }\n};",
        "explanation": "Intuition\nRecall the previous approach where we perform a binary search over the 'merged' array consisting of nums1 and nums2, resulting in a time complexity of O(log(m⋅n)). We could further improve the algorithm by performing the binary search only on the smaller array of nums1 and nums2, thus the time complexity is reduced to O(log(min(m,n))).\n\nThe main idea is similar to approach 2, where we need to find a point of partition in both arrays such that the maximum of the smaller half is less than or equal to the minimum of the larger half.\n\nHowever, instead of partitioning over the merged arrays, we can only focus on partitioning the smaller array (let's call this array A). Suppose the partition index is partitionA, we specify that the smaller half contains (m + n + 1) / 2 elements, and we can use this feature to our advantage by directly making partitionB equal to (m + n + 1) / 2 - partitionA, thus the smaller halves of both arrays always contain a total of (m + n + 1) / 2 elements, as shown in the picture below.\n\nAlgorithm\nAssuming nums1 to be the smaller array (If nums2 is smaller, we can swap them). Let m, n represent the size of nums1 and nums2, respectively.\n\nDefine the search space for the partitioning index partitionA by setting boundaries as left = 0 and right = m.\n\nWhile left <= right holds, do the following.\n\nCompute the partition index of nums1 as partitionA = (left + right) / 2. Consequently, the partition index of nums2 is (m + n + 1) / 2 - partitionA.\n\nObtain the edge elements:\n\nDetermine the maximum value of the section A_left as maxLeftA = nums1[partitionA - 1]. If partitionA - 1 < 0, set it as maxLeftA = float(-inf).\nDetermine the minimum value of the section A_right as minRightA = nums1[partitionA]. If partitionA >= m, set it as minRightA = float(inf).\nDetermine the maximum value of the section B_left as maxLeftB = nums2[partitionB - 1]. If partitionB - 1 < 0, set it as maxLeftB = float(-inf).\nDetermine the maximum value of the section B_right as minRightB = nums2[partitionB]. If partitionB >= n, set it as minRightB = float(inf).\nCompare and recalculate: Compare maxLeftA with minRightB and maxLeftB with minRightA.\n\nIf maxLeftA > minRightB, it means the maxLeftA is too large to be in the smaller half, so we update right = partitionA - 1 to move to the left half of the search space.\nIf maxLeftB > minRightA, it means that we are too far on the left side for partitionA and we need to go to the right half of the search space by updating left = partitionA + 1.\nRepeat step 4.\n\nWhen both maxLeftA <= minRightB and maxLeftB <= minRightA are true:\n\nIf (m + n) % 2 = 0, the median value is the average of the maximum value of the smaller half and the minimum value of the larger half, given by answer = (max(maxLeftA, maxLeftB) + min(minRightA, minRightB)) / 2.\nOtherwise, the median value is the maximum value of the smaller half, given by answer = max(maxLeftA, maxLeftB)."
    },
    {
        "question_id": "c2445e51-f884-45f7-857f-d9016a97360c",
        "title": "Pascal's Triangle",
        "difficulty": "Easy",
        "category": "Array Dynamic Programming",
        "question_text": "Given an integer numRows, return the first numRows of Pascal's triangle.\n\nIn Pascal's triangle, each number is the sum of the two numbers directly above it as shown:\nExample 1:\n\nInput: numRows = 5\nOutput: [[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1]]\nExample 2:\n\nInput: numRows = 1\nOutput: [[1]]\n \n\nConstraints:\n\n1 <= numRows <= 30",
        "solution": "class Solution {\npublic:\n    vector<vector<int>> generate(int numRows) {\n        vector<vector<int>> result;\n        vector<int> prevRow;\n        \n        for (int i = 0; i < numRows; i++) {\n            vector<int> currentRow(i + 1, 1);\n            \n            for (int j = 1; j < i; j++) {\n                currentRow[j] = prevRow[j - 1] + prevRow[j];\n            }\n            \n            result.push_back(currentRow);\n            prevRow = currentRow;\n        }\n        \n        return result;\n    }\n};",
        "explanation": "Intuition: We can use a dynamic programming approach with a 1D array to generate Pascal's triangle row by row. Instead of maintaining a 2D array, we can use a single array to store the current row and update it as we iterate through the rows. This approach reduces space complexity.\nInitialize a 1D array to store the current row.\nIterate through numRows and update the array for each row.\ntime complexity of O(numRows^2)\nO(numRows) space"
    },
    {
        "question_id": "c80d62a2-af92-460b-affc-4ddf4d5c1d1c",
        "title": "Best Time to Buy and Sell Stock",
        "difficulty": "Easy",
        "category": "Array Dynamic Programming",
        "question_text": "You are given an array prices where prices[i] is the price of a given stock on the ith day.\n\nYou want to maximize your profit by choosing a single day to buy one stock and choosing a different day in the future to sell that stock.\n\nReturn the maximum profit you can achieve from this transaction. If you cannot achieve any profit, return 0.\n\n \n\nExample 1:\n\nInput: prices = [7,1,5,3,6,4]\nOutput: 5\nExplanation: Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5.\nNote that buying on day 2 and selling on day 1 is not allowed because you must buy before you sell.\nExample 2:\n\nInput: prices = [7,6,4,3,1]\nOutput: 0\nExplanation: In this case, no transactions are done and the max profit = 0.\n \n\nConstraints:\n\n1 <= prices.length <= 105\n0 <= prices[i] <= 104",
        "solution": "class Solution {\npublic:\n    int maxProfit(std::vector<int>& prices) {\n        int buy = prices[0];\n        int profit = 0;\n        for (int i = 1; i < prices.size(); i++) {\n            if (prices[i] < buy) {\n                buy = prices[i];\n            } else if (prices[i] - buy > profit) {\n                profit = prices[i] - buy;\n            }\n        }\n        return profit;\n    }\n};",
        "explanation": "Intuition\nThe problem aims to find the maximum profit that can be obtained by buying and selling a stock. The given solution seems to follow a simple approach of iterating through the prices, keeping track of the minimum buying price, and updating the profit whenever a higher selling price is encountered.\nApproach\nInitialize variables buy with the first element of the prices array and profit as 0.\nIterate through the prices starting from the second element.\nUpdate the buy variable if the current price is lower than the current buying price.\nUpdate the profit if the difference between the current price and the buying price is greater than the current profit.\nReturn the final profit.\nKadane's Algorithm\nKadane's Algorithm is a dynamic programming technique used to find the maximum subarray sum in an array of numbers. The algorithm maintains two variables: max_current represents the maximum sum ending at the current position, and max_global represents the maximum subarray sum encountered so far. At each iteration, it updates max_current to include the current element or start a new subarray if the current element is larger than the accumulated sum. The max_global is updated if max_current surpasses its value.\n\nRelating with the Approach\nIn the provided approach for finding the maximum profit in stock prices, the algorithm can be seen as a variation of Kadane's Algorithm. Instead of finding the maximum subarray sum directly, it focuses on finding the maximum positive difference between consecutive elements (prices) in the array.\n\nHere's how the approach relates to Kadane's Algorithm:\n\nInitialization:\n\nIn Kadane's Algorithm, max_current and max_global are initialized to the first element of the array.\nIn the stock profit approach, buy is initialized with the first element of the prices array, and profit is initialized to 0.\nIteration:\n\nKadane's Algorithm iterates through the array, updating max_current based on the current element's value and deciding whether to start a new subarray.\nThe stock profit approach iterates through the prices array, updating buy when a lower price is encountered and treating the difference between the current price and buy as a potential profit.\nComparison and Update:\n\nKadane's Algorithm compares and updates max_current and max_global at each iteration.\nThe stock profit approach compares and updates profit whenever a positive difference between the current price and buy exceeds the current profit.\nComplexity\nTime complexity: O(n), where n is the length of the prices array. The algorithm iterates through the array once.\nSpace complexity: O(1), as only a constant amount of extra space is used."
    },
    {
        "question_id": "a6e75f42-0cfb-4b52-baef-4f3b8356f888",
        "title": "Best Time to Buy and Sell Stock III",
        "difficulty": "Hard",
        "category": "Array Dynamic Programming",
        "question_text": "You are given an array prices where prices[i] is the price of a given stock on the ith day.\n\nFind the maximum profit you can achieve. You may complete at most two transactions.\n\nNote: You may not engage in multiple transactions simultaneously (i.e., you must sell the stock before you buy again).\n\n \n\nExample 1:\n\nInput: prices = [3,3,5,0,0,3,1,4]\nOutput: 6\nExplanation: Buy on day 4 (price = 0) and sell on day 6 (price = 3), profit = 3-0 = 3.\nThen buy on day 7 (price = 1) and sell on day 8 (price = 4), profit = 4-1 = 3.\nExample 2:\n\nInput: prices = [1,2,3,4,5]\nOutput: 4\nExplanation: Buy on day 1 (price = 1) and sell on day 5 (price = 5), profit = 5-1 = 4.\nNote that you cannot buy on day 1, buy on day 2 and sell them later, as you are engaging multiple transactions at the same time. You must sell before buying again.\nExample 3:\n\nInput: prices = [7,6,4,3,1]\nOutput: 0\nExplanation: In this case, no transaction is done, i.e. max profit = 0.\n \n\nConstraints:\n\n1 <= prices.length <= 105\n0 <= prices[i] <= 105",
        "solution": "public int MaxProfitDpCompactFinal(int[] prices)  {\n            int buy1 = int.MaxValue, buy2 = int.MaxValue;\n            int sell1 = 0, sell2 = 0;\n\n            for (int i = 0; i < prices.Length; i++) {\n                buy1 = Math.Min(buy1, prices[i]);\n                sell1 = Math.Max(sell1, prices[i] - buy1);\n                buy2 = Math.Min(buy2, prices[i] - sell1);\n                sell2 = Math.Max(sell2, prices[i] - buy2);\n            }\n\n            return sell2;\n        }",
        "explanation": "It's not difficult to get the DP recursive formula:\n\ndp[k, i] = max(dp[k, i-1], prices[i] - prices[j] + dp[k-1, j-1]), j=[0..i-1]\nFor k transactions, on i-th day,\nif we don't trade then the profit is same as previous day dp[k, i-1];\nand if we bought the share on j-th day where j=[0..i-1], then sell the share on i-th day then the profit is prices[i] - prices[j] + dp[k-1, j-1] .\nActually j can be i as well. When j is i, the one more extra item prices[i] - prices[j] + dp[k-1, j] = dp[k-1, i] looks like we just lose one chance of transaction.\n\nI see someone else use the formula dp[k, i] = max(dp[k, i-1], prices[i] - prices[j] + dp[k-1, j]), where the last one is dp[k-1, j] instead of dp[k-1, j-1]. It's not the direct sense, as if the share was bought on j-th day, then the total profit of previous transactions should be done on (j-1)th day. However, the result based on that formula is also correct, because if the share was sold on j-th day and then bought again, it is the same if we didn't trade on that day.\n\nSo the straigtforward implementation is:"
    },
    {
        "question_id": "2b0ec068-f123-4ca5-b6df-ae11b28d59b7",
        "title": "Contains Duplicate III",
        "difficulty": "Hard",
        "category": "Array Sliding Window Sorting Bucket Sort Ordered Set",
        "question_text": "You are given an integer array nums and two integers indexDiff and valueDiff.\n\nFind a pair of indices (i, j) such that:\n\ni != j,\nabs(i - j) <= indexDiff.\nabs(nums[i] - nums[j]) <= valueDiff, and\nReturn true if such pair exists or false otherwise.\n\n \n\nExample 1:\n\nInput: nums = [1,2,3,1], indexDiff = 3, valueDiff = 0\nOutput: true\nExplanation: We can choose (i, j) = (0, 3).\nWe satisfy the three conditions:\ni != j --> 0 != 3\nabs(i - j) <= indexDiff --> abs(0 - 3) <= 3\nabs(nums[i] - nums[j]) <= valueDiff --> abs(1 - 1) <= 0\nExample 2:\n\nInput: nums = [1,5,9,1,5,9], indexDiff = 2, valueDiff = 3\nOutput: false\nExplanation: After trying all the possible pairs (i, j), we cannot satisfy the three conditions, so we return false.\n \n\nConstraints:\n\n2 <= nums.length <= 105\n-109 <= nums[i] <= 109\n1 <= indexDiff <= nums.length\n0 <= valueDiff <= 109",
        "solution": "class Solution {\npublic:\n    bool containsNearbyAlmostDuplicate(vector<int>& nums, int k, int t) {\n        int n = nums.size();\n        \n        if(n == 0 || k < 0  || t < 0) return false;\n        \n        unordered_map<int,int> buckets;\n        \n        for(int i=0; i<n; ++i) {\n            int bucket = nums[i] / ((long)t + 1);\n            \n\t\t\t// For negative numbers, we need to decrement bucket by 1\n\t\t\t// to ensure floor division.\n\t\t\t// For example, -1/2 = 0 but -1 should be put in Bucket[-1].\n\t\t\t// Therefore, decrement by 1.\n            if(nums[i] < 0) --bucket;\n            \n            if(buckets.find(bucket) != buckets.end()) return true;\n            else {\n                buckets[bucket] = nums[i];\n                if(buckets.find(bucket-1) != buckets.end() && (long) nums[i] - buckets[bucket-1] <= t) return true;\n                if(buckets.find(bucket+1) != buckets.end() && (long) buckets[bucket+1] - nums[i] <= t) return true;\n                \n                if(buckets.size() > k) {\n                    int key_to_remove = nums[i-k] / ((long)t + 1);\n                    \n                    if(nums[i-k] < 0) --key_to_remove;\n                    \n                    buckets.erase(key_to_remove);\n                }\n            }\n        }\n        \n        return false;\n    }\n};",
        "explanation": "We use the concept of sliding window and buckets together to achieve an optimal solution with O(N) time complexity.\n\nSliding window ensures only those indices are considered whose the absolute difference is at most k. We only consider k indices at a time. This fulfills the second condition.\n\nBuckets are used to ensure that the absolute difference between two numbers is at most t. Let's take a deeper look at them.\nWe (floor) divide each number by t+1 and put it in a bucket with key as the quotient.\nFor example,\n\n[1,5,2,4,3,9,1,5,9], k = 2, t = 3\n\n1 // (3+1) = 0\n5 // (3+1) = 1\n2 // (3+1) = 0\n4 // (3+1) = 1\n3 // (3+1) = 0\n9 // (3+1) = 2\n\nHere, Bucket[0] will contain numbers 0,1,2,3.\nBucket[1] will contain numbers 4,5,6,7.\nBucket[2] will contain numbers 8,9,10,11.\n\nOn observing carefully, we can see that the absolute difference\nbetween any two numbers in any bucket is at most t, which is what we want.\n\nAlso, there can be a case where the neighbouring bucket has some number\nwhose absolute difference with a number in the current bucket is at most t.\nFor instance, 2 lies in Bucket[0] and 4 lies in Bucket[1] and 4 - 2 = 2 < 3 (=t).\nThis can only happen in neighbouring buckets. Therefore, we need to check for this too."
    },
    {
        "question_id": "4469c2bc-41d2-4fd6-a33f-7d2cc51464af",
        "title": "H-Index II",
        "difficulty": "Medium",
        "category": "Array Binary Search",
        "question_text": "Given an array of integers citations where citations[i] is the number of citations a researcher received for their ith paper and citations is sorted in non-descending order, return the researcher's h-index.\n\nAccording to the definition of h-index on Wikipedia: The h-index is defined as the maximum value of h such that the given researcher has published at least h papers that have each been cited at least h times.\n\nYou must write an algorithm that runs in logarithmic time.\n\n \n\nExample 1:\n\nInput: citations = [0,1,3,5,6]\nOutput: 3\nExplanation: [0,1,3,5,6] means the researcher has 5 papers in total and each of them had received 0, 1, 3, 5, 6 citations respectively.\nSince the researcher has 3 papers with at least 3 citations each and the remaining two with no more than 3 citations each, their h-index is 3.\nExample 2:\n\nInput: citations = [1,2,100]\nOutput: 2\n \n\nConstraints:\n\nn == citations.length\n1 <= n <= 105\n0 <= citations[i] <= 1000\ncitations is sorted in ascending order.",
        "solution": "class Solution(object):\n    def hIndex(self, citations):\n        \"\"\"\n        :type citations: List[int]\n        :rtype: int\n        \"\"\"\n        n = len(citations)\n        l = 0\n        r = n\n        while l < r:\n            m = (l + r + 1) // 2\n            [l, r] = [m, r] if citations[n - m] >= m else [l, m - 1]\n        return l",
        "explanation": "Intuition\nTo efficiently determine the H-index, we can leverage binary search on a sorted list of citations. Instead of scanning linearly, we repeatedly narrow down the range by checking how many papers have at least h citations using a binary condition.\n\nSort the citations array.\nApply binary search on the potential H-index values (h) from 0 to n.\nFor a given mid-value m, check if there are at least m papers with m or more citations.\nAdjust the search range based on this condition.\nReturn the maximum m that satisfies the condition.\nComplexity\nTime Complexity:\n\n( O(\\log n) ) for binary search, each with a constant-time check.\n( O(n \\log n) ) overall because of sorting.\nSpace Complexity:\n\n( O(1) ) — constant space for pointers."
    },
    {
        "question_id": "faf01567-c8c3-4b2a-88d5-d844ba9170a4",
        "title": "Super Ugly Number",
        "difficulty": "Medium",
        "category": "Array Math Dynamic Programming",
        "question_text": "A super ugly number is a positive integer whose prime factors are in the array primes.\n\nGiven an integer n and an array of integers primes, return the nth super ugly number.\n\nThe nth super ugly number is guaranteed to fit in a 32-bit signed integer.\n\n \n\nExample 1:\n\nInput: n = 12, primes = [2,7,13,19]\nOutput: 32\nExplanation: [1,2,4,7,8,13,14,16,19,26,28,32] is the sequence of the first 12 super ugly numbers given primes = [2,7,13,19].\nExample 2:\n\nInput: n = 1, primes = [2,3,5]\nOutput: 1\nExplanation: 1 has no prime factors, therefore all of its prime factors are in the array primes = [2,3,5].\n \n\nConstraints:\n\n1 <= n <= 105\n1 <= primes.length <= 100\n2 <= primes[i] <= 1000\nprimes[i] is guaranteed to be a prime number.\nAll the values of primes are unique and sorted in ascending order.",
        "solution": "class Solution {\n    public int nthSuperUglyNumber(int n, int[] primes) {\n        PriorityQueue<int[]> queue=new PriorityQueue<>((a,b)->(a[0]-b[0]));\n        for (int i=0;i<primes.length;i++)\n            queue.offer(new int[]{primes[i], primes[i], 0});\n\n        int[] nums=new int[n+1];\n        nums[0]=1;\n        \n        int i=1;\n        while (i<n){\n            int[] entry=queue.poll();\n            int num=entry[0], prime=entry[1], index=entry[2];\n\t\t\t// remove duplicate\n            if (num!=nums[i-1]){\n                nums[i]=num;\n                i++;\n            }\n            queue.offer(new int[]{prime*nums[index+1], prime, index+1});\n        }\n        return nums[n-1];\n    }\n}",
        "explanation": "It is actually like how we merge k sorted list:\n\nugly number                       k sorted list\n    1                            2     7    13   19     1 * [2,7,13,19]\n    |                            |     |    |    |\n    2                            4     14   26   38     2 * [2,7,13,19]\n    |                            |     |    |    |\n    4                            8     28   52   76     4 * [2,7,13,19]\n    |                            |     |    |    |              \n    7                            14    49   91   133    7 * [2,7,13,19]\n    |                            |     |    |    |\n    8                            16    56   ...   ...   8 * [2,7,13,19]\n    |                            |     |    |     |\n    .                            .     .     .    .\n    .                            .     .     .    .\n    .                            .     .     .    .\nWe can see that each prime number in primes[] form a sorted list, and now our job is to merge them and find the nth minimum.\n\nHere we don't have the next pointer for each node to trace the next potential candidate. But as we can see in the graph, we can make use of the ugly number we have produced so far!\nHere, each entry has three parts: {num, prime, index}, num represents the value of the node, prime means which sorted list this node is in, and index tells us how far we have gone in that list, it works like the next pointer in linkedlist, help us find the next node in that sorted list.\n\nTime: O(nlogk)\nSpace: O(n+k)"
    },
    {
        "question_id": "6fd13fe3-bfc9-4d99-87fe-b92dabbf33c2",
        "title": "Create Maximum Number",
        "difficulty": "Hard",
        "category": "Array Two Pointers Stack Greedy Monotonic Stack",
        "question_text": "You are given two integer arrays nums1 and nums2 of lengths m and n respectively. nums1 and nums2 represent the digits of two numbers. You are also given an integer k.\n\nCreate the maximum number of length k <= m + n from digits of the two numbers. The relative order of the digits from the same array must be preserved.\n\nReturn an array of the k digits representing the answer.\n\n \n\nExample 1:\n\nInput: nums1 = [3,4,6,5], nums2 = [9,1,2,5,8,3], k = 5\nOutput: [9,8,6,5,3]\nExample 2:\n\nInput: nums1 = [6,7], nums2 = [6,0,4], k = 5\nOutput: [6,7,6,0,4]\nExample 3:\n\nInput: nums1 = [3,9], nums2 = [8,9], k = 3\nOutput: [9,8,9]\n \n\nConstraints:\n\nm == nums1.length\nn == nums2.length\n1 <= m, n <= 500\n0 <= nums1[i], nums2[i] <= 9\n1 <= k <= m + n\nnums1 and nums2 do not have leading zeros.",
        "solution": "class Solution {\npublic:\n    #define MIN(a,b) (a<b?a:b)\n    #define MAX(a,b) (a>b?a:b)\n    // create max number of length t from single non-empty vector\n    void getMax(int* num, int& len, int* result, int& t, int& sortedLen)\n    {\n    \tint n, top = 0;\n    \tresult[0] = num[0];\n    \tconst int need2drop = len - t;\n    \tfor (int i = 1; i < len; ++i){\n    \t\tn = num[i];\n    \t\twhile (top >= 0 && result[top] < n && (i - top) <= need2drop) --top; // i - top means already dropped i - top numbers\n    \t\tif (i - top > need2drop){\n    \t\t\tsortedLen = MAX(1,top);\n    \t\t\twhile (++top < t) result[top] = num[i++];\n    \t\t\treturn;\n    \t\t}\n    \t\tif (++top < t) result[top] = n;\n    \t\telse top = t - 1;\n    \t}\n    }\n    // create max number of different length from single vector\n    void dp(int *num, int len, int&sortedLen, int& minL, int& maxL, int *res, int &k){\n    \tint  j, *head, *prevhead = res;\n    \tconst int soi = sizeof(int);\n    \tgetMax(num, len, res, maxL,sortedLen);\n    \tfor (int l = maxL; l > MAX(minL,1); --l){\n    \t\thead = prevhead + k;\n    \t\tmemcpy(head, prevhead, l*soi);\n    \t\tfor (j = sortedLen; j < l; ++j){\n    \t\t\tif (head[j] > head[j - 1]){\n    \t\t\t\tsortedLen = MAX(1, j - 1);\n    \t\t\t\tmemcpy(head + j - 1, prevhead + j, soi*(l - j));\n    \t\t\t\tbreak;\n    \t\t\t}\n    \t\t}\n    \t\tif (j == l) sortedLen = l;\n    \t\tprevhead = head;\n    \t}\n    }\n    // merge max number created from single vector\n    void merge(int* num1,int len1,int* num2,int len2,int* result,int& resSize){\n    \tint i = 0, j = 0, k = 0;\n    \twhile (i < resSize){\n    \t\tif (j < len1 && k < len2){\n    \t\t\tif (num1[j] > num2[k])\n    \t\t\t\tresult[i++] = num1[j++];\n    \t\t\telse if (num1[j] < num2[k])\n    \t\t\t\tresult[i++] = num2[k++];\n    \t\t\telse{\n    \t\t\t\tint remaining1 = len1 - j, remaining2 = len2 - k, tmp = num1[j];\n    \t\t\t\tint flag = memcmp(num1 + j, num2 + k, sizeof(int) * MIN(remaining1, remaining2));\n    \t\t\t\tflag = (flag == 0 ? (remaining1>remaining2 ? 1 : -1) : flag);\n    \t\t\t\tint * num = flag > 0 ? num1 : num2;\n    \t\t\t\tint & cnt = flag > 0 ? j : k;\n    \t\t\t\tint len = flag > 0 ? len1 : len2;\n    \t\t\t\twhile (num[cnt]==tmp && cnt < len && i<resSize) result[i++] = num[cnt++];\n    \t\t\t}\n    \t\t}\n    \t\telse if (j < len1) result[i++] = num1[j++];\n    \t\telse result[i++] = num2[k++];\n    \t}\n    }\n    \n    vector<int> maxNumber(vector<int>& nums1, vector<int>& nums2, int k){\n    \tint soi = sizeof(int), len1 = nums1.size(), len2 = nums2.size(), step = k*soi;\n    \tint minL1 = MAX(0, k - len2), maxL1 = MIN(k, len1), minL2 = k - maxL1, maxL2 = k - minL1, range = maxL1 - minL1 + 1;\n    \tint * res = new int[range * k * 2 + 2 * k], *dp1 = res + k, *dp2 = res + range*k+k, *tmp=res+range*2*k+k;\n    \tmemset(res, 0, step);\n    \tint sortedLen1 = 1, sortedLen2 = 1;\n    \tif (len1 == 0 && len2 > 0) getMax(&nums2[0], len2, res, k, sortedLen2);\n    \telse if (len1 > 0 && len2 == 0) getMax(&nums1[0], len1, res, k, sortedLen2);\n    \telse if (len1 > 0 && len2 > 0){\n    \t\tdp(&nums1[0], len1, sortedLen1, minL1, maxL1, dp1,k);\n    \t\tdp(&nums2[0], len2, sortedLen2, minL2, maxL2, dp2,k);\n    \t\tif (sortedLen1 + sortedLen2 > k){\n    \t\t\tmerge(dp1 + k*(maxL1 - sortedLen1), sortedLen1, dp2 + k*(maxL2 - sortedLen2), sortedLen2, tmp, k);\n    \t\t\tvector<int> resv(tmp, tmp + k);\n    \t\t\tdelete[] res;\n    \t\t\treturn resv;\n    \t\t}\n    \t\tfor (int i = minL1; i <= maxL1; ++i){\n    \t\t\tmerge(dp1+k*(maxL1-i), i, dp2+k*(maxL2-k+i), (k-i), tmp,k);\n    \t\t\tif (memcmp(res, tmp, step) < 0) memcpy(res, tmp, step);\n    \t\t}\n    \t}\n    \tvector<int> resv(res, res + k);\n    \tdelete[] res;\n    \treturn resv;\n    }\n};",
        "explanation": "The basic idea:\n\nTo create max number of length k from two arrays, you need to create max number of length i from array one and max number of length k-i from array two, then combine them together. After trying all possible i, you will get the max number created from two arrays.\n\nOptimization:\n\nSuppose nums1 = [3, 4, 6, 5], nums2 = [9, 1, 2, 5, 8, 3], the maximum number you can create from nums1 is [6, 5] with length 2. For nums2, it's [9, 8, 3] with length 3. Merging the two sequence, we have [9, 8, 6, 5, 3], which is the max number we can create from two arrays without length constraint. If the required length k<=5, we can simply trim the result to required length from front. For instance, if k=3, then [9, 8, 6] is the result.\n\nSuppose we need to create max number with length 2 from num = [4, 5, 3, 2, 1, 6, 0, 8]. The simple way is to use a stack, first we push 4 and have stack [4], then comes 5 > 4, we pop 4 and push 5, stack becomes [5], 3 < 5, we push 3, stack becomes [5, 3]. Now we have the required length 2, but we need to keep going through the array in case a larger number comes, 2 < 3, we discard it instead of pushing it because the stack already grows to required size 2. 1 < 3, we discard it. 6 > 3, we pop 3, since 6 > 5 and there are still elements left, we can continue to pop 5 and push 6, the stack becomes [6], since 0 < 6, we push 0, the stack becomes [6, 0], the stack grows to required length again. Since 8 > 0, we pop 0, although 8 > 6, we can't continue to pop 6 since there is only one number, which is 8, left, if we pop 6 and push 8, we can't get to length 2, so we push 8 directly, the stack becomes [6, 8].\n\nIn the basic idea, we mentioned trying all possible length i. If we create max number for different i from scratch each time, that would be a waste of time. Suppose num = [4, 9, 3, 2, 1, 8, 7, 6], we need to create max number with length from 1 to 8. For i==8, result is the original array. For i==7, we need to drop 1 number from array, since 9 > 4, we drop 4, the result is [9, 3, 2, 1, 8, 7, 6]. For i==6, we need to drop 1 more number, 3 < 9, skip, 2 < 3, skip, 1 < 2, skip, 8 > 1, we drop 1, the result is [9, 3, 2, 8, 7, 6]. For i==5, we need to drop 1 more, but this time, we needn't check from beginning, during last scan, we already know [9, 3, 2] is monotonically non-increasing, so we check 8 directly, since 8 > 2, we drop 2, the result is [9, 3, 8, 7, 6]. For i==4, we start with 8, 8 > 3, we drop 3, the result is [9, 8, 7, 6]. For i==3, we start with 8, 8 < 9, skip, 7 < 8, skip, 6 < 7, skip, by now, we've got maximum number we can create from num without length constraint. So from now on, we can drop a number from the end each time. The result is [9, 8, 7], For i==2, we drop last number 7 and have [9, 8]. For i==1, we drop last number 8 and have [9]."
    },
    {
        "question_id": "aee3702f-6d92-4ddb-a790-b4d793189a86",
        "title": "Coin Change",
        "difficulty": "Medium",
        "category": "Array Two Pointers Stack Greedy Monotonic Stack",
        "question_text": "You are given an integer array coins representing coins of different denominations and an integer amount representing a total amount of money.\n\nReturn the fewest number of coins that you need to make up that amount. If that amount of money cannot be made up by any combination of the coins, return -1.\n\nYou may assume that you have an infinite number of each kind of coin.\n\n \n\nExample 1:\n\nInput: coins = [1,2,5], amount = 11\nOutput: 3\nExplanation: 11 = 5 + 5 + 1\nExample 2:\n\nInput: coins = [2], amount = 3\nOutput: -1\nExample 3:\n\nInput: coins = [1], amount = 0\nOutput: 0\n \n\nConstraints:\n\n1 <= coins.length <= 12\n1 <= coins[i] <= 231 - 1\n0 <= amount <= 104",
        "solution": "class Solution {\npublic:\n    int coinChange(vector<int>& coins, int amount) {\n        vector<int> minCoins(amount + 1, amount + 1);\n        minCoins[0] = 0;\n\n        for (int i = 1; i <= amount; i++) {\n            for (int j = 0; j < coins.size(); j++) {\n                if (i - coins[j] >= 0) {\n                    minCoins[i] = min(minCoins[i], 1 + minCoins[i - coins[j]]);\n                }\n            }\n        }\n\n        return minCoins[amount] != amount + 1 ? minCoins[amount] : -1;        \n    }\n};",
        "explanation": "Step by Step Algorithm\nInitialize min_coins array:\nCreate an array min_coins of length amount + 1, initialized with each element set to amount + 1.\nSet min_coins[0] to 0, as it takes zero coins to make up an amount of zero.\nmin_coins = [amount + 1] * (amount + 1)\nmin_coins[0] = 0\nIterate over each amount:\nStart a loop from 1 to amount (inclusive) to represent each amount from 1 to amount.\nFor each amount i, iterate over each coin denomination c in the coins list.\nfor i in range(1, amount + 1):\n    for c in coins:\nCalculate the minimum number of coins:\nCheck if the current amount i minus the coin denomination c is greater than or equal to 0.\nIf it is, update min_coins[i] to the minimum of its current value and 1 + min_coins[i - c].\n1 + min_coins[i - c] represents taking one coin of denomination c and the minimum number of coins required to make up the remaining amount i - c.\nif i - c >= 0:\n    min_coins[i] = min(min_coins[i], 1 + min_coins[i - c])\nReturn the result:\nAfter updating min_coins for all amounts from 1 to amount, return min_coins[-1] if it's not equal to amount + 1.\nIf min_coins[-1] is still amount + 1, it means the amount cannot be made up by any combination of coins, so return -1.\nreturn min_coins[-1] if min_coins[-1] != amount + 1 else -1\nThis algorithm uses dynamic programming to compute the minimum number of coins required to make up each amount from 1 to amount, ultimately providing the minimum number of coins required to make up the total amount."
    },
    {
        "question_id": "2970c755-4961-48be-b229-7f9c6f572b6e",
        "title": "Wiggle Sort II",
        "difficulty": "Medium",
        "category": "Array Divide and Conquer Greedy Sorting Quickselect",
        "question_text": "Given an integer array nums, reorder it such that nums[0] < nums[1] > nums[2] < nums[3]....\n\nYou may assume the input array always has a valid answer.\n\n \n\nExample 1:\n\nInput: nums = [1,5,1,1,6,4]\nOutput: [1,6,1,5,1,4]\nExplanation: [1,4,1,5,1,6] is also accepted.\nExample 2:\n\nInput: nums = [1,3,2,2,3,1]\nOutput: [2,3,1,3,1,2]\n \n\nConstraints:\n\n1 <= nums.length <= 5 * 104\n0 <= nums[i] <= 5000\nIt is guaranteed that there will be an answer for the given input nums.\n \n\nFollow Up: Can you do it in O(n) time and/or in-place with O(1) extra space?",
        "solution": "void wiggleSort(vector<int>& nums) {\n    int n = nums.size();\n    \n    // Find a median.\n    auto midptr = nums.begin() + n / 2;\n    nth_element(nums.begin(), midptr, nums.end());\n    int mid = *midptr;\n    \n    // Index-rewiring.\n    #define A(i) nums[(1+2*(i)) % (n|1)]\n\n    // 3-way-partition-to-wiggly in O(n) time with O(1) space.\n    int i = 0, j = 0, k = n - 1;\n    while (j <= k) {\n        if (A(j) > mid)\n            swap(A(i++), A(j++));\n        else if (A(j) < mid)\n            swap(A(j), A(k--));\n        else\n            j++;\n    }\n}",
        "explanation": "First I find a median using nth_element. That only guarantees O(n) average time complexity and I don't know about space complexity. I might write this myself using O(n) time and O(1) space, but that's not what I want to show here.\n\nThis post is about what comes after that. We can use three-way partitioning to arrange the numbers so that those larger than the median come first, then those equal to the median come next, and then those smaller than the median come last.\n\nOrdinarily, you'd then use one more phase to bring the numbers to their final positions to reach the overall wiggle-property. But I don't know a nice O(1) space way for this. Instead, I embed this right into the partitioning algorithm. That algorithm simply works with indexes 0 to n-1 as usual, but sneaky as I am, I rewire those indexes where I want the numbers to actually end up. The partitioning-algorithm doesn't even know that I'm doing that, it just works like normal (it just uses A(x) instead of nums[x]).\n\nLet's say nums is [10,11,...,19]. Then after nth_element and ordinary partitioning, we might have this (15 is my median):\n\nindex:     0  1  2  3   4   5  6  7  8  9\nnumber:   18 17 19 16  15  11 14 10 13 12\nI rewire it so that the first spot has index 5, the second spot has index 0, etc, so that I might get this instead:\n\nindex:     5  0  6  1  7  2  8  3  9  4\nnumber:   11 18 14 17 10 19 13 16 12 15\nAnd 11 18 14 17 10 19 13 16 12 15 is perfectly wiggly. And the whole partitioning-to-wiggly-arrangement (everything after finding the median) only takes O(n) time and O(1) space.\n\nIf the above description is unclear, maybe this explicit listing helps:\n\nAccessing A(0) actually accesses nums[1].\nAccessing A(1) actually accesses nums[3].\nAccessing A(2) actually accesses nums[5].\nAccessing A(3) actually accesses nums[7].\nAccessing A(4) actually accesses nums[9].\nAccessing A(5) actually accesses nums[0].\nAccessing A(6) actually accesses nums[2].\nAccessing A(7) actually accesses nums[4].\nAccessing A(8) actually accesses nums[6].\nAccessing A(9) actually accesses nums[8]."
    },
    {
        "question_id": "06b8783e-5cd4-4546-8190-976e9816b964",
        "title": "Count of Range Sum",
        "difficulty": "Hard",
        "category": "Array Binary Search Divide and Conquer Binary Indexed Tree Segment Tree Merge Sort Ordered Set",
        "question_text": "Given an integer array nums and two integers lower and upper, return the number of range sums that lie in [lower, upper] inclusive.\n\nRange sum S(i, j) is defined as the sum of the elements in nums between indices i and j inclusive, where i <= j.\n\n \n\nExample 1:\n\nInput: nums = [-2,5,-1], lower = -2, upper = 2\nOutput: 3\nExplanation: The three ranges are: [0,0], [2,2], and [0,2] and their respective sums are: -2, -1, 2.\nExample 2:\n\nInput: nums = [0], lower = 0, upper = 0\nOutput: 1\n \n\nConstraints:\n\n1 <= nums.length <= 105\n-231 <= nums[i] <= 231 - 1\n-105 <= lower <= upper <= 105\nThe answer is guaranteed to fit in a 32-bit integer.",
        "solution": "public int countRangeSum(int[] nums, int lower, int upper) {\n    int n = nums.length;\n    long[] sums = new long[n + 1];\n    for (int i = 0; i < n; ++i)\n        sums[i + 1] = sums[i] + nums[i];\n    return countWhileMergeSort(sums, 0, n + 1, lower, upper);\n}\n\nprivate int countWhileMergeSort(long[] sums, int start, int end, int lower, int upper) {\n    if (end - start <= 1) return 0;\n    int mid = (start + end) / 2;\n    int count = countWhileMergeSort(sums, start, mid, lower, upper) \n              + countWhileMergeSort(sums, mid, end, lower, upper);\n    int j = mid, k = mid, t = mid;\n    long[] cache = new long[end - start];\n    for (int i = start, r = 0; i < mid; ++i, ++r) {\n        while (k < end && sums[k] - sums[i] < lower) k++;\n        while (j < end && sums[j] - sums[i] <= upper) j++;\n        while (t < end && sums[t] < sums[i]) cache[r++] = sums[t++];\n        cache[r] = sums[i];\n        count += j - k;\n    }\n    System.arraycopy(cache, 0, sums, start, t - start);\n    return count;\n}",
        "explanation": "Recall count smaller number after self where we encountered the problem\n\ncount[i] = count of nums[j] - nums[i] < 0 with j > i\nHere, after we did the preprocess, we need to solve the problem\n\ncount[i] = count of a <= S[j] - S[i] <= b with j > i\nans = sum(count[:])\nTherefore the two problems are almost the same. We can use the same technique used in that problem to solve this problem. One solution is merge sort based; another one is Balanced BST based. The time complexity are both O(n log n).\n\nThe merge sort based solution counts the answer while doing the merge. During the merge stage, we have already sorted the left half [start, mid) and right half [mid, end). We then iterate through the left half with index i. For each i, we need to find two indices k and j in the right half where\n\nj is the first index satisfy sums[j] - sums[i] > upper and\nk is the first index satisfy sums[k] - sums[i] >= lower.\nThen the number of sums in [lower, upper] is j-k. We also use another index t to copy the elements satisfy sums[t] < sums[i] to a cache in order to complete the merge sort.\n\nDespite the nested loops, the time complexity of the \"merge & count\" stage is still linear. Because the indices k, j, t will only increase but not decrease, each of them will only traversal the right half once at most. The total time complexity of this divide and conquer solution is then O(n log n).\n\nOne other concern is that the sums may overflow integer. So we use long instead."
    },
    {
        "question_id": "f5beffad-88ee-494a-ad48-f6eac5c760c2",
        "title": "Russian Doll Envelopes",
        "difficulty": "Hard",
        "category": "Array Binary Search Dynamic Programming Sorting",
        "question_text": "You are given a 2D array of integers envelopes where envelopes[i] = [wi, hi] represents the width and the height of an envelope.\n\nOne envelope can fit into another if and only if both the width and height of one envelope are greater than the other envelope's width and height.\n\nReturn the maximum number of envelopes you can Russian doll (i.e., put one inside the other).\n\nNote: You cannot rotate an envelope.\n\n \n\nExample 1:\n\nInput: envelopes = [[5,4],[6,4],[6,7],[2,3]]\nOutput: 3\nExplanation: The maximum number of envelopes you can Russian doll is 3 ([2,3] => [5,4] => [6,7]).\nExample 2:\n\nInput: envelopes = [[1,1],[1,1],[1,1]]\nOutput: 1\n \n\nConstraints:\n\n1 <= envelopes.length <= 105\nenvelopes[i].length == 2\n1 <= wi, hi <= 105",
        "solution": "public int maxEnvelopes(int[][] envelopes) {\n    if(envelopes == null || envelopes.length == 0 \n       || envelopes[0] == null || envelopes[0].length != 2)\n        return 0;\n    Arrays.sort(envelopes, new Comparator<int[]>(){\n        public int compare(int[] arr1, int[] arr2){\n            if(arr1[0] == arr2[0])\n                return arr2[1] - arr1[1];\n            else\n                return arr1[0] - arr2[0];\n       } \n    });\n    int dp[] = new int[envelopes.length];\n    int len = 0;\n    for(int[] envelope : envelopes){\n        int index = Arrays.binarySearch(dp, 0, len, envelope[1]);\n        if(index < 0)\n            index = -(index + 1);\n        dp[index] = envelope[1];\n        if(index == len)\n            len++;\n    }\n    return len;\n}",
        "explanation": "Sort the array. Ascend on width and descend on height if width are same.\nFind the longest increasing subsequence based on height.\nSince the width is increasing, we only need to consider height.\n[3, 4] cannot contains [3, 3], so we need to put [3, 4] before [3, 3] when sorting otherwise it will be counted as an increasing number if the order is [3, 3], [3, 4]"
    },
    {
        "question_id": "88f8b68a-5005-40a4-ae24-0a0075a1371c",
        "title": "Maximum Product of Subsequences With an Alternating Sum Equal to K",
        "difficulty": "Hard",
        "category": "Array Hash Table Dynamic Programming",
        "question_text": "You are given an integer array nums and two integers, k and limit. Your task is to find a non-empty subsequence of nums that:\n\nHas an alternating sum equal to k.\nMaximizes the product of all its numbers without the product exceeding limit.\nReturn the product of the numbers in such a subsequence. If no subsequence satisfies the requirements, return -1.\n\nThe alternating sum of a 0-indexed array is defined as the sum of the elements at even indices minus the sum of the elements at odd indices.\n\n \n\nExample 1:\n\nInput: nums = [1,2,3], k = 2, limit = 10\n\nOutput: 6\n\nExplanation:\n\nThe subsequences with an alternating sum of 2 are:\n\n[1, 2, 3]\nAlternating Sum: 1 - 2 + 3 = 2\nProduct: 1 * 2 * 3 = 6\n[2]\nAlternating Sum: 2\nProduct: 2\nThe maximum product within the limit is 6.\n\nExample 2:\n\nInput: nums = [0,2,3], k = -5, limit = 12\n\nOutput: -1\n\nExplanation:\n\nA subsequence with an alternating sum of exactly -5 does not exist.\n\nExample 3:\n\nInput: nums = [2,2,3,3], k = 0, limit = 9\n\nOutput: 9\n\nExplanation:\n\nThe subsequences with an alternating sum of 0 are:\n\n[2, 2]\nAlternating Sum: 2 - 2 = 0\nProduct: 2 * 2 = 4\n[3, 3]\nAlternating Sum: 3 - 3 = 0\nProduct: 3 * 3 = 9\n[2, 2, 3, 3]\nAlternating Sum: 2 - 2 + 3 - 3 = 0\nProduct: 2 * 2 * 3 * 3 = 36\nThe subsequence [2, 2, 3, 3] has the greatest product with an alternating sum equal to k, but 36 > 9. The next greatest product is 9, which is within the limit.\n\n \n\nConstraints:\n\n1 <= nums.length <= 150\n0 <= nums[i] <= 12\n-105 <= k <= 105\n1 <= limit <= 5000",
        "solution": "const int MIN = -5000;\n\nclass Solution {\npublic:\n    unordered_map<int, unordered_map<int, unordered_map<int, unordered_map<int, int>>>> dp;\n    int recursion(int pos, int currSum, int product, int isOdd, int k, int n, vector<int> &nums, int limit) {\n        if(pos == n) {\n            return (currSum == k && isOdd != 0 && product <= limit ? product : MIN);\n        }\n        \n        if(dp.count(pos) && dp[pos].count(currSum) && dp[pos][currSum].count(product) && dp[pos][currSum][product].count(isOdd)) {\n            return dp[pos][currSum][product][isOdd];\n        }\n            \n        int ans = recursion(pos + 1, currSum, product, isOdd, k, n, nums, limit);\n        if(isOdd == 0) {\n            ans = max(ans, recursion(pos + 1, currSum + nums[pos], nums[pos], 2, k, n, nums, limit));\n        }\n        if(isOdd == 1) {\n            ans = max(ans, recursion(pos + 1, currSum + nums[pos], min(product * nums[pos], limit + 1), 2, k, n, nums, limit));\n        }\n        if(isOdd == 2) {\n            ans = max(ans, recursion(pos + 1, currSum - nums[pos], min(product * nums[pos], limit + 1), 1, k, n, nums, limit));\n        }\n        \n        return dp[pos][currSum][product][isOdd] = ans;\n    }\n    \n    int maxProduct(vector<int> &nums, int k, int limit) {\n        int n = nums.size();\n        \n        int sum = 0;\n        for(auto &x: nums) sum += x;\n        \n        if(k > sum || k < -sum) return -1;\n            \n        dp.clear();\n        int ans = recursion(0, 0, 0, 0, k, n, nums, limit);\n        return (ans == MIN) ? -1 : ans;\n    }\n};",
        "explanation": "Maximum Product of a Special Subsequence\n Intuition\nThe problem revolves around finding a special subsequence from a given array of positive integers nums, where we need to:\n\nSelect elements in a specific pattern: odd-indexed terms are added, and even-indexed terms are subtracted to form a total sum k.\nThe product of the elements in the subsequence should be maximum but not exceed a given limit.\nSo essentially, it's a dynamic programming problem with multiple states:\n\nThe current index (pos)\nThe current sum (currSum)\nThe product so far (product)\nThe stage or parity (isOdd): whether we're at the start, first number to add, or number to subtract\n Approach\nWe use a recursive function with memoization (unordered_map-based DP) to avoid recalculating overlapping subproblems.\n\nObservation\nOne interesting observation in this problem is sum doesn't exceeds 1800 because the max nums length is 150 and every element isn't greater than 12.\nState Definition\nWe define a DP state as dp[pos][currSum][product][isOdd]:\n\npos: Current index in nums\ncurrSum: Running total based on the subsequence pattern\nproduct: Product formed so far\nisOdd:\n0: Start of subsequence (no elements picked yet)\n1: Last operation was an addition (+a)\n2: Last operation was a subtraction (-b)\nTransition\nAt every step, we either:\n\nSkip the current number and continue (pos + 1).\nInclude the current number:\nIf isOdd == 0: First element, add it and begin product\nIf isOdd == 1: Subtract current number from sum and multiply in product\nIf isOdd == 2: Add current number to sum and multiply in product\nInclusion is only considered if the new product doesn't exceed the limit.\n\nAt base case (pos == n), we check if:\n\ncurrSum == k\nAt least one element should be considered (isOdd != 0)\nproduct <= limit\nIf all these hold, we return the product, else a minimum placeholder value (MIN = -5000).\n\nFinally, we return the best product found or -1 if no valid sequence exists.\n\n Complexity\nTime Complexity:\nO(n⋅sum⋅201⋅3)\n\nn for index\n2 * sum for possible values of currSum (including negatives)\n201 for possible unique product values (we prune above limit + 1)\n3 for possible values of isOdd\nSince we’re memoizing states using hash maps, pruning and skipping invalid states makes this faster than brute force.\n\nSpace Complexity:\nO(n⋅sum⋅201⋅3)\nDue to recursive call stack and DP table (stored in unordered maps), though it's sparsely populated."
    },
    {
        "question_id": "0d1483d9-9fd3-4e75-8200-34c7fb7d04e7",
        "title": "Final Array State After K Multiplication Operations II",
        "difficulty": "Hard",
        "category": "Array Heap (Priority Queue) Simulation",
        "question_text": "You are given an integer array nums, an integer k, and an integer multiplier.\n\nYou need to perform k operations on nums. In each operation:\n\nFind the minimum value x in nums. If there are multiple occurrences of the minimum value, select the one that appears first.\nReplace the selected minimum value x with x * multiplier.\nAfter the k operations, apply modulo 109 + 7 to every value in nums.\n\nReturn an integer array denoting the final state of nums after performing all k operations and then applying the modulo.\n\n \n\nExample 1:\n\nInput: nums = [2,1,3,5,6], k = 5, multiplier = 2\n\nOutput: [8,4,6,5,6]\n\nExplanation:\n\nOperation\tResult\nAfter operation 1\t[2, 2, 3, 5, 6]\nAfter operation 2\t[4, 2, 3, 5, 6]\nAfter operation 3\t[4, 4, 3, 5, 6]\nAfter operation 4\t[4, 4, 6, 5, 6]\nAfter operation 5\t[8, 4, 6, 5, 6]\nAfter applying modulo\t[8, 4, 6, 5, 6]\nExample 2:\n\nInput: nums = [100000,2000], k = 2, multiplier = 1000000\n\nOutput: [999999307,999999993]\n\nExplanation:\n\nOperation\tResult\nAfter operation 1\t[100000, 2000000000]\nAfter operation 2\t[100000000000, 2000000000]\nAfter applying modulo\t[999999307, 999999993]\n \n\nConstraints:\n\n1 <= nums.length <= 104\n1 <= nums[i] <= 109\n1 <= k <= 109\n1 <= multiplier <= 106",
        "solution": "const long long mod = 1000000007;\n\nclass Solution {\npublic:\n    long long power_mod(long long base, long long exp, long long mod) {\n    long long result = 1;\n    \n    while (exp > 0) {\n        if (exp % 2 == 1) {\n            result = (result * base) % mod;\n        }\n        base = (base * base) % mod;\n        exp = exp / 2;\n    }\n    // this function multiplies a number by itself n times in O(logn)\n    return result;\n}\n    vector<int> getFinalState(vector<int>& nums, int k, int multiplier) {\n        if (multiplier == 1) return nums; // do not miss this!!\n        priority_queue <pair<long long,long long>, vector<pair<long long,long long>>, greater<pair<long long,long long>>> pq;\n        int n = nums.size();\n        for (int i = 0; i < n; i++) pq.push({nums[i],i});\n        unordered_map<int,int> m,m1;\n        // m for storing number of operations at each index\n        //m1 to know if all elements have got an operation\n        while (1){\n            if ((int)m1.size() == n || k == 0) break; // no more operations or state achieved\n            long long x = pq.top().first, y = pq.top().second;\n            pq.pop();\n            x *= multiplier; pq.push({x,y});\n            m1[y]++; k--;\n        }\n        vector<long long> v(n); // to avoid integer overflow\n        // This vector will store the elements after ideal state is achieved\n        while (!pq.empty()){\n            long long x = pq.top().first, y = pq.top().second;\n            v[y] = x;\n            pq.pop();\n        }\n        int rep = k/n, md = k%n;\n        for (int i = 0; i < n; i++) pq.push({v[i],i});\n        // I had to push it again because I did not declare v initially due to contest pressure. Better to do that.\n        while (!pq.empty()){\n            int x = pq.top().second;\n            m[x] = rep;\n            if (md > 0)m[x]++,md--;\n            // index x has been assigned its number of operations\n            pq.pop();\n        }\n        // Now just compute every value while calling power_mod funtion\n        for (int i = 0; i < n; i++){\n            long long mlt = power_mod(multiplier, m[i],mod);\n            v[i] = ((v[i]%mod)*(mlt%mod))%mod;\n            nums[i] = v[i];\n        }\n        return nums;\n    }\n};",
        "explanation": "Intuition\nThe general idea is to divide the operations greedily among all indexes.\n\nEvery number after getting an operation should not remain as the smallest. So we will have to achieve that state first.\n\nBY OBSERVATION\nWhen all the elements get atleast an operation, we will achieve the above mentioned state. So we will first greedily assign them operation till all elements get atleast one operation.\n\nUse priority queue min heap or multiset for that.\n\nAfter this we can assign every index a number of operations through our initial general idea.\n\nWhat about such large value of k?\nThe number of operations of each index may be huge due to this. The optimal approach is achieved in log(n) as the multiplier increases exponentially. Check out the function in the code. This is called Exponentiation by Squaring.\n\nComplexity\nTime complexity: O(nlogk)\n\nSpace complexity: O(n)"
    },
    {
        "question_id": "878a31db-8cd5-4979-97d0-487d3796105a",
        "title": "Longest Subsequence With Decreasing Adjacent Difference",
        "difficulty": "Medium",
        "category": "Array Dynamic Programming",
        "question_text": "You are given an array of integers nums.\n\nYour task is to find the length of the longest subsequence seq of nums, such that the absolute differences between consecutive elements form a non-increasing sequence of integers. In other words, for a subsequence seq0, seq1, seq2, ..., seqm of nums, |seq1 - seq0| >= |seq2 - seq1| >= ... >= |seqm - seqm - 1|.\n\nReturn the length of such a subsequence.\n\n \n\nExample 1:\n\nInput: nums = [16,6,3]\n\nOutput: 3\n\nExplanation: \n\nThe longest subsequence is [16, 6, 3] with the absolute adjacent differences [10, 3].\n\nExample 2:\n\nInput: nums = [6,5,3,4,2,1]\n\nOutput: 4\n\nExplanation:\n\nThe longest subsequence is [6, 4, 2, 1] with the absolute adjacent differences [2, 2, 1].\n\nExample 3:\n\nInput: nums = [10,20,10,19,10,20]\n\nOutput: 5\n\nExplanation: \n\nThe longest subsequence is [10, 20, 10, 19, 10] with the absolute adjacent differences [10, 10, 9, 9].\n\n \n\nConstraints:\n\n2 <= nums.length <= 104\n1 <= nums[i] <= 300",
        "solution": "class Solution {\npublic:\n    int longestSubsequence(vector<int>& nums) {\n        vector<vector<int>> dp(302, vector<int>(302));\n\n        for (int i = nums.size() - 1; i >= 0; --i){\n            int num = nums[i];\n    \n            for (int next = 1; next <= 300; ++next){\n                int diff = abs(next - num);\n                dp[num][diff] = max(dp[num][diff], dp[next][diff] + 1);\n            }\n\n            for (int j = 1; j <= 300; ++j){\n                dp[num][j] = max(dp[num][j], dp[num][j - 1]);\n            }\n        }\n\n        int ans = INT_MIN;\n        for (int i = 0; i <= 301; ++i){\n            for (int j = 0; j <= 301; ++j){\n                ans = max(ans, dp[i][j]);\n            }\n        }\n\n        return ans;\n    }\n};",
        "explanation": "Intuition\nSince the range of values is small we can store information about longest subsequences starting from specific values and having differences less than or equal to some value.\n\nApproach\nGoing from back to front, compute for the current number num and for each possible absolute difference d, the maximum length subsequence starting from that number and having differences less than or equal to d between successive elements.\n\nTo do so, we can use information computed earlier. For each other number num2, update dp[num][abs(num−num2)] using dp[num2][abs(num−num2)].\n\nOnce this is done we can compute dp[num][diff] as max \nd≤diff\n​\n dp[num][d]. This is done because we are interested in the longest subsequences whose differences between successive elements are bounded by diff.\n\nComplexity\nTime complexity:\nO(n∗max_value)\n\nSpace complexity:\nO(max_value \n2\n )"
    },
    {
        "question_id": "077f0fd2-8197-4dcd-9948-b57fdd0ba649",
        "title": "Implement Router",
        "difficulty": "Medium",
        "category": "Array Hash Table Binary Search Design Queue Ordered Set",
        "question_text": "Design a data structure that can efficiently manage data packets in a network router. Each data packet consists of the following attributes:\n\nsource: A unique identifier for the machine that generated the packet.\ndestination: A unique identifier for the target machine.\ntimestamp: The time at which the packet arrived at the router.\nImplement the Router class:\n\nRouter(int memoryLimit): Initializes the Router object with a fixed memory limit.\n\nmemoryLimit is the maximum number of packets the router can store at any given time.\nIf adding a new packet would exceed this limit, the oldest packet must be removed to free up space.\nbool addPacket(int source, int destination, int timestamp): Adds a packet with the given attributes to the router.\n\nA packet is considered a duplicate if another packet with the same source, destination, and timestamp already exists in the router.\nReturn true if the packet is successfully added (i.e., it is not a duplicate); otherwise return false.\nint[] forwardPacket(): Forwards the next packet in FIFO (First In First Out) order.\n\nRemove the packet from storage.\nReturn the packet as an array [source, destination, timestamp].\nIf there are no packets to forward, return an empty array.\nint getCount(int destination, int startTime, int endTime):\n\nReturns the number of packets currently stored in the router (i.e., not yet forwarded) that have the specified destination and have timestamps in the inclusive range [startTime, endTime].\nNote that queries for addPacket will be made in increasing order of timestamp.\n\n \n\nExample 1:\n\nInput:\n[\"Router\", \"addPacket\", \"addPacket\", \"addPacket\", \"addPacket\", \"addPacket\", \"forwardPacket\", \"addPacket\", \"getCount\"]\n[[3], [1, 4, 90], [2, 5, 90], [1, 4, 90], [3, 5, 95], [4, 5, 105], [], [5, 2, 110], [5, 100, 110]]\n\nOutput:\n[null, true, true, false, true, true, [2, 5, 90], true, 1]\n\nExplanation\n\nRouter router = new Router(3); // Initialize Router with memoryLimit of 3.\nrouter.addPacket(1, 4, 90); // Packet is added. Return True.\nrouter.addPacket(2, 5, 90); // Packet is added. Return True.\nrouter.addPacket(1, 4, 90); // This is a duplicate packet. Return False.\nrouter.addPacket(3, 5, 95); // Packet is added. Return True\nrouter.addPacket(4, 5, 105); // Packet is added, [1, 4, 90] is removed as number of packets exceeds memoryLimit. Return True.\nrouter.forwardPacket(); // Return [2, 5, 90] and remove it from router.\nrouter.addPacket(5, 2, 110); // Packet is added. Return True.\nrouter.getCount(5, 100, 110); // The only packet with destination 5 and timestamp in the inclusive range [100, 110] is [4, 5, 105]. Return 1.\nExample 2:\n\nInput:\n[\"Router\", \"addPacket\", \"forwardPacket\", \"forwardPacket\"]\n[[2], [7, 4, 90], [], []]\n\nOutput:\n[null, true, [7, 4, 90], []]\n\nExplanation\n\nRouter router = new Router(2); // Initialize Router with memoryLimit of 2.\nrouter.addPacket(7, 4, 90); // Return True.\nrouter.forwardPacket(); // Return [7, 4, 90].\nrouter.forwardPacket(); // There are no packets left, return [].\n \n\nConstraints:\n\n2 <= memoryLimit <= 105\n1 <= source, destination <= 2 * 105\n1 <= timestamp <= 109\n1 <= startTime <= endTime <= 109\nAt most 105 calls will be made to addPacket, forwardPacket, and getCount methods altogether.\nqueries for addPacket will be made in increasing order of timestamp.",
        "solution": "class Router {\npublic:\n    map<vector<int>, int> mpp; // to track duplicates\n    queue<vector<int>> queue; // to store packets in FIFO order\n    unordered_map<int, vector<int>> timestamps; // for timestamps tracking\n    unordered_map<int, int> st; \n    int maxSize = 0; // maxSize allowed\n\n    Router(int memoryLimit) { \n        maxSize = memoryLimit; \n    }\n\n    bool addPacket(int source, int destination, int timestamp) {\n        vector<int> packet = {source, destination, timestamp};\n        // checking for duplicate\n        if (mpp.count(packet))\n            return false;\n        if (queue.size() == maxSize) { // remove the first element if queue is full\n            vector<int> res = queue.front();\n            mpp.erase(res);\n            int temp = res[1];\n            st[temp]++;  \n            queue.pop();\n        }\n        queue.push(packet);\n        mpp[packet]++;\n        timestamps[destination].push_back(timestamp);\n        return true;\n    }\n\n    vector<int> forwardPacket() {\n        if(queue.empty()) return {};\n        vector<int> res = queue.front();\n        queue.pop();\n        mpp.erase(res);\n        int temp = res[1];\n        st[temp]++;\n        return res;\n    }\n\n    int getCount(int destination, int startTime, int endTime) {\n        if(timestamps.find(destination) == timestamps.end())\n            return 0;\n        auto &p = timestamps[destination];\n        int temp = st[destination];\n        auto right = lower_bound(p.begin() + temp, p.end(), startTime);\n        auto left = upper_bound(p.begin() + temp, p.end(), endTime);\n        return int(left - right);\n    }\n};",
        "explanation": "Approach\nLets go over the data structures that we can use here to make our work simpler →\nUse a hashmap to track duplicates.\nUse a queue to store packets in FIFO order as mentioned in the question and pop when needed.\nUse a map of vector to track the timestamps and destinations.\nUse a map to track how many packets we have removed so far.\nNow lets go step by step through the functions,\nRouter → Here we only store the maxSize allowed nothing else.\naddPacket → We firstly check if the packet has already been added, if yes then we simply return false. Else we add it in our ds's.\nforwardPacket → Simply remove the packet from our map and update it in our ds's.\ngetCount → Use binary search functions lower bound and upper bound to return the range [left,right] which consists of elements in the range startTime and endTime."
    },
    {
        "question_id": "c851e74e-5a17-4c4a-92ce-f9c17afeaf80",
        "title": "Number of Unique XOR Triplets I",
        "difficulty": "Medium",
        "category": "Array Math Bit Manipulation",
        "question_text": "You are given an integer array nums of length n, where nums is a permutation of the numbers in the range [1, n].\n\nA XOR triplet is defined as the XOR of three elements nums[i] XOR nums[j] XOR nums[k] where i <= j <= k.\n\nReturn the number of unique XOR triplet values from all possible triplets (i, j, k).\n\n \n\nExample 1:\n\nInput: nums = [1,2]\n\nOutput: 2\n\nExplanation:\n\nThe possible XOR triplet values are:\n\n(0, 0, 0) → 1 XOR 1 XOR 1 = 1\n(0, 0, 1) → 1 XOR 1 XOR 2 = 2\n(0, 1, 1) → 1 XOR 2 XOR 2 = 1\n(1, 1, 1) → 2 XOR 2 XOR 2 = 2\nThe unique XOR values are {1, 2}, so the output is 2.\n\nExample 2:\n\nInput: nums = [3,1,2]\n\nOutput: 4\n\nExplanation:\n\nThe possible XOR triplet values include:\n\n(0, 0, 0) → 3 XOR 3 XOR 3 = 3\n(0, 0, 1) → 3 XOR 3 XOR 1 = 1\n(0, 0, 2) → 3 XOR 3 XOR 2 = 2\n(0, 1, 2) → 3 XOR 1 XOR 2 = 0\nThe unique XOR values are {0, 1, 2, 3}, so the output is 4.\n\n \n\nConstraints:\n\n1 <= n == nums.length <= 105\n1 <= nums[i] <= n\nnums is a permutation of integers from 1 to n.",
        "solution": "class Solution {\npublic:\n    int uniqueXorTriplets(vector<int>& nums) {\n        int n = nums.size();\n\n        if(n < 3) return n;\n\n        // Find the Most Significant Bit\n        int cnt = 0;\n        int temp = n;\n        while(temp > 0){\n            temp >>= 1;\n            cnt++;\n        }\n        \n        return pow(2, cnt);\n    }\n};",
        "explanation": "Problem Summary\nGiven a permutation nums of numbers from 1 to n, you are to find the number of unique values you can get by doing XOR of all triplets (i, j, k) where i <= j <= k.\n\nUnderstanding the Solution\nFor n < 3\nFor n = 1, only one element → 1 unique value.\nFor n = 2, only 2 combinations → 2 unique values.\nFor n >= 3\nThe number of possible XOR values between numbers from 1 to n is bounded by the number of bits required to represent n.\nSince any XOR operation between values in [1, n] gives a result between 0 to (2^cnt - 1), the maximum number of unique values is 2^cnt.\nComplexity\nTime complexity: O(log n)\nSpace complexity: O(1)"
    },
    {
        "question_id": "a01553b9-4b6f-42c6-9b94-a5214d3db43b",
        "title": "Non-decreasing Array",
        "difficulty": "Medium",
        "category": "Array",
        "question_text": "Given an array nums with n integers, your task is to check if it could become non-decreasing by modifying at most one element.\n\nWe define an array is non-decreasing if nums[i] <= nums[i + 1] holds for every i (0-based) such that (0 <= i <= n - 2).\n\n \n\nExample 1:\n\nInput: nums = [4,2,3]\nOutput: true\nExplanation: You could modify the first 4 to 1 to get a non-decreasing array.\nExample 2:\n\nInput: nums = [4,2,1]\nOutput: false\nExplanation: You cannot get a non-decreasing array by modifying at most one element.\n \n\nConstraints:\n\nn == nums.length\n1 <= n <= 104\n-105 <= nums[i] <= 105",
        "solution": "bool checkPossibility(vector<int>& nums) {\n        int cnt = 0;                                                                    //the number of changes\n        for(int i = 1; i < nums.size() && cnt<=1 ; i++){\n            if(nums[i-1] > nums[i]){\n                cnt++;\n                if(i-2<0 || nums[i-2] <= nums[i])nums[i-1] = nums[i];                    //modify nums[i-1] of a priority\n                else nums[i] = nums[i-1];                                                //have to modify nums[i]\n            }\n        }\n        return cnt<=1;\n    }",
        "explanation": "This problem is like a greedy problem. When you find nums[i-1] > nums[i] for some i, you will prefer to change nums[i-1]'s value, since a larger nums[i] will give you more risks that you get inversion errors after position i. But, if you also find nums[i-2] > nums[i], then you have to change nums[i]'s value instead, or else you need to change both of nums[i-2]'s and nums[i-1]'s values."
    },
    {
        "question_id": "5fffdee6-ccef-466e-93a2-0cb7307d811f",
        "title": "Split Array With Same Average",
        "difficulty": "Hard",
        "category": "Array Math Dynamic Programming Bit Manipulation Bitmask",
        "question_text": "You are given an integer array nums.\n\nYou should move each element of nums into one of the two arrays A and B such that A and B are non-empty, and average(A) == average(B).\n\nReturn true if it is possible to achieve that and false otherwise.\n\nNote that for an array arr, average(arr) is the sum of all the elements of arr over the length of arr.\n\n \n\nExample 1:\n\nInput: nums = [1,2,3,4,5,6,7,8]\nOutput: true\nExplanation: We can split the array into [1,4,5,8] and [2,3,6,7], and both of them have an average of 4.5.\nExample 2:\n\nInput: nums = [3,1]\nOutput: false\n \n\nConstraints:\n\n1 <= nums.length <= 30\n0 <= nums[i] <= 104",
        "solution": "class Solution(object):\n    def splitArraySameAverage(self, A):\n        from fractions import Fraction\n        N = len(A)\n        S = sum(A)\n        A = [z - Fraction(S, N) for z in A]\n\n        if N == 1: return False\n\n        #Want zero subset sum\n        left = {A[0]}\n        for i in xrange(1, N/2):\n            left = {z + A[i] for z in left} | left | {A[i]}\n        if 0 in left: return True\n\n        right = {A[-1]}\n        for i in xrange(N/2, N-1):\n            right = {z + A[i] for z in right} | right | {A[i]}\n        if 0 in right: return True\n\n        sleft = sum(A[i] for i in xrange(N/2))\n        sright = sum(A[i] for i in xrange(N/2, N))\n\n        return any(-ha in right and (ha, -ha) != (sleft, sright) for ha in left)",
        "explanation": "Intuition and Algorithm\n\nFirst, let's get a sense of the condition that average(B) = average(C), where B, C are defined in the problem statement.\n\nSay A (the input array) has N elements which sum to S, and B (one of the splitting sets) has K elements which sum to X. Then the equation for average(B) = average(C) becomes  \nK\nX\n​\n = \nN−K\nS−X\n​\n . This reduces to X(N−K)=(S−X)K which is  \nK\nX\n​\n = \nN\nS\n​\n . That is, average(B) = average(A).\n\nNow, we could delete average(A) from each element A[i] without changing our choice for B. (A[i] -= mu, where mu = average(A)). This means we just want to choose a set B that sums to 0.\n\nTrying all 2 \nN\n  sets is still too many choices, so we will create sets of sums left, right of the approximately 2 \nN/2\n  choices on the left and on the right separately. (That is, left is a set of sums of every powerset in the first half of A, and right is the set of sums of every powerset in the second half of A). Then, it is true if we find 0 in these powersets, or if two sums in different halves cancel out (-x in right for x in left), except for one minor detail below.\n\nCare must be taken that we do not specify sets that would make the original B or C empty. If sleft = A[0] + A[1] + ... + A[N/2 - 1], and sright = A[N/2] + ... + A[N-1], (where A[i] was transformed to the new A[i] - average(A)) then we cannot choose both (sleft, sright). This is correct because if for example sleft was a sum reached by a strictly smaller powerset than {A[0], A[1], ..., A[N/2 - 1]}, then the difference between these sets would be non-empty and have sum 0.\nComplexity Analysis\n\nTime Complexity: O(2 N/2 ), where N is the length of A.\n\nSpace Complexity: O(2 N/2 )."
    },
    {
        "question_id": "cb60a672-8727-40fb-b49b-a3a153e87182",
        "title": "Maximum Unique Subarray Sum After Deletion",
        "difficulty": "Easy",
        "category": "Array Hash Table Greedy",
        "question_text": "You are given an integer array nums.\n\nYou are allowed to delete any number of elements from nums without making it empty. After performing the deletions, select a subarray of nums such that:\n\nAll elements in the subarray are unique.\nThe sum of the elements in the subarray is maximized.\nReturn the maximum sum of such a subarray.\n\n \n\nExample 1:\n\nInput: nums = [1,2,3,4,5]\n\nOutput: 15\n\nExplanation:\n\nSelect the entire array without deleting any element to obtain the maximum sum.\n\nExample 2:\n\nInput: nums = [1,1,0,1,1]\n\nOutput: 1\n\nExplanation:\n\nDelete the element nums[0] == 1, nums[1] == 1, nums[2] == 0, and nums[3] == 1. Select the entire array [1] to obtain the maximum sum.\n\nExample 3:\n\nInput: nums = [1,2,-1,-2,1,0,-1]\n\nOutput: 3\n\nExplanation:\n\nDelete the elements nums[2] == -1 and nums[3] == -2, and select the subarray [2, 1] from [1, 2, 1, 0, -1] to obtain the maximum sum.\n\n \n\nConstraints:\n\n1 <= nums.length <= 100\n-100 <= nums[i] <= 100",
        "solution": "class Solution {\npublic:\n    int maxSum(vector<int>& nums) {\n        int sum = 0;\n        set<int> st;\n        int mxNeg = INT_MIN;\n        for (int i = 0; i < nums.size(); i++) {\n            if (nums[i] > 0)\n                st.insert(nums[i]);\n            else\n                mxNeg = max(mxNeg, nums[i]);\n        }\n        for (auto val : st) {\n            sum += val;\n        }\n        if (st.size())\n            return sum;\n        else\n            return mxNeg;\n    }\n};",
        "explanation": "Intuition\nThe problem is asking for the maximum sum of a subarray with unique elements. We need to maximize the sum while ensuring that no duplicates are included in the subarray. This means we will need to track positive numbers and handle cases where no positive numbers exist.\n\nApproach\nTraverse through the array and store positive numbers in a set (which ensures uniqueness).\nKeep track of the maximum negative number in case there are no positive numbers.\nThe result will either be the sum of unique positive numbers or the largest negative number.\nComplexity\nTime complexity: (O(n))\nWe process each element of the array exactly once, either inserting it into a set or comparing it to the current maximum negative value.\n\nSpace complexity: (O(n))\nThe space is used by the set to store unique positive numbers, which may be up to (n) elements in the worst case."
    },
    {
        "question_id": "c5d24e1a-0ff0-4c81-9f34-05b2439b5e92",
        "title": "Max Points on a Line",
        "difficulty": "Hard",
        "category": "Array Hash Table Math Geometry",
        "question_text": "Given an array of points where points[i] = [xi, yi] represents a point on the X-Y plane, return the maximum number of points that lie on the same straight line.\nExample 1:\nInput: points = [[1,1],[2,2],[3,3]]\nOutput: 3\nExample 2:\nInput: points = [[1,1],[3,2],[5,3],[4,1],[2,3],[1,4]]\nOutput: 4\nConstraints:\n\n1 <= points.length <= 300\npoints[i].length == 2\n-104 <= xi, yi <= 104\nAll the points are unique.",
        "solution": "class Solution {\npublic:\n    int maxPoints(vector<vector<int>>& pt) {\n        int ans=1; \n        int n=pt.size();\n       // slope of every point with selected point\n        for(int i=0;i<n-1;i++){\n            map<double,int> mp;\n            for(int j=i+1;j<n;j++){\n                //calculating the slope\n                double x = (double)(pt[j][1]-pt[i][1])/(double)(pt[j][0]-pt[i][0]);\n                if(pt[j][1]-pt[i][1]<0 &&(pt[j][0]-pt[i][0])==0 ) //infinite slop for Perpendicular line\n                mp[abs(x)]++; \n                else\n               //storing the slop into map\n                    mp[x]++;\n            }\n            // same slope w.r.t.that selected point\n            int temp = 0;\n            for(auto it:mp)\n                temp = max(temp, it.second+1);    // +1 for the current point(point itself)\n            ans = max(temp, ans);\n        }\n        return ans;\n    }\n};",
        "explanation": "Intuition\nHere we will calculate the slope\nApproach\nIdea is very simple\n\nWe will select point and for every selected point we will calculate the slope wr.t to another point and store into the map\nIn map we will store <slope,that selected point>\nfor example we have point :-[[1,1],[2,2],[3,3]......\nwe pick point [1,1]and for that [1,1] we will calculate the slope\nw.r.t [2,2] ,[3,3]....... and store like this-\nfor understanding purpose i'm writing\nmp[slope1,[1,1]]\nmp[slope2,[1,1]]\nmp[slope1,[1,1]].........\nThis type we will store the slope for [2,2] , [3,3],....\nAter storing the slope into map we will calculate the max point for that slope\nFor example after storing the slope map can look like this\n[2/3,3]\n[INF,1]//for perpendicular case\n[1/3,2]...\nfind the max number of points having the same slope w.r.t. that selected point :-means which slope have maximum point\n:- here 2/3 have 3 point so our answer will be 3+1(we are adding that point as well)"
    },
    {
        "question_id": "7a15a0a1-23da-4914-996f-52d9168ab758",
        "title": "X of a Kind in a Deck of Cards",
        "difficulty": "Easy",
        "category": "Array Hash Table Math Counting Number Theory",
        "question_text": "You are given an integer array deck where deck[i] represents the number written on the ith card.\n\nPartition the cards into one or more groups such that:\n\nEach group has exactly x cards where x > 1, and\nAll the cards in one group have the same integer written on them.\nReturn true if such partition is possible, or false otherwise.\n\n \n\nExample 1:\n\nInput: deck = [1,2,3,4,4,3,2,1]\nOutput: true\nExplanation: Possible partition [1,1],[2,2],[3,3],[4,4].\nExample 2:\n\nInput: deck = [1,1,1,2,2,2,3,3]\nOutput: false\nExplanation: No possible partition.\n \n\nConstraints:\n\n1 <= deck.length <= 104\n0 <= deck[i] < 104",
        "solution": "class Solution(object):\n    def hasGroupsSizeX(self, deck):\n        from fractions import gcd\n        vals = collections.Counter(deck).values()\n        return reduce(gcd, vals) >= 2",
        "explanation": "Greatest Common Divisor\nIntuition and Algorithm\n\nAgain, say there are C_i cards of number i. These must be broken down into piles of X cards each, ie. C_i % X == 0 for all i.\n\nThus, X must divide the greatest common divisor of C_i. If this greatest common divisor g is greater than 1, then X = g will satisfy. Otherwise, it won't.\nComplexity Analysis\n\nTime Complexity: O(Nlog \n2\n N), where N is the number of votes. If there are C \ni\n​\n  cards with number i, then each gcd operation is naively O(log \n2\n C \ni\n​\n ). Better bounds exist, but are outside the scope of this article to develop.\n\nSpace Complexity: O(N)."
    },
    {
        "question_id": "effa6fd6-4f6a-4d5d-91a7-de295dd8fb7c",
        "title": "Longest Substring Without Repeating Characters",
        "difficulty": "Medium",
        "category": "Hash Table String Sliding Window",
        "question_text": "Given a string s, find the length of the longest substring without duplicate characters.\n\n \n\nExample 1:\n\nInput: s = \"abcabcbb\"\nOutput: 3\nExplanation: The answer is \"abc\", with the length of 3.\nExample 2:\n\nInput: s = \"bbbbb\"\nOutput: 1\nExplanation: The answer is \"b\", with the length of 1.\nExample 3:\n\nInput: s = \"pwwkew\"\nOutput: 3\nExplanation: The answer is \"wke\", with the length of 3.\nNotice that the answer must be a substring, \"pwke\" is a subsequence and not a substring.\n \n\nConstraints:\n\n0 <= s.length <= 5 * 104\ns consists of English letters, digits, symbols and spaces.",
        "solution": "class Solution {\npublic:\n    int lengthOfLongestSubstring(string s) {\n        int n = s.length();\n        int maxLength = 0;\n        unordered_set<char> charSet;\n        int left = 0;\n        \n        for (int right = 0; right < n; right++) {\n            if (charSet.count(s[right]) == 0) {\n                charSet.insert(s[right]);\n                maxLength = max(maxLength, right - left + 1);\n            } else {\n                while (charSet.count(s[right])) {\n                    charSet.erase(s[left]);\n                    left++;\n                }\n                charSet.insert(s[right]);\n            }\n        }\n        \n        return maxLength;\n    }\n};",
        "explanation": "Intuition\nThe intuition behind the 3 solutions is to iteratively find the longest substring without repeating characters by maintaining a sliding window approach. We use two pointers (left and right) to represent the boundaries of the current substring. As we iterate through the string, we update the pointers and adjust the window to accommodate new unique characters and eliminate repeating characters.\n\nApproach 1 - Set\nWe use a set (charSet) to keep track of unique characters in the current substring.\nWe maintain two pointers, left and right, to represent the boundaries of the current substring.\nThe maxLength variable keeps track of the length of the longest substring encountered so far.\nWe iterate through the string using the right pointer.\nIf the current character is not in the set (charSet), it means we have a new unique character.\nWe insert the character into the set and update the maxLength if necessary.\nIf the character is already present in the set, it indicates a repeating character within the current substring.\nIn this case, we move the left pointer forward, removing characters from the set until the repeating character is no longer present.\nWe insert the current character into the set and continue the iteration.\nFinally, we return the maxLength as the length of the longest substring without repeating characters."
    },
    {
        "question_id": "bcaf91f0-8bef-48e0-816e-9eeef44b8f73",
        "title": "String to Integer (atoi)",
        "difficulty": "Medium",
        "category": "String",
        "question_text": "Implement the myAtoi(string s) function, which converts a string to a 32-bit signed integer.\n\nThe algorithm for myAtoi(string s) is as follows:\n\nWhitespace: Ignore any leading whitespace (\" \").\nSignedness: Determine the sign by checking if the next character is '-' or '+', assuming positivity if neither present.\nConversion: Read the integer by skipping leading zeros until a non-digit character is encountered or the end of the string is reached. If no digits were read, then the result is 0.\nRounding: If the integer is out of the 32-bit signed integer range [-231, 231 - 1], then round the integer to remain in the range. Specifically, integers less than -231 should be rounded to -231, and integers greater than 231 - 1 should be rounded to 231 - 1.\nReturn the integer as the final result.\n\n \n\nExample 1:\n\nInput: s = \"42\"\n\nOutput: 42\n\nExplanation:\n\nThe underlined characters are what is read in and the caret is the current reader position.\nStep 1: \"42\" (no characters read because there is no leading whitespace)\n         ^\nStep 2: \"42\" (no characters read because there is neither a '-' nor '+')\n         ^\nStep 3: \"42\" (\"42\" is read in)\n           ^\nExample 2:\n\nInput: s = \" -042\"\n\nOutput: -42\n\nExplanation:\n\nStep 1: \"   -042\" (leading whitespace is read and ignored)\n            ^\nStep 2: \"   -042\" ('-' is read, so the result should be negative)\n             ^\nStep 3: \"   -042\" (\"042\" is read in, leading zeros ignored in the result)\n               ^\nExample 3:\n\nInput: s = \"1337c0d3\"\n\nOutput: 1337\n\nExplanation:\n\nStep 1: \"1337c0d3\" (no characters read because there is no leading whitespace)\n         ^\nStep 2: \"1337c0d3\" (no characters read because there is neither a '-' nor '+')\n         ^\nStep 3: \"1337c0d3\" (\"1337\" is read in; reading stops because the next character is a non-digit)\n             ^\nExample 4:\n\nInput: s = \"0-1\"\n\nOutput: 0\n\nExplanation:\n\nStep 1: \"0-1\" (no characters read because there is no leading whitespace)\n         ^\nStep 2: \"0-1\" (no characters read because there is neither a '-' nor '+')\n         ^\nStep 3: \"0-1\" (\"0\" is read in; reading stops because the next character is a non-digit)\n          ^\nExample 5:\n\nInput: s = \"words and 987\"\n\nOutput: 0\n\nExplanation:\n\nReading stops at the first non-digit character 'w'.\n\n \n\nConstraints:\n\n0 <= s.length <= 200\ns consists of English letters (lower-case and upper-case), digits (0-9), ' ', '+', '-', and '.'.",
        "solution": "#include <iostream>\n#include <string>\nusing namespace std;\n\nclass Solution {\npublic:\n    int myAtoi(string s) {\n        int i = 0, sign = 1;\n        long res = 0; // Using long to handle overflow cases\n\n        // Trim leading spaces\n        while (i < s.size() && s[i] == ' ') i++;\n        if (i == s.size()) return 0;\n\n        // Check for sign\n        if (s[i] == '-') { sign = -1; i++; }\n        else if (s[i] == '+') i++;\n\n        // Process numerical characters\n        while (i < s.size() && isdigit(s[i])) {\n            res = res * 10 + (s[i] - '0');\n\n            // Handle overflow\n            if (sign * res > INT_MAX) return INT_MAX;\n            if (sign * res < INT_MIN) return INT_MIN;\n\n            i++;\n        }\n\n        return (int)(sign * res);\n    }\n};",
        "explanation": "Intuition\nThe problem requires converting a given string into an integer while following specific rules. Key challenges include handling whitespace, signs (+ and -), non-numeric characters, and integer overflow.\n\nA simple string parsing approach can be used:\n\nIgnore leading whitespace.\nDetermine the sign (+ or -).\nConvert valid numeric characters to an integer.\nStop conversion when a non-numeric character appears.\nHandle integer overflow by capping the value at INT_MAX or INT_MIN.\nApproach\nTrim leading spaces using trim().\nCheck for sign at the beginning (+ or -).\nIterate through characters while they are numeric:\nConvert each character to a digit.\nMultiply the existing result by 10 and add the new digit.\nCheck for integer overflow conditions.\nReturn the final computed integer with the correct sign.\nThis approach ensures we efficiently extract and convert the number in O(n) time complexity.\n\nComplexity\nTime Complexity: O(n) (where n is the length of the string)\nSpace Complexity: O(1) (constant extra space used)"
    },
    {
        "question_id": "5b6a36eb-a3f6-4746-91a8-c2c6ed29ed07",
        "title": "Regular Expression Matching",
        "difficulty": "Hard",
        "category": "String Dynamic Programming Recursion",
        "question_text": "Given an input string s and a pattern p, implement regular expression matching with support for '.' and '*' where:\n\n'.' Matches any single character.​​​​\n'*' Matches zero or more of the preceding element.\nThe matching should cover the entire input string (not partial).\n\n \n\nExample 1:\n\nInput: s = \"aa\", p = \"a\"\nOutput: false\nExplanation: \"a\" does not match the entire string \"aa\".\nExample 2:\n\nInput: s = \"aa\", p = \"a*\"\nOutput: true\nExplanation: '*' means zero or more of the preceding element, 'a'. Therefore, by repeating 'a' once, it becomes \"aa\".\nExample 3:\n\nInput: s = \"ab\", p = \".*\"\nOutput: true\nExplanation: \".*\" means \"zero or more (*) of any character (.)\".\n \n\nConstraints:\n\n1 <= s.length <= 20\n1 <= p.length <= 20\ns contains only lowercase English letters.\np contains only lowercase English letters, '.', and '*'.\nIt is guaranteed for each appearance of the character '*', there will be a previous valid character to match.",
        "solution": "class Solution(object):\n    def isMatch(self, text: str, pattern: str) -> bool:\n        memo = {}\n\n        def dp(i: int, j: int) -> bool:\n            if (i, j) not in memo:\n                if j == len(pattern):\n                    ans = i == len(text)\n                else:\n                    first_match = i < len(text) and pattern[j] in {text[i], \".\"}\n                    if j + 1 < len(pattern) and pattern[j + 1] == \"*\":\n                        ans = dp(i, j + 2) or first_match and dp(i + 1, j)\n                    else:\n                        ans = first_match and dp(i + 1, j + 1)\n\n                memo[i, j] = ans\n            return memo[i, j]\n\n        return dp(0, 0)",
        "explanation": "Intuition\n\nAs the problem has an optimal substructure, it is natural to cache intermediate results. We ask the question dp(i, j): does text[i:] and pattern[j:] match? We can describe our answer in terms of answers to questions involving smaller strings.\n\nAlgorithm\n\nWe proceed with the same recursion as in Approach 1, except because calls will only ever be made to match(text[i:], pattern[j:]), we use dp(i, j) to handle those calls instead, saving us expensive string-building operations and allowing us to cache the intermediate results."
    },
    {
        "question_id": "85555f11-af97-4365-85e3-4dc8715405e4",
        "title": "Roman to Integer",
        "difficulty": "Easy",
        "category": "Hash Table Math String",
        "question_text": "Roman numerals are represented by seven different symbols: I, V, X, L, C, D and M.\n\nSymbol       Value\nI             1\nV             5\nX             10\nL             50\nC             100\nD             500\nM             1000\nFor example, 2 is written as II in Roman numeral, just two ones added together. 12 is written as XII, which is simply X + II. The number 27 is written as XXVII, which is XX + V + II.\n\nRoman numerals are usually written largest to smallest from left to right. However, the numeral for four is not IIII. Instead, the number four is written as IV. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as IX. There are six instances where subtraction is used:\n\nI can be placed before V (5) and X (10) to make 4 and 9. \nX can be placed before L (50) and C (100) to make 40 and 90. \nC can be placed before D (500) and M (1000) to make 400 and 900.\nGiven a roman numeral, convert it to an integer.\n\n \n\nExample 1:\n\nInput: s = \"III\"\nOutput: 3\nExplanation: III = 3.\nExample 2:\n\nInput: s = \"LVIII\"\nOutput: 58\nExplanation: L = 50, V= 5, III = 3.\nExample 3:\n\nInput: s = \"MCMXCIV\"\nOutput: 1994\nExplanation: M = 1000, CM = 900, XC = 90 and IV = 4.\n \n\nConstraints:\n\n1 <= s.length <= 15\ns contains only the characters ('I', 'V', 'X', 'L', 'C', 'D', 'M').\nIt is guaranteed that s is a valid roman numeral in the range [1, 3999].",
        "solution": "class Solution {\npublic:\n    int romanToInt(string s) {\n        int res = 0;\n        unordered_map<char, int> roman = {\n            {'I', 1},\n            {'V', 5},\n            {'X', 10}, \n            {'L', 50},\n            {'C', 100},\n            {'D', 500},\n            {'M', 1000}\n        };\n\n        for (int i = 0; i < s.size() - 1; i++) {\n            if (roman[s[i]] < roman[s[i + 1]]) {\n                res -= roman[s[i]];\n            } else {\n                res += roman[s[i]];\n            }\n        }\n\n        return res + roman[s[s.size() - 1]];        \n    }\n};",
        "explanation": "Approach\nThe description includes the example of 27. If the values are written from left to right in descending order, simply adding each number one by one will give the result.\n\nXXVII\n↓\n10(X) + 10(X) + 5(V) + 1(I) + 1(I) = 27\nLVIII\n↓\n50(L) + 5(V) + 1(I) + 1(I) + 1(I) = 58\nBut numbers like 4 and 9 are represented as a single number using two Roman numerals.\n\nIV = 4\nIX = 9\n Points\n\nBasically, you just need to convert either one or two characters into a number to get the answer.\n\nHow do we determine if it’s one or two characters?\nSince a single number can use up to two Roman characters, we loop through the string two characters at a time, shifting by one each time.\n\nLet’s take a look at this example.\n\nInput: s = \"XIV\"\nIn the first loop, we use X and I. In this case, the second character I is less than X. I is 1 and X is 10. That means we can simply add X to result variable, because 10 → 1 is a descending order. It's the same as 27 or 58 above.\n\nres = 10\nNext, we use I and V. In this case, the second character V is greater than I, because V is 5 and I is 1.\n\nThe description says \"there are six instances where subtraction is used.\"\n\nIV = 4\nIX = 9\nXL = 40\nXC = 90\nCD = 400\nCM = 900\nLook at all the first characters and the second characters. The first characters are less than the second characters.\n\nI(1) + V(5) = 4\nI(1) + X(10) = 9\nX(10) + L(50) = 40\nX(10) + C(100) = 90\nC(100) + D(500) = 400\nC(100) + M(1000) = 900\nThe current first character is I and the second character is V, so we are using two Roman characters to form a single number.\n\nIn this case, we subtract I(= 1) from result variable, because in the next loop, we will add V(= 5), so the total of I and V will be 4 in the end.\n\nres = 9\nThe next two number is V and nothing(= out of bounds), so we stop iteration.\n\nThe last point is that as I told you, we should add V before return the answer, because one of values was out of bounds, that's why we couldn't add the last Roman chartacter which is V.\n\nreturn res + 5\nBefore we start looping, we have HashMap to combine Roman and Integer, so that we can convert Roman to Integer easily.\n\nIn the solution code,\n\nreturn res + roman[s[-1]]\n\ns is input string\nroman is HashMap"
    },
    {
        "question_id": "9a9b9b8c-7fee-47c4-b970-5a888a40f529",
        "title": "Longest Common Prefix",
        "difficulty": "Easy",
        "category": "String Trie",
        "question_text": "Write a function to find the longest common prefix string amongst an array of strings.\n\nIf there is no common prefix, return an empty string \"\".\n\n \n\nExample 1:\n\nInput: strs = [\"flower\",\"flow\",\"flight\"]\nOutput: \"fl\"\nExample 2:\n\nInput: strs = [\"dog\",\"racecar\",\"car\"]\nOutput: \"\"\nExplanation: There is no common prefix among the input strings.\n \n\nConstraints:\n\n1 <= strs.length <= 200\n0 <= strs[i].length <= 200\nstrs[i] consists of only lowercase English letters if it is non-empty.",
        "solution": "class Solution {\npublic:\n    string longestCommonPrefix(vector<string>& strs) {\n        if (strs.empty()) return \"\";\n        return longestCommonPrefix(strs, 0, strs.size() - 1);\n    }\n\nprivate:\n    string longestCommonPrefix(vector<string>& strs, int l, int r) {\n        if (l == r) {\n            return strs[l];\n        } else {\n            int mid = (l + r) / 2;\n            string lcpLeft = longestCommonPrefix(strs, l, mid);\n            string lcpRight = longestCommonPrefix(strs, mid + 1, r);\n            return commonPrefix(lcpLeft, lcpRight);\n        }\n    }\n\n    string commonPrefix(string left, string right) {\n        int min = std::min(left.length(), right.length());\n        for (int i = 0; i < min; i++) {\n            if (left[i] != right[i]) return left.substr(0, i);\n        }\n        return left.substr(0, min);\n    }\n};",
        "explanation": "Divide and conquer\nIntuition\nThe idea of the algorithm comes from the associative property of LCP operation. We notice that :\nLCP(S 1 …S n )=LCP(LCP(S 1 …S k ),LCP(S k+1 …S n )), where LCP(​ …S n ) is the longest common prefix in set of strings [S 1 …S n ] ,1<k<n\nAlgorithm\nTo apply the observation above, we use divide and conquer technique, where we split the LCP(S \ni\n​\n …S \nj\n​\n ) problem into two subproblems LCP(S \ni\n​\n …S \nmid\n​\n ) and LCP(S \nmid+1\n​\n …S \nj\n​\n ), where mid is  \n2\ni+j\n​\n . We use their solutions lcpLeft and lcpRight to construct the solution of the main problem LCP(S \ni\n​\n …S \nj\n​\n ). To accomplish this we compare one by one the characters of lcpLeft and lcpRight till there is no character match. The found common prefix of lcpLeft and lcpRight is the solution of the LCP(S \ni\n​\n …S \nj\n​\n ).\n\n Complexity Analysis\nIn the worst case we have n equal strings with length m\n\nTime complexity : O(S), where S is the number of all characters in the array, S=m⋅n\nTime complexity is 2⋅T( \n2\nn\n​\n )+O(m). Therefore time complexity is O(S).\nIn the best case this algorithm performs O(minLen⋅n) comparisons, where minLen is the shortest string of the array\n\nSpace complexity : O(m⋅logn)\n\nThere is a memory overhead since we store recursive calls in the execution stack. There are logn recursive calls, each store need m space to store the result, so space complexity is O(m⋅logn)"
    },
    {
        "question_id": "4612d5a3-b44d-4345-9af3-40ac6d214dd6",
        "title": "Wildcard Matching",
        "difficulty": "Hard",
        "category": "String Dynamic Programming Greedy Recursion",
        "question_text": "Given an input string (s) and a pattern (p), implement wildcard pattern matching with support for '?' and '*' where:\n\n'?' Matches any single character.\n'*' Matches any sequence of characters (including the empty sequence).\nThe matching should cover the entire input string (not partial).\n\n \n\nExample 1:\n\nInput: s = \"aa\", p = \"a\"\nOutput: false\nExplanation: \"a\" does not match the entire string \"aa\".\nExample 2:\n\nInput: s = \"aa\", p = \"*\"\nOutput: true\nExplanation: '*' matches any sequence.\nExample 3:\n\nInput: s = \"cb\", p = \"?a\"\nOutput: false\nExplanation: '?' matches 'c', but the second letter is 'a', which does not match 'b'.\n \n\nConstraints:\n\n0 <= s.length, p.length <= 2000\ns contains only lowercase English letters.\np contains only lowercase English letters, '?' or '*'.",
        "solution": "bool isMatch(const char *s, const char *p) {\n        const char* star=NULL;\n        const char* ss=s;\n        while (*s){\n            //advancing both pointers when (both characters match) or ('?' found in pattern)\n            //note that *p will not advance beyond its length \n            if ((*p=='?')||(*p==*s)){s++;p++;continue;} \n\n            // * found in pattern, track index of *, only advancing pattern pointer \n            if (*p=='*'){star=p++; ss=s;continue;} \n\n            //current characters didn't match, last pattern pointer was *, current pattern pointer is not *\n            //only advancing pattern pointer\n            if (star){ p = star+1; s=++ss;continue;} \n\n           //current pattern pointer is not star, last patter pointer was not *\n           //characters do not match\n            return false;\n        }\n\n       //check for remaining characters in pattern\n        while (*p=='*'){p++;}\n\n        return !*p;  \n    }",
        "explanation": "The basic idea is to have one pointer for the string and one pointer for the pattern. This algorithm iterates at most length(string) + length(pattern) times, for each iteration, at least one pointer advance one step."
    },
    {
        "question_id": "9b7427e5-d04d-4606-ba13-e2b79456333a",
        "title": "Fraction to Recurring Decimal",
        "difficulty": "Medium",
        "category": "Hash Table Math String",
        "question_text": "Given two integers representing the numerator and denominator of a fraction, return the fraction in string format.\n\nIf the fractional part is repeating, enclose the repeating part in parentheses.\n\nIf multiple answers are possible, return any of them.\n\nIt is guaranteed that the length of the answer string is less than 104 for all the given inputs.\n\n \n\nExample 1:\n\nInput: numerator = 1, denominator = 2\nOutput: \"0.5\"\nExample 2:\n\nInput: numerator = 2, denominator = 1\nOutput: \"2\"\nExample 3:\n\nInput: numerator = 4, denominator = 333\nOutput: \"0.(012)\"\n \n\nConstraints:\n\n-231 <= numerator, denominator <= 231 - 1\ndenominator != 0",
        "solution": "public class Solution {\n    public String fractionToDecimal(int numerator, int denominator) {\n        if (numerator == 0) {\n            return \"0\";\n        }\n        StringBuilder res = new StringBuilder();\n        // \"+\" or \"-\"\n        res.append(((numerator > 0) ^ (denominator > 0)) ? \"-\" : \"\");\n        long num = Math.abs((long)numerator);\n        long den = Math.abs((long)denominator);\n        \n        // integral part\n        res.append(num / den);\n        num %= den;\n        if (num == 0) {\n            return res.toString();\n        }\n        \n        // fractional part\n        res.append(\".\");\n        HashMap<Long, Integer> map = new HashMap<Long, Integer>();\n        map.put(num, res.length());\n        while (num != 0) {\n            num *= 10;\n            res.append(num / den);\n            num %= den;\n            if (map.containsKey(num)) {\n                int index = map.get(num);\n                res.insert(index, \"(\");\n                res.append(\")\");\n                break;\n            }\n            else {\n                map.put(num, res.length());\n            }\n        }\n        return res.toString();\n    }\n}",
        "explanation": "The important thing is to consider all edge cases while thinking this problem through, including: negative integer, possible overflow, etc.\n\nUse HashMap to store a remainder and its associated index while doing the division so that whenever a same remainder comes up, we know there is a repeating fractional part."
    },
    {
        "question_id": "0cffb6fd-d7d8-406c-be67-ec6cf8bbecab",
        "title": "Basic Calculator",
        "difficulty": "Hard",
        "category": "Math String Stack Recursion",
        "question_text": "Given a string s representing a valid expression, implement a basic calculator to evaluate it, and return the result of the evaluation.\n\nNote: You are not allowed to use any built-in function which evaluates strings as mathematical expressions, such as eval().\n\n \n\nExample 1:\n\nInput: s = \"1 + 1\"\nOutput: 2\nExample 2:\n\nInput: s = \" 2-1 + 2 \"\nOutput: 3\nExample 3:\n\nInput: s = \"(1+(4+5+2)-3)+(6+8)\"\nOutput: 23\n \n\nConstraints:\n\n1 <= s.length <= 3 * 105\ns consists of digits, '+', '-', '(', ')', and ' '.\ns represents a valid expression.\n'+' is not used as a unary operation (i.e., \"+1\" and \"+(2 + 3)\" is invalid).\n'-' could be used as a unary operation (i.e., \"-1\" and \"-(2 + 3)\" is valid).\nThere will be no two consecutive operators in the input.\nEvery number and running calculation will fit in a signed 32-bit integer.",
        "solution": "public int calculate(String s) {\n    Stack<Integer> stack = new Stack<Integer>();\n    int result = 0;\n    int number = 0;\n    int sign = 1;\n    for(int i = 0; i < s.length(); i++){\n        char c = s.charAt(i);\n        if(Character.isDigit(c)){\n            number = 10 * number + (int)(c - '0');\n        }else if(c == '+'){\n            result += sign * number;\n            number = 0;\n            sign = 1;\n        }else if(c == '-'){\n            result += sign * number;\n            number = 0;\n            sign = -1;\n        }else if(c == '('){\n            //we push the result first, then sign;\n            stack.push(result);\n            stack.push(sign);\n            //reset the sign and result for the value in the parenthesis\n            sign = 1;   \n            result = 0;\n        }else if(c == ')'){\n            result += sign * number;  \n            number = 0;\n            result *= stack.pop();    //stack.pop() is the sign before the parenthesis\n            result += stack.pop();   //stack.pop() now is the result calculated before the parenthesis\n            \n        }\n    }\n    if(number != 0) result += sign * number;\n    return result;\n}",
        "explanation": "Simple iterative solution by identifying characters one by one. One important thing is that the input is valid, which means the parentheses are always paired and in order.\nOnly 5 possible input we need to pay attention:\n\ndigit: it should be one digit from the current number\n\n'+': number is over, we can add the previous number and start a new number\n\n'-': same as above\n\n'(': push the previous result and the sign into the stack, set result to 0, just calculate the new result within the parenthesis.\n\n')': pop out the top two numbers from stack, first one is the sign before this pair of parenthesis, second is the temporary result before this pair of parenthesis. We add them together.\n\nFinally if there is only one number, from the above solution, we haven't add the number to the result, so we do a check see if the number is zero."
    },
    {
        "question_id": "a46cfe35-3aa8-4876-b29c-e3b83ca9e6a7",
        "title": "Binary Tree Paths",
        "difficulty": "Easy",
        "category": "Math String Stack Recursion",
        "question_text": "Given the root of a binary tree, return all root-to-leaf paths in any order.\n\nA leaf is a node with no children.\n\n \n\nExample 1:\n\n\nInput: root = [1,2,3,null,5]\nOutput: [\"1->2->5\",\"1->3\"]\nExample 2:\n\nInput: root = [1]\nOutput: [\"1\"]\n \n\nConstraints:\n\nThe number of nodes in the tree is in the range [1, 100].\n-100 <= Node.val <= 100",
        "solution": "class Solution(object):\n    def binaryTreePaths(self, root):\n        res = []\n        if not root:\n            return res\n        stack = [(root, str(root.val))]\n        while stack:\n            node, path = stack.pop()\n            if not node.left and not node.right:\n                res.append(path)\n            if node.right:\n                stack.append((node.right, path + \"->\" + str(node.right.val)))\n            if node.left:\n                stack.append((node.left, path + \"->\" + str(node.left.val)))\n        return res",
        "explanation": "Intuition\nTo collect all root-to-leaf paths in a binary tree, we use DFS traversal. At every node, we build a path string. Once we reach a leaf, we save the full path.\nUse a stack to simulate DFS. At each step, track both the node and the current path string. When a leaf is reached, push the path to the result array. If children exist, extend the path and continue traversing.\n\nComplexity\nTime complexity: (O(n)), where (n) is the number of nodes.\nSpace complexity: (O(n)), for recursion stack or explicit stack and result storage."
    },
    {
        "question_id": "6ac240b7-38cd-4c39-a53a-613838ac801e",
        "title": "Reverse Vowels of a String",
        "difficulty": "Easy",
        "category": "Two Pointers String",
        "question_text": "Given a string s, reverse only all the vowels in the string and return it.\n\nThe vowels are 'a', 'e', 'i', 'o', and 'u', and they can appear in both lower and upper cases, more than once.\n\n \n\nExample 1:\n\nInput: s = \"IceCreAm\"\n\nOutput: \"AceCreIm\"\n\nExplanation:\n\nThe vowels in s are ['I', 'e', 'e', 'A']. On reversing the vowels, s becomes \"AceCreIm\".\n\nExample 2:\n\nInput: s = \"leetcode\"\n\nOutput: \"leotcede\"\n\n \n\nConstraints:\n\n1 <= s.length <= 3 * 105\ns consist of printable ASCII characters.",
        "solution": "class Solution {\npublic:\n    string reverseVowels(string s) {\n        // Convert the input string to a character array.\n        string word = s;\n        int start = 0;\n        int end = s.length() - 1;\n        string vowels = \"aeiouAEIOU\";\n        \n        // Loop until the start pointer is no longer less than the end pointer.\n        while (start < end) {\n            // Move the start pointer towards the end until it points to a vowel.\n            while (start < end && vowels.find(word[start]) == string::npos) {\n                start++;\n            }\n            \n            // Move the end pointer towards the start until it points to a vowel.\n            while (start < end && vowels.find(word[end]) == string::npos) {\n                end--;\n            }\n            \n            // Swap the vowels found at the start and end positions.\n            swap(word[start], word[end]);\n            \n            // Move the pointers towards each other for the next iteration.\n            start++;\n            end--;\n        }\n        \n        // Return the modified string.\n        return word;\n    }\n};",
        "explanation": "Intuition\nThe goal of the problem is to reverse the order of vowels in a given string while keeping the non-vowel characters in their original positions. To achieve this, we can use two pointers technique: one pointer starting from the beginning of the string and another starting from the end. We will move these pointers towards each other, swapping the vowels they point to until they meet in the middle of the string.\n\nApproach\nConvert the input string s to an array of characters word. This step is necessary because strings are immutable in Java, and we need to modify the vowels' positions.\n\nInitialize two pointers, start and end, to the first and last characters of the string, respectively.\n\nCreate a String variable vowels containing all the vowel characters (both lowercase and uppercase).\n\nUse a while loop to iterate until start is no longer less than end. This loop ensures that the pointers will not cross each other, and we process the characters in the middle of the string only once.\n\nInside the loop:\n\nMove the start pointer towards the end of the string until it points to a vowel character. We do this by using the indexOf method to find the index of the character in the vowels string. If the character is not a vowel, we keep moving the start pointer.\n\nSimilarly, move the end pointer towards the beginning of the string until it points to a vowel character. Again, we use the indexOf method to check if the character is a vowel and keep moving the end pointer if it is not.\n\nSwap the vowels found at the start and end positions in the word array.\n\nMove the start pointer one step ahead and the end pointer one step back to continue searching for more vowels.\n\nAfter the loop finishes, the word array will contain the string with the reversed vowels. Convert the character array back to a String and return the result.\n\nComplexity\nTime complexity:\nThe time complexity of this solution is O(n), where n is the length of the input string s. The two pointers start and end move towards each other, and each character is processed once.\n\nSpace complexity:\nThe space complexity of this solution is O(n) because we create a character array word to store the characters of the input string. The space used is proportional to the length of the input string. Other than that, we use a constant amount of extra space for the vowels string and a few integer variables, which doesn't depend on the input size."
    },
    {
        "question_id": "4a0dcadd-efa6-4e30-8d31-0a0edb117ec2",
        "title": "Word Break II",
        "difficulty": "Hard",
        "category": "Array Hash Table String Dynamic Programming Backtracking Trie Memoization",
        "question_text": "Given a string s and a dictionary of strings wordDict, add spaces in s to construct a sentence where each word is a valid dictionary word. Return all such possible sentences in any order.\n\nNote that the same word in the dictionary may be reused multiple times in the segmentation.\n\n \n\nExample 1:\n\nInput: s = \"catsanddog\", wordDict = [\"cat\",\"cats\",\"and\",\"sand\",\"dog\"]\nOutput: [\"cats and dog\",\"cat sand dog\"]\nExample 2:\n\nInput: s = \"pineapplepenapple\", wordDict = [\"apple\",\"pen\",\"applepen\",\"pine\",\"pineapple\"]\nOutput: [\"pine apple pen apple\",\"pineapple pen apple\",\"pine applepen apple\"]\nExplanation: Note that you are allowed to reuse a dictionary word.\nExample 3:\n\nInput: s = \"catsandog\", wordDict = [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]\nOutput: []\n \n\nConstraints:\n\n1 <= s.length <= 20\n1 <= wordDict.length <= 1000\n1 <= wordDict[i].length <= 10\ns and wordDict[i] consist of only lowercase English letters.\nAll the strings of wordDict are unique.\nInput is generated in a way that the length of the answer doesn't exceed 105.",
        "solution": "class Solution {\npublic:\n    vector<string> wordBreak(string s, vector<string>& wordDict) {\n        unordered_set<string> wordSet(wordDict.begin(), wordDict.end());\n        unordered_map<string, vector<string>> memoization;\n        return dfs(s, wordSet, memoization);\n    }\n\nprivate:\n    // Depth-first search function to find all possible word break combinations\n    vector<string> dfs(const string& remainingStr,\n                       const unordered_set<string>& wordSet,\n                       unordered_map<string, vector<string>>& memoization) {\n        // Check if result for this substring is already memoized\n        if (memoization.count(remainingStr)) return memoization[remainingStr];\n        // Base case: when the string is empty, return a list containing an\n        // empty string\n        if (remainingStr.empty()) return {\"\"};\n        vector<string> results;\n        for (int i = 1; i <= remainingStr.length(); ++i) {\n            string currentWord = remainingStr.substr(0, i);\n            // If the current substring is a valid word\n            if (wordSet.count(currentWord)) {\n                for (const string& nextWord :\n                     dfs(remainingStr.substr(i), wordSet, memoization)) {\n                    // Append current word and next word with space in between\n                    // if next word exists\n                    results.push_back(currentWord +\n                                      (nextWord.empty() ? \"\" : \" \") + nextWord);\n                }\n            }\n        }\n        // Memoize the results for the current substring\n        memoization[remainingStr] = results;\n        return results;\n    }\n};",
        "explanation": "Intuition\nWe can improve the efficiency of the backtracking method by using Memoization, which stores the results of subproblems to avoid recalculating them.\n\nWe use a depth-first search (DFS) function that recursively breaks the string into words. However, before performing a recursive call, we check if the results for the current substring have already been computed and stored in a memoization map (typically a dictionary or hash table).\n\nIf the results of the current substring are found in the memoization map, we can directly return them without further computation. If not, we proceed with the recursive call, computing the results and storing them in the memoization map before returning them.\n\nBy memoizing the results, we can reduce the number of computations by ensuring that each substring is processed only once in average cases.\n\nAlgorithm\nwordBreak Function:\n\nConvert the wordDict array into an unordered set wordSet for efficient lookups.\nInitialize an empty unordered map memoization to store the results of subproblems.\nCall the dfs function with the input string s, wordSet, and memoization.\ndfs Function:\n\nCheck if the answer for the current remainingStr(the remaining part of the string to be processed) are already in memoization. If so, return them.\nBase Case: If remainingStr is empty, it means that all characters have been processed. An empty string represents a valid sentence so return an array containing the empty string.\nInitialize an empty array results.\nIterate from 1 to the length of remainingStr:\nExtract the substring currentWord from 0 to i to check if it is a valid word.\nIf currentWord is found in wordSet:\nRecursively call dfs with remainingStr.substr(i), wordSet, and memoization.\nAppend currentWord and the recursive results to results(with a space if needed) to form valid sentences.\nStore the results for remainingStr in memoization.\nReturn results."
    },
    {
        "question_id": "6f72755d-22e3-4386-a430-8811419fd470",
        "title": "Remove K Digits",
        "difficulty": "Medium",
        "category": "String Stack Greedy Monotonic Stack",
        "question_text": "Given string num representing a non-negative integer num, and an integer k, return the smallest possible integer after removing k digits from num.\n\n \n\nExample 1:\n\nInput: num = \"1432219\", k = 3\nOutput: \"1219\"\nExplanation: Remove the three digits 4, 3, and 2 to form the new number 1219 which is the smallest.\nExample 2:\n\nInput: num = \"10200\", k = 1\nOutput: \"200\"\nExplanation: Remove the leading 1 and the number is 200. Note that the output must not contain leading zeroes.\nExample 3:\n\nInput: num = \"10\", k = 2\nOutput: \"0\"\nExplanation: Remove all the digits from the number and it is left with nothing which is 0.\n \n\nConstraints:\n\n1 <= k <= num.length <= 105\nnum consists of only digits.\nnum does not have any leading zeros except for the zero itself.",
        "solution": "class Solution {\npublic:\n    std::string removeKdigits(std::string num, int k) {\n        std::stack<char> stack;\n        \n        for (char digit : num) {\n            while (!stack.empty() && k > 0 && stack.top() > digit) {\n                stack.pop();\n                k--;\n            }\n            stack.push(digit);\n        }\n        \n        // Remove remaining k digits from the end of the stack\n        while (k > 0 && !stack.empty()) {\n            stack.pop();\n            k--;\n        }\n        \n        // Construct the resulting string from the stack\n        std::string result;\n        while (!stack.empty()) {\n            result += stack.top();\n            stack.pop();\n        }\n        std::reverse(result.begin(), result.end()); // Reverse to get the correct order\n        \n        // Remove leading zeros\n        size_t pos = result.find_first_not_of('0');\n        result = (pos == std::string::npos) ? \"0\" : result.substr(pos);\n        \n        return result;\n    }\n};",
        "explanation": "Greedy Approach:\nThe problem requires us to minimize the resulting number by removing k digits from the given number num.\nA greedy approach is suitable because at each step (processing each digit), we make a locally optimal choice (keeping the smallest possible digit) with the aim of achieving the overall optimal solution (smallest resulting number).\nBy prioritizing smaller digits for the most significant places (leftmost positions), we ensure that the resulting number is minimized.\nUse of Stack:\nA stack is employed to facilitate the greedy decision-making process:\nWe traverse each digit of num and compare it with the top of the stack (the most recent digit we've chosen to keep).\nIf the current digit is smaller than the top of the stack and we still have removals (k > 0) remaining, we pop digits from the stack until a suitable position for the current digit is found.\nThis stack-based approach allows us to maintain the order of digits while dynamically removing larger, less significant digits to form the smallest possible number.\nApproach:\nInitialize an empty stack.\nTraverse each digit of num.\nFor each digit, while the stack is not empty and k is greater than zero, check if the current digit is smaller than the top of the stack. If so, pop from the stack (remove the top digit) and decrement k.\nPush the current digit onto the stack.\nAfter processing all digits, handle remaining k (if any) by popping from the stack.\nConstruct the resulting number from the stack and remove any leading zeros.\nReturn the smallest possible number as a string."
    },
    {
        "question_id": "6f3ca429-0138-4f12-b44d-304fd5438ad8",
        "title": "Strong Password Checker",
        "difficulty": "Hard",
        "category": "String Greedy Heap (Priority Queue)",
        "question_text": "A password is considered strong if the below conditions are all met:\n\nIt has at least 6 characters and at most 20 characters.\nIt contains at least one lowercase letter, at least one uppercase letter, and at least one digit.\nIt does not contain three repeating characters in a row (i.e., \"Baaabb0\" is weak, but \"Baaba0\" is strong).\nGiven a string password, return the minimum number of steps required to make password strong. if password is already strong, return 0.\n\nIn one step, you can:\n\nInsert one character to password,\nDelete one character from password, or\nReplace one character of password with another character.\n \n\nExample 1:\n\nInput: password = \"a\"\nOutput: 5\nExample 2:\n\nInput: password = \"aA1\"\nOutput: 3\nExample 3:\n\nInput: password = \"1337C0d3\"\nOutput: 0\n \n\nConstraints:\n\n1 <= password.length <= 50\npassword consists of letters, digits, dot '.' or exclamation mark '!'.",
        "solution": "class Solution(object):\n    def strongPasswordChecker(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        missing_type = 3\n        if any('a' <= c <= 'z' for c in s): missing_type -= 1\n        if any('A' <= c <= 'Z' for c in s): missing_type -= 1\n        if any(c.isdigit() for c in s): missing_type -= 1\n\n        change = 0\n        one = two = 0\n        p = 2\n        while p < len(s):\n            if s[p] == s[p-1] == s[p-2]:\n                length = 2\n                while p < len(s) and s[p] == s[p-1]:\n                    length += 1\n                    p += 1\n                    \n                change += length / 3\n                if length % 3 == 0: one += 1\n                elif length % 3 == 1: two += 1\n            else:\n                p += 1\n        \n        if len(s) < 6:\n            return max(missing_type, 6 - len(s))\n        elif len(s) <= 20:\n            return max(missing_type, change)\n        else:\n            delete = len(s) - 20\n            \n            change -= min(delete, one)\n            change -= min(max(delete - one, 0), two * 2) / 2\n            change -= max(delete - one - 2 * two, 0) / 3\n                \n            return delete + max(missing_type, change)",
        "explanation": "The len < 6 and 6 <= len <= 20 cases are easy. When len > 20, we need to do len - 20 times deletion. Also we need to do a change for every three repeating characters.\n\nFor any repeating sequences with len % 3 == 0, we can reduce one replacement by deleting one character. For any repeating sequences with len % 3 == 1, we can reduce one replacement by deleting two character. For the remaining sequences, we can reduce every replacement by deleting three character."
    },
    {
        "question_id": "efbc59c7-0c2f-499f-bfba-f49a51762e64",
        "title": "Number of Segments in a String",
        "difficulty": "Easy",
        "category": "String",
        "question_text": "Given a string s, return the number of segments in the string.\n\nA segment is defined to be a contiguous sequence of non-space characters.\n\n \n\nExample 1:\n\nInput: s = \"Hello, my name is John\"\nOutput: 5\nExplanation: The five segments are [\"Hello,\", \"my\", \"name\", \"is\", \"John\"]\nExample 2:\n\nInput: s = \"Hello\"\nOutput: 1\n \n\nConstraints:\n\n0 <= s.length <= 300\ns consists of lowercase and uppercase English letters, digits, or one of the following characters \"!@#$%^&*()_+-=',.:\".\nThe only space character in s is ' '.",
        "solution": "class Solution:\n    def countSegments(self, s):\n        segment_count = 0\n\n        for i in range(len(s)):\n            if (i == 0 or s[i-1] == ' ') and s[i] != ' ':\n                segment_count += 1\n\n        return segment_count",
        "explanation": "Intuition\n\nIf we cannot afford to allocate linear additional space, a fairly simple\nalgorithm can deduce the number of segments in linear time and constant\nspace.\n\nAlgorithm\n\nTo count the number of segments, it is equivalent to count the number of\nstring indices at which a segment begins. Therefore, by formally defining the\ncharacteristics of such an index, we can simply iterate over the string and\ntest each index in turn. Such a definition is as follows: a string index\nbegins a segment if it is preceded by whitespace (or is the first index) and\nis not whitespace itself, which can be checked in constant time. Finally, we\nsimply return the number of indices for which the condition is satisfied.\n\nComplexity Analysis\n\nTime complexity : O(n)\n\nWe do a constant time check for each of the string's n indices, so the\nruntime is overall linear.\n\nSpace complexity : O(1)\n\nThere are only a few integers allocated, so the memory footprint is\nconstant."
    },
    {
        "question_id": "a5dae9ee-b542-4a38-8529-fa3173cde53f",
        "title": "Count The Repetitions",
        "difficulty": "Hard",
        "category": "String Dynamic Programming",
        "question_text": "We define str = [s, n] as the string str which consists of the string s concatenated n times.\n\nFor example, str == [\"abc\", 3] ==\"abcabcabc\".\nWe define that string s1 can be obtained from string s2 if we can remove some characters from s2 such that it becomes s1.\n\nFor example, s1 = \"abc\" can be obtained from s2 = \"abdbec\" based on our definition by removing the bolded underlined characters.\nYou are given two strings s1 and s2 and two integers n1 and n2. You have the two strings str1 = [s1, n1] and str2 = [s2, n2].\n\nReturn the maximum integer m such that str = [str2, m] can be obtained from str1.\n\n \n\nExample 1:\n\nInput: s1 = \"acb\", n1 = 4, s2 = \"ab\", n2 = 2\nOutput: 2\nExample 2:\n\nInput: s1 = \"acb\", n1 = 1, s2 = \"acb\", n2 = 1\nOutput: 1\n \n\nConstraints:\n\n1 <= s1.length, s2.length <= 100\ns1 and s2 consist of lowercase English letters.\n1 <= n1, n2 <= 106",
        "solution": "int getMaxRepetitions(string s1, int n1, string s2, int n2)\n{\n    if (n1 == 0)\n        return 0;\n    int indexr[s2.size() + 1] = { 0 }; // index at start of each s1 block\n    int countr[s2.size() + 1] = { 0 }; // count of repititions till the present s1 block\n    int index = 0, count = 0;\n    for (int i = 0; i < n1; i++) {\n        for (int j = 0; j < s1.size(); j++) {\n            if (s1[j] == s2[index])\n                ++index;\n            if (index == s2.size()) {\n                index = 0;\n                ++count;\n            }\n        }\n        countr[i] = count;\n        indexr[i] = index;\n        for (int k = 0; k < i; k++) {\n            if (indexr[k] == index) {\n                int prev_count = countr[k];\n                int pattern_count = (countr[i] - countr[k]) * (n1 - 1 - k) / (i - k);\n                int remain_count = countr[k + (n1 - 1 - k) % (i - k)] - countr[k];\n                return (prev_count + pattern_count + remain_count) / n2;\n            }\n        }\n    }\n    return countr[n1 - 1] / n2;\n}",
        "explanation": "After finding the repitition pattern, we can calculate the sum of repeating pattern, part before repitition and part left after repitition as the result in O(1).\n\nBut will this repitition always take place?\n\nYes! By Pigeonhole principle, which states that if n items are put into m containers, with n>m, then at least one container must contain more than one item. So, according to this, we are sure to find 2 same index after scanning at max size(s2) blocks of s1.\n\nAlgorithm\n\nIntialize count=0 nd index=0, which are same as in Approach #1.\nInitialize 2 arrays, say indexr and countr of size (size(s2)+1), initialized with 0. The size (size(s2)+1) is based on the Pigeonhole principle as discussed above. The 2 arrays specifies the index and count at the start of each s1 block.\nIterate over i from 0 to n1−1:\nIterate over j from 0 to size(s1)−1:\n\nIf s1[j]==s2[index], increment index.\nIf index is equal to size(s2), set index=0 and increment count.\nSet countr[i]=count and indexr[i]=index\n\nIterate over k from 0 to i−1:\n\nIf we find the repitition, i.e. current index=indexr[k], we calculate the count for block before the repitition starts, the repeating block and the block left after repitition pattern, which can be calculated as:\nprev_count\npattern_count\nremain_count\n​\n  \n=countr[k]\n=(countr[i]−countr[k])∗ \ni−k\nn1−1−k\n​\n \n=countr[k+(n1−1−k)%(i−k)]−countr[k]\n​\n \nSum the 3 counts and return the sum divided by n2, since S2 = [s2,n2]\nIf no repetition is found, return countr[n1-1]/n2.\n\nComplexity analysis\n\nTime complexity: O(size(s1)*size(s2)).\n\nAccording to the Pigeonhole principle, we need to iterate over s1 only (size(s2)+1) times at max.\nSpace complexity: O(size(s2)) extra space for indexr and countr string."
    },
    {
        "question_id": "93034d0b-6361-47f5-8343-dc93b3cfd58d",
        "title": "Validate IP Address",
        "difficulty": "Medium",
        "category": "String Dynamic Programming",
        "question_text": "Given a string queryIP, return \"IPv4\" if IP is a valid IPv4 address, \"IPv6\" if IP is a valid IPv6 address or \"Neither\" if IP is not a correct IP of any type.\n\nA valid IPv4 address is an IP in the form \"x1.x2.x3.x4\" where 0 <= xi <= 255 and xi cannot contain leading zeros. For example, \"192.168.1.1\" and \"192.168.1.0\" are valid IPv4 addresses while \"192.168.01.1\", \"192.168.1.00\", and \"192.168@1.1\" are invalid IPv4 addresses.\n\nA valid IPv6 address is an IP in the form \"x1:x2:x3:x4:x5:x6:x7:x8\" where:\n\n1 <= xi.length <= 4\nxi is a hexadecimal string which may contain digits, lowercase English letter ('a' to 'f') and upper-case English letters ('A' to 'F').\nLeading zeros are allowed in xi.\nFor example, \"2001:0db8:85a3:0000:0000:8a2e:0370:7334\" and \"2001:db8:85a3:0:0:8A2E:0370:7334\" are valid IPv6 addresses, while \"2001:0db8:85a3::8A2E:037j:7334\" and \"02001:0db8:85a3:0000:0000:8a2e:0370:7334\" are invalid IPv6 addresses.\n\n \n\nExample 1:\n\nInput: queryIP = \"172.16.254.1\"\nOutput: \"IPv4\"\nExplanation: This is a valid IPv4 address, return \"IPv4\".\nExample 2:\n\nInput: queryIP = \"2001:0db8:85a3:0:0:8A2E:0370:7334\"\nOutput: \"IPv6\"\nExplanation: This is a valid IPv6 address, return \"IPv6\".\nExample 3:\n\nInput: queryIP = \"256.256.256.256\"\nOutput: \"Neither\"\nExplanation: This is neither a IPv4 address nor a IPv6 address.\n \n\nConstraints:\n\nqueryIP consists only of English letters, digits and the characters '.' and ':'.",
        "solution": "class Solution {\npublic:\n    string validIPAddress(string IP) {\n        const string chunkIPv4 =\n            \"([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\";\n        regex patternIPv4(\"^(\" + chunkIPv4 + \"\\\\.){3}\" + chunkIPv4 + \"$\");\n\n        const string chunkIPv6 = \"([0-9a-fA-F]{1,4})\";\n        regex patternIPv6(\"^(\" + chunkIPv6 + \"\\\\:){7}\" + chunkIPv6 + \"$\");\n\n        if (regex_match(IP, patternIPv4)) return \"IPv4\";\n        return regex_match(IP, patternIPv6) ? \"IPv6\" : \"Neither\";\n    }\n};",
        "explanation": "Let's construct step by step regex for \"IPv4\"\nas it's described in the problem description. Note, that it's not\na real-life IPv4 because of leading zeros problem as we've discussed above.\n\nAnyway, we start to construct regex pattern by using raw string in Python\nr'' and standard string \"\" in Java. Here is how its skeleton looks like for Python\n\nNow the problem is reduced to the construction of pattern to match each chunk.\nIt's an integer in range (0, 255), and the leading zeros are not allowed.\nThat results in five possible situations:\n\nChunk contains only one digit, from 0 to 9.\n\nChunk contains two digits. The first one could be from 1 to 9, and the second\none from 0 to 9.\n\nChunk contains three digits, and the first one is 1. The second and the third ones\ncould be from 0 to 9.\n\nChunk contains three digits, the first one is 2 and the second one is from 0 to 4.\nThen the third one could be from 0 to 9.\n\nChunk contains three digits, the first one is 2, and the second one is 5.\nThen the third one could be from 0 to 5.\n\nLet's use pipe to create a regular expression that will match either case 1, or\ncase 2, ..., or case 5.\n\nThe job is done. The same logic could be used to construct \"IPv6\" regex pattern.\n\nComplexity Analysis\n\nTime complexity: O(1) because the patterns to match have\nconstant length.\n\nSpace complexity: O(1)."
    },
    {
        "question_id": "b6360a6a-06f0-47b0-830e-e32831b0e34c",
        "title": "Ones and Zeroes",
        "difficulty": "Medium",
        "category": "String Dynamic Programming",
        "question_text": "You are given an array of binary strings strs and two integers m and n.\n\nReturn the size of the largest subset of strs such that there are at most m 0's and n 1's in the subset.\n\nA set x is a subset of a set y if all elements of x are also elements of y.\n\n \n\nExample 1:\n\nInput: strs = [\"10\",\"0001\",\"111001\",\"1\",\"0\"], m = 5, n = 3\nOutput: 4\nExplanation: The largest subset with at most 5 0's and 3 1's is {\"10\", \"0001\", \"1\", \"0\"}, so the answer is 4.\nOther valid but smaller subsets include {\"0001\", \"1\"} and {\"10\", \"1\", \"0\"}.\n{\"111001\"} is an invalid subset because it contains 4 1's, greater than the maximum of 3.\nExample 2:\n\nInput: strs = [\"10\",\"0\",\"1\"], m = 1, n = 1\nOutput: 2\nExplanation: The largest subset is {\"0\", \"1\"}, so the answer is 2.\n \n\nConstraints:\n\n1 <= strs.length <= 600\n1 <= strs[i].length <= 100\nstrs[i] consists only of digits '0' and '1'.\n1 <= m, n <= 100",
        "solution": "int findMaxForm(vector<string>& strs, int m, int n) {\n\t// dp[i][j] will store Max subset size possible with zeros_limit = i, ones_limit = j\n\tvector<vector<int> > dp(m + 1, vector<int>(n + 1));\n\tfor(auto& str : strs) {\n\t\t// count zeros & ones frequency in current string            \n\t\tint zeros = count(begin(str), end(str), '0'), ones = size(str) - zeros; \n\t\t// which positions of dp will be updated ?\n\t\t// Only those having atleast `zeros` 0s(i >= zeros) and `ones` 1s(j >= ones)\n\t\tfor(int i = m; i >= zeros; i--)\n\t\t\tfor(int j = n; j >= ones; j--)                    \n\t\t\t\tdp[i][j] = max(dp[i][j], // either leave the current string\n\t\t\t\t\t\t\t   dp[i - zeros][j - ones] + 1); // or take it by adding 1 to optimal solution of remaining balance\n\t\t// at this point each dp[i][j] will store optimal value for items considered till now & having constraints i and j respectively\n\t}\n\treturn dp[m][n];\n}",
        "explanation": "This problem looks a lot like the knapsack just that we have two constraints here m and n instead of just W in the knapsack problem. Here, a set of items(strings) are given and we have to choose a subset satisfying given constraints. We can apply DP here. We can maintain a 2d dp array, where dp[i][j] will maintain the optimal solution when zeros_limit = i & ones_limit = j.\n\nFor each string, some number of 0s(lets call zeros) and 1s (lets call ones) are required. Obviously, if our balance of zeros and ones is less than what is required by current string, we can't choose it. But in the case where our balance of zeros and ones is greater than the required, we have two cases -\n\nEither take the current string into our subset. The resultant count would be 1 + optimal solution that we had when our balance was i - zeros & j - ones.\nOr leave the current string meaning the resultant count will remain the same.\nFor each string in strs, we will update the dp matrix as per the above two cases.\n\nTime Complexity : O(L*m*n), where L is the length of strs\nSpace Complexity : O(m*n)"
    },
    {
        "question_id": "7a665462-05d1-4cfd-8c28-28ba12435fbf",
        "title": "Zuma Game",
        "difficulty": "Hard",
        "category": "String Dynamic Programming Stack Breadth-First Search Memoization",
        "question_text": "You are playing a variation of the game Zuma.\n\nIn this variation of Zuma, there is a single row of colored balls on a board, where each ball can be colored red 'R', yellow 'Y', blue 'B', green 'G', or white 'W'. You also have several colored balls in your hand.\n\nYour goal is to clear all of the balls from the board. On each turn:\n\nPick any ball from your hand and insert it in between two balls in the row or on either end of the row.\nIf there is a group of three or more consecutive balls of the same color, remove the group of balls from the board.\nIf this removal causes more groups of three or more of the same color to form, then continue removing each group until there are none left.\nIf there are no more balls on the board, then you win the game.\nRepeat this process until you either win or do not have any more balls in your hand.\nGiven a string board, representing the row of balls on the board, and a string hand, representing the balls in your hand, return the minimum number of balls you have to insert to clear all the balls from the board. If you cannot clear all the balls from the board using the balls in your hand, return -1.\n\n \n\nExample 1:\n\nInput: board = \"WRRBBW\", hand = \"RB\"\nOutput: -1\nExplanation: It is impossible to clear all the balls. The best you can do is:\n- Insert 'R' so the board becomes WRRRBBW. WRRRBBW -> WBBW.\n- Insert 'B' so the board becomes WBBBW. WBBBW -> WW.\nThere are still balls remaining on the board, and you are out of balls to insert.\nExample 2:\n\nInput: board = \"WWRRBBWW\", hand = \"WRBRW\"\nOutput: 2\nExplanation: To make the board empty:\n- Insert 'R' so the board becomes WWRRRBBWW. WWRRRBBWW -> WWBBWW.\n- Insert 'B' so the board becomes WWBBBWW. WWBBBWW -> WWWW -> empty.\n2 balls from your hand were needed to clear the board.\nExample 3:\n\nInput: board = \"G\", hand = \"GGGGG\"\nOutput: 2\nExplanation: To make the board empty:\n- Insert 'G' so the board becomes GG.\n- Insert 'G' so the board becomes GGG. GGG -> empty.\n2 balls from your hand were needed to clear the board.\n \n\nConstraints:\n\n1 <= board.length <= 16\n1 <= hand.length <= 5\nboard and hand consist of the characters 'R', 'Y', 'B', 'G', and 'W'.\nThe initial row of balls on the board will not have any groups of three or more consecutive balls of the same color.",
        "solution": "int MAXCOUNT = 6;   // the max balls you need will not exceed 6 since \"The number of balls in your hand won't exceed 5\"\n\npublic int findMinStep(String board, String hand) {\n    int[] handCount = new int[26];\n    for (int i = 0; i < hand.length(); ++i) ++handCount[hand.charAt(i) - 'A'];\n    int rs = helper(board + \"#\", handCount);  // append a \"#\" to avoid special process while j==board.length, make the code shorter.\n    return rs == MAXCOUNT ? -1 : rs;\n}\nprivate int helper(String s, int[] h) {\n    s = removeConsecutive(s);     \n    if (s.equals(\"#\")) return 0;\n    int  rs = MAXCOUNT, need = 0;\n    for (int i = 0, j = 0 ; j < s.length(); ++j) {\n        if (s.charAt(j) == s.charAt(i)) continue;\n        need = 3 - (j - i);     //balls need to remove current consecutive balls.\n        if (h[s.charAt(i) - 'A'] >= need) {\n            h[s.charAt(i) - 'A'] -= need;\n            rs = Math.min(rs, need + helper(s.substring(0, i) + s.substring(j), h));\n            h[s.charAt(i) - 'A'] += need;\n        }\n        i = j;\n    }\n    return rs;\n}\n//remove consecutive balls longer than 3\nprivate String removeConsecutive(String board) {\n    for (int i = 0, j = 0; j < board.length(); ++j) {\n        if (board.charAt(j) == board.charAt(i)) continue;\n        if (j - i >= 3) return removeConsecutive(board.substring(0, i) + board.substring(j));\n        else i = j;\n    }\n    return board;\n}",
        "explanation": "My idea is simple and clear. it's just like a DFS or a Backtracking solution. word is poor, just look the code."
    },
    {
        "question_id": "048c8b98-6c0c-4690-b6f2-ba477ac11b7d",
        "title": "Largest Component Size by Common Factor",
        "difficulty": "Hard",
        "category": "Array Hash Table Math Union Find Number Theory",
        "question_text": "You are given an integer array of unique positive integers nums. Consider the following graph:\n\nThere are nums.length nodes, labeled nums[0] to nums[nums.length - 1],\nThere is an undirected edge between nums[i] and nums[j] if nums[i] and nums[j] share a common factor greater than 1.\nReturn the size of the largest connected component in the graph.\n\n \n\nExample 1:\nInput: nums = [4,6,15,35]\nOutput: 4\nExample 2:\nInput: nums = [20,50,9,63]\nOutput: 2\nExample 3:\nInput: nums = [2,3,6,7,4,12,21,39]\nOutput: 8\n \n\nConstraints:\n\n1 <= nums.length <= 2 * 104\n1 <= nums[i] <= 105\nAll the values of nums are unique.",
        "solution": "class UnionFind {\n    public:\n    vector<int> par, sz;\n    UnionFind(int n) : par(n), sz(n,1) {\n        iota(begin(par), end(par), 0);\n    }\n    int find(int x) {\n        if(par[x] == x) return x;\n        return par[x] = find(par[x]);\n    }\n    bool Union(int x, int y) {\n        int xp = find(x), yp = find(y);\n        if(xp == yp) return false;\n        if(sz[xp] > sz[yp]) par[yp] = par[xp], sz[xp] += sz[yp];\n        else par[xp] = par[yp], sz[yp] += sz[xp];\n        return true;\n    }\n};\nclass Solution {\npublic:\n    int largestComponentSize(vector<int>& nums) {\n        int n = size(nums), ans = 1;\n        UnionFind uf(n + 1);\n        unordered_map<int, int> mp;                    // stores {p : 1st found index i such that nums[i] % p == 0}\n        auto putOrUnion = [&](int p, int i){           // puts 1st found index of element that p divides into hashmap\n            if(mp.count(p)) uf.Union(mp[p], i);        // and if already exists, directly union them\n            else mp[p] = i;\n        };\n        for(int i = 0; i < n; i++) {                   // prime factorize nums[i]\n            int cur = nums[i];\n            if(cur % 2 == 0) {                        \n                putOrUnion(2, i);\n                while(cur % 2 == 0) cur >>= 1;\n            }\n            for(int p = 3; p <= sqrt(cur); p += 2)   \n                if(cur % p == 0) {                 \n                    putOrUnion(p, i);\n                    while(cur % p == 0) cur /= p;\n                }\n            if(cur > 1) putOrUnion(cur, i);            // nums[i] itself is prime   \n        }\n        return *max_element(begin(uf.sz), end(uf.sz)); // return largest component\n    }\n};",
        "explanation": "(Union-Find w/ Prime Factorization)\n\nWe can see that if two numbers belong to the same group due to some common factor, they should also have some common prime factor. This allows us to use slightly different approach where we find all prime factors of a number and union the elements based on the common prime factors amongst them. This can reduce the space used by DSU to O(N) down from O(M) by allowing us to perform union on indices of elements instead of elements & its factors, although we do incur a cost of storing primes and elements in nums that it divides.\nHowever, we can add another small optimization for space. Instead of storing all the primes as a vector in the hashmap and then performing union on the indices of element that each prime divides, we can just put the 1st index of element we find that a prime p divides and then for every subsequent indices, we just union them there itself. This saves space and also eliminate the last step of iterating over each prime and then unioning the indices."
    },
    {
        "question_id": "875f8b83-c677-458e-80be-1031f2c1349e",
        "title": "Minimum Area Rectangle",
        "difficulty": "Medium",
        "category": "Array Hash Table Math Union Find Number Theory",
        "question_text": "You are given an array of points in the X-Y plane points where points[i] = [xi, yi].\n\nReturn the minimum area of a rectangle formed from these points, with sides parallel to the X and Y axes. If there is not any such rectangle, return 0.\n\n \n\nExample 1:\nInput: points = [[1,1],[1,3],[3,1],[3,3],[2,2]]\nOutput: 4\nExample 2:\nInput: points = [[1,1],[1,3],[3,1],[3,3],[4,1],[4,3]]\nOutput: 2\n \n\nConstraints:\n\n1 <= points.length <= 500\npoints[i].length == 2\n0 <= xi, yi <= 4 * 104\nAll the given points are unique.",
        "solution": "class Solution(object):\n    def minAreaRect(self, points):\n        S = set(map(tuple, points))\n        ans = float('inf')\n        for j, p2 in enumerate(points):\n            for i in xrange(j):\n                p1 = points[i]\n                if (p1[0] != p2[0] and p1[1] != p2[1] and\n                        (p1[0], p2[1]) in S and (p2[0], p1[1]) in S):\n                    ans = min(ans, abs(p2[0] - p1[0]) * abs(p2[1] - p1[1]))\n        return ans if ans < float('inf') else 0",
        "explanation": "Intuition\n\nFor each pair of points in the array, consider them to be the long diagonal of a potential rectangle. We can check if all 4 points are there using a Set.\n\nFor example, if the points are (1, 1) and (5, 5), we check if we also have (1, 5) and (5, 1). If we do, we have a candidate rectangle.\n\nAlgorithm\n\nPut all the points in a set. For each pair of points, if the associated rectangle are 4 distinct points all in the set, then take the area of this rectangle as a candidate answer.\nComplexity Analysis\n\nTime Complexity: O(N \n2\n ), where N is the length of points.\n\nSpace Complexity: O(N)."
    },
    {
        "question_id": "3b085e25-b785-4729-9d0c-ebc73cd2f37c",
        "title": "Delete and Earn",
        "difficulty": "Medium",
        "category": "Array Hash Table Dynamic Programming",
        "question_text": "You are given an integer array nums. You want to maximize the number of points you get by performing the following operation any number of times:\n\nPick any nums[i] and delete it to earn nums[i] points. Afterwards, you must delete every element equal to nums[i] - 1 and every element equal to nums[i] + 1.\nReturn the maximum number of points you can earn by applying the above operation some number of times.\n\n \n\nExample 1:\n\nInput: nums = [3,4,2]\nOutput: 6\nExplanation: You can perform the following operations:\n- Delete 4 to earn 4 points. Consequently, 3 is also deleted. nums = [2].\n- Delete 2 to earn 2 points. nums = [].\nYou earn a total of 6 points.\nExample 2:\n\nInput: nums = [2,2,3,3,3,4]\nOutput: 9\nExplanation: You can perform the following operations:\n- Delete a 3 to earn 3 points. All 2's and 4's are also deleted. nums = [3,3].\n- Delete a 3 again to earn 3 points. nums = [3].\n- Delete a 3 once more to earn 3 points. nums = [].\nYou earn a total of 9 points.\n \n\nConstraints:\n\n1 <= nums.length <= 2 * 104\n1 <= nums[i] <= 104",
        "solution": "class Solution {\npublic:\n    int t[20001]; // declaring 1 d array, to store some already computed results\n    int solve(vector<int> &arr, int i)\n    {\n        if(i >= arr.size()) // if i is greater than size of array\n        {\n            return 0; // then simply returnn zero\n        }\n        \n         // if result is already computed, then return from here\n        // this one line which we say to add\n        if(t[i] != -1)\n        {\n            return t[i];\n        }\n        \n        // current 'i' on which we are standing\n        int currValue = arr[i];  // current value\n        int currSum = arr[i]; // intial make sum as same as value\n        int index = i + 1; // index to take elemets, so  i + 1\n        \n        // while it is the same as the current value, include in our sum\n        while(index < arr.size() && arr[index] == currValue)\n        {\n            currSum += arr[i];\n            index++;\n        }\n        \n        // Now, we have to skip all the elements, whose value is equal to\n        // currValue + 1\n        while(index < arr.size() && arr[index] == currValue + 1)\n        {\n            index++;\n        }\n        \n        //And lastly, we have two choices-\n        //whether to include the sum of this current element in our answer\n        // or not include the sum of current element in our answer\n        // so we explore all possibility and take maximum of them\n        \n        return t[i] = max(currSum + solve(arr, index), solve(arr, i + 1));\n        \n        // If we decide to take the curr element in our answer, then upto the elemet we skip the next value, we paas that index\n        // but if decided no to make this vurrent element then simply paas\n        // i + 1\n    }\n    int deleteAndEarn(vector<int>& arr) {\n        int n = arr.size(); // take the size of the array\n        \n        memset(t, -1, sizeof(t));\n        \n        // sort the array to get rid of all arr[i] - 1 elements\n        sort(arr.begin(), arr.end());\n        \n        // solve function which give us our final answer\n        return solve(arr, 0);\n        //                ↑\n        //                we start from zero index\n    }\n};",
        "explanation": "For the memoziation part, we use a 1 d array to store some already computed results.\nThat's all about dp, nothing much.\nWe have to add just one line (see below)."
    },
    {
        "question_id": "67a2c24b-ead9-43cf-8b80-4313d2a4d5d6",
        "title": "Random Pick with Blacklist",
        "difficulty": "Hard",
        "category": "Array Hash Table Math Binary Search Sorting Randomized",
        "question_text": "You are given an integer n and an array of unique integers blacklist. Design an algorithm to pick a random integer in the range [0, n - 1] that is not in blacklist. Any integer that is in the mentioned range and not in blacklist should be equally likely to be returned.\n\nOptimize your algorithm such that it minimizes the number of calls to the built-in random function of your language.\n\nImplement the Solution class:\n\nSolution(int n, int[] blacklist) Initializes the object with the integer n and the blacklisted integers blacklist.\nint pick() Returns a random integer in the range [0, n - 1] and not in blacklist.\n \n\nExample 1:\n\nInput\n[\"Solution\", \"pick\", \"pick\", \"pick\", \"pick\", \"pick\", \"pick\", \"pick\"]\n[[7, [2, 3, 5]], [], [], [], [], [], [], []]\nOutput\n[null, 0, 4, 1, 6, 1, 0, 4]\n\nExplanation\nSolution solution = new Solution(7, [2, 3, 5]);\nsolution.pick(); // return 0, any integer from [0,1,4,6] should be ok. Note that for every call of pick,\n                 // 0, 1, 4, and 6 must be equally likely to be returned (i.e., with probability 1/4).\nsolution.pick(); // return 4\nsolution.pick(); // return 1\nsolution.pick(); // return 6\nsolution.pick(); // return 1\nsolution.pick(); // return 0\nsolution.pick(); // return 4\n \n\nConstraints:\n\n1 <= n <= 109\n0 <= blacklist.length <= min(105, n - 1)\n0 <= blacklist[i] < n\nAll the values of blacklist are unique.\nAt most 2 * 104 calls will be made to pick.",
        "solution": "class Solution {\n    \n    // N: [0, N)\n    // B: blacklist\n    // B1: < N\n    // B2: >= N\n    // M: N - B1\n    int M;\n    Random r;\n    Map<Integer, Integer> map;\n\n    public Solution(int N, int[] blacklist) {\n        map = new HashMap();\n        for (int b : blacklist) // O(B)\n            map.put(b, -1);\n        M = N - map.size();\n        \n        for (int b : blacklist) { // O(B)\n            if (b < M) { // re-mapping\n                while (map.containsKey(N - 1))\n                    N--;\n                map.put(b, N - 1);\n                N--;\n            }\n        }\n        \n        r = new Random();\n    }\n    \n    public int pick() {\n        int p = r.nextInt(M);\n        if (map.containsKey(p))\n            return map.get(p);\n        return p;\n    }\n}",
        "explanation": "Suppose N=10, blacklist=[3, 5, 8, 9], re-map 3 and 5 to 7 and 6."
    },
    {
        "question_id": "b9456589-f1fa-4c77-b736-f791e20ab9e8",
        "title": "Find Duplicate Subtrees",
        "difficulty": "Medium",
        "category": "Hash Table Tree Depth-First Search Binary Tree",
        "question_text": "For each kind of duplicate subtrees, you only need to return the root node of any one of them.\n\nTwo trees are duplicate if they have the same structure with the same node values.\n\n \n\nExample 1:\nInput: root = [1,2,3,4,null,2,4,null,null,4]\nOutput: [[2,4],[4]]\nExample 2:\nInput: root = [2,1,1]\nOutput: [[1]]\nExample 3:\nInput: root = [2,2,2,3,null,3,null]\nOutput: [[2,3],[3]]\n \n\nConstraints:\n\nThe number of the nodes in the tree will be in the range [1, 5000]\n-200 <= Node.val <= 200",
        "solution": "class Solution {\n   int curId = 1;\n\n    public List<TreeNode> findDuplicateSubtrees(TreeNode root) {\n        Map<String, Integer> serialToId = new HashMap<>();\n        Map<Integer, Integer> idToCount = new HashMap<>();\n        List<TreeNode> res = new LinkedList<>();\n        postorder(root, serialToId, idToCount, res);\n        return res;\n    }\n    \n    private int postorder(TreeNode root, Map<String, Integer> serialToId, Map<Integer, Integer> idToCount, List<TreeNode> res) {\n        if (root == null) return 0;\n        int leftId = postorder(root.left, serialToId, idToCount, res);\n        int rightId = postorder(root.right, serialToId, idToCount, res);\n        String curSerial = leftId + \",\" + root.val + \",\" + rightId;\n        int serialId = serialToId.getOrDefault(curSerial, curId);\n        if (serialId == curId) curId++;\n        serialToId.put(curSerial, serialId);\n        idToCount.put(serialId, idToCount.getOrDefault(serialId, 0) + 1);\n        if (idToCount.get(serialId) == 2) res.add(root);\n        return serialId;\n    }\n    \n}",
        "explanation": "We perform postorder traversal, serializing and hashing the serials of subtrees in the process. We can recognize a duplicate subtree by its serialization.\n\nThe above time complexity is O(n^2). We can improve this to O(n) by replacing full serializations with serial ids instead."
    },
    {
        "question_id": "6e846c2a-231c-4aad-89e0-964a63c9f753",
        "title": "Encode and Decode TinyURL",
        "difficulty": "Medium",
        "category": "Hash Table String Design Hash Function",
        "question_text": "TinyURL is a URL shortening service where you enter a URL such as https://leetcode.com/problems/design-tinyurl and it returns a short URL such as http://tinyurl.com/4e9iAk. Design a class to encode a URL and decode a tiny URL.\n\nThere is no restriction on how your encode/decode algorithm should work. You just need to ensure that a URL can be encoded to a tiny URL and the tiny URL can be decoded to the original URL.\n\nImplement the Solution class:\n\nSolution() Initializes the object of the system.\nString encode(String longUrl) Returns a tiny URL for the given longUrl.\nString decode(String shortUrl) Returns the original long URL for the given shortUrl. It is guaranteed that the given shortUrl was encoded by the same object.\n \n\nExample 1:\n\nInput: url = \"https://leetcode.com/problems/design-tinyurl\"\nOutput: \"https://leetcode.com/problems/design-tinyurl\"\n\nExplanation:\nSolution obj = new Solution();\nstring tiny = obj.encode(url); // returns the encoded tiny url.\nstring ans = obj.decode(tiny); // returns the original url after decoding it.\n \n\nConstraints:\n\n1 <= url.length <= 104\nurl is guranteed to be a valid URL.",
        "solution": "class Codec:\n\n    alphabet = string.ascii_letters + '0123456789'\n\n    def __init__(self):\n        self.url2code = {}\n        self.code2url = {}\n\n    def encode(self, longUrl):\n        while longUrl not in self.url2code:\n            code = ''.join(random.choice(Codec.alphabet) for _ in range(6))\n            if code not in self.code2url:\n                self.code2url[code] = longUrl\n                self.url2code[longUrl] = code\n        return 'http://tinyurl.com/' + self.url2code[longUrl]\n\n    def decode(self, shortUrl):\n        return self.code2url[shortUrl[-6:]]",
        "explanation": "Using increasing numbers as codes like that is simple but has some disadvantages, which the below solution fixes:\n\nIf I'm asked to encode the same long URL several times, it will get several entries. That wastes codes and memory.\nPeople can find out how many URLs have already been encoded. Not sure I want them to know.\nPeople might try to get special numbers by spamming me with repeated requests shortly before their desired number comes up.\nOnly using digits means the codes can grow unnecessarily large. Only offers a million codes with length 6 (or smaller). Using six digits or lower or upper case letters would offer (10+26*2)6 = 56,800,235,584 codes with length 6.\nThe following solution doesn't have these problems. It produces short URLs like http://tinyurl.com/KtLa2U, using a random code of six digits or letters. If a long URL is already known, the existing short URL is used and no new entry is generated."
    },
    {
        "question_id": "70041bd1-a55a-4f8f-8415-99fbd4440c8e",
        "title": "All O`one Data Structure",
        "difficulty": "Hard",
        "category": "Hash Table Linked List Design Doubly-Linked List",
        "question_text": "Design a data structure to store the strings' count with the ability to return the strings with minimum and maximum counts.\n\nImplement the AllOne class:\n\nAllOne() Initializes the object of the data structure.\ninc(String key) Increments the count of the string key by 1. If key does not exist in the data structure, insert it with count 1.\ndec(String key) Decrements the count of the string key by 1. If the count of key is 0 after the decrement, remove it from the data structure. It is guaranteed that key exists in the data structure before the decrement.\ngetMaxKey() Returns one of the keys with the maximal count. If no element exists, return an empty string \"\".\ngetMinKey() Returns one of the keys with the minimum count. If no element exists, return an empty string \"\".\nNote that each function must run in O(1) average time complexity.\n\n \n\nExample 1:\n\nInput\n[\"AllOne\", \"inc\", \"inc\", \"getMaxKey\", \"getMinKey\", \"inc\", \"getMaxKey\", \"getMinKey\"]\n[[], [\"hello\"], [\"hello\"], [], [], [\"leet\"], [], []]\nOutput\n[null, null, null, \"hello\", \"hello\", null, \"hello\", \"leet\"]\n\nExplanation\nAllOne allOne = new AllOne();\nallOne.inc(\"hello\");\nallOne.inc(\"hello\");\nallOne.getMaxKey(); // return \"hello\"\nallOne.getMinKey(); // return \"hello\"\nallOne.inc(\"leet\");\nallOne.getMaxKey(); // return \"hello\"\nallOne.getMinKey(); // return \"leet\"\n \n\nConstraints:\n\n1 <= key.length <= 10\nkey consists of lowercase English letters.\nIt is guaranteed that for each call to dec, key is existing in the data structure.\nAt most 5 * 104 calls will be made to inc, dec, getMaxKey, and getMinKey.",
        "solution": "class Node {\npublic:\n    int freq;\n    Node* prev;\n    Node* next;\n    unordered_set<string> keys;\n\n    Node(int freq) : freq(freq), prev(nullptr), next(nullptr) {}\n};\n\nclass AllOne {\nprivate:\n    Node* head;                        // Dummy head\n    Node* tail;                        // Dummy tail\n    unordered_map<string, Node*> map;  // Mapping from key to its node\n\npublic:\n    // Initialize your data structure here.\n    AllOne() {\n        head = new Node(0);  // Create dummy head\n        tail = new Node(0);  // Create dummy tail\n        head->next = tail;   // Link dummy head to dummy tail\n        tail->prev = head;   // Link dummy tail to dummy head\n    }\n\n    // Inserts a new key <Key> with value 1. Or increments an existing key by 1.\n    void inc(string key) {\n        if (map.find(key) != map.end()) {\n            Node* node = map[key];\n            int freq = node->freq;\n            node->keys.erase(key);  // Remove key from current node\n\n            Node* nextNode = node->next;\n            if (nextNode == tail || nextNode->freq != freq + 1) {\n                // Create a new node if next node does not exist or freq is not\n                // freq + 1\n                Node* newNode = new Node(freq + 1);\n                newNode->keys.insert(key);\n                newNode->prev = node;\n                newNode->next = nextNode;\n                node->next = newNode;\n                nextNode->prev = newNode;\n                map[key] = newNode;\n            } else {\n                // Increment the existing next node\n                nextNode->keys.insert(key);\n                map[key] = nextNode;\n            }\n\n            // Remove the current node if it has no keys left\n            if (node->keys.empty()) {\n                removeNode(node);\n            }\n        } else {  // Key does not exist\n            Node* firstNode = head->next;\n            if (firstNode == tail || firstNode->freq > 1) {\n                // Create a new node\n                Node* newNode = new Node(1);\n                newNode->keys.insert(key);\n                newNode->prev = head;\n                newNode->next = firstNode;\n                head->next = newNode;\n                firstNode->prev = newNode;\n                map[key] = newNode;\n            } else {\n                firstNode->keys.insert(key);\n                map[key] = firstNode;\n            }\n        }\n    }\n\n    // Decrements an existing key by 1. If Key's value is 1, remove it from the\n    // data structure.\n    void dec(string key) {\n        if (map.find(key) == map.end()) {\n            return;  // Key does not exist\n        }\n\n        Node* node = map[key];\n        node->keys.erase(key);\n        int freq = node->freq;\n\n        if (freq == 1) {\n            // Remove the key from the map if freq is 1\n            map.erase(key);\n        } else {\n            Node* prevNode = node->prev;\n            if (prevNode == head || prevNode->freq != freq - 1) {\n                // Create a new node if the previous node does not exist or freq\n                // is not freq - 1\n                Node* newNode = new Node(freq - 1);\n                newNode->keys.insert(key);\n                newNode->prev = prevNode;\n                newNode->next = node;\n                prevNode->next = newNode;\n                node->prev = newNode;\n                map[key] = newNode;\n            } else {\n                // Decrement the existing previous node\n                prevNode->keys.insert(key);\n                map[key] = prevNode;\n            }\n        }\n\n        // Remove the node if it has no keys left\n        if (node->keys.empty()) {\n            removeNode(node);\n        }\n    }\n\n    // Returns one of the keys with maximal value.\n    string getMaxKey() {\n        if (tail->prev == head) {\n            return \"\";  // No keys exist\n        }\n        return *(tail->prev->keys.begin());  // Return one of the keys from the\n                                             // tail's previous node\n    }\n\n    // Returns one of the keys with minimal value.\n    string getMinKey() {\n        if (head->next == tail) {\n            return \"\";  // No keys exist\n        }\n        return *(\n            head->next->keys\n                .begin());  // Return one of the keys from the head's next node\n    }\n\nprivate:\n    void removeNode(Node* node) {\n        Node* prevNode = node->prev;\n        Node* nextNode = node->next;\n\n        prevNode->next = nextNode;  // Link previous node to next node\n        nextNode->prev = prevNode;  // Link next node to previous node\n\n        delete node;  // Free the memory of the removed node\n    }\n};",
        "explanation": "Using Doubly Linked List\nIntuition\nTo manage a collection of keys and their frequencies, we need a structure that updates easily and provides quick access to maximum and minimum frequencies. We start with a hashmap to look up each key’s frequency quickly.\n\nHowever, a hashmap alone does not track frequencies well. We need a way to group keys by their frequencies and find keys with the same frequency. We use a doubly linked list for this. Each node represents a frequency and holds all keys linked to that frequency. This setup allows us to add and remove keys efficiently as their frequencies change.\n\nTo handle edge cases better, we include dummy head and tail nodes in the list. These nodes make it easier to manage operations when the list is empty or when we add or remove nodes at the ends.\n\nWhen we increment a key, we first check if it exists in the hashmap. If the key is new, we look at the node after the dummy head. If that node does not have a frequency of 1, we create a new node for frequency 1. We add the key to this node and update the hashmap. If the key already exists, we find its current frequency node and check the next node, which shows the next higher frequency. If that next node is the tail or does not have the expected frequency, we create a new node with the increased frequency. We then move the key to the right node, remove it from the old node, and delete the old node if it becomes empty.\n\nWhen we decrement a key, we first check if it is in the hashmap. If it is, we remove it from its current node. If the key’s frequency is greater than one, we check the previous node. If needed, we create a new node for the decreased frequency and add the key to the appropriate previous node, updating the hashmap. If the frequency is one, we remove the key from the hashmap completely.\n\nTo find the key with the maximum frequency, we return one of the keys from the last node in the list. For the minimum frequency key, we get a key from the first node after the dummy head. If there are no keys, we return an empty string."
    },
    {
        "question_id": "a9554ee0-ae3b-41cc-baf9-b1c15f11ddad",
        "title": "Insert Delete GetRandom O(1) - Duplicates allowed",
        "difficulty": "Hard",
        "category": "Array Hash Table Math Design Randomized",
        "question_text": "RandomizedCollection is a data structure that contains a collection of numbers, possibly duplicates (i.e., a multiset). It should support inserting and removing specific elements and also reporting a random element.\n\nImplement the RandomizedCollection class:\n\nRandomizedCollection() Initializes the empty RandomizedCollection object.\nbool insert(int val) Inserts an item val into the multiset, even if the item is already present. Returns true if the item is not present, false otherwise.\nbool remove(int val) Removes an item val from the multiset if present. Returns true if the item is present, false otherwise. Note that if val has multiple occurrences in the multiset, we only remove one of them.\nint getRandom() Returns a random element from the current multiset of elements. The probability of each element being returned is linearly related to the number of the same values the multiset contains.\nYou must implement the functions of the class such that each function works on average O(1) time complexity.\n\nNote: The test cases are generated such that getRandom will only be called if there is at least one item in the RandomizedCollection.\n\n \n\nExample 1:\n\nInput\n[\"RandomizedCollection\", \"insert\", \"insert\", \"insert\", \"getRandom\", \"remove\", \"getRandom\"]\n[[], [1], [1], [2], [], [1], []]\nOutput\n[null, true, false, true, 2, true, 1]\n\nExplanation\nRandomizedCollection randomizedCollection = new RandomizedCollection();\nrandomizedCollection.insert(1);   // return true since the collection does not contain 1.\n                                  // Inserts 1 into the collection.\nrandomizedCollection.insert(1);   // return false since the collection contains 1.\n                                  // Inserts another 1 into the collection. Collection now contains [1,1].\nrandomizedCollection.insert(2);   // return true since the collection does not contain 2.\n                                  // Inserts 2 into the collection. Collection now contains [1,1,2].\nrandomizedCollection.getRandom(); // getRandom should:\n                                  // - return 1 with probability 2/3, or\n                                  // - return 2 with probability 1/3.\nrandomizedCollection.remove(1);   // return true since the collection contains 1.\n                                  // Removes 1 from the collection. Collection now contains [1,2].\nrandomizedCollection.getRandom(); // getRandom should return 1 or 2, both equally likely.\n \n\nConstraints:\n\n-231 <= val <= 231 - 1\nAt most 2 * 105 calls in total will be made to insert, remove, and getRandom.\nThere will be at least one element in the data structure when getRandom is called.",
        "solution": "from collections import defaultdict\nfrom random import choice\n\nclass RandomizedCollection:\n\n    def __init__(self):\n        \"\"\"\n        Initialize your data structure here.\n        \"\"\"\n        self.lst = []\n        self.idx = defaultdict(set)\n\n\n    def insert(self, val: int) -> bool:\n        \"\"\"\n        Inserts a value to the collection. Returns true if the collection did not already contain the specified element.\n        \"\"\"\n        self.idx[val].add(len(self.lst))\n        self.lst.append(val)\n        return len(self.idx[val]) == 1\n\n\n    def remove(self, val: int) -> bool:\n        \"\"\"\n        Removes a value from the collection. Returns true if the collection contained the specified element.\n        \"\"\"\n        if not self.idx[val]: return False\n        remove, last = self.idx[val].pop(), self.lst[-1]\n        self.lst[remove] = last\n        self.idx[last].add(remove)\n        self.idx[last].discard(len(self.lst) - 1)\n\n        self.lst.pop()\n        return True\n\n\n    def getRandom(self) -> int:\n        \"\"\"\n        Get a random element from the collection.\n        \"\"\"\n        return choice(self.lst)",
        "explanation": "ArrayList + HashMap\nAlgorithm\n\nWe will keep a list to store all our elements. In order to make finding the index of elements we want to remove O(1), we will use a HashMap or dictionary to map values to all indices that have those values. To make this work each value will be mapped to a set of indices. The tricky part is properly updating the HashMap as we modify the list.\n\ninsert: Append the element to the list and add the index to HashMap[element].\nremove: This is the tricky part. We find the index of the element using the HashMap. We use the trick discussed in the intuition to remove the element from the list in O(1). Since the last element in the list gets moved around, we have to update its value in the HashMap. We also have to get rid of the index of the element we removed from the HashMap.\ngetRandom: Sample a random element from the list.\n\nComplexity Analysis\n\nTime complexity : O(N), with N being the number of operations. All of our operations are O(1), giving N∗O(1)=O(N).\n\nSpace complexity : O(N), with N being the number of operations. The worst case scenario is if we get N add operations, in which case our ArrayList and our HashMap grow to size N."
    },
    {
        "question_id": "63592949-5b5f-4783-8cfe-e9023e6df924",
        "title": "Repeated DNA Sequences",
        "difficulty": "Medium",
        "category": "Hash Table String Bit Manipulation Sliding Window Rolling Hash Hash Function",
        "question_text": "The DNA sequence is composed of a series of nucleotides abbreviated as 'A', 'C', 'G', and 'T'.\n\nFor example, \"ACGAATTCCG\" is a DNA sequence.\nWhen studying DNA, it is useful to identify repeated sequences within the DNA.\n\nGiven a string s that represents a DNA sequence, return all the 10-letter-long sequences (substrings) that occur more than once in a DNA molecule. You may return the answer in any order.\n\n \n\nExample 1:\n\nInput: s = \"AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT\"\nOutput: [\"AAAAACCCCC\",\"CCCCCAAAAA\"]\nExample 2:\n\nInput: s = \"AAAAAAAAAAAAA\"\nOutput: [\"AAAAAAAAAA\"]\n \n\nConstraints:\n\n1 <= s.length <= 105\ns[i] is either 'A', 'C', 'G', or 'T'.",
        "solution": "class Solution {\n\tpublic List<String> findRepeatedDnaSequences(String s) {\n\t\tif(s == null || s.length() < 10) {\n\t\t\treturn Collections.emptyList();\n\t\t}\n\t\tint start = 0;\n\t\tint end = 10;\n\t\tSet<String> set = new HashSet<>();\n\t\tSet<String> result = new HashSet<>();\n\t\tStringBuilder builder = new StringBuilder(s);\n\t\twhile(end <= s.length()) {            \n\t\t\t//String curr = s.substring(start,end);   \n\t\t\t//builder is faster, so using builder below\n\t\t\tString curr = builder.substring(start,end);   \n\t\t\tif(set.contains(curr)) {\n\t\t\t\tresult.add(curr);\n\t\t\t}\n\t\t\tset.add(curr);\n\t\t\tstart++;\n\t\t\tend++;\n\t\t}\n\t\treturn new ArrayList<>(result);\n\t}\n}",
        "explanation": "Time complexity is O(n) where n is length of input string s\nwhile loop runs O(n) times and substring method O(m) where is m is length of substring\nit is not O(n^2) as you think, because the subString method is O(1) because m = 10 is constant\nSpace is O(p) where p is total number of subSequences"
    },
    {
        "question_id": "9b3a21b2-a8c2-4587-bbfc-16f19a162b79",
        "title": "Majority Element",
        "difficulty": "Easy",
        "category": "Array Hash Table Divide and Conquer Sorting Counting",
        "question_text": "The DNA sequence is composed of a series of nucleotides abbreviated as 'A', 'C', 'G', and 'T'.\n\nFor example, \"ACGAATTCCG\" is a DNA sequence.\nWhen studying DNA, it is useful to identify repeated sequences within the DNA.\n\nGiven a string s that represents a DNA sequence, return all the 10-letter-long sequences (substrings) that occur more than once in a DNA molecule. You may return the answer in any order.\n\n \n\nExample 1:\n\nInput: s = \"AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT\"\nOutput: [\"AAAAACCCCC\",\"CCCCCAAAAA\"]\nExample 2:\n\nInput: s = \"AAAAAAAAAAAAA\"\nOutput: [\"AAAAAAAAAA\"]\n \n\nConstraints:\n\n1 <= s.length <= 105\ns[i] is either 'A', 'C', 'G', or 'T'.",
        "solution": "class Solution {\npublic:\n    int majorityElement(vector<int>& nums) {\n        int count = 0;\n        int candidate = 0;\n        \n        for (int num : nums) {\n            if (count == 0) {\n                candidate = num;\n            }\n            \n            if (num == candidate) {\n                count++;\n            } else {\n                count--;\n            }\n        }\n        \n        return candidate;\n    }\n};",
        "explanation": "Intuition:\nThe intuition behind the Moore's Voting Algorithm is based on the fact that if there is a majority element in an array, it will always remain in the lead, even after encountering other elements.\n\nExplanation:\nAlgorithm:\n\nInitialize two variables: count and candidate. Set count to 0 and candidate to an arbitrary value.\nIterate through the array nums:\na. If count is 0, assign the current element as the new candidate and increment count by 1.\nb. If the current element is the same as the candidate, increment count by 1.\nc. If the current element is different from the candidate, decrement count by 1.\nAfter the iteration, the candidate variable will hold the majority element.\nExplanation:\n\nThe algorithm starts by assuming the first element as the majority candidate and sets the count to 1.\nAs it iterates through the array, it compares each element with the candidate:\na. If the current element matches the candidate, it suggests that it reinforces the majority element because it appears again. Therefore, the count is incremented by 1.\nb. If the current element is different from the candidate, it suggests that there might be an equal number of occurrences of the majority element and other elements. Therefore, the count is decremented by 1.\nNote that decrementing the count doesn't change the fact that the majority element occurs more than n/2 times.\nIf the count becomes 0, it means that the current candidate is no longer a potential majority element. In this case, a new candidate is chosen from the remaining elements.\nThe algorithm continues this process until it has traversed the entire array.\nThe final value of the candidate variable will hold the majority element.\nExplanation of Correctness:\nThe algorithm works on the basis of the assumption that the majority element occurs more than n/2 times in the array. This assumption guarantees that even if the count is reset to 0 by other elements, the majority element will eventually regain the lead.\n\nLet's consider two cases:\n\nIf the majority element has more than n/2 occurrences:\n\nThe algorithm will ensure that the count remains positive for the majority element throughout the traversal, guaranteeing that it will be selected as the final candidate.\nIf the majority element has exactly n/2 occurrences:\n\nIn this case, there will be an equal number of occurrences for the majority element and the remaining elements combined.\nHowever, the majority element will still be selected as the final candidate because it will always have a lead over any other element.\nIn both cases, the algorithm will correctly identify the majority element.\n\nThe time complexity of the Moore's Voting Algorithm is O(n) since it traverses the array once.\n\nThis approach is efficient compared to sorting as it requires only a single pass through the array and does not change the original order of the elements."
    },
    {
        "question_id": "0b41ec80-41e7-43ee-9d52-73537691625e",
        "title": "Sudoku Solver",
        "difficulty": "Hard",
        "category": "Array Hash Table Backtracking Matrix",
        "question_text": "Write a program to solve a Sudoku puzzle by filling the empty cells.\n\nA sudoku solution must satisfy all of the following rules:\n\nEach of the digits 1-9 must occur exactly once in each row.\nEach of the digits 1-9 must occur exactly once in each column.\nEach of the digits 1-9 must occur exactly once in each of the 9 3x3 sub-boxes of the grid.\nThe '.' character indicates empty cells.\n\n \n\nExample 1:\nInput: board = [[\"5\",\"3\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\"],[\"6\",\".\",\".\",\"1\",\"9\",\"5\",\".\",\".\",\".\"],[\".\",\"9\",\"8\",\".\",\".\",\".\",\".\",\"6\",\".\"],[\"8\",\".\",\".\",\".\",\"6\",\".\",\".\",\".\",\"3\"],[\"4\",\".\",\".\",\"8\",\".\",\"3\",\".\",\".\",\"1\"],[\"7\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\",\"6\"],[\".\",\"6\",\".\",\".\",\".\",\".\",\"2\",\"8\",\".\"],[\".\",\".\",\".\",\"4\",\"1\",\"9\",\".\",\".\",\"5\"],[\".\",\".\",\".\",\".\",\"8\",\".\",\".\",\"7\",\"9\"]]\nOutput: [[\"5\",\"3\",\"4\",\"6\",\"7\",\"8\",\"9\",\"1\",\"2\"],[\"6\",\"7\",\"2\",\"1\",\"9\",\"5\",\"3\",\"4\",\"8\"],[\"1\",\"9\",\"8\",\"3\",\"4\",\"2\",\"5\",\"6\",\"7\"],[\"8\",\"5\",\"9\",\"7\",\"6\",\"1\",\"4\",\"2\",\"3\"],[\"4\",\"2\",\"6\",\"8\",\"5\",\"3\",\"7\",\"9\",\"1\"],[\"7\",\"1\",\"3\",\"9\",\"2\",\"4\",\"8\",\"5\",\"6\"],[\"9\",\"6\",\"1\",\"5\",\"3\",\"7\",\"2\",\"8\",\"4\"],[\"2\",\"8\",\"7\",\"4\",\"1\",\"9\",\"6\",\"3\",\"5\"],[\"3\",\"4\",\"5\",\"2\",\"8\",\"6\",\"1\",\"7\",\"9\"]]\nExplanation: The input board is shown above and the only valid solution is shown below:\n\nConstraints:\n\nboard.length == 9\nboard[i].length == 9\nboard[i][j] is a digit or '.'.\nIt is guaranteed that the input board has only one solution.",
        "solution": "class Solution {\npublic:\n    void solveSudoku(vector<vector<char>>& board) {\n        solve(board);\n    }\n\nprivate:\n    bool solve(vector<vector<char>>& board) {\n        for (int row = 0; row < 9; row++) {\n            for (int col = 0; col < 9; col++) {\n                if (board[row][col] == '.') {\n                    for (char num = '1'; num <= '9'; num++) {\n                        if (isValid(board, row, col, num)) {\n                            board[row][col] = num;\n                            if (solve(board)) return true;\n                            board[row][col] = '.';\n                        }\n                    }\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n\n    bool isValid(vector<vector<char>>& board, int row, int col, char num) {\n        for (int i = 0; i < 9; i++) {\n            if (board[row][i] == num || board[i][col] == num) return false;\n        }\n        int startRow = (row / 3) * 3, startCol = (col / 3) * 3;\n        for (int i = startRow; i < startRow + 3; i++) {\n            for (int j = startCol; j < startCol + 3; j++) {\n                if (board[i][j] == num) return false;\n            }\n        }\n        return true;\n    }\n};",
        "explanation": "Intuition\nTo solve a Sudoku puzzle, try to place numbers one by one in each cell, ensuring that the number placement obeys the Sudoku rules. If placing a number leads to a valid board configuration, continue; otherwise, backtrack by removing the number.\n\nApproach\nTraverse the board cell by cell:\nIf a cell is empty, try placing each number from 1 to 9.\nAfter placing a number, check if the board remains valid.\nRecursively attempt to solve the remaining board with the current placement.\nIf the placement fails, reset the cell and try the next number.\nUse backtracking to explore all possible configurations until the board is solved.\nComplexity\nTime complexity:\nO(9 \n(n×n)\n ) where ( n = 9 ), due to backtracking over each cell and number combination.\n\nSpace complexity:\nO(n \n2\n ) due to recursive stack usage in backtracking."
    },
    {
        "question_id": "83dd40cf-ebad-4a5b-add2-ee4699adb157",
        "title": "Rotate Image",
        "difficulty": "Medium",
        "category": "Array Math Matrix",
        "question_text": "You are given an n x n 2D matrix representing an image, rotate the image by 90 degrees (clockwise).\n\nYou have to rotate the image in-place, which means you have to modify the input 2D matrix directly. DO NOT allocate another 2D matrix and do the rotation.\n\n \n\nExample 1:\nInput: matrix = [[1,2,3],[4,5,6],[7,8,9]]\nOutput: [[7,4,1],[8,5,2],[9,6,3]]\nExample 2:\nInput: matrix = [[5,1,9,11],[2,4,8,10],[13,3,6,7],[15,14,12,16]]\nOutput: [[15,13,2,5],[14,3,4,1],[12,6,8,9],[16,7,10,11]]\n \n\nConstraints:\n\nn == matrix.length == matrix[i].length\n1 <= n <= 20\n-1000 <= matrix[i][j] <= 1000",
        "solution": "class Solution {\npublic:\n    void rotate(vector<vector<int>>& matrix) {\n        int row = matrix.size();\n        for(int i=0;i<row; i++){\n            for(int j=0; j<=i;j++){\n                swap(matrix[i][j], matrix[j][i]);\n            }\n        }\n        for(int i=0;i<row;i++){\n            reverse(matrix[i].begin(), matrix[i].end());\n        }\n    }\n};",
        "explanation": "Approach\n2 Steps to rotate image\n\nTranspose the matrix\nSwap the columns"
    },
    {
        "question_id": "b9fd67df-a486-4ec6-8f13-571c860b63f5",
        "title": "Pow(x, n)",
        "difficulty": "Medium",
        "category": "Math Recursion",
        "question_text": "Implement pow(x, n), which calculates x raised to the power n (i.e., xn).\n\n \n\nExample 1:\n\nInput: x = 2.00000, n = 10\nOutput: 1024.00000\nExample 2:\n\nInput: x = 2.10000, n = 3\nOutput: 9.26100\nExample 3:\n\nInput: x = 2.00000, n = -2\nOutput: 0.25000\nExplanation: 2-2 = 1/22 = 1/4 = 0.25\n \n\nConstraints:\n\n-100.0 < x < 100.0\n-231 <= n <= 231-1\nn is an integer.\nEither x is not zero or n > 0.\n-104 <= xn <= 104",
        "solution": "class Solution {\npublic:\n    double myPow(double x, int n) {\n        return binaryExp(x, static_cast<long>(n));\n    }\n\nprivate:\n    double binaryExp(double x, long n) {\n        if (n == 0) {\n            return 1;\n        }\n       \n        if (n < 0) {\n            return 1.0 / binaryExp(x, -n);\n        }\n       \n        if (n % 2 == 1) {\n            return x * binaryExp(x * x, (n - 1) / 2);\n        } else {\n            return binaryExp(x * x, n / 2);\n        }\n    }\n};",
        "explanation": "Approach\nThis is based on Python Code. Other language might be different a bit.\n\nDefine the myPow function that takes two parameters: x (the base) and n (the exponent). The function returns the value of x raised to the power of n.\n\nDefine a helper function calc_power(x, n) that will be used for the recursive calculation. This function takes two parameters: x (the base) and n (the exponent).\n\nIn the calc_power function:\n\nCheck the base case: If x is 0, return 0 (as anything raised to the power of 0 is 1).\nCheck another base case: If n is 0, return 1 (as anything raised to the power of 0 is 1).\nIf n is even, recursively calculate res by calling calc_power(x, n // 2) and then square res (res = res * res).\nIf n is odd, recursively calculate res by calling calc_power(x, (n - 1) // 2) and then square res, finally multiply it with x (res = res * res * x).\nNow, in the myPow function:\n\nGet the absolute value of n using abs(n) and store it in a variable abs_n.\nCalculate ans by calling calc_power(x, abs_n), which gives us the value of x raised to the power of abs_n.\nIf n is non-negative (n >= 0), return ans.\n\nIf n is negative (n < 0), return 1 / ans (which gives us the result of x raised to the power of -n, i.e., the reciprocal).\nThe algorithm takes advantage of the properties of exponents and the concept that x^(n) can be calculated using x^(n/2) to avoid redundant calculations and improve the efficiency of the power calculation."
    },
    {
        "question_id": "95d1d8d9-d995-41e9-8e5f-68e84e984cb1",
        "title": "Add Binary",
        "difficulty": "Easy",
        "category": "Math String Bit Manipulation Simulation",
        "question_text": "Given two binary strings a and b, return their sum as a binary string.\n\n \n\nExample 1:\n\nInput: a = \"11\", b = \"1\"\nOutput: \"100\"\nExample 2:\n\nInput: a = \"1010\", b = \"1011\"\nOutput: \"10101\"\n \n\nConstraints:\n\n1 <= a.length, b.length <= 104\na and b consist only of '0' or '1' characters.\nEach string does not contain leading zeros except for the zero itself.",
        "solution": "class Solution {\n public:\n  string addBinary(string a, string b) {\n    string ans;\n    int carry = 0;\n    int i = a.length() - 1;\n    int j = b.length() - 1;\n\n    while (i >= 0 || j >= 0 || carry) {\n      if (i >= 0)\n        carry += a[i--] - '0';\n      if (j >= 0)\n        carry += b[j--] - '0';\n      ans += carry % 2 + '0';\n      carry /= 2;\n    }\n\n    reverse(begin(ans), end(ans));\n    return ans;\n  }\n};",
        "explanation": "Intuition :\nWe have to add two binary numbers (made up of 0's and 1's) and returns the result in binary.\nApproach :\nWe start at the right end of each binary number, adding the digits and any carry-over value, and storing the result in a new string.\nNow we move to the next digit on the left and repeats the process until it has gone through all the digits in both binary numbers.\nIf there is any carry-over value after adding all the digits, append it to the end of the new string.\nFinally, the new string is reversed and returned as the sum of the two binary numbers."
    },
    {
        "question_id": "c6444c79-5b50-4da1-bc91-8ec6b6c09633",
        "title": "Can I Win",
        "difficulty": "Medium",
        "category": "Math Dynamic Programming Bit Manipulation Memoization Game Theory Bitmask",
        "question_text": "In the \"100 game\" two players take turns adding, to a running total, any integer from 1 to 10. The player who first causes the running total to reach or exceed 100 wins.\n\nWhat if we change the game so that players cannot re-use integers?\n\nFor example, two players might take turns drawing from a common pool of numbers from 1 to 15 without replacement until they reach a total >= 100.\n\nGiven two integers maxChoosableInteger and desiredTotal, return true if the first player to move can force a win, otherwise, return false. Assume both players play optimally.\n\n \n\nExample 1:\n\nInput: maxChoosableInteger = 10, desiredTotal = 11\nOutput: false\nExplanation:\nNo matter which integer the first player choose, the first player will lose.\nThe first player can choose an integer from 1 up to 10.\nIf the first player choose 1, the second player can only choose integers from 2 up to 10.\nThe second player will win by choosing 10 and get a total = 11, which is >= desiredTotal.\nSame with other integers chosen by the first player, the second player will always win.\nExample 2:\n\nInput: maxChoosableInteger = 10, desiredTotal = 0\nOutput: true\nExample 3:\n\nInput: maxChoosableInteger = 10, desiredTotal = 1\nOutput: true\n \n\nConstraints:\n\n1 <= maxChoosableInteger <= 20\n0 <= desiredTotal <= 300",
        "solution": "class Solution:\n    def canIWin(self, maxChoosableInteger, desiredTotal):\n        \"\"\"\n        :type maxChoosableInteger: int\n        :type desiredTotal: int\n        :rtype: bool\n        \"\"\"\n        seen = {}\n\n        def can_win(choices, remainder):\n            # if the largest choice exceeds the remainder, then we can win!\n            if choices[-1] >= remainder:\n                return True\n\n            # if we have seen this exact scenario play out, then we know the outcome\n            seen_key = tuple(choices)\n            if seen_key in seen:\n                return seen[seen_key]\n\n            # we haven't won yet.. it's the next player's turn.\n            for index in range(len(choices)):\n                if not can_win(choices[:index] + choices[index + 1:], remainder - choices[index]):\n                    seen[seen_key] = True\n                    return True\n\n            # uh-oh if we got here then next player won all permutations, we can't force their hand\n            # actually, they were able to force our hand :(\n            seen[seen_key] = False\n            return False\n\n        # let's do some quick checks before we journey through the tree of permutations\n        summed_choices = (maxChoosableInteger + 1) * maxChoosableInteger / 2\n\n        # if all the choices added up are less then the total, no-one can win\n        if summed_choices < desiredTotal:\n            return False\n\n        # if the sum matches desiredTotal exactly then you win if there's an odd number of turns\n        if summed_choices == desiredTotal:\n\t\t    return maxChoosableInteger % 2\n\n        # slow: time to go through the tree of permutations\n\t\tchoices = list(range(1, maxChoosableInteger + 1))\n        return can_win(choices, desiredTotal)",
        "explanation": "no explanation"
    },
    {
        "question_id": "67675ff0-b820-4c0b-9823-d47af128c715",
        "title": "Arranging Coins",
        "difficulty": "Easy",
        "category": "Math Binary Search",
        "question_text": "You have n coins and you want to build a staircase with these coins. The staircase consists of k rows where the ith row has exactly i coins. The last row of the staircase may be incomplete.\n\nGiven the integer n, return the number of complete rows of the staircase you will build.\n\n \n\nExample 1:\nInput: n = 5\nOutput: 2\nExplanation: Because the 3rd row is incomplete, we return 2.\nExample 2:\nInput: n = 8\nOutput: 3\nExplanation: Because the 4th row is incomplete, we return 3.\n \n\nConstraints:\n\n1 <= n <= 231 - 1",
        "solution": "import math\n\nclass Solution(object):\n    def arrangeCoins(self, n):\n        return int((math.sqrt(8 * n + 1) - 1) // 2)",
        "explanation": "Intuition\nThis is about forming full staircase rows with coins: row i needs i coins. The total coins used for k full rows is the sum of 1 + 2 + ... + k = k(k+1)/2. Solve this inequality for k.\n\nApproach\nUse the quadratic formula to solve:\n\nk(k + 1)/2 <= n\n=> k² + k - 2n <= 0\nUsing the positive root of the quadratic equation, compute:\n\nk = (sqrt(8n + 1) - 1) / 2\nThen return the floor of k.\n\nComplexity\nTime Complexity: ( O(1) ) — single math operation.\nSpace Complexity: ( O(1) ) — no extra space."
    },
    {
        "question_id": "4fb7fb94-b0fc-4618-83ae-2c48fac22884",
        "title": "Generate Random Point in a Circle",
        "difficulty": "Medium",
        "category": "Math Geometry Rejection Sampling Randomized",
        "question_text": "Given the radius and the position of the center of a circle, implement the function randPoint which generates a uniform random point inside the circle.\n\nImplement the Solution class:\n\nSolution(double radius, double x_center, double y_center) initializes the object with the radius of the circle radius and the position of the center (x_center, y_center).\nrandPoint() returns a random point inside the circle. A point on the circumference of the circle is considered to be in the circle. The answer is returned as an array [x, y].\n \n\nExample 1:\n\nInput\n[\"Solution\", \"randPoint\", \"randPoint\", \"randPoint\"]\n[[1.0, 0.0, 0.0], [], [], []]\nOutput\n[null, [-0.02493, -0.38077], [0.82314, 0.38945], [0.36572, 0.17248]]\n\nExplanation\nSolution solution = new Solution(1.0, 0.0, 0.0);\nsolution.randPoint(); // return [-0.02493, -0.38077]\nsolution.randPoint(); // return [0.82314, 0.38945]\nsolution.randPoint(); // return [0.36572, 0.17248]\n \n\nConstraints:\n\n0 < radius <= 108\n-107 <= x_center, y_center <= 107\nAt most 3 * 104 calls will be made to randPoint.",
        "solution": "class Solution:\n    def __init__(self, radius, x_center, y_center):\n        self.r, self.x, self.y = radius, x_center, y_center\n\n    def randPoint(self):\n        theta = uniform(0,2*pi)\n        R = self.r*sqrt(uniform(0,1))\n        return [self.x + R*cos(theta), self.y + R*sin(theta)]",
        "explanation": "Imagine first special case for this problem: we have circle with radius equal to 1 and coordinates of center is (0, 0). Let us use polar coordinates:\nx = R * cos(theta)\ny = R * sin(theta).\nHere R is distance between our point (call it A) and the origin (call it O). theta is angle between OA and axis OX.\nWhy it is good idea to go to polar coordinates here? Because in polar coordiantes unity circle can be written as:\nR <= 1\n0 <= theta <= 2*pi.\n\nNow we need to answer two qustions: how to generate R and how to generate theta.\n\nAbout theta it is quite obvious: we do it uniformly.\nAbout R it is not obvious: if we do it uniformly, there will be more points closer if we generate it in uniform way. Look at this intuition: let us fix R = 1 and generate 10 points, then fix R = 0.5 and generate 10 more points. What you can see? Distance between points on the big circle is in average 2 times bigger, than between 2 points on smaller circle. It actually means, that for small circle you need to generate only 5 points, not 10, and by this logic if you have x points for circle with R = 1, you need x*R points for smaller radius.\nThis was intuition, now let go into mathematics: what does uniform distribution means, that if we choose small element inside our circle, than probability to get inside this element should be proportional to area of this element. Let us define F(R) cumulative distribution function (cdf) for radius. Then by definition probability to get between R and R + dR is equal to F(R + dR) - F(R) = f(R)*dR, where f(R) is probability density function (pdf), so probability to get into this small region is f(R)* dR * dTheta. From other point of view, area of this region can be calclated as [(R+dR)^2 - R^2]*dTheta = 2*R*dR*dTheta. From here we get, that f(R) = c*R for some constant c (because we say it is proportional, not equal). Now, F'(R) = f(R), so F(R) = c*R^2 (here c is another conatant). Now the question is how you generate data such that cumulative function is proportional to R^2. The answer is Inverse transform sampling (check wikipedia), where idea is given uniform distribution generate data from any distribution F(R): we need to generate R from uniform distrubution and than apply inverse function, that is we have sqrt(uniform(0,1)) in the end."
    },
    {
        "question_id": "71ab2f20-49bb-4d58-ad4a-df2761c6f2a3",
        "title": "Base 7",
        "difficulty": "Easy",
        "category": "Math",
        "question_text": "Given an integer num, return a string of its base 7 representation.\n\n \n\nExample 1:\n\nInput: num = 100\nOutput: \"202\"\nExample 2:\n\nInput: num = -7\nOutput: \"-10\"\n \n\nConstraints:\n\n-107 <= num <= 107",
        "solution": "class Solution {\npublic:\n    string convertToBase7(int num) {\n        if (num == 0) return \"0\";\n        string res;\n        bool neg = num < 0;\n        num = abs(num);\n        while (num > 0) {\n            res = to_string(num % 7) + res;\n            num /= 7;\n        }\n        return neg ? \"-\" + res : res;\n    }\n};",
        "explanation": "Intuition\nThe simplest way to convert a number to base 7 is by leveraging built-in conversion functions. Many languages have direct methods to convert a number to a different base.\n\nApproach\nUse a built-in function (if available) to convert num to a base 7 string.\n\nIf not available, manually implement base conversion by repeatedly dividing the number by 7 and collecting remainders.\n\nComplexity\nTime complexity: O(log n)\nSince the number is divided by 7 in each step\n\nSpace complexity: O(1)\nConstant space usage"
    },
    {
        "question_id": "96cd0883-7761-4a3c-9ac9-ef643a84aa65",
        "title": "Self Dividing Numbers",
        "difficulty": "Easy",
        "category": "Math",
        "question_text": "A self-dividing number is a number that is divisible by every digit it contains.\n\nFor example, 128 is a self-dividing number because 128 % 1 == 0, 128 % 2 == 0, and 128 % 8 == 0.\nA self-dividing number is not allowed to contain the digit zero.\n\nGiven two integers left and right, return a list of all the self-dividing numbers in the range [left, right] (both inclusive).\n\n \n\nExample 1:\n\nInput: left = 1, right = 22\nOutput: [1,2,3,4,5,6,7,8,9,11,12,15,22]\nExample 2:\n\nInput: left = 47, right = 85\nOutput: [48,55,66,77]\n \n\nConstraints:\n\n1 <= left <= right <= 104",
        "solution": "class Solution:\n    def selfDividingNumbers(self, left: int, right: int) -> List[int]:\n        # Helper function to check if a number is self-dividing\n        def self_dividing(n: int) -> bool:\n            for d in str(n):\n                if d == \"0\" or n % int(d) > 0:\n                    return False\n            return True\n\n        \"\"\"\n        def self_dividing(n: int) -> bool:\n            x = n\n            while x > 0:\n                d = x % 10\n                if d == 0 or (n % d) > 0:\n                    return False\n                x //= 10\n            return True\n        \"\"\"\n\n        # List to store self-dividing numbers\n        ans = []\n\n        # Iterate over the range and find self-dividing numbers\n        for n in range(left, right + 1):\n            if self_dividing(n):\n                ans.append(n)\n\n        # Alternatively: return list(filter(self_dividing, range(left, right + 1)))\n        return ans",
        "explanation": "Brute Force [Accepted]\nIntuition and Algorithm\n\nFor each number in the given range, we will directly test if that number is self-dividing.\n\nBy definition, we want to test each whether each digit is non-zero and divide the number. For example, with 128, we want to test d != 0 && 128 % d == 0 for d = 1, 2, 8. To do that, we need to iterate over each digit of the number.\n\nA straightforward approach to that problem would be to convert the number into a character array (string in Python), and then convert it back to an integer to perform the modulo operation when checking n % d == 0.\n\nWe could also continually divide the number by 10 and peek at the last digit. That is shown as a variation in a comment.\nComplexity Analysis\n\nTime Complexity: We iterate through each digit in the given number; therefore, the time complexity is O(D), where D represents the number of digits in the number.\n\nSpace Complexity: O(1), since we do not include the output size in space complexity calculations and only consider the intermediate variables or references used during the computation."
    },
    {
        "question_id": "356d0648-1285-47d1-8f66-a2aa7b46c5d3",
        "title": "Reach a Number",
        "difficulty": "Medium",
        "category": "Math Binary Search",
        "question_text": "You are standing at position 0 on an infinite number line. There is a destination at position target.\n\nYou can make some number of moves numMoves so that:\n\nOn each move, you can either go left or right.\nDuring the ith move (starting from i == 1 to i == numMoves), you take i steps in the chosen direction.\nGiven the integer target, return the minimum number of moves required (i.e., the minimum numMoves) to reach the destination.\n\n \n\nExample 1:\n\nInput: target = 2\nOutput: 3\nExplanation:\nOn the 1st move, we step from 0 to 1 (1 step).\nOn the 2nd move, we step from 1 to -1 (2 steps).\nOn the 3rd move, we step from -1 to 2 (3 steps).\nExample 2:\n\nInput: target = 3\nOutput: 2\nExplanation:\nOn the 1st move, we step from 0 to 1 (1 step).\nOn the 2nd move, we step from 1 to 3 (2 steps).\n \n\nConstraints:\n\n-109 <= target <= 109\ntarget != 0",
        "solution": "class Solution(object):\n    def reachNumber(self, target):\n        target = abs(target)\n        k = 0\n        while target > 0:\n            k += 1\n            target -= k\n\n        return k if target % 2 == 0 else k + 1 + k%2",
        "explanation": "Intuition\n\nThe crux of the problem is to put + and - signs on the numbers 1, 2, 3, ..., k so that the sum is target.\n\nWhen target < 0 and we made a sum of target, we could switch the signs of all the numbers so that it equals Math.abs(target). Thus, the answer for target is the same as Math.abs(target), and so without loss of generality, we can consider only target > 0.\n\nNow let's say k is the smallest number with S = 1 + 2 + ... + k >= target. If S == target, the answer is clearly k.\n\nIf S > target, we need to change some number signs. If delta = S - target is even, then we can always find a subset of {1, 2, ..., k} equal to delta / 2 and switch the signs, so the answer is k. (This depends on T = delta / 2 being at most S.) [The proof is simple: either T <= k and we choose it, or we choose k in our subset and try to solve the same instance of the problem for T -= k and the set {1, 2, ..., k-1}.]\n\nOtherwise, if delta is odd, we can't do it, as every sign change from positive to negative changes the sum by an even number. So let's consider a candidate answer of k+1, which changes delta by k+1. If this is odd, then delta will be even and we can have an answer of k+1. Otherwise, delta will be odd, and we will have an answer of k+2.\n\nFor concrete examples of the above four cases, consider the following:\n\nIf target = 3, then k = 2, delta = 0 and the answer is k = 2.\nIf target = 4, then k = 3, delta = 2, delta is even and the answer is k = 3.\nIf target = 7, then k = 4, delta = 3, delta is odd and adding k+1 makes delta even. The answer is k+1 = 5.\nIf target = 5, then k = 3, delta = 1, delta is odd and adding k+1 keeps delta odd. The answer is k+2 = 5.\nAlgorithm\n\nSubtract ++k from target until it goes non-positive. Then k will be as described, and target will be delta as described. We can output the four cases above: if delta is even then the answer is k, if delta is odd then the answer is k+1 or k+2 depending on the parity of k."
    },
    {
        "question_id": "ead2e9a9-ae35-47f1-9ae1-ad538c0ffb6d",
        "title": "Magic Squares In Grid",
        "difficulty": "Medium",
        "category": "Array Hash Table Math Matrix",
        "question_text": "A 3 x 3 magic square is a 3 x 3 grid filled with distinct numbers from 1 to 9 such that each row, column, and both diagonals all have the same sum.\n\nGiven a row x col grid of integers, how many 3 x 3 magic square subgrids are there?\n\nNote: while a magic square can only contain numbers from 1 to 9, grid may contain numbers up to 15.\n\n \n\nExample 1:\nInput: grid = [[4,3,8,4],[9,5,1,9],[2,7,6,2]]\nOutput: 1\nExplanation: \nThe following subgrid is a 3 x 3 magic square:\nwhile this one is not:\nIn total, there is only one magic square inside the given grid.\nExample 2:\n\nInput: grid = [[8]]\nOutput: 0\n \n\nConstraints:\n\nrow == grid.length\ncol == grid[i].length\n1 <= row, col <= 10\n0 <= grid[i][j] <= 15",
        "solution": "class Solution {\npublic:\n    int numMagicSquaresInside(vector<vector<int>>& grid) {\n        int ans = 0;\n        int m = grid.size();\n        int n = grid[0].size();\n        for (int row = 0; row + 2 < m; row++) {\n            for (int col = 0; col + 2 < n; col++) {\n                if (isMagicSquare(grid, row, col)) {\n                    ans++;\n                }\n            }\n        }\n        return ans;\n    }\n\nprivate:\n    bool isMagicSquare(vector<vector<int>>& grid, int row, int col) {\n        // The sequences are each repeated twice to account for\n        // the different possible starting points of the sequence\n        // in the magic square\n        string sequence = \"2943816729438167\";\n        string sequenceReversed = \"7618349276183492\";\n\n        string border = \"\";\n        // Flattened indices for bordering elements of 3x3 grid\n        vector<int> borderIndices = {0, 1, 2, 5, 8, 7, 6, 3};\n        for (int i : borderIndices) {\n            int num = grid[row + i / 3][col + (i % 3)];\n            border += to_string(num);\n        }\n\n        // Make sure the sequence starts at one of the corners\n        return (grid[row][col] % 2 == 0 && grid[row + 1][col + 1] == 5 &&\n                (sequence.find(border) != string::npos ||\n                 sequenceReversed.find(border) != string::npos));\n    }\n};",
        "explanation": "Intuition\nIn Approach 1, we determined whether each subarray of grid is a magic square by explicitly checking each criterion of the magic square definition given in the problem statement.\n\nWe can dive deeper into the definition of a 3 x 3 magic square to find additional properties that can help us simplify the logic for determining if a subarray is a magic square:\n\nConstant Sum\n\nBy definition, every row has the same sum S. Furthermore, the definition states that a magic grid can only contain values 1 to 9 and each value must be distinct. Since every 3 x 3 magic grid will contain exactly 9 squares, we can see that every magic grid will have exactly one of each allowed value. Thus, we can see that the total sum of an entire 3 x 3 magic square is 1+2+3+...+9=45.\n\nBecause each magic square consists of 3 rows, we can say that 3S=45 and thus S=15. This means that every row sum, and in turn every column sum and diagonal sum, equals 15.\n\nLimited Number of Arrangements\n\nIf every row, column, and diagonal has to sum up to 15 and can only contain distinct values from 1 to 9, then there are only a limited number of arrangements to form a magic square. Listed below are all possible combinations of 3-part sums that add up to 15, where each value is between 1 and 9:\n\n1+5+9\n\n1+6+8\n\n2+4+9\n\n2+5+8\n\n2+6+7\n\n3+4+8\n\n3+5+7\n\n4+5+6\n\nWe can see that there are 8 different ways, which map directly to the 8 3-part sums in the magic square (3 rows + 3 columns + 2 diagonals = 8 total sums). We can explore further constraints on arranging the possible magic squares.\n\nConstraint 1 - Middle element\n\n5 appears in exactly 4 of these sums. The only element that would appear in 4 sums is the middle element of the magic square. Specifically, the middle element appears in the sums for the middle row, the middle column, and both diagonals. Thus, we know that for a subarray to be a magic square, its middle element has to be 5.\nConstraint 2 - Even numbers\n\nMoreover, the even numbers (2, 4, 6, and 8) each appear in exactly 3 of the sums. Only the corner elements of the grid can appear in exactly 3 sums. Specifically, they appear in the sum for one row, one column, and one diagonal. Thus, we know the corner elements have to be even numbers.\nConstraint 3 - Odd numbers\n\nFinally, the only numbers remaining are the odd numbers (1, 3, 7, and 9). They each appear in exactly 2 of the sums. The remaining elements on the edges of the grid also appear in exactly 2 sums: the sums for one row and one column. Thus, we know the remaining edge elements have to be odd numbers.\nWe observe that for all possible arrangements, the elements around the border (the even/odd numbers from constraints 2/3 above) all follow the ordered sequence\n\n2,9,4,3,8,1,6,7\n\neither moving clockwise or counter-clockwise around the border, starting at a corner element.\n\nThus, we know that a subarray is a magic square if and only if it satisfies the 2 following properties:\n\nThe middle element is 5\nThe bordering elements follow the 2,9,4,3,8,1,6,7 sequence, starting at some corner element and going either clockwise or counter-clockwise."
    },
    {
        "question_id": "9b99b6df-586d-4622-bf91-2bbb8af54af5",
        "title": "Balanced Binary Tree",
        "difficulty": "Easy",
        "category": "Tree Depth-First Search Binary Tree",
        "question_text": "iven a binary tree, determine if it is height-balanced.\n\n \n\nExample 1:\n\nInput: root = [3,9,20,null,null,15,7]\nOutput: true\nExample 2:\nInput: root = [1,2,2,3,3,null,null,4,4]\nOutput: false\nExample 3:\n\nInput: root = []\nOutput: true\n \n\nConstraints:\n\nThe number of nodes in the tree is in the range [0, 5000].\n-104 <= Node.val <= 104",
        "solution": "class Solution {\npublic:\n    bool isBalanced(TreeNode* root) {\n        return dfs(root).first;        \n    }\n\nprivate:\n    pair<bool, int> dfs(TreeNode* node) {\n        if (!node) return {true, 0};\n        \n        auto [leftBalanced, leftHeight] = dfs(node->left);\n        auto [rightBalanced, rightHeight] = dfs(node->right);\n        \n        bool isBalanced = leftBalanced && rightBalanced && abs(leftHeight - rightHeight) <= 1;\n        \n        return {isBalanced, 1 + max(leftHeight, rightHeight)};\n    }    \n};",
        "explanation": "Approach\nFirst of all, what is the points to solve this question?\n\nHow do you handle null?\nHow do you calculate height difference?\nWhat do you keep for the next recursive process?\nHow do you handle null?\nSimply, we consider null as balanced. null is nothing at current position and both side. That means the fact that nothing exists makes the left and right sides balanced.\n\nHow do you calculate height difference?\nThe description says \"A height-balanced binary tree is a binary tree in which the depth of the two subtrees of every node never differs by more than one.\"\n\nSince we need to know the height difference, we have to subtract the left and right heights.\n\nFor example,\n\nleft height is 5.\nright height is 4.\nIn this case, difference is 1. But one problem here is that if we calculate\n\nleft height - right height\n= 5 - 4\n= 1(= true)\nWe will get 1, but these is a case where left height is 4 and right height is 5. left height is not always higher than right height. In that case,\n\nleft height - right height\n= 4 - 5\n= -1\nDifference should be 1 for both cases. You could handle this with an if statement, but it might not be the most elegant solution. There’s probably a simpler and smarter way—any ideas?\n\nMy answer is to use absolute values, so that we can handle 1 and -1 as 1.\n\nabs(left height - right height)\n= abs(4 - 5)\n= 1\nComplexity\nTime complexity: O(n)\nSpace complexity: O(n)\nIn the worst case (a skewed tree), the recursion depth is O(n)."
    },
    {
        "question_id": "b01dde81-3317-4192-a426-b711b371821b",
        "title": "Validate Binary Search Tree",
        "difficulty": "Medium",
        "category": "Tree Depth-First Search Binary Search Tree Binary Tree",
        "question_text": "Given the root of a binary tree, determine if it is a valid binary search tree (BST).\n\nA valid BST is defined as follows:\n\nThe left subtree of a node contains only nodes with keys less than the node's key.\nThe right subtree of a node contains only nodes with keys greater than the node's key.\nBoth the left and right subtrees must also be binary search trees.\n \n\nExample 1:\nInput: root = [2,1,3]\nOutput: true\nExample 2:\nInput: root = [5,1,4,null,null,3,6]\nOutput: false\nExplanation: The root node's value is 5 but its right child's value is 4.\n \n\nConstraints:\n\nThe number of nodes in the tree is in the range [1, 104].\n-231 <= Node.val <= 231 - 1",
        "solution": "class Solution {\npublic:\n    bool isValidBST(TreeNode* root) {\n        return valid(root, LONG_MIN, LONG_MAX);        \n    }\n\nprivate:\n    bool valid(TreeNode* node, long minimum, long maximum) {\n        if (!node) return true;\n\n        if (!(node->val > minimum && node->val < maximum)) return false;\n\n        return valid(node->left, minimum, node->val) && valid(node->right, node->val, maximum);\n    }    \n};",
        "explanation": "Approach\n        10\n       /  \\\n      8    15\n          /  \\\n         12  18\nLet's think about possible range of root value. It's easy right?\n\n8 < root(= 10) < 15\nBut problem is we don't konw what number is minimum and maximum in algorithm, so my strategy is to put infinity numbers.\n\nnegative infinity < root < infinity\nIn that case, we can put any number at root node.\n\nLet's think about range of each node.\n\n10 → -i < 10 < i\n 8 → -i <  8 < 10\n15 → 10 < 15 < i\n12 → 10 < 12 < 15\n18 → 15 < 18 < i\n\ni is infinity\nIf we meet all condition, we can say this is valid binary search tree.\n\nLet's separate like this.\n\nGo Left\n 8 → -i <  8 < 10\n12 → 10 < 12 < 15\n\nGo Right\n15 → 10 < 15 < i\n18 → 15 < 18 < i\n Points\n\nWhen we go left, update maxinum value only. A minimum number will be the same number from parent.\n\nOn the other hand, when we go right, update minimum number only. A maxinum number will be the same number from parent."
    },
    {
        "question_id": "c2811532-1830-4a8d-8965-7389e0519e23",
        "title": "Same Tree",
        "difficulty": "Easy",
        "category": "Tree Depth-First Search Breadth-First Search Binary Tree",
        "question_text": "Given the roots of two binary trees p and q, write a function to check if they are the same or not.\n\nTwo binary trees are considered the same if they are structurally identical, and the nodes have the same value.\n\n \n\nExample 1:\nInput: p = [1,2,3], q = [1,2,3]\nOutput: true\nExample 2:\nInput: p = [1,2], q = [1,null,2]\nOutput: false\nExample 3:\nInput: p = [1,2,1], q = [1,1,2]\nOutput: false\n \n\nConstraints:\n\nThe number of nodes in both trees is in the range [0, 100].\n-104 <= Node.val <= 104",
        "solution": "class Solution {\npublic:\n    bool isSameTree(TreeNode* p, TreeNode* q) {\n        // If both nodes are NULL, they are identical\n        if (p == NULL && q == NULL) {\n            return true;\n        }\n        // If only one of the nodes is NULL, they are not identical\n        if (p == NULL || q == NULL) {\n            return false;\n        }\n        // Check if values are equal and recursively check left and right subtrees\n        if (p->val == q->val) {\n            return isSameTree(p->left, q->left) && isSameTree(p->right, q->right);\n        }\n        // Values are not equal, they are not identical\n        return false;\n    }\n};",
        "explanation": "Intuition\nThe intuition behind the solution is to recursively check if two binary trees are identical. If both trees are empty (null), they are considered identical. If only one tree is empty or the values of the current nodes are different, the trees are not identical. Otherwise, we recursively check if the left and right subtrees of both trees are identical.\n\nApproach\nCheck the base case: if both trees are null, return true.\nCheck if only one tree is null or the values of the current nodes are different, return false.\nRecursively check if the left subtrees of both trees are identical.\nRecursively check if the right subtrees of both trees are identical.\nReturn the logical AND of the results from steps 3 and 4.\nComplexity\n\nTime complexity:\nThe time complexity of the solution is O(min(N,M)), where N and M are the number of nodes in the two trees, respectively. This is because we need to visit each node once in order to compare their values. In the worst case, where both trees have the same number of nodes, the time complexity would be O(N).\n\nSpace complexity:\nThe space complexity of the solution isO(min(H1,H2)), where H1 and H2 are the heights of the two trees, respectively. This is because the space used by the recursive stack is determined by the height of the smaller tree. In the worst case, where one tree is significantly larger than the other, the space complexity would be closer to O(N) or O(M), depending on which tree is larger."
    },
    {
        "question_id": "7b712ef6-27c3-475a-8bef-be783d2a9898",
        "title": "Symmetric Tree",
        "difficulty": "Easy",
        "category": "Tree Depth-First Search Breadth-First Search Binary Tree",
        "question_text": "Given the root of a binary tree, check whether it is a mirror of itself (i.e., symmetric around its center).\n\n \n\nExample 1:\nInput: root = [1,2,2,3,4,4,3]\nOutput: true\nExample 2:\nInput: root = [1,2,2,null,3,null,3]\nOutput: false\n \n\nConstraints:\n\nThe number of nodes in the tree is in the range [1, 1000].\n-100 <= Node.val <= 100",
        "solution": "class Solution {\npublic:\n    bool isMirror(TreeNode* left, TreeNode* right) {\n    if (!left && !right) return true;\n    if (!left || !right) return false;\n    return (left->val == right->val) && isMirror(left->left, right->right) && isMirror(left->right, right->left);\n}\n\nbool isSymmetric(TreeNode* root) {\n    if (!root) return true;\n    return isMirror(root->left, root->right);\n}\n\n};",
        "explanation": "Intuition\nTo check if a binary tree is symmetric, we need to compare its left subtree and right subtree. To do this, we can traverse the tree recursively and compare the left and right subtrees at each level. If they are symmetric, we continue the traversal. Otherwise, we can immediately return false.\n\nApproach\nWe can define a recursive helper function that takes two nodes as input, one from the left subtree and one from the right subtree. The helper function returns true if both nodes are null, or if their values are equal and their subtrees are symmetric.\n\nComplexity\nTime complexity:The time complexity of the algorithm is O(n), where n is the number of nodes in the binary tree. We need to visit each node once to check if the tree is symmetric.\nSpace complexity:\nThe space complexity of the algorithm is O(h), where h is the height of the binary tree. In the worst case, the tree can be completely unbalanced, and the recursion stack can go as deep as the height of the tree"
    },
    {
        "question_id": "13284f7a-1600-46d7-b091-d3383f8fb55d",
        "title": "Clone Graph",
        "difficulty": "Medium",
        "category": "Hash Table Depth-First Search Breadth-First Search Graph",
        "question_text": "Given a reference of a node in a connected undirected graph.\n\nReturn a deep copy (clone) of the graph.\n\nEach node in the graph contains a value (int) and a list (List[Node]) of its neighbors.\n\nclass Node {\n    public int val;\n    public List<Node> neighbors;\n}\n \n\nTest case format:\n\nFor simplicity, each node's value is the same as the node's index (1-indexed). For example, the first node with val == 1, the second node with val == 2, and so on. The graph is represented in the test case using an adjacency list.\n\nAn adjacency list is a collection of unordered lists used to represent a finite graph. Each list describes the set of neighbors of a node in the graph.\n\nThe given node will always be the first node with val = 1. You must return the copy of the given node as a reference to the cloned graph.\n\n \n\nExample 1:\nInput: adjList = [[2,4],[1,3],[2,4],[1,3]]\nOutput: [[2,4],[1,3],[2,4],[1,3]]\nExplanation: There are 4 nodes in the graph.\n1st node (val = 1)'s neighbors are 2nd node (val = 2) and 4th node (val = 4).\n2nd node (val = 2)'s neighbors are 1st node (val = 1) and 3rd node (val = 3).\n3rd node (val = 3)'s neighbors are 2nd node (val = 2) and 4th node (val = 4).\n4th node (val = 4)'s neighbors are 1st node (val = 1) and 3rd node (val = 3).\nExample 2:\nInput: adjList = [[]]\nOutput: [[]]\nExplanation: Note that the input contains one empty list. The graph consists of only one node with val = 1 and it does not have any neighbors.\nExample 3:\n\nInput: adjList = []\nOutput: []\nExplanation: This an empty graph, it does not have any nodes.\n \n\nConstraints:\n\nThe number of nodes in the graph is in the range [0, 100].\n1 <= Node.val <= 100\nNode.val is unique for each node.\nThere are no repeated edges and no self-loops in the graph.\nThe Graph is connected and all nodes can be visited starting from the given node.",
        "solution": "class Solution {\n    public:\n    Node* dfs(Node* cur,unordered_map<Node*,Node*>& mp)\n    {\n        vector<Node*> neighbour;\n        Node* clone=new Node(cur->val);\n        mp[cur]=clone;\n            for(auto it:cur->neighbors)\n            {\n                if(mp.find(it)!=mp.end())   //already clone and stored in map\n                {\n                    neighbour.push_back(mp[it]);    //directly push back the clone node from map to neigh\n                }\n                else\n                    neighbour.push_back(dfs(it,mp));\n            }\n            clone->neighbors=neighbour;\n            return clone;\n    }\n    Node* cloneGraph(Node* node) {\n        unordered_map<Node*,Node*> mp;\n        if(node==NULL)\n            return NULL;\n        if(node->neighbors.size()==0)   //if only one node present no neighbors\n        {\n            Node* clone= new Node(node->val);\n            return clone; \n        }\n        return dfs(node,mp);\n    }\n};",
        "explanation": "1. We use HashMap to solve it and using DFS.\n2. Initially our hash map will be empty and we try to map the old node with the new node or the copy node.\n3. We start with any entry point.\n4. I am using '1' as my entry point.\n\nNow lets see how its going i am starting with 1 and whenever i visited a new node i coloned it and put in there.\nWe are using DFS so algorithm is like 'it starts at the root node (select some arbitrary node as root node in the case of a graph) and explores as far as possible along each branch before backtracking.\nSo the basic idea is to start from the root or any arbitrary node and mark the node and move to the adjacentunmarked node and continue this loop until there is no unmarked adjacent node. \nThen backtrack and check for other unmarked nodes and traverse them. Finally, print the nodes in the path.'\nSo we are using HashMap to put all the visited node or old node there with clone one to.\n _________\n| HashMap |\n ----------\n|Old|Clone| \n| 1  | 1 |\n|  2 | 2 |\n|  3 | 3 |                                                     \n|  4 | 4 |                                                                                                            \n---------\n\nNow i started with 1 so i cloned it and from 1 can go to 2 and 4 so i go 2 and when i visited 2 i cloned 2 and now fro  i have two choices either go to previous one that is 1 or discover 3 i.e new node\nso accordingly to dfs i go to 3 and from 3 i can go to 4 i go there and cloned it. Now if we see fro each node we have viisted to a new node but what about 4. So here half part of Dfs is completed,\nand now its time for recursive call to go back and now from here we check from current node i can go where and where.\nAnd follow the same rules over there.\n\nBUT BEFORE STARTING ANY CLONING WE HAVE TO CHECK THAT IF WE HAVE CLONED THAT NODE ALREADY THERE OR NOT. IF NOT THAN ONLY WE CLONED IT. \n\nThats the only reason we are using hash map so that we don't need to clone again and again.\nFor every uncloned node we make a clone and iterate over the neighbors of original node using dfs traversal or bfs traversal."
    },
    {
        "question_id": "2c27c82b-f5a1-4557-9613-967595339a68",
        "title": "Invert Binary Tree",
        "difficulty": "Easy",
        "category": "Tree Depth-First Search Breadth-First Search Binary Tree",
        "question_text": "Given the root of a binary tree, invert the tree, and return its root.\n\n \n\nExample 1:\nInput: root = [4,2,7,1,3,6,9]\nOutput: [4,7,2,9,6,3,1]\nExample 2:\nInput: root = [2,1,3]\nOutput: [2,3,1]\nExample 3:\n\nInput: root = []\nOutput: []\n \n\nConstraints:\n\nThe number of nodes in the tree is in the range [0, 100].\n-100 <= Node.val <= 100",
        "solution": "class Solution {\npublic:\n    TreeNode* invertTree(TreeNode* root) {\n        // Base Case\n        if(root==NULL)\n            return NULL;\n        invertTree(root->left); //Call the left substree\n        invertTree(root->right); //Call the right substree\n        // Swap the nodes\n        TreeNode* temp = root->left;\n        root->left = root->right;\n        root->right = temp;\n        return root; // Return the root\n    }\n};",
        "explanation": "Intuition\nIn this question we have to Invert the binary tree.\nSo we use Post Order Treversal in which first we go in Left subtree and then in Right subtree then we return back to Parent node.\nWhen we come back to the parent node we swap it's Left subtree and Right subtree.\nComplexity\nTime complexity: O(N)\nSpace complexity: O(N) Recursive stack space"
    },
    {
        "question_id": "bcfdc828-cd20-4b51-94df-4448ed81ffd2",
        "title": "Path Sum III",
        "difficulty": "Medium",
        "category": "Tree Depth-First Search Binary Tree",
        "question_text": "Given the root of a binary tree and an integer targetSum, return the number of paths where the sum of the values along the path equals targetSum.\n\nThe path does not need to start or end at the root or a leaf, but it must go downwards (i.e., traveling only from parent nodes to child nodes).\n\n \n\nExample 1:\nInput: root = [10,5,-3,3,2,null,11,3,-2,null,1], targetSum = 8\nOutput: 3\nExplanation: The paths that sum to 8 are shown.\nExample 2:\n\nInput: root = [5,4,8,11,null,13,4,7,2,null,null,5,1], targetSum = 22\nOutput: 3\n \n\nConstraints:\n\nThe number of nodes in the tree is in the range [0, 1000].\n-109 <= Node.val <= 109\n-1000 <= targetSum <= 1000",
        "solution": "class Solution(object):\n    def pathSum(self, root, target):\n        # define global result and path\n        self.result = 0\n        cache = {0:1}\n        \n        # recursive to get result\n        self.dfs(root, target, 0, cache)\n        \n        # return result\n        return self.result\n    \n    def dfs(self, root, target, currPathSum, cache):\n        # exit condition\n        if root is None:\n            return  \n        # calculate currPathSum and required oldPathSum\n        currPathSum += root.val\n        oldPathSum = currPathSum - target\n        # update result and cache\n        self.result += cache.get(oldPathSum, 0)\n        cache[currPathSum] = cache.get(currPathSum, 0) + 1\n        \n        # dfs breakdown\n        self.dfs(root.left, target, currPathSum, cache)\n        self.dfs(root.right, target, currPathSum, cache)\n        # when move to a different branch, the currPathSum is no longer available, hence remove one. \n        cache[currPathSum] -= 1",
        "explanation": "Memorization of path sum: O(n)\n2.1 High level walk through\nIn order to optimize from the brutal force solution, we will have to think of a clear way to memorize the intermediate result. Namely in the brutal force solution, we did a lot repeated calculation. For example 1->3->5, we calculated: 1, 1+3, 1+3+5, 3, 3+5, 5.\nThis is a classical 'space and time tradeoff': we can create a dictionary (named cache) which saves all the path sum (from root to current node) and their frequency.\nAgain, we traverse through the tree, at each node, we can get the currPathSum (from root to current node). If within this path, there is a valid solution, then there must be a oldPathSum such that currPathSum - oldPathSum = target.\nWe just need to add the frequency of the oldPathSum to the result.\nDuring the DFS break down, we need to -1 in cache[currPathSum], because this path is not available in later traverse.\nCheck the graph below for easy visualization."
    },
    {
        "question_id": "0662bccf-1951-497e-9593-9cb3cbd5f0ca",
        "title": "Second Minimum Node In a Binary Tree",
        "difficulty": "Easy",
        "category": "Tree Depth-First Search Binary Tree",
        "question_text": "Given a non-empty special binary tree consisting of nodes with the non-negative value, where each node in this tree has exactly two or zero sub-node. If the node has two sub-nodes, then this node's value is the smaller value among its two sub-nodes. More formally, the property root.val = min(root.left.val, root.right.val) always holds.\n\nGiven such a binary tree, you need to output the second minimum value in the set made of all the nodes' value in the whole tree.\n\nIf no such second minimum value exists, output -1 instead.\n\n \n\n \n\nExample 1:\n\nInput: root = [2,2,5,null,null,5,7]\nOutput: 5\nExplanation: The smallest value is 2, the second smallest value is 5.\nExample 2:\nInput: root = [2,2,2]\nOutput: -1\nExplanation: The smallest value is 2, but there isn't any second smallest value.\n \n\nConstraints:\n\nThe number of nodes in the tree is in the range [1, 25].\n1 <= Node.val <= 231 - 1\nroot.val == min(root.left.val, root.right.val) for each internal node of the tree.",
        "solution": "class Solution {\n    int min1;\n    long ans = Long.MAX_VALUE;\n\n    public void dfs(TreeNode root) {\n        if (root != null) {\n            if (min1 < root.val && root.val < ans) {\n                ans = root.val;\n            } else if (min1 == root.val) {\n                dfs(root.left);\n                dfs(root.right);\n            }\n        }\n    }\n    public int findSecondMinimumValue(TreeNode root) {\n        min1 = root.val;\n        dfs(root);\n        return ans < Long.MAX_VALUE ? (int) ans : -1;\n    }\n}",
        "explanation": "Intuition and Algorithm\n\nLet min1 = root.val. When traversing the tree at some node, node, if node.val > min1, we know all values in the subtree at node are at least node.val, so there cannot be a better candidate for the second minimum in this subtree. Thus, we do not need to search this subtree.\n\nAlso, as we only care about the second minimum ans, we do not need to record any values that are larger than our current candidate for the second minimum, so unlike Approach #1, we can skip maintaining a Set of values(uniques) entirely.\nComplexity Analysis\n\nTime Complexity: O(N), where N is the total number of nodes in the given tree. We visit each node at most once.\n\nSpace Complexity: O(N). The information stored in ans and min1 is O(1), but our depth-first search may store up to O(h)=O(N) information in the call stack, where h is the height of the tree."
    },
    {
        "question_id": "2086ccff-8798-470e-b7d9-252cbfadda6d",
        "title": "Climbing Stairs",
        "difficulty": "Easy",
        "category": "Math Dynamic Programming Memoization",
        "question_text": "You are climbing a staircase. It takes n steps to reach the top.\n\nEach time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?\n\n \n\nExample 1:\n\nInput: n = 2\nOutput: 2\nExplanation: There are two ways to climb to the top.\n1. 1 step + 1 step\n2. 2 steps\nExample 2:\n\nInput: n = 3\nOutput: 3\nExplanation: There are three ways to climb to the top.\n1. 1 step + 1 step + 1 step\n2. 1 step + 2 steps\n3. 2 steps + 1 step\n \n\nConstraints:\n\n1 <= n <= 45",
        "solution": "class Solution {\npublic:\n    int climbStairs(int n) {\n        if (n == 0 || n == 1) {\n            return 1;\n        }\n        int prev = 1, curr = 1;\n        for (int i = 2; i <= n; i++) {\n            int temp = curr;\n            curr = prev + curr;\n            prev = temp;\n        }\n        return curr;\n    }\n};",
        "explanation": "The space-optimized solution further reduces the space complexity by using only two variables (prev and curr) instead of an entire DP table. It initializes prev and curr to 1 since there is only one way to reach the base cases (0 and 1 steps). Then, in each iteration, it updates prev and curr by shifting their values. curr becomes the sum of the previous two values, and prev stores the previous value of curr."
    },
    {
        "question_id": "bb327cee-54a1-4d9a-bdbb-4b5bbe1cd69f",
        "title": "Frog Jump",
        "difficulty": "Hard",
        "category": "Array Dynamic Programming",
        "question_text": "A frog is crossing a river. The river is divided into some number of units, and at each unit, there may or may not exist a stone. The frog can jump on a stone, but it must not jump into the water.\n\nGiven a list of stones positions (in units) in sorted ascending order, determine if the frog can cross the river by landing on the last stone. Initially, the frog is on the first stone and assumes the first jump must be 1 unit.\n\nIf the frog's last jump was k units, its next jump must be either k - 1, k, or k + 1 units. The frog can only jump in the forward direction.\n\n \n\nExample 1:\n\nInput: stones = [0,1,3,5,6,8,12,17]\nOutput: true\nExplanation: The frog can jump to the last stone by jumping 1 unit to the 2nd stone, then 2 units to the 3rd stone, then 2 units to the 4th stone, then 3 units to the 6th stone, 4 units to the 7th stone, and 5 units to the 8th stone.\nExample 2:\n\nInput: stones = [0,1,2,3,4,8,9,11]\nOutput: false\nExplanation: There is no way to jump to the last stone as the gap between the 5th and 6th stone is too large.\n \n\nConstraints:\n\n2 <= stones.length <= 2000\n0 <= stones[i] <= 231 - 1\nstones[0] == 0\nstones is sorted in a strictly increasing order.",
        "solution": "class Solution {\n    public boolean canCross(int[] stones) {\n        int N = stones.length;\n        boolean[][] dp = new boolean[N][N + 1];\n        dp[0][1] = true;\n        \n        for(int i = 1; i < N; ++i){\n            for(int j = 0; j < i; ++j){\n                int diff = stones[i] - stones[j];\n                if(diff < 0 || diff > N || !dp[j][diff]) continue;\n                dp[i][diff] = true;\n                if(diff - 1 >= 0) dp[i][diff - 1] = true;\n                if(diff + 1 <= N) dp[i][diff + 1] = true;\n                if(i == N - 1) return true;\n            }\n        }\n\n        return false;\n    }\n}",
        "explanation": "+----+    +----+        +----+     +----+       \nstone:          | S1 |    | S2 |        | S3 |     | S4 | \n            ____|____|____|____|________|____|_____|____|____________\n           ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ \nposition:\"         0         1             3          5             \"        \n\njump size:         1     [0, 1, 2]     [1, 2, 3]\n\n// Suppose we want to know if the frog can reach stone 2 (S2),\n// and we know the frog must come from S1, \n// dist(S1->S2) = 1 - 0 = 1, and we already know the frog is able to make a jump of size 1 at S1.\n// Hence, the frog is able to reach S2, and the next jump would be 0, 1 or 2 units.\n\n\n// Then, we want to know if the frog can reach stone 3 (S3),\n// we know the frog must be at either S1 or S2 before reaching S3,\n\n// If the frog comes from S1, then \n// we know dist(S1->S3) = 3 - 0 = 3, and we know frog couldn't make a jump of size 3 at S1.\n// So it is not possible the frog can jump from S1 to S3.\n\n// If the frog comes from S2, then\n// we know dist(S2->S3) = 3 - 1 = 2, and we know frog could make a jump of size 2 at S2.\n// Hence, the frog is able to reach S3, and the next jump would be 1, 2 or 3 units.\n\n// If we repeat doing this for the rest stones, we'll end with something like below:\nExapme 1:\n            \nindex:        0   1   2   3   4   5   6   7 \n            +---+---+---+---+---+---+---+---+\nstone pos:  | 0 | 1 | 3 | 5 | 6 | 8 | 12| 17|\n            +---+---+---+---+---+---+---+---+\nk:          | 1 | 0 | 1 | 1 | 0 | 1 | 3 | 5 |\n            |   | 1 | 2 | 2 | 1 | 2 | 4 | 6 |\n            |   | 2 | 3 | 3 | 2 | 3 | 5 | 7 |\n            |   |   |   |   | 3 | 4 |   |   |\n            |   |   |   |   | 4 |   |   |   |\n            |   |   |   |   |   |   |   |   |\n\n// Sub-problem and state:\nlet dp(i) denote a set containing all next jump size at stone i\n\n// Recurrence relation:\nfor any j < i,\ndist = stones[i] - stones[j];\nif dist is in dp(j):\n    put dist - 1, dist, dist + 1 into dp(i). \n\n// Now lets make this approach more efficient.\n// BECAUSE \n// 1. The number of stones is ≥ 2 and is < 1,100. \n// 2. The frog is on the first stone and assume the first jump must be 1 unit.\n// 3. If the frog's last jump was k units, then its next jump must be either k - 1, k, or k + 1 units,\n\n// The maximum jump size the frog can make at each stone if possible is shown as followings: \n// stone:      0, 1, 2, 3, 4, 5\n// jump size:  1, 2, 3, 4, 5, 6 (suppose frog made jump with size k + 1 at each stone)\n\n// So instead of creating a HashSet for lookup for each stone, \n// we can create a boolean array with size of N + 1 (N is the number of stones),\n// Like in the given example, at stone 2 the next jump could be 1, 2, 3, \n// we can use a bool array to represent this like\n// index:    0  1  2  3  4  5  6  7  ...\n//          [0, 1, 1, 1, 0, 0, 0, 0, ...]\n// index is jump size, boolean value represents if the frog can make this jump.\n\n// Then, the 2D array will be something like below.\n\nindex:        0   1   2   3   4   5   6   7 \n            +---+---+---+---+---+---+---+---+\nstone pos:  | 0 | 1 | 3 | 5 | 6 | 8 | 12| 17|\n            +---+---+---+---+---+---+---+---+\nk:        0 | 0 | 1 | 0 | 0 | 1 | 0 | 0 | 0 |\n          1 | 1 | 1 | 1 | 1 | 1 | 1 | 0 | 0 |\n          2 | 0 | 1 | 1 | 1 | 1 | 1 | 0 | 0 |\n          3 | 0 | 0 | 1 | 1 | 1 | 1 | 1 | 0 |\n          4 | 0 | 0 | 0 | 0 | 1 | 1 | 1 | 0 |\n          5 | 0 | 0 | 0 | 0 | 0 | 0 | 1 | 1 |\n          6 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 1 |\n          7 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 1 |\n\n// Sub-problem and state:\nlet dp[i][j] denote at stone i, the frog can or cannot make jump of size j\n\n// Recurrence relation:\nfor any j < i,\ndist = stones[i] - stones[j];\nif dp[j][dist]:\n    dp[i][dist - 1] = ture\n    dp[i][dist] = ture\n    dp[i][dist + 1] = ture"
    },
    {
        "question_id": "2bb29db1-1d04-4270-992a-73e7fb43089e",
        "title": "Can I Win",
        "difficulty": "Medium",
        "category": "Math Dynamic Programming Bit Manipulation Memoization Game Theory Bitmask",
        "question_text": "In the \"100 game\" two players take turns adding, to a running total, any integer from 1 to 10. The player who first causes the running total to reach or exceed 100 wins.\n\nWhat if we change the game so that players cannot re-use integers?\n\nFor example, two players might take turns drawing from a common pool of numbers from 1 to 15 without replacement until they reach a total >= 100.\n\nGiven two integers maxChoosableInteger and desiredTotal, return true if the first player to move can force a win, otherwise, return false. Assume both players play optimally.\n\n \n\nExample 1:\n\nInput: maxChoosableInteger = 10, desiredTotal = 11\nOutput: false\nExplanation:\nNo matter which integer the first player choose, the first player will lose.\nThe first player can choose an integer from 1 up to 10.\nIf the first player choose 1, the second player can only choose integers from 2 up to 10.\nThe second player will win by choosing 10 and get a total = 11, which is >= desiredTotal.\nSame with other integers chosen by the first player, the second player will always win.\nExample 2:\n\nInput: maxChoosableInteger = 10, desiredTotal = 0\nOutput: true\nExample 3:\n\nInput: maxChoosableInteger = 10, desiredTotal = 1\nOutput: true\n \n\nConstraints:\n\n1 <= maxChoosableInteger <= 20\n0 <= desiredTotal <= 300",
        "solution": "public class Solution {\n    Map<Integer, Boolean> map;\n    boolean[] used;\n    public boolean canIWin(int maxChoosableInteger, int desiredTotal) {\n        int sum = (1+maxChoosableInteger)*maxChoosableInteger/2;\n        if(sum < desiredTotal) return false;\n        if(desiredTotal <= 0) return true;\n        \n        map = new HashMap();\n        used = new boolean[maxChoosableInteger+1];\n        return helper(desiredTotal);\n    }\n    \n    public boolean helper(int desiredTotal){\n        if(desiredTotal <= 0) return false;\n        int key = format(used);\n        if(!map.containsKey(key)){\n    // try every unchosen number as next step\n            for(int i=1; i<used.length; i++){\n                if(!used[i]){\n                    used[i] = true;\n     // check whether this lead to a win (i.e. the other player lose)\n                    if(!helper(desiredTotal-i)){\n                        map.put(key, true);\n                        used[i] = false;\n                        return true;\n                    }\n                    used[i] = false;\n                }\n            }\n            map.put(key, false);\n        }\n        return map.get(key);\n    }\n   \n// transfer boolean[] to an Integer \n    public int format(boolean[] used){\n        int num = 0;\n        for(boolean b: used){\n            num <<= 1;\n            if(b) num |= 1;\n        }\n        return num;\n    }\n}",
        "explanation": "After solving several \"Game Playing\" questions in leetcode, I find them to be pretty similar. Most of them can be solved using the top-down DP approach, which \"brute-forcely\" simulates every possible state of the game.\n\nThe key part for the top-down dp strategy is that we need to avoid repeatedly solving sub-problems. Instead, we should use some strategy to \"remember\" the outcome of sub-problems. Then when we see them again, we instantly know their result. By doing this, we can always reduce time complexity from exponential to polynomial.\n(EDIT: Thanks for @billbirdh for pointing out the mistake here. For this problem, by applying the memo, we at most compute for every subproblem once, and there are O(2^n) subproblems, so the complexity is O(2^n) after memorization. (Without memo, time complexity should be like O(n!))\n\nFor this question, the key part is: what is the state of the game? Intuitively, to uniquely determine the result of any state, we need to know:\n\nThe unchosen numbers\nThe remaining desiredTotal to reach\nA second thought reveals that 1) and 2) are actually related because we can always get the 2) by deducting the sum of chosen numbers from original desiredTotal.\n\nThen the problem becomes how to describe the state using 1).\n\nIn my solution, I use a boolean array to denote which numbers have been chosen, and then a question comes to mind, if we want to use a Hashmap to remember the outcome of sub-problems, can we just use Map<boolean[], Boolean> ? Obviously we cannot, because the if we use boolean[] as a key, the reference to boolean[] won't reveal the actual content in boolean[].\n\nSince in the problem statement, it says maxChoosableInteger will not be larger than 20, which means the length of our boolean[] array will be less than 20. Then we can use an Integer to represent this boolean[] array. How?\n\nSay the boolean[] is {false, false, true, true, false}, then we can transfer it to an Integer with binary representation as 00110. Since Integer is a perfect choice to be the key of HashMap, then we now can \"memorize\" the sub-problems using Map<Integer, Boolean>.\n\nThe rest part of the solution is just simulating the game process using the top-down dp."
    },
    {
        "question_id": "8667341d-9e33-4a48-ac92-344df5887929",
        "title": "Poor Pigs",
        "difficulty": "Hard",
        "category": "Math Dynamic Programming Combinatorics",
        "question_text": "There are buckets buckets of liquid, where exactly one of the buckets is poisonous. To figure out which one is poisonous, you feed some number of (poor) pigs the liquid to see whether they will die or not. Unfortunately, you only have minutesToTest minutes to determine which bucket is poisonous.\n\nYou can feed the pigs according to these steps:\n\nChoose some live pigs to feed.\nFor each pig, choose which buckets to feed it. The pig will consume all the chosen buckets simultaneously and will take no time. Each pig can feed from any number of buckets, and each bucket can be fed from by any number of pigs.\nWait for minutesToDie minutes. You may not feed any other pigs during this time.\nAfter minutesToDie minutes have passed, any pigs that have been fed the poisonous bucket will die, and all others will survive.\nRepeat this process until you run out of time.\nGiven buckets, minutesToDie, and minutesToTest, return the minimum number of pigs needed to figure out which bucket is poisonous within the allotted time.\n\n \n\nExample 1:\n\nInput: buckets = 4, minutesToDie = 15, minutesToTest = 15\nOutput: 2\nExplanation: We can determine the poisonous bucket as follows:\nAt time 0, feed the first pig buckets 1 and 2, and feed the second pig buckets 2 and 3.\nAt time 15, there are 4 possible outcomes:\n- If only the first pig dies, then bucket 1 must be poisonous.\n- If only the second pig dies, then bucket 3 must be poisonous.\n- If both pigs die, then bucket 2 must be poisonous.\n- If neither pig dies, then bucket 4 must be poisonous.\nExample 2:\n\nInput: buckets = 4, minutesToDie = 15, minutesToTest = 30\nOutput: 2\nExplanation: We can determine the poisonous bucket as follows:\nAt time 0, feed the first pig bucket 1, and feed the second pig bucket 2.\nAt time 15, there are 2 possible outcomes:\n- If either pig dies, then the poisonous bucket is the one it was fed.\n- If neither pig dies, then feed the first pig bucket 3, and feed the second pig bucket 4.\nAt time 30, one of the two pigs must die, and the poisonous bucket is the one it was fed.\n \n\nConstraints:\n\n1 <= buckets <= 1000\n1 <= minutesToDie <= minutesToTest <= 100",
        "solution": "class Solution {\npublic:\n\nint poorPigs(int buckets, int poisonTime, int totalTime) {\n    return ceil(log(buckets) / log(totalTime / poisonTime + 1));\n}\n};",
        "explanation": "This question is based on combinatrics. \n\nLets assume that we have p pigs which can give us the accurate result. Now we have\ntotal Round of test = (timetoTest/TimetoDie) ie. T tests. \n\nSo for each T test there can be T+1  outcomes that is it can die in 1st or 2nd or Tth oit it means the T cases and the last case is it won't die! So total T+1 Outcomes are possible.\n\nNow for each pig we have to go for T+1 outcomes i.e\n(T+1)*(T+1)........*(T+1).\n\nSo T+1 tests rounds are there so for all p pigs the total combination will be (T+1) to the power p i.e (T+1)^p. Now** this total combination should be greater than or equal to N.**\n\nHence  the condition for the answer is going to be \n(T+1)^p >= N\nTaking log on both sides we will get the required answee\np >= log(N)/ log(T+1);\nand hence ceil function is used in the return."
    },
    {
        "question_id": "ced5925e-fdd0-4970-860f-7d05bb817ec5",
        "title": "Cat and Mouse",
        "difficulty": "Hard",
        "category": "Math Dynamic Programming Graph Topological Sort Memoization Game Theory",
        "question_text": "A game on an undirected graph is played by two players, Mouse and Cat, who alternate turns.\n\nThe graph is given as follows: graph[a] is a list of all nodes b such that ab is an edge of the graph.\n\nThe mouse starts at node 1 and goes first, the cat starts at node 2 and goes second, and there is a hole at node 0.\n\nDuring each player's turn, they must travel along one edge of the graph that meets where they are.  For example, if the Mouse is at node 1, it must travel to any node in graph[1].\n\nAdditionally, it is not allowed for the Cat to travel to the Hole (node 0).\n\nThen, the game can end in three ways:\n\nIf ever the Cat occupies the same node as the Mouse, the Cat wins.\nIf ever the Mouse reaches the Hole, the Mouse wins.\nIf ever a position is repeated (i.e., the players are in the same position as a previous turn, and it is the same player's turn to move), the game is a draw.\nGiven a graph, and assuming both players play optimally, return\n\n1 if the mouse wins the game,\n2 if the cat wins the game, or\n0 if the game is a draw.\n \n\nExample 1:\nInput: graph = [[2,5],[3],[0,4,5],[1,4,5],[2,3],[0,2,3]]\nOutput: 0\nExample 2:\n\nInput: graph = [[1,3],[0],[3],[0,2]]\nOutput: 1\n \n\nConstraints:\n\n3 <= graph.length <= 50\n1 <= graph[i].length < graph.length\n0 <= graph[i][j] < graph.length\ngraph[i][j] != i\ngraph[i] is unique.\nThe mouse and the cat can always move.",
        "solution": "class Solution {\n    public int catMouseGame(int[][] graph) {\n        int N = graph.length;\n        final int DRAW = 0, MOUSE = 1, CAT = 2;\n\n        int[][][] color = new int[50][50][3];\n        int[][][] degree = new int[50][50][3];\n\n        // degree[node] : the number of neutral children of this node\n        for (int m = 0; m < N; ++m)\n            for (int c = 0; c < N; ++c) {\n                degree[m][c][1] = graph[m].length;\n                degree[m][c][2] = graph[c].length;\n                for (int x: graph[c]) if (x == 0) {\n                    degree[m][c][2]--;\n                    break;\n                }\n            }\n\n        // enqueued : all nodes that are colored\n        Queue<int[]> queue = new LinkedList();\n        for (int i = 0; i < N; ++i)\n            for (int t = 1; t <= 2; ++t) {\n                color[0][i][t] = MOUSE;\n                queue.add(new int[]{0, i, t, MOUSE});\n                if (i > 0) {\n                    color[i][i][t] = CAT;\n                    queue.add(new int[]{i, i, t, CAT});\n                }\n            }\n\n        // percolate\n        while (!queue.isEmpty()) {\n            // for nodes that are colored :\n            int[] node = queue.remove();\n            int i = node[0], j = node[1], t = node[2], c = node[3];\n            // for every parent of this node i, j, t :\n            for (int[] parent: parents(graph, i, j, t)) {\n                int i2 = parent[0], j2 = parent[1], t2 = parent[2];\n                // if this parent is not colored :\n                if (color[i2][j2][t2] == DRAW) {\n                    // if the parent can make a winning move (ie. mouse to MOUSE), do so\n                    if (t2 == c) {\n                        color[i2][j2][t2] = c;\n                        queue.add(new int[]{i2, j2, t2, c});\n                    } else {\n                        // else, this parent has degree[parent]--, and enqueue\n                        // if all children of this parent are colored as losing moves\n                        degree[i2][j2][t2]--;\n                        if (degree[i2][j2][t2] == 0) {\n                            color[i2][j2][t2] = 3 - t2;\n                            queue.add(new int[]{i2, j2, t2, 3 - t2});\n                        }\n                    }\n                }\n            }\n        }\n\n        return color[1][2][1];\n    }\n\n    // What nodes could play their turn to\n    // arrive at node (m, c, t) ?\n    public List<int[]> parents(int[][] graph, int m, int c, int t) {\n        List<int[]> ans = new ArrayList();\n        if (t == 2) {\n            for (int m2: graph[m])\n                ans.add(new int[]{m2, c, 3-t});\n        } else {\n            for (int c2: graph[c]) if (c2 > 0)\n                ans.add(new int[]{m, c2, 3-t});\n        }\n        return ans;\n    }\n}",
        "explanation": "Intuition\n\nThe state of the game can be represented as (m, c, t) where m is the location of the mouse, c is the location of the cat, and t is 1 if it is the mouse's move, else 2. Let's call these states nodes. These states form a directed graph: the player whose turn it is has various moves which can be considered as outgoing edges from this node to other nodes.\n\nSome of these nodes are already resolved: if the mouse is at the hole (m = 0), then the mouse wins; if the cat is where the mouse is (c = m), then the cat wins. Let's say that nodes will either be colored MOUSE, CAT, or DRAW depending on which player is assured victory.\n\nAs in a standard minimax algorithm, the Mouse player will prefer MOUSE nodes first, DRAW nodes second, and CAT nodes last, and the Cat player prefers these nodes in the opposite order.\n\nAlgorithm\n\nWe will color each node marked DRAW according to the following rule. (We'll suppose the node has node.turn = Mouse: the other case is similar.)\n\n(\"Immediate coloring\"): If there is a child that is colored MOUSE, then this node will also be colored MOUSE.\n\n(\"Eventual coloring\"): If all children are colored CAT, then this node will also be colored CAT.\n\nWe will repeatedly do this kind of coloring until no node satisfies the above conditions. To perform this coloring efficiently, we will use a queue and perform a bottom-up percolation:\n\nEnqueue any node initially colored (because the Mouse is at the Hole, or the Cat is at the Mouse.)\n\nFor every node in the queue, for each parent of that node:\n\nDo an immediate coloring of parent if you can.\n\nIf you can't, then decrement the side-count of the number of children marked DRAW. If it becomes zero, then do an \"eventual coloring\" of this parent.\n\nAll parents that were colored in this manner get enqueued to the queue.\n\nProof of Correctness\n\nOur proof is similar to a proof that minimax works.\n\nSay we cannot color any nodes any more, and say from any node colored CAT or MOUSE we need at most K moves to win. If say, some node marked DRAW is actually a win for Mouse, it must have been with >K moves. Then, a path along optimal play (that tries to prolong the loss as long as possible) must arrive at a node colored MOUSE (as eventually the Mouse reaches the Hole.) Thus, there must have been some transition DRAW→MOUSE along this path.\n\nIf this transition occurred at a node with node.turn = Mouse, then it breaks our immediate coloring rule. If it occured with node.turn = Cat, and all children of node have color MOUSE, then it breaks our eventual coloring rule. If some child has color CAT, then it breaks our immediate coloring rule. Thus, in this case node will have some child with DRAW, which breaks our optimal play assumption, as moving to this child ends the game in >K moves, whereas moving to the colored neighbor ends the game in ≤K moves."
    },
    {
        "question_id": "9785bea6-e2d3-4d30-8e14-44b1bea559f7",
        "title": "Sum of Subsequence Widths",
        "difficulty": "Hard",
        "category": "Array Math Sorting",
        "question_text": "The width of a sequence is the difference between the maximum and minimum elements in the sequence.\n\nGiven an array of integers nums, return the sum of the widths of all the non-empty subsequences of nums. Since the answer may be very large, return it modulo 109 + 7.\n\nA subsequence is a sequence that can be derived from an array by deleting some or no elements without changing the order of the remaining elements. For example, [3,6,2,7] is a subsequence of the array [0,3,1,6,2,2,7].\n\n \n\nExample 1:\n\nInput: nums = [2,1,3]\nOutput: 6\nExplanation: The subsequences are [1], [2], [3], [2,1], [2,3], [1,3], [2,1,3].\nThe corresponding widths are 0, 0, 0, 1, 1, 2, 2.\nThe sum of these widths is 6.\nExample 2:\n\nInput: nums = [2]\nOutput: 0\n \n\nConstraints:\n\n1 <= nums.length <= 105\n1 <= nums[i] <= 105",
        "solution": "class Solution {\n    public int sumSubseqWidths(int[] A) {\n        int MOD = 1_000_000_007;\n        int N = A.length;\n        Arrays.sort(A);\n\n        long[] pow2 = new long[N];\n        pow2[0] = 1;\n        for (int i = 1; i < N; ++i)\n            pow2[i] = pow2[i-1] * 2 % MOD;\n\n        long ans = 0;\n        for (int i = 0; i < N; ++i)\n            ans = (ans + (pow2[i] - pow2[N-1-i]) * A[i]) % MOD;\n\n        return (int) ans;\n    }\n}",
        "explanation": "Mathematical\nIntuition\n\nLet's try to count the number of subsequences with minimum A[i] and maximum A[j].\n\nAlgorithm\n\nWe can sort the array as it doesn't change the answer. After sorting the array, this allows us to know that the number of subsequences with minimum A[i] and maximum A[j] is 2 \nj−i−1\n . Hence, the desired answer is:\n\nj>i\n∑\n​\n (2 \nj−i−1\n )(A \nj\n​\n −A \ni\n​\n )\n\n=( \ni=0\n∑\nn−2\n​\n  \nj=i+1\n∑\nn−1\n​\n (2 \nj−i−1\n )(A \nj\n​\n ))−( \ni=0\n∑\nn−2\n​\n  \nj=i+1\n∑\nn−1\n​\n (2 \nj−i−1\n )(A \ni\n​\n ))\n\n=((2 \n0\n A \n1\n​\n +2 \n1\n A \n2\n​\n +2 \n2\n A \n3\n​\n +⋯)+(2 \n0\n A \n2\n​\n +2 \n1\n A \n3\n​\n +⋯)+(2 \n0\n A \n3\n​\n +2 \n1\n A \n4\n​\n +⋯)+⋯)\n−( \ni=0\n∑\nn−2\n​\n (2 \n0\n +2 \n1\n +⋯+2 \nN−i−2\n )(A \ni\n​\n ))\n\n=( \nj=1\n∑\nn−1\n​\n (2 \nj\n −1)A \nj\n​\n )−( \ni=0\n∑\nn−2\n​\n (2 \nN−i−1\n −1)A \ni\n​\n )\n\n= \ni=0\n∑\nn−1\n​\n (((2 \ni\n −1)A \ni\n​\n )−((2 \nN−i−1\n −1)A \ni\n​\n ))\n\n= \ni=0\n∑\nn−1\n​\n (2 \ni\n −2 \nN−i−1\n )A \ni\n​"
    },
    {
        "question_id": "317985b4-a757-41da-96a3-0ba8a1e14088",
        "title": "Maximize Sum Of Array After K Negations",
        "difficulty": "Easy",
        "category": "Array Greedy Sorting",
        "question_text": "Given an integer array nums and an integer k, modify the array in the following way:\n\nchoose an index i and replace nums[i] with -nums[i].\nYou should apply this process exactly k times. You may choose the same index i multiple times.\n\nReturn the largest possible sum of the array after modifying it in this way.\n\n \n\nExample 1:\n\nInput: nums = [4,2,3], k = 1\nOutput: 5\nExplanation: Choose index 1 and nums becomes [4,-2,3].\nExample 2:\n\nInput: nums = [3,-1,0,2], k = 3\nOutput: 6\nExplanation: Choose indices (1, 2, 2) and nums becomes [3,1,0,2].\nExample 3:\n\nInput: nums = [2,-3,-1,5,-4], k = 2\nOutput: 13\nExplanation: Choose indices (1, 4) and nums becomes [2,3,-1,5,4].\n \n\nConstraints:\n\n1 <= nums.length <= 104\n-100 <= nums[i] <= 100\n1 <= k <= 104",
        "solution": "class Solution {\npublic:\nlong long getSum(vector<int> negate, vector<int>positive)\n{\n    long long sum =0;\n                for(int i=0;i<negate.size();i++)\n            {\n                sum+=negate[i];\n            }\n        for(int i=0;i<positive.size();i++)\n            {\n                sum+=positive[i];\n            }\n            return sum;\n}\n    int largestSumAfterKNegations(vector<int>& nums, int k) {\n   vector<int>negate;\n   vector<int>positive;\n    for(int i=0;i<nums.size();i++)\n    {\n        if(nums[i]>=0)\n        {\n            positive.push_back(nums[i]);\n        }\n        else{\n            negate.push_back(nums[i]);\n        }\n    }\n    if(negate.size()>k)\n    {\n        sort(negate.begin(), negate.end());\n        for(int i=0;i<k;i++)\n        {\n            negate[i] = abs(negate[i]);\n        }\n        return getSum(negate, positive);\n    } else {\n        for(int i=0;i<negate.size();i++)\n        {\n            negate[i] = abs(negate[i]);\n        }\n        int remainingcount = k-negate.size();\n        if(remainingcount%2==0)\n        {\n            return getSum(negate, positive);\n        } else {\n        int mini = INT_MAX;\n            for(int i=0;i<negate.size();i++)\n            {\n                mini = min(mini, negate[i]);\n            }\n        for(int i=0;i<positive.size();i++)\n            {\n                mini = min(mini, positive[i]);\n            }\ncout<<mini<<endl;\ncout<<getSum(negate, positive)<<endl;\n            return (getSum(negate, positive) - 2*mini);\n        }\n    }\n    }\n};",
        "explanation": "1- sort the numbers in ascending order\n2- flip all the negative numbers, as long as k > 0\n3- find the sum of the new array (with flipped numbers if any) and keep track of the minimum number\n4- Now for the return statement"
    },
    {
        "question_id": "6398fee7-a478-4c9f-a904-d277544a2c4a",
        "title": "Search Suggestions System",
        "difficulty": "Medium",
        "category": "Array String Binary Search Trie Sorting Heap (Priority Queue)",
        "question_text": "You are given an array of strings products and a string searchWord.\n\nDesign a system that suggests at most three product names from products after each character of searchWord is typed. Suggested products should have common prefix with searchWord. If there are more than three products with a common prefix return the three lexicographically minimums products.\n\nReturn a list of lists of the suggested products after each character of searchWord is typed.\n\n \n\nExample 1:\n\nInput: products = [\"mobile\",\"mouse\",\"moneypot\",\"monitor\",\"mousepad\"], searchWord = \"mouse\"\nOutput: [[\"mobile\",\"moneypot\",\"monitor\"],[\"mobile\",\"moneypot\",\"monitor\"],[\"mouse\",\"mousepad\"],[\"mouse\",\"mousepad\"],[\"mouse\",\"mousepad\"]]\nExplanation: products sorted lexicographically = [\"mobile\",\"moneypot\",\"monitor\",\"mouse\",\"mousepad\"].\nAfter typing m and mo all products match and we show user [\"mobile\",\"moneypot\",\"monitor\"].\nAfter typing mou, mous and mouse the system suggests [\"mouse\",\"mousepad\"].\nExample 2:\n\nInput: products = [\"havana\"], searchWord = \"havana\"\nOutput: [[\"havana\"],[\"havana\"],[\"havana\"],[\"havana\"],[\"havana\"],[\"havana\"]]\nExplanation: The only word \"havana\" will be always suggested while typing the search word.\n \n\nConstraints:\n\n1 <= products.length <= 1000\n1 <= products[i].length <= 3000\n1 <= sum(products[i].length) <= 2 * 104\nAll the strings of products are unique.\nproducts[i] consists of lowercase English letters.\n1 <= searchWord.length <= 1000\nsearchWord consists of lowercase English letters.",
        "solution": "// Custom class Trie with function to get 3 words starting with given prefix\nclass Trie\n{\n    // Node definition of a trie\n    struct Node {\n        bool isWord = false;\n        vector<Node *> children{vector<Node *>(26, NULL)};\n    } * Root, *curr;\n\n    // Runs a DFS on trie starting with given prefix and adds all the words in the result, limiting result size to 3\n    void dfsWithPrefix(Node * curr, string & word, vector<string> & result) {\n        if (result.size() == 3)\n            return;\n        if (curr->isWord)\n            result.push_back(word);\n\n        // Run DFS on all possible paths.\n        for (char c = 'a'; c <= 'z'; c++)\n            if (curr->children[c - 'a']) {\n                word += c;\n                dfsWithPrefix(curr->children[c - 'a'], word, result);\n                word.pop_back();\n            }\n    }\n\npublic:\n    Trie() {\n        Root = new Node();\n    }\n    // Inserts the string in trie.\n    void insert(string & s) {\n        // Points curr to the root of trie.\n        curr = Root;\n        for (char &c : s) {\n            if (!curr->children[c - 'a'])\n                curr->children[c - 'a'] = new Node();\n            curr = curr->children[c - 'a'];\n        }\n        // Mark this node as a completed word.\n        curr->isWord = true;\n    }\n    vector<string> getWordsStartingWith(string & prefix) {\n        curr = Root;\n        vector<string> result;\n\n        // Move curr to the end of prefix in its trie representation.\n        for (char &c : prefix) {\n            if (!curr->children[c - 'a'])\n                return result;\n            curr = curr->children[c - 'a'];\n        }\n        dfsWithPrefix(curr, prefix, result);\n        return result;\n    }\n};\nclass Solution {\npublic:\n    vector<vector<string>> suggestedProducts(vector<string> &products,\n                                             string searchWord) {\n        Trie trie=Trie();\n        vector<vector<string>> result;\n\n        // Add all words to trie.\n        for(string &w:products)\n            trie.insert(w);\n        string prefix;\n        for (char &c : searchWord) {\n            prefix += c;\n            result.push_back(trie.getWordsStartingWith(prefix));\n        }\n        return result;\n    }\n};",
        "explanation": "Algorithm\n\nCreate a Trie from the given products input.\nIterate each character of the searchWord adding it to the prefix to search for.\nAfter adding the current character to the prefix traverse the trie pointer to the node representing prefix.\nNow traverse the tree from curr pointer in a preorder fashion and record whenever we encounter a complete word.\nLimit the result to 3 and return dfs once reached this limit.\nAdd the words to the final result."
    },
    {
        "question_id": "b332a4ab-d8d3-4bf3-ad57-812d4f91c42c",
        "title": "Candy",
        "difficulty": "Hard",
        "category": "Array Greedy",
        "question_text": "There are n children standing in a line. Each child is assigned a rating value given in the integer array ratings.\n\nYou are giving candies to these children subjected to the following requirements:\n\nEach child must have at least one candy.\nChildren with a higher rating get more candies than their neighbors.\nReturn the minimum number of candies you need to have to distribute the candies to the children.\n\n \n\nExample 1:\n\nInput: ratings = [1,0,2]\nOutput: 5\nExplanation: You can allocate to the first, second and third child with 2, 1, 2 candies respectively.\nExample 2:\n\nInput: ratings = [1,2,2]\nOutput: 4\nExplanation: You can allocate to the first, second and third child with 1, 2, 1 candies respectively.\nThe third child gets 1 candy because it satisfies the above two conditions.\n \n\nConstraints:\n\nn == ratings.length\n1 <= n <= 2 * 104\n0 <= ratings[i] <= 2 * 104",
        "solution": "class Solution {\npublic:\n    int candy(vector<int>& ratings) {\n        int n = ratings.size();\n        int candy = n, i=1;\n        while(i<n){\n            if(ratings[i] == ratings[i-1]){\n                i++;\n                continue;\n            }\n            \n            //For increasing slope\n            int peak = 0;\n            while(ratings[i] > ratings [i-1]){\n                peak++;\n                candy += peak;\n                i++;\n                if(i == n) return candy;\n            }\n            \n            //For decreasing slope\n            int valley = 0;\n            while(i<n && ratings[i] < ratings[i-1]){\n                valley++;\n                candy += valley;\n                i++;\n            }\n            candy -= min(peak, valley); //Keep only the higher peak\n        }\n        return candy;\n    }\n};",
        "explanation": "Implementation :\n\nSo we take initially n candy for n children. Then we start traversing the rating array from the second element. If we find equal elements we continue to next element as they already have 1 candy.\n\nIf an increasing slop is found (ratings[i] > ratings [i-1]) we increase value of peak and and add the peak value to candy. After each iteration new peak is found and the value is added to candy. In this way we also get the value of minimum height of the peak at the end.\n\nIf a decreasing slope is found (ratings[i] < ratings [i-1]) we calculate the depth of the valley which is in turn the minimum height of the previous peak. In each iteration we increse the valley by 1 and add it to the candy. You can visualise it as 1 candy is added to each of the previous members untill peak or the new peak value is interted at the previous peak and other values are shifted to right by 1 place. We also need to check if it is going out of array if so then return the number of candy.\n\nAfter this we can see we have added the peak value twice in candy once as peak and once as valley. But we need only the max value out of these two so we substract the min(peak, valley) from candy.\n\nAfter that return the candy.\n\nNote : We have considered the sequence increasing -> decreasing as peak should have the max value between the height of left (increasing) side and height of right (decreasing) side. In case of decresing -> increasing we dont need to give special attention as the vallley will always have 1 candy and in our code in this case peak will have 0 value so nothing will be substracted from the candy in the end of iteration."
    },
    {
        "question_id": "9f3fa96c-46ab-4c15-be6e-ed6fc3666864",
        "title": "Largest Number",
        "difficulty": "Medium",
        "category": "Array String Greedy Sorting",
        "question_text": "Given a list of non-negative integers nums, arrange them such that they form the largest number and return it.\n\nSince the result may be very large, so you need to return a string instead of an integer.\n\n \n\nExample 1:\n\nInput: nums = [10,2]\nOutput: \"210\"\nExample 2:\n\nInput: nums = [3,30,34,5,9]\nOutput: \"9534330\"\n \n\nConstraints:\n\n1 <= nums.length <= 100\n0 <= nums[i] <= 109",
        "solution": "class Solution {\npublic:\n    string largestNumber(vector<int>& nums) {\n        // Sort the numbers using Tim Sort\n        timSort(nums);\n        // Concatenate sorted numbers to form the largest number\n        string largestNum;\n        for (int num : nums) {\n            largestNum += to_string(num);\n        }\n        // Handle the case where the largest number is zero\n        return largestNum[0] == '0' ? \"0\" : largestNum;\n    }\n\nprivate:\n    const int RUN = 32;\n\n    void insertionSort(vector<int>& nums, int left, int right) {\n        for (int i = left + 1; i <= right; ++i) {\n            int temp = nums[i];\n            int j = i - 1;\n            while (j >= left && compare(temp, nums[j])) {\n                nums[j + 1] = nums[j];\n                --j;\n            }\n            nums[j + 1] = temp;\n        }\n    }\n\n    void merge(vector<int>& nums, int left, int mid, int right) {\n        vector<int> leftArr(nums.begin() + left, nums.begin() + mid + 1);\n        vector<int> rightArr(nums.begin() + mid + 1, nums.begin() + right + 1);\n\n        int i = 0, j = 0, k = left;\n        while (i < leftArr.size() && j < rightArr.size()) {\n            if (compare(leftArr[i], rightArr[j])) {\n                nums[k++] = leftArr[i++];\n            } else {\n                nums[k++] = rightArr[j++];\n            }\n        }\n        while (i < leftArr.size()) nums[k++] = leftArr[i++];\n        while (j < rightArr.size()) nums[k++] = rightArr[j++];\n    }\n\n    void timSort(vector<int>& nums) {\n        int n = nums.size();\n        // Sort small runs with insertion sort\n        for (int i = 0; i < n; i += RUN) {\n            insertionSort(nums, i, min(i + RUN - 1, n - 1));\n        }\n        // Merge sorted runs\n        for (int size = RUN; size < n; size = 2 * size) {\n            for (int left = 0; left < n; left += 2 * size) {\n                int mid = left + size - 1;\n                int right = min(left + 2 * size - 1, n - 1);\n                if (mid < right) {\n                    merge(nums, left, mid, right);\n                }\n            }\n        }\n    }\n\n    bool compare(int firstNum, int secondNum) {\n        return to_string(firstNum) + to_string(secondNum) >\n               to_string(secondNum) + to_string(firstNum);\n    }\n};",
        "explanation": "Intuition\nTimSort is a sorting algorithm that combines insertion sort and merge sort.\n\nWe start by dividing the list into small segments called runs. Each run is a segment of the list that is sorted independently using insertion sort. Insertion sort is well-suited for this task because it efficiently handles small or already partially sorted segments. For instance, in our example list [3, 30, 34, 5, 9], TimSort first breaks it into runs. Since the list is small, it might treat the entire list as a single run or split it into smaller manageable runs like [3, 30] and [34, 5, 9] [Usually runs are not this small but for the sake of this example lets say its 2].\n\nMinrun is chosen from the range 32 to 64 inclusive, such that the size of the data, divided by minrun, is equal to, or slightly less than, a power of two.\n\nNext, we merge these sorted runs into larger, sorted segments. During the merging phase, we use a custom comparison function to determine the order of numbers based on which concatenated result is larger.\n\nAfter all runs are merged, we get a fully sorted list arranged to form the largest possible number. Finally, we check if the result starts with '0'. If it does, this indicates that all numbers are zeros, so we return \"0\".\n\nConsider the list [3, 30, 34, 5, 9]. TimSort starts by sorting small runs like [3, 30] and [34, 5, 9] using insertion sort. It then merges these runs, comparing concatenated results to determine the correct order. For instance, it would compare \"330\" with \"303\" and place \"3\" before \"30\" because \"330\" is larger. The final merge step sorts the list to [9, 5, 34, 3, 30]. Concatenating these gives us the largest number, \"9534330\".\n\nTimsort aims to optimize the merging process by ensuring that the number of runs is close to a power of two. Merging is most effective when the number of runs is equal to or just under a power of two, while it becomes less efficient when the number of runs exceeds a power of two. To achieve this, Timsort selects the value of RUN so that the total number of runs is close to a power of two.\n\nRUN is chosen within the range of 32 to 64. It is set so that the total size of the data divided by RUN is either equal to or slightly less than a power of two. The method for determining RUN involves taking the six most significant bits of the array size, adding one if any of the remaining bits are set, and using this result for RUN. This approach accommodates all array sizes, including those smaller than 64. For arrays with 63 or fewer elements, RUN is set equal to the array size, effectively reducing Timsort to insertion sort for those smaller arrays.\n\nFun fact: Timsort is highly regarded for its efficiency and stability. It is more advanced compared to older algorithms like bubble sort or insertion sort. Invented by Tim Peters in 2002, it was named after him. Timsort is used in Python sort.\n\nAlgorithm\nSort the nums array using the custom timSort algorithm.\n\ntimSort function:\n\nFor each small run of size RUN (32 elements), call insertionSort to sort the subarrays.\nAfter sorting small runs, iteratively merge them using the merge function until the entire array is sorted.\ninsertionSort function:\n\nIterate through the subarray from left + 1 to right.\nFor each element, store it in a temporary variable temp.\nCompare temp with its previous elements (from right to left) using the compare function:\nIf the comparison returns true (i.e., temp should precede the compared element), shift the previous element to the right.\nInsert temp in its correct position once all comparisons are done.\nmerge function:\n\nSplit the array into two subarrays: leftArr (from left to mid) and rightArr (from mid + 1 to right).\nMerge the two subarrays back into the original array:\nCompare the elements from both subarrays using the compare function.\nInsert the smaller element into the original array and proceed until both subarrays are fully merged.\ncompare function:\n\nConvert the two numbers firstNum and secondNum into strings.\nConcatenate them in both possible orders and return true if the first concatenation results in a larger number.\nOnce nums is sorted, concatenate all elements in nums to form the largestNum string.\n\nIf the first character of largestNum is '0', return \"0\" to handle the case where all numbers are zero.\n\nOtherwise, return largestNum as the final result."
    },
    {
        "question_id": "e9b7df3f-d96e-49e6-8565-69155786ad42",
        "title": "Can Place Flowers",
        "difficulty": "Easy",
        "category": "Array Greedy",
        "question_text": "You have a long flowerbed in which some of the plots are planted, and some are not. However, flowers cannot be planted in adjacent plots.\n\nGiven an integer array flowerbed containing 0's and 1's, where 0 means empty and 1 means not empty, and an integer n, return true if n new flowers can be planted in the flowerbed without violating the no-adjacent-flowers rule and false otherwise.\n\n \n\nExample 1:\n\nInput: flowerbed = [1,0,0,0,1], n = 1\nOutput: true\nExample 2:\n\nInput: flowerbed = [1,0,0,0,1], n = 2\nOutput: false\n \n\nConstraints:\n\n1 <= flowerbed.length <= 2 * 104\nflowerbed[i] is 0 or 1.\nThere are no two adjacent flowers in flowerbed.\n0 <= n <= flowerbed.length",
        "solution": "class Solution {\npublic:\n    bool canPlaceFlowers(vector<int>& flowerbed, int n) {\n        int count = 0;\n        for (int i = 0; i < flowerbed.size(); i++) {\n            // Check if the current plot is empty.\n            if (flowerbed[i] == 0) {\n                // Check if the left and right plots are empty.\n                bool emptyLeftPlot = (i == 0) || (flowerbed[i - 1] == 0);\n                bool emptyRightPlot = (i == flowerbed.size() - 1) || (flowerbed[i + 1] == 0);\n                \n                // If both plots are empty, we can plant a flower here.\n                if (emptyLeftPlot && emptyRightPlot) {\n                    flowerbed[i] = 1;\n                    count++;\n                    if (count >= n) {\n                        return true;\n                    }\n                }\n            }\n        }\n        return count >= n;\n    }\n};",
        "explanation": "Algorithm\n\nInstead of finding the maximum value of count that can be obtained, as done in the last approach, we can stop the process of checking the positions for planting the flowers as soon as count becomes equal to n. Doing this leads to an optimization of the first approach. If count never becomes equal to n, n flowers can't be planted at the empty positions.\nComplexity Analysis\n\nTime complexity: O(n). A single scan of the flowerbed array of size n is done.\n\nSpace complexity: O(1). Constant extra space is used."
    },
    {
        "question_id": "b0d9108c-166a-45c9-bfcc-1fc048a4e05e",
        "title": "Search a 2D Matrix II",
        "difficulty": "Medium",
        "category": "Array Binary Search Divide and Conquer Matrix",
        "question_text": "Write an efficient algorithm that searches for a value target in an m x n integer matrix matrix. This matrix has the following properties:\n\nIntegers in each row are sorted in ascending from left to right.\nIntegers in each column are sorted in ascending from top to bottom.\n \n\nExample 1:\nInput: matrix = [[1,4,7,11,15],[2,5,8,12,19],[3,6,9,16,22],[10,13,14,17,24],[18,21,23,26,30]], target = 5\nOutput: true\nExample 2:\nInput: matrix = [[1,4,7,11,15],[2,5,8,12,19],[3,6,9,16,22],[10,13,14,17,24],[18,21,23,26,30]], target = 20\nOutput: false\n \n\nConstraints:\n\nm == matrix.length\nn == matrix[i].length\n1 <= n, m <= 300\n-109 <= matrix[i][j] <= 109\nAll the integers in each row are sorted in ascending order.\nAll the integers in each column are sorted in ascending order.\n-109 <= target <= 109",
        "solution": "class Solution(object):\n    def searchMatrix(self, matrix, target):\n        r = 0\n        c = len(matrix[0]) - 1\n        while r < len(matrix) and c >= 0:\n            if matrix[r][c] == target:\n                return True\n            elif matrix[r][c] > target:\n                c -= 1\n            else:\n                r += 1\n        return False",
        "explanation": "Intuition\nThis problem can be approached with a clever trick: leverage the matrix's sorted property (rows and columns are sorted). By starting at the top-right, we can reduce our search space in each step.\nStart at the top-right cell.\nIf the current value is greater than the target, move left.\nIf less, move down.\nRepeat until found or bounds exceeded.\nThis avoids binary search and leverages the matrix structure for an efficient solution.\n\nComplexity\nTime Complexity:\n\n( O(n + m) ) — at most one pass down and one leftward pass.\nSpace Complexity:\n\n( O(1) ) — only pointers are used."
    },
    {
        "question_id": "605406ba-8ac4-4402-8863-5e995987b51b",
        "title": "Nth Digit",
        "difficulty": "Medium",
        "category": "Math Binary Search",
        "question_text": "Given an integer n, return the nth digit of the infinite integer sequence [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, ...].\n\n \n\nExample 1:\n\nInput: n = 3\nOutput: 3\nExample 2:\n\nInput: n = 11\nOutput: 0\nExplanation: The 11th digit of the sequence 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, ... is a 0, which is part of the number 10.\n \n\nConstraints:\n\n1 <= n <= 231 - 1",
        "solution": "public int findNthDigit(int n) {\n\t\tint len = 1;\n\t\tlong count = 9;\n\t\tint start = 1;\n\n\t\twhile (n > len * count) {\n\t\t\tn -= len * count;\n\t\t\tlen += 1;\n\t\t\tcount *= 10;\n\t\t\tstart *= 10;\n\t\t}\n\n\t\tstart += (n - 1) / len;\n\t\tString s = Integer.toString(start);\n\t\treturn Character.getNumericValue(s.charAt((n - 1) % len));\n\t}",
        "explanation": "Straight forward way to solve the problem in 3 steps:\n\nfind the length of the number where the nth digit is from\nfind the actual number where the nth digit is from\nfind the nth digit and return"
    },
    {
        "question_id": "7a3783b1-b5b0-439a-ae34-71b96bed3398",
        "title": "K-diff Pairs in an Array",
        "difficulty": "Medium",
        "category": "Array Hash Table Two Pointers Binary Search Sorting",
        "question_text": "Given an array of integers nums and an integer k, return the number of unique k-diff pairs in the array.\n\nA k-diff pair is an integer pair (nums[i], nums[j]), where the following are true:\n\n0 <= i, j < nums.length\ni != j\n|nums[i] - nums[j]| == k\nNotice that |val| denotes the absolute value of val.\n\n \n\nExample 1:\n\nInput: nums = [3,1,4,1,5], k = 2\nOutput: 2\nExplanation: There are two 2-diff pairs in the array, (1, 3) and (3, 5).\nAlthough we have two 1s in the input, we should only return the number of unique pairs.\nExample 2:\n\nInput: nums = [1,2,3,4,5], k = 1\nOutput: 4\nExplanation: There are four 1-diff pairs in the array, (1, 2), (2, 3), (3, 4) and (4, 5).\nExample 3:\n\nInput: nums = [1,3,1,5,4], k = 0\nOutput: 1\nExplanation: There is one 0-diff pair in the array, (1, 1).\n \n\nConstraints:\n\n1 <= nums.length <= 104\n-107 <= nums[i] <= 107\n0 <= k <= 107",
        "solution": "class Solution(object):\n    def findPairs(self, nums, k):\n        if k < 0:\n            return 0\n        count = 0\n        num_counts = {}\n        for num in nums:\n            num_counts[num] = num_counts.get(num, 0) + 1\n        for num in num_counts:\n            if k == 0:\n                if num_counts[num] >= 2:\n                    count += 1\n            else:\n                if num + k in num_counts:\n                    count += 1\n        return count",
        "explanation": "Intuition\nWe want to find unique pairs (i, j) where the difference between nums[i] and nums[j] is exactly k. The trick is to use a hashmap to track occurrences and avoid duplicates.\nApproach\nIf k < 0, return 0 — absolute difference can't be negative.\nCount the frequency of each number in the array using a hashmap.\nFor each number:\nIf k == 0, we’re looking for duplicates (frequency ≥ 2).\nIf k > 0, we check if num + k exists in the map.\nCount how many such cases exist.\nThis approach avoids sorting and handles duplicates smartly.\n\nComplexity\nTime Complexity: ( O(n) ) — one pass to build the map, one to count pairs.\nSpace Complexity: ( O(n) ) — for the hashmap."
    },
    {
        "question_id": "4240a5ae-7c65-4d0e-a650-2f487255b99b",
        "title": "Binary Search",
        "difficulty": "Easy",
        "category": "Array Binary Search",
        "question_text": "Given an array of integers nums which is sorted in ascending order, and an integer target, write a function to search target in nums. If target exists, then return its index. Otherwise, return -1.\n\nYou must write an algorithm with O(log n) runtime complexity.\n\n \n\nExample 1:\n\nInput: nums = [-1,0,3,5,9,12], target = 9\nOutput: 4\nExplanation: 9 exists in nums and its index is 4\nExample 2:\n\nInput: nums = [-1,0,3,5,9,12], target = 2\nOutput: -1\nExplanation: 2 does not exist in nums so return -1\n \n\nConstraints:\n\n1 <= nums.length <= 104\n-104 < nums[i], target < 104\nAll the integers in nums are unique.\nnums is sorted in ascending order.",
        "solution": "class Solution {\npublic:\n    int search(vector<int>& nums, int target) {\n        // Find the insertion position `idx`.\n        int idx = upper_bound(nums.begin(), nums.end(), target) - nums.begin();\n\n        if (idx > 0 && nums[idx - 1] == target) {\n            return idx - 1;\n        } else {\n            return -1;\n        }    \n    }\n};",
        "explanation": "Intuition\nWe have implemented various templates of binary search, now let's quickly go through the last approach that uses built-in functions. C++ provides the <algorithm> library that defines functions for binary searching, Python provides bisect module which also supports binary search functions. If we are solving some standard problems that do not require a lot of customization, it's feasible to rely on these built-in tools to save time.\n\nNote that upper_bound and bisect.bisect_right look for the rightmost insertion position and bring the same result as approach 2, while lower_bound and bisect.bisect_left look for the leftmost insertion position and end up with the same result as approach 3. Once we find the insertion position, check if the value at the corresponding position equals target.\n\nHere we implement the method that uses upper_bound or bisect.bisect_right and leave another half as a practice!\n\n\nAlgorithm\nUse built-in tools to locate the rightmost insertion position idx.\nIf idx > 0 and nums[idx - 1] = target, return idx -1. Otherwise, return -1.\nComplexity Analysis\nLet n be the size of the input array nums.\n\nTime complexity: O(logn)\n\nThe time complexity of the built-in binary search is O(logn).\nSpace complexity: O(1)\n\nThe built-in binary search only takes O(1) space."
    },
    {
        "question_id": "db899de6-78c4-4ef6-a4c6-65670e9cb128",
        "title": "Sum Root to Leaf Numbers",
        "difficulty": "Medium",
        "category": "Tree Depth-First Search Binary Tree",
        "question_text": "You are given the root of a binary tree containing digits from 0 to 9 only.\n\nEach root-to-leaf path in the tree represents a number.\n\nFor example, the root-to-leaf path 1 -> 2 -> 3 represents the number 123.\nReturn the total sum of all root-to-leaf numbers. Test cases are generated so that the answer will fit in a 32-bit integer.\n\nA leaf node is a node with no children.\n\n \n\nExample 1:\nInput: root = [1,2,3]\nOutput: 25\nExplanation:\nThe root-to-leaf path 1->2 represents the number 12.\nThe root-to-leaf path 1->3 represents the number 13.\nTherefore, sum = 12 + 13 = 25.\nExample 2:\nInput: root = [4,9,0,5,1]\nOutput: 1026\nExplanation:\nThe root-to-leaf path 4->9->5 represents the number 495.\nThe root-to-leaf path 4->9->1 represents the number 491.\nThe root-to-leaf path 4->0 represents the number 40.\nTherefore, sum = 495 + 491 + 40 = 1026.\n \n\nConstraints:\n\nThe number of nodes in the tree is in the range [1, 1000].\n0 <= Node.val <= 9\nThe depth of the tree will not exceed 10.",
        "solution": "/**\n * Go language\n * Definition for a binary tree node.\n * type TreeNode struct {\n *     Val int\n *     Left *TreeNode\n *     Right *TreeNode\n * }\n */\nfunc sumNumbers(root *TreeNode) int {\n    sum, num := 0, 0\n    calculateSum(root, &sum, &num)\n    return sum\n}\n\nfunc calculateSum(root *TreeNode, sum *int, num *int) {\n    // if root nil, return\n    if root == nil { return }\n\n    // else multiply num*10 and send to next level\n    *num = (*num * 10) + root.Val\n\n    // if both left and right nil then add this num in sum\n    if root.Left == nil && root.Right == nil {\n        *sum += *num\n    }\n\n    // else traverse tree left and right\n    calculateSum(root.Left, sum, num)\n    calculateSum(root.Right, sum, num)\n\n    // when the level ends, divide num by 10 before going to upper level\n    *num = *num / 10\n}",
        "explanation": "Approach\nSimplest DFS traversal\n\nComplexity\nTime complexity:\n0 ms Beats 100.00%\n\nSpace complexity:\n4.20 MB Beats 84.73%"
    },
    {
        "question_id": "fb6bd9d8-caad-4c05-9d6a-c6c33f448e8a",
        "title": "Kth Smallest Element in a BST",
        "difficulty": "Medium",
        "category": "Tree Depth-First Search Binary Search Tree Binary Tree",
        "question_text": "Given the root of a binary search tree, and an integer k, return the kth smallest value (1-indexed) of all the values of the nodes in the tree.\n\n \n\nExample 1:\nInput: root = [3,1,4,null,2], k = 1\nOutput: 1\nExample 2:\nInput: root = [5,3,6,2,4,null,null,1], k = 3\nOutput: 3\n \n\nConstraints:\n\nThe number of nodes in the tree is n.\n1 <= k <= n <= 104\n0 <= Node.val <= 104",
        "solution": "class Solution(object):\n    def kthSmallest(self, root, k):\n        def inorder_traversal(node):\n            if not node:\n                return []\n            return inorder_traversal(node.left) + [node.val] + inorder_traversal(node.right)\n\n        sorted_elements = inorder_traversal(root)\n        return sorted_elements[k - 1]",
        "explanation": "Intuition\nIn a Binary Search Tree (BST), an inorder traversal yields sorted values. So, the k-th smallest element corresponds to the (k-1)-th index in this sorted list.\nUse recursive inorder traversal to collect values. Once the entire sorted list is built, return the k-th element (1-indexed). This method is simple and reliable, especially when k is small.\n\nComplexity\nTime Complexity:\n\n( O(n) ) — traverses all nodes once.\nSpace Complexity:\n\n( O(n) ) — stores all node values."
    },
    {
        "question_id": "35efc8fa-00d2-4277-8db4-2546a4173d25",
        "title": "Kth Smallest Element in a BST",
        "difficulty": "Medium",
        "category": "Tree Depth-First Search Binary Search Tree Binary Tree",
        "question_text": "Given the root of a binary search tree, and an integer k, return the kth smallest value (1-indexed) of all the values of the nodes in the tree.\n\n \n\nExample 1:\nInput: root = [3,1,4,null,2], k = 1\nOutput: 1\nExample 2:\nInput: root = [5,3,6,2,4,null,null,1], k = 3\nOutput: 3\n \n\nConstraints:\n\nThe number of nodes in the tree is n.\n1 <= k <= n <= 104\n0 <= Node.val <= 104",
        "solution": "class Solution(object):\n    def kthSmallest(self, root, k):\n        def inorder_traversal(node):\n            if not node:\n                return []\n            return inorder_traversal(node.left) + [node.val] + inorder_traversal(node.right)\n\n        sorted_elements = inorder_traversal(root)\n        return sorted_elements[k - 1]",
        "explanation": "Intuition\nIn a Binary Search Tree (BST), an inorder traversal yields sorted values. So, the k-th smallest element corresponds to the (k-1)-th index in this sorted list.\nUse recursive inorder traversal to collect values. Once the entire sorted list is built, return the k-th element (1-indexed). This method is simple and reliable, especially when k is small.\n\nComplexity\nTime Complexity:\n\n( O(n) ) — traverses all nodes once.\nSpace Complexity:\n\n( O(n) ) — stores all node values."
    },
    {
        "question_id": "95b88706-2f68-4b31-aab9-22803da9748d",
        "title": "Serialize and Deserialize Binary Tree",
        "difficulty": "Hard",
        "category": "String Tree Depth-First Search Breadth-First Search Design Binary Tree",
        "question_text": "Serialization is the process of converting a data structure or object into a sequence of bits so that it can be stored in a file or memory buffer, or transmitted across a network connection link to be reconstructed later in the same or another computer environment.\n\nDesign an algorithm to serialize and deserialize a binary tree. There is no restriction on how your serialization/deserialization algorithm should work. You just need to ensure that a binary tree can be serialized to a string and this string can be deserialized to the original tree structure.\n\nClarification: The input/output format is the same as how LeetCode serializes a binary tree. You do not necessarily need to follow this format, so please be creative and come up with different approaches yourself.\n\n \n\nExample 1:\nInput: root = [1,2,3,null,null,4,5]\nOutput: [1,2,3,null,null,4,5]\nExample 2:\n\nInput: root = []\nOutput: []\n \n\nConstraints:\n\nThe number of nodes in the tree is in the range [0, 104].\n-1000 <= Node.val <= 1000",
        "solution": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\npublic class Codec {\n\n    // Encodes a tree to a single string.\n    public String serialize(TreeNode root) {\n\n        if(root==null) return \"null\";\n\n        Queue<TreeNode> q=new LinkedList<>();\n        StringBuilder sb=new StringBuilder();\n\n        q.offer(root);\n\n        while(!q.isEmpty()){\n\n            TreeNode node=q.poll();\n\n            if(node==null){\n                sb.append(\"null,\");\n                continue;\n            }\n            sb.append(node.val).append(\",\");\n            q.offer(node.left);\n            q.offer(node.right);\n        }\n        \n        return sb.toString();\n    }\n\n    // Decodes your encoded data to tree.\n    public TreeNode deserialize(String data) {\n\n        if(data.equals(\"null\")) return null;\n\n        String nodes[]=data.split(\",\");\n        TreeNode root=new TreeNode(Integer.parseInt(nodes[0]));\n\n        Queue<TreeNode> q=new LinkedList<>();\n\n        q.offer(root);\n        int i=1;\n        while(!q.isEmpty() && i<nodes.length){\n\n            TreeNode node=q.poll();\n\n            if(!nodes[i].equals(\"null\")){\n                node.left=new TreeNode(Integer.parseInt(nodes[i]));\n                q.offer(node.left);\n            }\n            i++;\n\n            if(!nodes[i].equals(\"null\")){\n                node.right=new TreeNode(Integer.parseInt(nodes[i]));\n                q.offer(node.right);\n            }\n            i++;\n        }\n        return root;\n    }\n}\n\n// Your Codec object will be instantiated and called as such:\n// Codec ser = new Codec();\n// Codec deser = new Codec();\n// TreeNode ans = deser.deserialize(ser.serialize(root));",
        "explanation": "Best optimal Code"
    },
    {
        "question_id": "e6f49d64-16aa-42b0-a61a-a1a5fac7333a",
        "title": "House Robber III",
        "difficulty": "Medium",
        "category": "Dynamic Programming Tree Depth-First Search Binary Tree",
        "question_text": "The thief has found himself a new place for his thievery again. There is only one entrance to this area, called root.\n\nBesides the root, each house has one and only one parent house. After a tour, the smart thief realized that all houses in this place form a binary tree. It will automatically contact the police if two directly-linked houses were broken into on the same night.\n\nGiven the root of the binary tree, return the maximum amount of money the thief can rob without alerting the police.\n\n \n\nExample 1:\nInput: root = [3,2,3,null,3,null,1]\nOutput: 7\nExplanation: Maximum amount of money the thief can rob = 3 + 3 + 1 = 7.\nExample 2:\nInput: root = [3,4,5,1,3,null,1]\nOutput: 9\nExplanation: Maximum amount of money the thief can rob = 4 + 5 = 9.\n \n\nConstraints:\n\nThe number of nodes in the tree is in the range [1, 104].\n0 <= Node.val <= 104",
        "solution": "public int rob(TreeNode root) {\n    int[] res = robSub(root);\n    return Math.max(res[0], res[1]);\n}\n\nprivate int[] robSub(TreeNode root) {\n    if (root == null) return new int[2];\n    \n    int[] left = robSub(root.left);\n    int[] right = robSub(root.right);\n    int[] res = new int[2];\n\n    res[0] = Math.max(left[0], left[1]) + Math.max(right[0], right[1]);\n    res[1] = root.val + left[0] + right[0];\n    \n    return res;\n}",
        "explanation": "In step I, we defined our problem as rob(root), which will yield the maximum amount of money that can be robbed of the binary tree rooted at root. This leads to the DP problem summarized in step II.\n\nNow let's take one step back and ask why we have overlapping subproblems. If you trace all the way back to the beginning, you'll find the answer lies in the way how we have defined rob(root). As I mentioned, for each tree root, there are two scenarios: it is robbed or is not. rob(root) does not distinguish between these two cases, so \"information is lost as the recursion goes deeper and deeper\", which results in repeated subproblems.\n\nIf we were able to maintain the information about the two scenarios for each tree root, let's see how it plays out. Redefine rob(root) as a new function which will return an array of two elements, the first element of which denotes the maximum amount of money that can be robbed if root is not robbed, while the second element signifies the maximum amount of money robbed if it is robbed.\n\nLet's relate rob(root) to rob(root.left) and rob(root.right)..., etc. For the 1st element of rob(root), we only need to sum up the larger elements of rob(root.left) and rob(root.right), respectively, since root is not robbed and we are free to rob its left and right subtrees. For the 2nd element of rob(root), however, we only need to add up the 1st elements of rob(root.left) and rob(root.right), respectively, plus the value robbed from root itself, since in this case it's guaranteed that we cannot rob the nodes of root.left and root.right.\n\nAs you can see, by keeping track of the information of both scenarios, we decoupled the subproblems and the solution essentially boiled down to a greedy one. Here is the program:"
    },
    {
        "question_id": "be488271-ce7d-470a-8108-8e07b8e793e0",
        "title": "All Nodes Distance K in Binary Tree",
        "difficulty": "Medium",
        "category": "Hash Table Tree Depth-First Search Breadth-First Search Binary Tree",
        "question_text": "Given the root of a binary tree, the value of a target node target, and an integer k, return an array of the values of all nodes that have a distance k from the target node.\n\nYou can return the answer in any order.\n\n \n\nExample 1:\nInput: root = [3,5,1,6,2,0,8,null,null,7,4], target = 5, k = 2\nOutput: [7,4,1]\nExplanation: The nodes that are a distance 2 from the target node (with value 5) have values 7, 4, and 1.\nExample 2:\n\nInput: root = [1], target = 1, k = 3\nOutput: []\n \n\nConstraints:\n\nThe number of nodes in the tree is in the range [1, 500].\n0 <= Node.val <= 500\nAll the values Node.val are unique.\ntarget is the value of one of the nodes in the tree.\n0 <= k <= 1000",
        "solution": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    /**\n     * Return all node values at distance K from the target node.\n     */\n    vector<int> distanceK(TreeNode* root, TreeNode* target, int k) {\n        // p will store the path from root to target\n        string p;\n        // Find and record path\n        findPath(root, target, \"\", p);\n\n        vector<int> ans;\n        // Traverse from root, tracking current distance and path index\n        searchFromRoot(root, k, p.length(), p, 0, ans);\n        return ans;\n    }\n\nprivate:\n    /**\n     * Build path string: 'l' for left, 'r' for right.\n     * s is the growing path; p is the output reference.\n     */\n    void findPath(TreeNode* node, TreeNode* target, string s, string &p) {\n        if (!node) return;\n        if (node == target) {\n            p = s;\n            return;\n        }\n        findPath(node->left, target, s + 'l', p);\n        findPath(node->right, target, s + 'r', p);\n    }\n\n    /**\n     * Traverse tree from node, adjust distance based on recorded path:\n     * - curr: current distance from target\n     * - s: path string\n     * - i: index in path (next direction upward), or -1 if off-path\n     */\n    void searchFromRoot(TreeNode* node, int k, int curr, const string &s,\n                        int i, vector<int> &ans) {\n        if (!node) return;\n\n        // If reached distance k, record value\n        if (curr == k) ans.push_back(node->val);\n\n        if (i == -1) {\n            // Off the path: distance always increases\n            searchFromRoot(node->left, k, curr + 1, s, -1, ans);\n            searchFromRoot(node->right, k, curr + 1, s, -1, ans);\n        } else {\n            if (i >= (int)s.length()) {\n                // At target: explore both subtrees starting at distance=1\n                searchFromRoot(node->left, k, 1, s, -1, ans);\n                searchFromRoot(node->right, k, 1, s, -1, ans);\n            } else if (s[i] == 'l') {\n                // Next move is left: left decreases distance, right increases\n                searchFromRoot(node->left, k, curr - 1, s, i + 1, ans);\n                searchFromRoot(node->right, k, curr + 1, s, -1, ans);\n            } else {\n                // Next move is right: mirror logic\n                searchFromRoot(node->right, k, curr - 1, s, i + 1, ans);\n                searchFromRoot(node->left, k, curr + 1, s, -1, ans);\n            }\n        }\n    }\n};",
        "explanation": "Intuition\nNormally, people solve this problem by building a parent pointer map and then doing BFS from the target.\nInstead, here we use a simple two-pass strategy:\n\nFirst, find and record the path from root to target as a sequence of 'l' and 'r' moves.\n\nThen, traverse the tree while adjusting the distance:\n\nIf we stay on the path toward the target, distance decreases.\n\nIf we go off the path (switch direction), we reset and start counting distance up again.\n\nThis allows us to calculate the distance without explicitly building parent links.\n\nApproach\nFind the Path\nPerform a DFS and record the moves ('l' for left, 'r' for right) from root to target node in a string.\n\nTraverse the Tree\nStart from the root:\n\nFollow the path string.\n\nWhen moving along the path, decrease the distance.\n\nIf we branch away from the path, start fresh with distance increased by 1.\n\nCollect Nodes\nEvery time we find a node at the exact distance k, add its value to the answer list.\n\nComplexity\nTime complexity:\nO(n)\nSpace complexity:\nO(n)"
    },
    {
        "question_id": "488aa51e-9695-4142-80ec-a5a5aef55600",
        "title": "Word Ladder II",
        "difficulty": "Hard",
        "category": "Hash Table String Backtracking Breadth-First Search",
        "question_text": "A transformation sequence from word beginWord to word endWord using a dictionary wordList is a sequence of words beginWord -> s1 -> s2 -> ... -> sk such that:\n\nEvery adjacent pair of words differs by a single letter.\nEvery si for 1 <= i <= k is in wordList. Note that beginWord does not need to be in wordList.\nsk == endWord\nGiven two words, beginWord and endWord, and a dictionary wordList, return all the shortest transformation sequences from beginWord to endWord, or an empty list if no such sequence exists. Each sequence should be returned as a list of the words [beginWord, s1, s2, ..., sk].\n\n \n\nExample 1:\n\nInput: beginWord = \"hit\", endWord = \"cog\", wordList = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\",\"cog\"]\nOutput: [[\"hit\",\"hot\",\"dot\",\"dog\",\"cog\"],[\"hit\",\"hot\",\"lot\",\"log\",\"cog\"]]\nExplanation: There are 2 shortest transformation sequences:\n\"hit\" -> \"hot\" -> \"dot\" -> \"dog\" -> \"cog\"\n\"hit\" -> \"hot\" -> \"lot\" -> \"log\" -> \"cog\"\nExample 2:\n\nInput: beginWord = \"hit\", endWord = \"cog\", wordList = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\"]\nOutput: []\nExplanation: The endWord \"cog\" is not in wordList, therefore there is no valid transformation sequence.\n \n\nConstraints:\n\n1 <= beginWord.length <= 5\nendWord.length == beginWord.length\n1 <= wordList.length <= 500\nwordList[i].length == beginWord.length\nbeginWord, endWord, and wordList[i] consist of lowercase English letters.\nbeginWord != endWord\nAll the words in wordList are unique.\nThe sum of all shortest transformation sequences does not exceed 105.",
        "solution": "vector<vector<string>> findLadders(string beginWord, string endWord, unordered_set<string> &wordList) {\n        //very interesting problem\n        //It can be solved with standard BFS. The tricky idea is doing BFS of paths instead of words!\n        //Then the queue becomes a queue of paths.\n        vector<vector<string>> ans;\n        queue<vector<string>> paths;\n        wordList.insert(endWord);\n        paths.push({beginWord});\n        int level = 1;\n        int minLevel = INT_MAX;\n        \n        //\"visited\" records all the visited nodes on this level\n        //these words will never be visited again after this level \n        //and should be removed from wordList. This is guaranteed\n        // by the shortest path.\n        unordered_set<string> visited; \n        \n        while (!paths.empty()) {\n            vector<string> path = paths.front();\n            paths.pop();\n            if (path.size() > level) {\n                //reach a new level\n                for (string w : visited) wordList.erase(w);\n                visited.clear();\n                if (path.size() > minLevel)\n                    break;\n                else\n                    level = path.size();\n            }\n            string last = path.back();\n            //find next words in wordList by changing\n            //each element from 'a' to 'z'\n            for (int i = 0; i < last.size(); ++i) {\n                string news = last;\n                for (char c = 'a'; c <= 'z'; ++c) {\n                    news[i] = c;\n                    if (wordList.find(news) != wordList.end()) {\n                    //next word is in wordList\n                    //append this word to path\n                    //path will be reused in the loop\n                    //so copy a new path\n                        vector<string> newpath = path;\n                        newpath.push_back(news);\n                        visited.insert(news);\n                        if (news == endWord) {\n                            minLevel = level;\n                            ans.push_back(newpath);\n                        }\n                        else\n                            paths.push(newpath);\n                    }\n                }\n            }\n        }\n        return ans;\n    }",
        "explanation": "I have struggled with this problem for a long time because nearly all the solution on the web is too long or too tricky and can hardly be remembered during the interview.\n\nIn fact, this problem can be solved with a very standard BFS process, whose structure could haven been written by you for many many times (using while loop and a queue).\nThe following code is written in a very standard BFS method, which is easy to memorize.\n\nThe only tricky thing you need to remember is this is a BFS of paths not words!\nSo the element is the queue is a vector. That's it."
    },
    {
        "question_id": "4761a9b4-27fa-4c7d-9aa2-e7d078050f6f",
        "title": "Course Schedule II",
        "difficulty": "Medium",
        "category": "Depth-First Search Breadth-First Search Graph Topological Sort",
        "question_text": "There are a total of numCourses courses you have to take, labeled from 0 to numCourses - 1. You are given an array prerequisites where prerequisites[i] = [ai, bi] indicates that you must take course bi first if you want to take course ai.\n\nFor example, the pair [0, 1], indicates that to take course 0 you have to first take course 1.\nReturn the ordering of courses you should take to finish all courses. If there are many valid answers, return any of them. If it is impossible to finish all courses, return an empty array.\n\n \n\nExample 1:\n\nInput: numCourses = 2, prerequisites = [[1,0]]\nOutput: [0,1]\nExplanation: There are a total of 2 courses to take. To take course 1 you should have finished course 0. So the correct course order is [0,1].\nExample 2:\n\nInput: numCourses = 4, prerequisites = [[1,0],[2,0],[3,1],[3,2]]\nOutput: [0,2,1,3]\nExplanation: There are a total of 4 courses to take. To take course 3 you should have finished both courses 1 and 2. Both courses 1 and 2 should be taken after you finished course 0.\nSo one correct course order is [0,1,2,3]. Another correct ordering is [0,2,1,3].\nExample 3:\n\nInput: numCourses = 1, prerequisites = []\nOutput: [0]\n \n\nConstraints:\n\n1 <= numCourses <= 2000\n0 <= prerequisites.length <= numCourses * (numCourses - 1)\nprerequisites[i].length == 2\n0 <= ai, bi < numCourses\nai != bi\nAll the pairs [ai, bi] are distinct.",
        "solution": "from collections import defaultdict, deque\n\nclass Solution(object):\n    def findOrder(self, numCourses, prerequisites):\n        graph = defaultdict(list)\n        in_degree = [0] * numCourses\n\n        for course, prereq in prerequisites:\n            graph[prereq].append(course)\n            in_degree[course] += 1\n\n        queue = deque([i for i in range(numCourses) if in_degree[i] == 0])\n        result = []\n\n        while queue:\n            current = queue.popleft()\n            result.append(current)\n\n            for neighbor in graph[current]:\n                in_degree[neighbor] -= 1\n                if in_degree[neighbor] == 0:\n                    queue.append(neighbor)\n\n        return result if len(result) == numCourses else []",
        "explanation": "Intuition\nWhen scheduling courses with prerequisites, we can represent the problem as a Directed Graph. Each course is a node, and an edge from A → B means you must take A before B. To find a valid order to take all courses, we perform topological sorting.\n\nApproach\nWe use Kahn's Algorithm (BFS-based topological sort):\n\nBuild a graph and track the in-degree of each course.\nStart with courses that have no prerequisites (in-degree = 0).\nIteratively process these and reduce the in-degree of their dependent courses.\nIf all courses are added to the result, a valid schedule exists; otherwise, there is a cycle.\nComplexity\nTime complexity: (O(V + E)), where V is the number of courses and E is the number of prerequisites\nSpace complexity: (O(V + E)) for the graph and queue"
    },
    {
        "question_id": "2f5baf91-34d2-4cbe-a8bb-a79d6017facc",
        "title": "01 Matrix",
        "difficulty": "Medium",
        "category": "Array Dynamic Programming Breadth-First Search Matrix",
        "question_text": "Given an m x n binary matrix mat, return the distance of the nearest 0 for each cell.\n\nThe distance between two cells sharing a common edge is 1.\n\n \n\nExample 1:\nInput: mat = [[0,0,0],[0,1,0],[0,0,0]]\nOutput: [[0,0,0],[0,1,0],[0,0,0]]\nExample 2:\nInput: mat = [[0,0,0],[0,1,0],[1,1,1]]\nOutput: [[0,0,0],[0,1,0],[1,2,1]]\n \n\nConstraints:\n\nm == mat.length\nn == mat[i].length\n1 <= m, n <= 104\n1 <= m * n <= 104\nmat[i][j] is either 0 or 1.\nThere is at least one 0 in mat.",
        "solution": "class Solution { // 48 ms, faster than 99.64%\npublic:\n    vector<vector<int>> updateMatrix(vector<vector<int>> &mat) {\n        int m = mat.size(), n = mat[0].size(), INF = m + n; // The distance of cells is up to (M+N)\n        for (int r = 0; r < m; r++) {\n            for (int c = 0; c < n; c++) {\n                if (mat[r][c] == 0) continue;\n                int top = INF, left = INF;\n                if (r - 1 >= 0) top = mat[r - 1][c];\n                if (c - 1 >= 0) left = mat[r][c - 1];\n                mat[r][c] = min(top, left) + 1;\n            }\n        }\n        for (int r = m - 1; r >= 0; r--) {\n            for (int c = n - 1; c >= 0; c--) {\n                if (mat[r][c] == 0) continue;\n                int bottom = INF, right = INF;\n                if (r + 1 < m) bottom = mat[r + 1][c];\n                if (c + 1 < n) right = mat[r][c + 1];\n                mat[r][c] = min(mat[r][c], min(bottom, right) + 1);\n            }\n        }\n        return mat;\n    }\n};",
        "explanation": "For convinience, let's call the cell with value 0 as zero-cell, the cell has with value 1 as one-cell, the distance of the nearest 0 of a cell as distance.\nFirstly, we can see that the distance of all zero-cells are 0, so we skip zero-cells, we process one-cells only.\nIn DP, we can only use prevous values if they're already computed.\nIn this problem, a cell has at most 4 neighbors that are left, top, right, bottom. If we use dynamic programming to compute the distance of the current cell based on 4 neighbors simultaneously, it's impossible because we are not sure if distance of neighboring cells is already computed or not.\nThat's why, we need to compute the distance one by one:\nFirstly, for a cell, we restrict it to only 2 directions which are left and top. Then we iterate cells from top to bottom, and from left to right, we calculate the distance of a cell based on its left and top neighbors.\nSecondly, for a cell, we restrict it only have 2 directions which are right and bottom. Then we iterate cells from bottom to top, and from right to left, we update the distance of a cell based on its right and bottom neighbors."
    },
    {
        "question_id": "d828b3fe-9889-4a69-8d4b-38c47e54ef51",
        "title": "Cut Off Trees for Golf Event",
        "difficulty": "Hard",
        "category": "Array Breadth-First Search Heap (Priority Queue) Matrix",
        "question_text": "You are asked to cut off all the trees in a forest for a golf event. The forest is represented as an m x n matrix. In this matrix:\n\n0 means the cell cannot be walked through.\n1 represents an empty cell that can be walked through.\nA number greater than 1 represents a tree in a cell that can be walked through, and this number is the tree's height.\nIn one step, you can walk in any of the four directions: north, east, south, and west. If you are standing in a cell with a tree, you can choose whether to cut it off.\n\nYou must cut off the trees in order from shortest to tallest. When you cut off a tree, the value at its cell becomes 1 (an empty cell).\n\nStarting from the point (0, 0), return the minimum steps you need to walk to cut off all the trees. If you cannot cut off all the trees, return -1.\n\nNote: The input is generated such that no two trees have the same height, and there is at least one tree needs to be cut off.\n\n \n\nExample 1:\nInput: forest = [[1,2,3],[0,0,4],[7,6,5]]\nOutput: 6\nExplanation: Following the path above allows you to cut off the trees from shortest to tallest in 6 steps.\nExample 2:\nInput: forest = [[1,2,3],[0,0,0],[7,6,5]]\nOutput: -1\nExplanation: The trees in the bottom row cannot be accessed as the middle row is blocked.\nExample 3:\n\nInput: forest = [[2,3,4],[0,0,5],[8,7,6]]\nOutput: 6\nExplanation: You can follow the same path as Example 1 to cut off all the trees.\nNote that you can cut off the first tree at (0, 0) before making any steps.\n \n\nConstraints:\n\nm == forest.length\nn == forest[i].length\n1 <= m, n <= 50\n0 <= forest[i][j] <= 109\nHeights of all trees are distinct.",
        "solution": "def astar(forest, sr, sc, tr, tc):\n    R, C = len(forest), len(forest[0])\n    heap = [(0, 0, sr, sc)]\n    cost = {(sr, sc): 0}\n    while heap:\n        f, g, r, c = heapq.heappop(heap)\n        if r == tr and c == tc: return g\n        for nr, nc in ((r-1,c), (r+1,c), (r,c-1), (r,c+1)):\n            if 0 <= nr < R and 0 <= nc < C and forest[nr][nc]:\n                ncost = g + 1 + abs(nr - tr) + abs(nc - tc)\n                if ncost < cost.get((nr, nc), 9999):\n                    cost[nr, nc] = ncost\n                    heapq.heappush(heap, (ncost, g+1, nr, nc))\n    return -1",
        "explanation": "A* Search [Accepted]\nIntuition and Algorithm\n\nThe A* star algorithm is another path-finding algorithm. For every node at position (r, c), we have some estimated cost node.f = node.g + node.h, where node.g is the actual distance from (sr, sc) to (r, c), and node.h is our heuristic (guess) of the distance from (r, c) to (tr, tc). In this case, our guess will be the taxicab distance, node.h = abs(r-tr) + abs(c-tc).\n\nWe keep a priority queue to decide what node to search in (expand) next. We can prove that if we find the target node, we must have traveled the lowest possible distance node.g. By considering the last time when two backward paths are the same, without loss of generality we could suppose the penultimate square of the two paths are different, and then in this case node.f = node.g + 1, showing the path with less actual distance travelled is expanded first as desired.\n\nIt might be useful for solvers familiar with Dijkstra's Algorithm to know that Dijkstra's algorithm is a special case of A* Search with node.h = 0 always."
    },
    {
        "question_id": "9b2bad04-20e8-496c-89ae-b1bb3050a014",
        "title": "Flood Fill",
        "difficulty": "Easy",
        "category": "Array Depth-First Search Breadth-First Search Matrix",
        "question_text": "You are given an image represented by an m x n grid of integers image, where image[i][j] represents the pixel value of the image. You are also given three integers sr, sc, and color. Your task is to perform a flood fill on the image starting from the pixel image[sr][sc].\n\nTo perform a flood fill:\n\nBegin with the starting pixel and change its color to color.\nPerform the same process for each pixel that is directly adjacent (pixels that share a side with the original pixel, either horizontally or vertically) and shares the same color as the starting pixel.\nKeep repeating this process by checking neighboring pixels of the updated pixels and modifying their color if it matches the original color of the starting pixel.\nThe process stops when there are no more adjacent pixels of the original color to update.\nReturn the modified image after performing the flood fill.\n\n \n\nExample 1:\n\nInput: image = [[1,1,1],[1,1,0],[1,0,1]], sr = 1, sc = 1, color = 2\n\nOutput: [[2,2,2],[2,2,0],[2,0,1]]\n\nExplanation:\nFrom the center of the image with position (sr, sc) = (1, 1) (i.e., the red pixel), all pixels connected by a path of the same color as the starting pixel (i.e., the blue pixels) are colored with the new color.\n\nNote the bottom corner is not colored 2, because it is not horizontally or vertically connected to the starting pixel.\n\nExample 2:\n\nInput: image = [[0,0,0],[0,0,0]], sr = 0, sc = 0, color = 0\n\nOutput: [[0,0,0],[0,0,0]]\n\n\nThe starting pixel is already colored with 0, which is the same as the target color. Therefore, no changes are made to the image.\n\n \n\nConstraints:\n\nm == image.length\nn == image[i].length\n1 <= m, n <= 50\n0 <= image[i][j], color < 216\n0 <= sr < m\n0 <= sc < n",
        "solution": "class Solution {\n    public int[][] floodFill(int[][] image, int sr, int sc, int newColor) {\n        int color = image[sr][sc];\n        if (color != newColor) {\n            dfs(image, sr, sc, color, newColor);\n        }\n        return image;\n    }\n    public void dfs(int[][] image, int r, int c, int color, int newColor) {\n        if (image[r][c] == color) {\n            image[r][c] = newColor;\n            if (r >= 1) {\n                dfs(image, r - 1, c, color, newColor);\n            }\n            if (c >= 1) {\n                dfs(image, r, c - 1, color, newColor);\n            }\n            if (r + 1 < image.length) {\n                dfs(image, r + 1, c, color, newColor);\n            }\n            if (c + 1 < image[0].length) {\n                dfs(image, r, c + 1, color, newColor);\n            }\n        }\n    }\n}",
        "explanation": "Depth-First Search [Accepted]\nIntuition\n\nWe perform the algorithm explained in the problem description: paint the starting pixels, plus adjacent pixels of the same color, and so on.\n\nAlgorithm\n\nSay color is the color of the starting pixel. Let's flood fill the starting pixel: we change the color of that pixel to the new color, then check the 4 neighboring pixels to make sure they are valid pixels of the same color, and of the valid ones, we flood fill those, and so on.\n\nWe can use a function dfs to perform a flood fill on a target pixel."
    },
    {
        "question_id": "0c5619c0-aa2b-4890-ae7e-5d0700393e6d",
        "title": "Bitwise AND of Numbers Range",
        "difficulty": "Medium",
        "category": "Array Depth-First Search Breadth-First Search Matrix",
        "question_text": "Given two integers left and right that represent the range [left, right], return the bitwise AND of all numbers in this range, inclusive.\n\n \n\nExample 1:\n\nInput: left = 5, right = 7\nOutput: 4\nExample 2:\n\nInput: left = 0, right = 0\nOutput: 0\nExample 3:\n\nInput: left = 1, right = 2147483647\nOutput: 0\n \n\nConstraints:\n\n0 <= left <= right <= 231 - 1",
        "solution": "class Solution {\npublic:\n    int rangeBitwiseAnd(int left, int right) {\n        int cnt = 0;\n        while (left != right) {\n            left >>= 1;\n            right >>= 1;\n            cnt++;\n        }\n        return (left << cnt);\n    }\n};",
        "explanation": "Approaches\n(Also explained in the code)\n\nCommon Prefix Identification:\n\nThe function iteratively right-shifts both left and right until they become equal, identifying the common prefix of their binary representations.\nCounting Shifts:\n\nIt counts the number of right-shifts performed, storing the count in the variable cnt.\nBitwise AND Calculation:\n\nAfter finding the common prefix, it reconstructs the bitwise AND result by left-shifting the common prefix by cnt bits."
    },
    {
        "question_id": "2e78c045-b176-4835-aa2f-d699791757c5",
        "title": "Power of Four",
        "difficulty": "Easy",
        "category": "Math Bit Manipulation Recursion",
        "question_text": "Given an integer n, return true if it is a power of four. Otherwise, return false.\n\nAn integer n is a power of four, if there exists an integer x such that n == 4x.\n\n \n\nExample 1:\n\nInput: n = 16\nOutput: true\nExample 2:\n\nInput: n = 5\nOutput: false\nExample 3:\n\nInput: n = 1\nOutput: true\n \n\nConstraints:\n\n-231 <= n <= 231 - 1",
        "solution": "class Solution(object):\n    def isPowerOfFour(self, n):\n        if n <= 0:\n            return False\n        return (n & (n - 1)) == 0 and (n - 1) % 3 == 0",
        "explanation": "Intuition\nWe know powers of 4 are also powers of 2. So first, check that n has only one bit set. But not all powers of 2 are powers of 4. The trick? For powers of 4, (n - 1) must be divisible by 3.\n\nApproach\nn & (n - 1) ensures n is a power of 2.\n(n - 1) % 3 == 0 further filters powers of 4.\nThis bitwise + math combo avoids loops or recursion.\n\nComplexity\nTime Complexity:\n( O(1) ) — constant time bitwise and modulo checks.\n\nSpace Complexity:\n( O(1) ) — no extra space needed."
    },
    {
        "question_id": "cf690558-dacc-4096-a077-278bad9313ec",
        "title": "Convert a Number to Hexadecimal",
        "difficulty": "Easy",
        "category": "Math Bit Manipulation",
        "question_text": "Given a 32-bit integer num, return a string representing its hexadecimal representation. For negative integers, two’s complement method is used.\n\nAll the letters in the answer string should be lowercase characters, and there should not be any leading zeros in the answer except for the zero itself.\n\nNote: You are not allowed to use any built-in library method to directly solve this problem.\n\n \n\nExample 1:\n\nInput: num = 26\nOutput: \"1a\"\nExample 2:\n\nInput: num = -1\nOutput: \"ffffffff\"\n \n\nConstraints:\n\n-231 <= num <= 231 - 1",
        "solution": "/*\nBasic idea: each time we take a look at the last four digits of\n            binary verion of the input, and maps that to a hex char\n            shift the input to the right by 4 bits, do it again\n            until input becomes 0.\n\n*/\n\npublic class Solution {\n    \n    char[] map = {'0','1','2','3','4','5','6','7','8','9','a','b','c','d','e','f'};\n    \n    public String toHex(int num) {\n        if(num == 0) return \"0\";\n        String result = \"\";\n        while(num != 0){\n            result = map[(num & 15)] + result; \n            num = (num >>> 4);\n        }\n        return result;\n    }\n    \n    \n}",
        "explanation": "Explanation in code"
    },
    {
        "question_id": "6c57edd4-e667-45f2-a241-0ed734ed2db9",
        "title": "Stickers to Spell Word",
        "difficulty": "Hard",
        "category": "Array Hash Table String Dynamic Programming Backtracking Bit Manipulation Memoization Bitmask",
        "question_text": "We are given n different types of stickers. Each sticker has a lowercase English word on it.\n\nYou would like to spell out the given string target by cutting individual letters from your collection of stickers and rearranging them. You can use each sticker more than once if you want, and you have infinite quantities of each sticker.\n\nReturn the minimum number of stickers that you need to spell out target. If the task is impossible, return -1.\n\nNote: In all test cases, all words were chosen randomly from the 1000 most common US English words, and target was chosen as a concatenation of two random words.\n\n \n\nExample 1:\n\nInput: stickers = [\"with\",\"example\",\"science\"], target = \"thehat\"\nOutput: 3\nExplanation:\nWe can use 2 \"with\" stickers, and 1 \"example\" sticker.\nAfter cutting and rearrange the letters of those stickers, we can form the target \"thehat\".\nAlso, this is the minimum number of stickers necessary to form the target string.\nExample 2:\n\nInput: stickers = [\"notice\",\"possible\"], target = \"basicbasic\"\nOutput: -1\nExplanation:\nWe cannot form the target \"basicbasic\" from cutting letters from the given stickers.\n \n\nConstraints:\n\nn == stickers.length\n1 <= n <= 50\n1 <= stickers[i].length <= 10\n1 <= target.length <= 15\nstickers[i] and target consist of lowercase English letters.",
        "solution": "class Solution {\n    public int minStickers(String[] stickers, String target) {\n        int N = target.length();\n        int[] dp = new int[1 << N];\n        for (int i = 1; i < 1 << N; i++) dp[i] = -1;\n\n        for (int state = 0; state < 1 << N; state++) {\n            if (dp[state] == -1) continue;\n            for (String sticker: stickers) {\n                int now = state;\n                for (char letter: sticker.toCharArray()) {\n                    for (int i = 0; i < N; i++) {\n                        if (((now >> i) & 1) == 1) continue;\n                        if (target.charAt(i) == letter) {\n                            now |= 1 << i;\n                            break;\n                        }\n                    }\n                }\n                if (dp[now] == -1 || dp[now] > dp[state] + 1) {\n                    dp[now] = dp[state] + 1;\n                }\n            }\n        }\n        return dp[(1 << N) - 1];\n    }\n}",
        "explanation": "Intuition\n\nSuppose we need dp[state] stickers to satisfy all target[i]'s for which the i-th bit of state is set. We would like to know dp[(1 << len(target)) - 1].\n\n\nAlgorithm\n\nFor each state, let's work with it as now and look at what happens to it after applying a sticker. For each letter in the sticker that can satisfy an unset bit of state, we set the bit (now |= 1 << i). In the end, we know now is the result of applying that sticker to state, and we update our dp appropriately.\nComplexity Analysis\n\nTime Complexity: O(2 \nT\n ∗S∗T) where S is the total number of letters in all stickers, and T is the number of letters in the target word. We can examine each loop carefully to arrive at this conclusion.\n\nSpace Complexity: O(2 \nT\n ), the space used by dp."
    },
    {
        "question_id": "dbd16dc8-90b3-4b4c-913b-a34a0aaab3c7",
        "title": "Find the Shortest Superstring",
        "difficulty": "Hard",
        "category": "Array String Dynamic Programming Bit Manipulation Bitmask",
        "question_text": "Given an array of strings words, return the smallest string that contains each string in words as a substring. If there are multiple valid strings of the smallest length, return any of them.\n\nYou may assume that no string in words is a substring of another string in words.\n\n \n\nExample 1:\n\nInput: words = [\"alex\",\"loves\",\"leetcode\"]\nOutput: \"alexlovesleetcode\"\nExplanation: All permutations of \"alex\",\"loves\",\"leetcode\" would also be accepted.\nExample 2:\n\nInput: words = [\"catg\",\"ctaagt\",\"gcta\",\"ttca\",\"atgcatc\"]\nOutput: \"gctaagttcatgcatc\"\n \n\nConstraints:\n\n1 <= words.length <= 12\n1 <= words[i].length <= 20\nwords[i] consists of lowercase English letters.\nAll the strings of words are unique.",
        "solution": "class Solution {\n    public String shortestSuperstring(String[] A) {\n        int N = A.length;\n\n        // Populate overlaps\n        int[][] overlaps = new int[N][N];\n        for (int i = 0; i < N; ++i)\n            for (int j = 0; j < N; ++j) if (i != j) {\n                int m = Math.min(A[i].length(), A[j].length());\n                for (int k = m; k >= 0; --k)\n                    if (A[i].endsWith(A[j].substring(0, k))) {\n                        overlaps[i][j] = k;\n                        break;\n                    }\n            }\n\n        // dp[mask][i] = most overlap with mask, ending with ith element\n        int[][] dp = new int[1<<N][N];\n        int[][] parent = new int[1<<N][N];\n        for (int mask = 0; mask < (1<<N); ++mask) {\n            Arrays.fill(parent[mask], -1);\n\n            for (int bit = 0; bit < N; ++bit) if (((mask >> bit) & 1) > 0) {\n                // Let's try to find dp[mask][bit].  Previously, we had\n                // a collection of items represented by pmask.\n                int pmask = mask ^ (1 << bit);\n                if (pmask == 0) continue;\n                for (int i = 0; i < N; ++i) if (((pmask >> i) & 1) > 0) {\n                    // For each bit i in pmask, calculate the value\n                    // if we ended with word i, then added word 'bit'.\n                    int val = dp[pmask][i] + overlaps[i][bit];\n                    if (val > dp[mask][bit]) {\n                        dp[mask][bit] = val;\n                        parent[mask][bit] = i;\n                    }\n                }\n            }\n        }\n\n        // # Answer will have length sum(len(A[i]) for i) - max(dp[-1])\n        // Reconstruct answer, first as a sequence 'perm' representing\n        // the indices of each word from left to right.\n\n        int[] perm = new int[N];\n        boolean[] seen = new boolean[N];\n        int t = 0;\n        int mask = (1 << N) - 1;\n\n        // p: the last element of perm (last word written left to right)\n        int p = 0;\n        for (int j = 0; j < N; ++j)\n            if (dp[(1<<N) - 1][j] > dp[(1<<N) - 1][p])\n                p = j;\n\n        // Follow parents down backwards path that retains maximum overlap\n        while (p != -1) {\n            perm[t++] = p;\n            seen[p] = true;\n            int p2 = parent[mask][p];\n            mask ^= 1 << p;\n            p = p2;\n        }\n\n        // Reverse perm\n        for (int i = 0; i < t/2; ++i) {\n            int v = perm[i];\n            perm[i] = perm[t-1-i];\n            perm[t-1-i] = v;\n        }\n\n        // Fill in remaining words not yet added\n        for (int i = 0; i < N; ++i) if (!seen[i])\n            perm[t++] = i;\n\n        // Reconstruct final answer given perm\n        StringBuilder ans = new StringBuilder(A[perm[0]]);\n        for (int i = 1; i < N; ++i) {\n            int overlap = overlaps[perm[i-1]][perm[i]];\n            ans.append(A[perm[i]].substring(overlap));\n        }\n\n        return ans.toString();\n    }\n}",
        "explanation": "Intuition\n\nWe have to put the words into a row, where each word may overlap the previous word. This is because no word is contained in any word.\n\nAlso, it is sufficient to try to maximize the total overlap of the words.\n\nSay we have put some words down in our row, ending with word A[i]. Now say we put down word A[j] as the next word, where word j hasn't been put down yet. The overlap increases by overlap(A[i], A[j]).\n\nWe can use dynamic programming to leverage this recursion. Let dp(mask, i) be the total overlap after putting some words down (represented by a bitmask mask), for which A[i] was the last word put down. Then, the key recursion is dp(mask ^ (1<<j), j) = max(overlap(A[i], A[j]) + dp(mask, i)), where the jth bit is not set in mask, and i ranges over all bits set in mask.\n\nOf course, this only tells us what the maximum overlap is for each set of words. We also need to remember each choice along the way (ie. the specific i that made dp(mask ^ (1<<j), j) achieve a minimum) so that we can reconstruct the answer.\n\nAlgorithm\n\nOur algorithm has 3 main components:\n\nPrecompute overlap(A[i], A[j]) for all possible i, j.\nCalculate dp[mask][i], keeping track of the \"parent\" i for each j as described above.\nReconstruct the answer using parent information.\n\nComplexity Analysis\n\nTime Complexity: O(N \n2\n (2 \nN\n +W)), where N is the number of words, and W is the maximum length of each word.\n\nSpace Complexity: O(N(2 \nN\n +W))."
    },
    {
        "question_id": "d20f9182-1292-40b8-8b67-b285b5011ae6",
        "title": "Minimum Number of K Consecutive Bit Flips",
        "difficulty": "Hard",
        "category": "Array Bit Manipulation Queue Sliding Window Prefix Sum",
        "question_text": "You are given a binary array nums and an integer k.\n\nA k-bit flip is choosing a subarray of length k from nums and simultaneously changing every 0 in the subarray to 1, and every 1 in the subarray to 0.\n\nReturn the minimum number of k-bit flips required so that there is no 0 in the array. If it is not possible, return -1.\n\nA subarray is a contiguous part of an array.\n\n \n\nExample 1:\n\nInput: nums = [0,1,0], k = 1\nOutput: 2\nExplanation: Flip nums[0], then flip nums[2].\nExample 2:\n\nInput: nums = [1,1,0], k = 2\nOutput: -1\nExplanation: No matter how we flip subarrays of size 2, we cannot make the array become [1,1,1].\nExample 3:\n\nInput: nums = [0,0,0,1,0,1,1,0], k = 3\nOutput: 3\nExplanation: \nFlip nums[0],nums[1],nums[2]: nums becomes [1,1,1,1,0,1,1,0]\nFlip nums[4],nums[5],nums[6]: nums becomes [1,1,1,1,1,0,0,0]\nFlip nums[5],nums[6],nums[7]: nums becomes [1,1,1,1,1,1,1,1]\n \n\nConstraints:\n\n1 <= nums.length <= 105\n1 <= k <= nums.length",
        "solution": "class Solution {\npublic:\n    int minKBitFlips(vector<int>& nums, int k) {\n        // Tracks the current number of flips\n        int currentFlips = 0;\n        // Tracks the total number of flips\n        int totalFlips = 0;\n\n        for (int i = 0; i < nums.size(); ++i) {\n            // If the window slides out of the range and the leftmost element\n            // is marked as flipped (2), decrement currentFlips\n            if (i >= k && nums[i - k] == 2) {\n                currentFlips--;\n            }\n\n            // Check if the current bit needs to be flipped\n            if ((currentFlips % 2) == nums[i]) {\n                // If flipping would exceed array bounds, return -1\n                if (i + k > nums.size()) {\n                    return -1;\n                }\n                // Mark the current bit as flipped\n                nums[i] = 2;\n                currentFlips++;\n                totalFlips++;\n            }\n        }\n\n        return totalFlips;\n    }\n};",
        "explanation": "Intuition\nThis approach works as a one-pass solution without requiring any additional data structures. The main idea is to maintain a variable currentFlips that represents the number of flips in the current sliding window of size k, to decide whether we need to perform a flip or not.\n\nIf currentFlips is even and nums[i] is 0, we need to flip the bit. Similarly, if currentFlips is odd and nums[i] is 1, we also need to flip the bit. We use the parity of currentFlips (whether it's even or odd) to determine if the current bit needs flipping.\n\nTo perform a flip, we mark the current bit by setting nums[i] to 2, increment currentFlips, and increase totalFlips. As the window slides, if the element at the start of the previous window (i - k) was flipped (i.e., it was set to 2), we decrement currentFlips.\n\nIf flipping the current bit would go beyond the array bounds (i.e., i + k exceeds the array size), we return -1 as it is impossible to make all elements 1.\n\nAlgorithm\nInitialize currentFlips to 0, representing the current number of flips.\nInitialize totalFlips to 0, representing the total number of flips.\nIterate through the nums array from index 0 to nums.size() - 1:\nIf the current index i is greater than or equal to k and nums[i - k] == 2 (the leftmost element is marked as flipped):\nDecrement currentFlips.\nCheck if the current bit nums[i] needs to be flipped:\nIf (currentFlips % 2) == nums[i]:\nIf i + k > nums.size(), return -1 (flipping the window extends beyond the array length).\nSet nums[i] to 2 (mark the current bit as flipped).\nIncrement currentFlips.\nIncrement totalFlips.\nReturn totalFlips.\nComplexity Analysis\nLet n be the size of input array.\n\nTime complexity: O(n)\n\nThe algorithm iterates through the input array once with constant time operations inside the loop (comparisons, increments/decrements, and array access). This results in a linear time complexity.\n\nSpace complexity: O(1)\n\nThe algorithm uses constant additional space for variables like currentFlips and totalFlips. It doesn't create any data structures that scale with the input size (n or k). Therefore, the space complexity is constant."
    },
    {
        "question_id": "0e82dbe8-a4df-4e1f-83cb-0124ff67122c",
        "title": "Parallel Courses II",
        "difficulty": "Hard",
        "category": "Dynamic Programming Bit Manipulation Graph Bitmask",
        "question_text": "You are given an integer n, which indicates that there are n courses labeled from 1 to n. You are also given an array relations where relations[i] = [prevCoursei, nextCoursei], representing a prerequisite relationship between course prevCoursei and course nextCoursei: course prevCoursei has to be taken before course nextCoursei. Also, you are given the integer k.\n\nIn one semester, you can take at most k courses as long as you have taken all the prerequisites in the previous semesters for the courses you are taking.\n\nReturn the minimum number of semesters needed to take all courses. The testcases will be generated such that it is possible to take every course.\n\n \n\nExample 1:\nInput: n = 4, relations = [[2,1],[3,1],[1,4]], k = 2\nOutput: 3\nExplanation: The figure above represents the given graph.\nIn the first semester, you can take courses 2 and 3.\nIn the second semester, you can take course 1.\nIn the third semester, you can take course 4.\nExample 2:\nInput: n = 5, relations = [[2,1],[3,1],[4,1],[1,5]], k = 2\nOutput: 4\nExplanation: The figure above represents the given graph.\nIn the first semester, you can only take courses 2 and 3 since you cannot take more than two per semester.\nIn the second semester, you can take course 4.\nIn the third semester, you can take course 1.\nIn the fourth semester, you can take course 5.\n \n\nConstraints:\n\n1 <= n <= 15\n1 <= k <= n\n0 <= relations.length <= n * (n-1) / 2\nrelations[i].length == 2\n1 <= prevCoursei, nextCoursei <= n\nprevCoursei != nextCoursei\nAll the pairs [prevCoursei, nextCoursei] are unique.\nThe given graph is a directed acyclic graph.",
        "solution": "class Solution:\n    @lru_cache(None) # caching for faster lookups\n    def recurse(self, mask, in_degrees):\n        # if all the bits are 0, we have taken all the courses\n        if not mask: return 0\n        \n        # all the nodes that *can* be taken now, following both the properties\n        nodes = [i for i in range(self.n) if mask & 1 << i and in_degrees[i] == 0]\n        \n        ans = float('inf')\n        # enumerating all the possible combinations\n        for k_nodes in combinations(nodes, min(self.k, len(nodes))):\n            new_mask, new_in_degrees = mask, list(in_degrees)\n            \n            # updating what would happen to new_mask and new_in_degrees \n            # if we considered the nodes in k_nodes\n            for node in k_nodes:\n                # since we know the bit is set, we un-set this bit, to mark it \"considered\"\n                new_mask ^= 1 << node\n                # updating each of the in-degrees, since the \"parents\" have been taken away\n                for child in self.graph[node]:\n                    new_in_degrees[child] -= 1\n            \n            # the heart of recursion\n            # note the +1!\n            ans = min(ans, 1+self.recurse(new_mask, tuple(new_in_degrees)))\n        return ans\n    \n    def minNumberOfSemesters(self, n: int, relations: List[List[int]], k: int) -> int:\n        # saving n and k for later use\n        self.n = n\n        self.k = k\n        in_degrees = [0]*self.n\n        # graph layout remains the same, although the in_degrees change. \n        # This allows us to keep graph as self.graph \n        # instead of passing it over and over.\n        self.graph = defaultdict(list)\n        for prev_course, next_course in relations:\n            # remember, its 0-indexed now!\n            in_degrees[next_course - 1] += 1\n            self.graph[prev_course - 1].append(next_course - 1)\n        \n        # start with all the bits set\n        return self.recurse((1 << self.n) - 1, tuple(in_degrees))",
        "explanation": "Data Structures\n\nWe need to know the layout of the graph, who points to what. Let's keep a structure like graph = {node: [children]}\nWe also need to encode the information of how may in-edges are there for each node. We store that in a list like: in_degrees = [values]. We keep the in_degrees and graph separate for implementation reasons.\nImplementation detail: the inputs are 1 indexed, we make everything 0-indexed for easier implementations.\nNodes\nThere are two types of nodes:\n\nThere are nodes which have been already considered. Let's label them with 0.\nThere are nodes which have not been taken yet. Let's label them with 1.\nNote that even if a node is marked 1, it does not mean its in_degree[node] is 0. It only means it needs to be taken - either in the present or in the future.\n\nMoreover, labelling a node either 0 or 1 allows us to represent the status of the problem in a neat format. What we have done here is called bit masking. mask = 10110 represents the nodes 1, 2, 4 are yet to be considered (aka the course is yet to be taken), and the rest have already been taken.\n\nRecursion\nWe know that decisions taken now can produce different results later on. This makes the recursive approach favourable. For each particular iteration, we consider all the possible combinations of the currently available nodes - in_degree[node] == 0 and mask & 1 << node. The second part is checking if the nodeth bit is set in mask."
    },
    {
        "question_id": "25f3049b-5b9f-4908-9ca4-7a8ad2a25cd6",
        "title": "3Sum",
        "difficulty": "Medium",
        "category": "Array Two Pointers Sorting",
        "question_text": "Given an integer array nums, return all the triplets [nums[i], nums[j], nums[k]] such that i != j, i != k, and j != k, and nums[i] + nums[j] + nums[k] == 0.\n\nNotice that the solution set must not contain duplicate triplets.\n\n \n\nExample 1:\n\nInput: nums = [-1,0,1,2,-1,-4]\nOutput: [[-1,-1,2],[-1,0,1]]\nExplanation: \nnums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0.\nnums[1] + nums[2] + nums[4] = 0 + 1 + (-1) = 0.\nnums[0] + nums[3] + nums[4] = (-1) + 2 + (-1) = 0.\nThe distinct triplets are [-1,0,1] and [-1,-1,2].\nNotice that the order of the output and the order of the triplets does not matter.\nExample 2:\n\nInput: nums = [0,1,1]\nOutput: []\nExplanation: The only possible triplet does not sum up to 0.\nExample 3:\n\nInput: nums = [0,0,0]\nOutput: [[0,0,0]]\nExplanation: The only possible triplet sums up to 0.\n \n\nConstraints:\n\n3 <= nums.length <= 3000\n-105 <= nums[i] <= 105",
        "solution": "//Optimized Approach - O(n^2 logn + nlogn) - o(n^2 logn) time and O(n) space\nclass Solution {\npublic:\n    vector<vector<int>> threeSum(vector<int>& nums) {\n        int target = 0;\n        sort(nums.begin(), nums.end());\n        set<vector<int>> s;\n        vector<vector<int>> output;\n        for (int i = 0; i < nums.size(); i++){\n            int j = i + 1;\n            int k = nums.size() - 1;\n            while (j < k) {\n                int sum = nums[i] + nums[j] + nums[k];\n                if (sum == target) {\n                    s.insert({nums[i], nums[j], nums[k]});\n                    j++;\n                    k--;\n                } else if (sum < target) {\n                    j++;\n                } else {\n                    k--;\n                }\n            }\n        }\n        for(auto triplets : s)\n            output.push_back(triplets);\n        return output;\n    }\n};",
        "explanation": "Intuition of this Problem:\nSet is used to prevent duplicate triplets and parallely we will use two pointer approach to maintain J and k.\n\nNOTE - PLEASE READ APPROACH FIRST THEN SEE THE CODE. YOU WILL DEFINITELY UNDERSTAND THE CODE LINE BY LINE AFTER SEEING THE APPROACH.\n\nApproach for this Problem:\nSort the input array\nInitialize a set to store the unique triplets and an output vector to store the final result\nIterate through the array with a variable i, starting from index 0.\nInitialize two pointers, j and k, with j starting at i+1 and k starting at the end of the array.\nIn the while loop, check if the sum of nums[i], nums[j], and nums[k] is equal to 0. If it is, insert the triplet into the set and increment j and decrement k to move the pointers.\nIf the sum is less than 0, increment j. If the sum is greater than 0, decrement k.\nAfter the while loop, iterate through the set and add each triplet to the output vector.\nReturn the output vector"
    },
    {
        "question_id": "d77440a4-5a11-4cce-b096-817875ca8334",
        "title": "Next Greater Element III",
        "difficulty": "Medium",
        "category": "Math Two Pointers String",
        "question_text": "Given a positive integer n, find the smallest integer which has exactly the same digits existing in the integer n and is greater in value than n. If no such positive integer exists, return -1.\n\nNote that the returned integer should fit in 32-bit integer, if there is a valid answer but it does not fit in 32-bit integer, return -1.\n\n \n\nExample 1:\n\nInput: n = 12\nOutput: 21\nExample 2:\n\nInput: n = 21\nOutput: -1\n \n\nConstraints:\n\n1 <= n <= 231 - 1",
        "solution": "class Solution {\n    public int nextGreaterElement(int n) {\n        String numStr = String.valueOf(n);\n        int[] digits = new int[numStr.length()];\n\n        int len = numStr.length();\n        for (int i = 0; i < len; i++) {\n            digits[i] = numStr.charAt(i) - '0';\n        }\n        int found = -1;\n        for (int i = len - 2; i >= 0; i--) {\n            if (digits[i] < digits[i + 1]) {\n                found = i;\n                break;\n            }\n        }\n        if (found == -1) {\n            return -1;\n        } else {\n            for (int i = len - 1; i >= 0; i--) {\n                if (digits[i] > digits[found]) {\n                    int temp = digits[i];\n                    digits[i] = digits[found];\n                    digits[found] = temp;\n                    break;\n                }\n            }\n            int start = found + 1;\n            int end = len - 1;\n            while (start < end) {\n                int temp = digits[start];\n                digits[start] = digits[end];\n                digits[end] = temp;\n                start++;\n                end--;\n            }\n            int newNum = 0;\n            for (int digit : digits) {\n                if (newNum > (Integer.MAX_VALUE - digit) / 10) {\n                    return -1; // overflow will occur\n                }\n                newNum = newNum * 10 + digit;\n            }\n\n            return newNum;\n        }\n    }\n}",
        "explanation": "Intuition\nWhen you look at a number like 1243, you might wonder:\n \"What's the next bigger number I can make by rearranging its digits?\"\nThat’s exactly what we’re trying to find out! \n\nWe want to find the next greater number that can be formed by changing the order of the digits.\nIf there's no such number (like 4321), we return -1. \n\n Approach\nLet’s break it down step by step! \n\n Step 1: Convert number to array of digits\n Turn the number into an array to easily access and swap digits.\n\n Step 2: Find the first digit (from right) that is smaller than its next digit\nThis is the point where the digits start decreasing — we call this the pivot point.\n\n Example: In 1243, 2 < 4 → so 2 is our pivot.\n\n Step 3: Find the smallest digit on the right of the pivot that is greater than the pivot\n This is the number we’ll swap with the pivot.\n\n Step 4: Swap them\nJust like rearranging puzzle pieces \n\n Step 5: Reverse the part after the pivot\nSo we get the smallest possible next greater number.\n\n Step 6: Check for overflow\nIf the result is too big for an integer return -1.\n\n Complexity\nTime complexity:\n O(n) — Just a few loops over the digits.\nSpace complexity:\n O(n) — Because we convert the number to an array."
    },
    {
        "question_id": "5cde90a0-013e-4000-a0a2-cdf91b551d5f",
        "title": "Next Permutation",
        "difficulty": "Medium",
        "category": "Array Two Pointers",
        "question_text": "A permutation of an array of integers is an arrangement of its members into a sequence or linear order.\n\nFor example, for arr = [1,2,3], the following are all the permutations of arr: [1,2,3], [1,3,2], [2, 1, 3], [2, 3, 1], [3,1,2], [3,2,1].\nThe next permutation of an array of integers is the next lexicographically greater permutation of its integer. More formally, if all the permutations of the array are sorted in one container according to their lexicographical order, then the next permutation of that array is the permutation that follows it in the sorted container. If such arrangement is not possible, the array must be rearranged as the lowest possible order (i.e., sorted in ascending order).\n\nFor example, the next permutation of arr = [1,2,3] is [1,3,2].\nSimilarly, the next permutation of arr = [2,3,1] is [3,1,2].\nWhile the next permutation of arr = [3,2,1] is [1,2,3] because [3,2,1] does not have a lexicographical larger rearrangement.\nGiven an array of integers nums, find the next permutation of nums.\n\nThe replacement must be in place and use only constant extra memory.\n\n \n\nExample 1:\n\nInput: nums = [1,2,3]\nOutput: [1,3,2]\nExample 2:\n\nInput: nums = [3,2,1]\nOutput: [1,2,3]\nExample 3:\n\nInput: nums = [1,1,5]\nOutput: [1,5,1]\n \n\nConstraints:\n\n1 <= nums.length <= 100\n0 <= nums[i] <= 100",
        "solution": "class Solution {\npublic:\n    void nextPermutation(vector<int>& nums) {\n        int i = nums.size() - 2;\n        while (i >= 0 && nums[i + 1] <= nums[i]) {\n            i--;\n        }\n        if (i >= 0) {\n            int j = nums.size() - 1;\n            while (nums[j] <= nums[i]) {\n                j--;\n            }\n            swap(nums, i, j);\n        }\n        reverse(nums.begin() + i + 1, nums.end());\n    }\n\nprivate:\n    void swap(vector<int>& nums, int i, int j) {\n        int temp = nums[i];\n        nums[i] = nums[j];\n        nums[j] = temp;\n    }\n};",
        "explanation": "Single Pass Approach\nAlgorithm\n\nFirst, we observe that for any given sequence that is in descending order, no next larger permutation is possible.\nFor example, no next permutation is possible for the following array:\n\n[9, 5, 4, 3, 1]\nWe need to find the first pair of two successive numbers a[i] and a[i−1], from the right, which satisfy\na[i]>a[i−1]. Now, no rearrangements to the right of a[i−1] can create a larger permutation since that subarray consists of numbers in descending order.\nThus, we need to rearrange the numbers to the right of a[i−1] including itself.\n\nNow, what kind of rearrangement will produce the next larger number? We want to create the permutation just larger than the current one. Therefore, we need to replace the number a[i−1] with the number which is just larger than itself among the numbers lying to its right section, say a[j].\nWe swap the numbers a[i−1] and a[j]. We now have the correct number at index i−1. But still the current permutation isn't the permutation\nthat we are looking for. We need the smallest permutation that can be formed by using the numbers only to the right of a[i−1]. Therefore, we need to place those\nnumbers in ascending order to get their smallest permutation.\n\nBut, recall that while scanning the numbers from the right, we simply kept decrementing the index\nuntil we found the pair a[i] and a[i−1] where, a[i]>a[i−1]. Thus, all numbers to the right of a[i−1] were already sorted in descending order.\nFurthermore, swapping a[i−1] and a[j] didn't change that order.\nTherefore, we simply need to reverse the numbers following a[i−1] to get the next smallest lexicographic permutation.\n\nThe following animation will make things clearer:"
    },
    {
        "question_id": "ccc07c43-96fb-4529-a94f-113c1edde116",
        "title": "Rotate List",
        "difficulty": "Medium",
        "category": "Linked List Two Pointers",
        "question_text": "Given the head of a linked list, rotate the list to the right by k places.\n\n \n\nExample 1:\nInput: head = [1,2,3,4,5], k = 2\nOutput: [4,5,1,2,3]\nExample 2:\nInput: head = [0,1,2], k = 4\nOutput: [2,0,1]\n \n\nConstraints:\n\nThe number of nodes in the list is in the range [0, 500].\n-100 <= Node.val <= 100\n0 <= k <= 2 * 109",
        "solution": "# Definition for singly-linked list.\nclass ListNode(object):\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\nclass Solution(object):\n    def rotateRight(self, head, k):\n        if not head or k == 0:\n            return head\n\n        length = 1\n        tail = head\n        while tail.next:\n            tail = tail.next\n            length += 1\n\n        k = k % length\n        if k == 0:\n            return head\n\n        tail.next = head  # Make it circular\n        steps_to_new_head = length - k\n        new_tail = tail\n        while steps_to_new_head:\n            new_tail = new_tail.next\n            steps_to_new_head -= 1\n\n        new_head = new_tail.next\n        new_tail.next = None\n        return new_head",
        "explanation": "Approach\nCount the length of the list.\nConnect the tail to the head to form a cycle.\nFind the new tail: (length - k % length) steps from head.\nBreak the cycle and return the new head.\nComplexity\nTime Complexity:\n\n( O(n) ) — Single pass to count and another to break rotation.\nSpace Complexity:\n\n( O(1) ) — No extra space used."
    },
    {
        "question_id": "50af1d6c-803b-41c7-9d6b-bc84109dc3f0",
        "title": "Longest Uncommon Subsequence II",
        "difficulty": "Medium",
        "category": "Array Hash Table Two Pointers String Sorting",
        "question_text": "Given an array of strings strs, return the length of the longest uncommon subsequence between them. If the longest uncommon subsequence does not exist, return -1.\n\nAn uncommon subsequence between an array of strings is a string that is a subsequence of one string but not the others.\n\nA subsequence of a string s is a string that can be obtained after deleting any number of characters from s.\n\nFor example, \"abc\" is a subsequence of \"aebdc\" because you can delete the underlined characters in \"aebdc\" to get \"abc\". Other subsequences of \"aebdc\" include \"aebdc\", \"aeb\", and \"\" (empty string).\n \n\nExample 1:\n\nInput: strs = [\"aba\",\"cdc\",\"eae\"]\nOutput: 3\nExample 2:\n\nInput: strs = [\"aaa\",\"aaa\",\"aa\"]\nOutput: -1\n \n\nConstraints:\n\n2 <= strs.length <= 50\n1 <= strs[i].length <= 10\nstrs[i] consists of lowercase English letters.",
        "solution": "class Solution {\npublic:\n    int findLUSlength(vector<string>& strs) {\n        int maxi = -1;\n        // the longest string which is not a subsequence of other is the answer\n        for (int i = 0; i < strs.size(); i++) {\n            bool isSubsequence = false;\n            for (int j = 0; j < strs.size(); j++) {\n                if (i != j && subseq(strs[i], strs[j])) {\n                    isSubsequence = true;\n                    break;\n                }\n            }\n            if (!isSubsequence) maxi = max(maxi, (int)strs[i].length());\n        }\n        return maxi;\n    }\n\n    bool subseq(string a, string b) {\n    int i = 0;\n    for (char c : b) if (i < a.size() && a[i] == c) i++;\n    return i == a.size();\n    }\n};",
        "explanation": "Insights\nWe need to find the longest string which is not a subsequence of other.\nThis question is similar to the first version of it where we needed to simply return the longest string if both the strings were not equal.\nSimilarly, here we need to find the longest such string from an array of strings, so it is as simple as the first question.\nGo through the strings one by one and check which string isn't a subsequence of another and has the longest length. We can simply pick that string as the LUS."
    },
    {
        "question_id": "6ff96b32-b8de-4592-aaa4-34f1b0ab2589",
        "title": "Find Median from Data Stream",
        "difficulty": "Hard",
        "category": "Two Pointers Design Sorting Heap (Priority Queue) Data Stream",
        "question_text": "The median is the middle value in an ordered integer list. If the size of the list is even, there is no middle value, and the median is the mean of the two middle values.\n\nFor example, for arr = [2,3,4], the median is 3.\nFor example, for arr = [2,3], the median is (2 + 3) / 2 = 2.5.\nImplement the MedianFinder class:\n\nMedianFinder() initializes the MedianFinder object.\nvoid addNum(int num) adds the integer num from the data stream to the data structure.\ndouble findMedian() returns the median of all elements so far. Answers within 10-5 of the actual answer will be accepted.\n \n\nExample 1:\n\nInput\n[\"MedianFinder\", \"addNum\", \"addNum\", \"findMedian\", \"addNum\", \"findMedian\"]\n[[], [1], [2], [], [3], []]\nOutput\n[null, null, null, 1.5, null, 2.0]\n\nExplanation\nMedianFinder medianFinder = new MedianFinder();\nmedianFinder.addNum(1);    // arr = [1]\nmedianFinder.addNum(2);    // arr = [1, 2]\nmedianFinder.findMedian(); // return 1.5 (i.e., (1 + 2) / 2)\nmedianFinder.addNum(3);    // arr[1, 2, 3]\nmedianFinder.findMedian(); // return 2.0\n \n\nConstraints:\n\n-105 <= num <= 105\nThere will be at least one element in the data structure before calling findMedian.\nAt most 5 * 104 calls will be made to addNum and findMedian.\n \n\nFollow up:\n\nIf all integer numbers from the stream are in the range [0, 100], how would you optimize your solution?\nIf 99% of all integer numbers from the stream are in the range [0, 100], how would you optimize your solution?",
        "solution": "class MedianFinder {\npublic:\n    priority_queue<int> maxHeap;\n    priority_queue<int, vector<int>, greater<int>> minHeap;\n    \n    MedianFinder() {\n    }\n    void addNum(int num) {\n        maxHeap.push(num);\n        minHeap.push(maxHeap.top());\n        maxHeap.pop();\n        if (minHeap.size() > maxHeap.size()) {\n            maxHeap.push(minHeap.top());\n            minHeap.pop();\n        }\n    }\n    double findMedian() {\n        if (maxHeap.size() > minHeap.size()) return maxHeap.top();\n        return (maxHeap.top() + minHeap.top()) / 2.0;\n    }\n};",
        "explanation": "MaxHeap to store a half of low numbers, MinHeap to store a half of high numbers\n\nThe idea is to divide numbers into 2 balanced halves, one half low stores low numbers, the other half high stores high numbers. To access the median in O(1), we need a data structure that give us the maximum of low half and the minimum of high half in O(1). That's where maxHeap and minHeap come into play.\nWe use maxHeap to store a half of low numbers, top of the maxHeap is the highest number among low numbers.\nWe use minHeap to store a half of high numbers, top of the minHeap is the lowest number among high numbers.\nWe need to balance the size between maxHeap and minHeap while processing. Hence after adding k elements,\nIf k = 2 * i then maxHeap.size = minHeap.size = i\nIf k = 2 * i + 1, let maxHeap store 1 element more than minHeap, then maxHeap.size = minHeap.size + 1.\nWhen adding a new number num into our MedianFinder:\nFirstly, add num to the maxHeap, now maxHeap may contain the big element (which should belong to minHeap). So we need to balance, by removing the highest element from maxHeap, and offer it to minHeap.\nNow, the minHeap might hold more elements than maxHeap, in that case, we need to balance the size, by removing the lowest element from minHeap and offer it back to maxHeap.\nWhen doing findMedian():\nIf maxHeap.size > minHeap.size return top of the maxHeap, which is the highest number amongs low numbers.\nElse if maxHeap.size == minHeap return the (maxHeap.top() + minHeap.top()) / 2."
    },
    {
        "question_id": "aea3013b-f37f-4626-9902-0c5e592705b4",
        "title": "IPO",
        "difficulty": "Hard",
        "category": "Array Greedy Sorting Heap (Priority Queue)",
        "question_text": "Suppose LeetCode will start its IPO soon. In order to sell a good price of its shares to Venture Capital, LeetCode would like to work on some projects to increase its capital before the IPO. Since it has limited resources, it can only finish at most k distinct projects before the IPO. Help LeetCode design the best way to maximize its total capital after finishing at most k distinct projects.\n\nYou are given n projects where the ith project has a pure profit profits[i] and a minimum capital of capital[i] is needed to start it.\n\nInitially, you have w capital. When you finish a project, you will obtain its pure profit and the profit will be added to your total capital.\n\nPick a list of at most k distinct projects from given projects to maximize your final capital, and return the final maximized capital.\n\nThe answer is guaranteed to fit in a 32-bit signed integer.\n\n \n\nExample 1:\n\nInput: k = 2, w = 0, profits = [1,2,3], capital = [0,1,1]\nOutput: 4\nExplanation: Since your initial capital is 0, you can only start the project indexed 0.\nAfter finishing it you will obtain profit 1 and your capital becomes 1.\nWith capital 1, you can either start the project indexed 1 or the project indexed 2.\nSince you can choose at most 2 projects, you need to finish the project indexed 2 to get the maximum capital.\nTherefore, output the final maximized capital, which is 0 + 1 + 3 = 4.\nExample 2:\n\nInput: k = 3, w = 0, profits = [1,2,3], capital = [0,1,2]\nOutput: 6\n \n\nConstraints:\n\n1 <= k <= 105\n0 <= w <= 109\nn == profits.length\nn == capital.length\n1 <= n <= 105\n0 <= profits[i] <= 104\n0 <= capital[i] <= 109",
        "solution": "class Solution {\npublic:\n    int findMaximizedCapital(int k, int w, vector<int>& profits, vector<int>& capital) {\n        int n = profits.size();\n        vector<pair<int, int>> projects(n);\n        for (int i = 0; i < n; i++) {\n            projects[i] = {capital[i], profits[i]};\n        }\n        //We sort the projects by their minimum capital required in ascending order because we want to consider the projects that we can afford with our current capital. By iterating over the sorted projects, we can ensure that we only consider the projects that have a minimum capital requirement less than or equal to our current capital.\n        sort(projects.begin(), projects.end());\n        int i = 0;\n        priority_queue<int> maximizeCapital;\n        while (k--) {\n            //The condition projects[i].first <= w checks if the minimum capital requirement of the next project is less than or equal to our current capital w. If this condition is true, we can add the project to the priority queue because we have enough capital to start the project.\n            //We use this condition to ensure that we only add the available projects that we can afford to the priority queue. By checking the minimum capital requirement of the next project before adding it to the priority queue, we can avoid adding projects that we cannot afford, and we can focus on selecting the most profitable project that we can afford with our current capital.\n            //The loop while (i < n && projects[i].first <= w) runs until we add all the available projects that we can afford to the priority queue\n            while (i < n && projects[i].first <= w) {\n                maximizeCapital.push(projects[i].second);\n                i++;\n            }\n            if (maximizeCapital.empty())\n                break;\n            w += maximizeCapital.top();\n            maximizeCapital.pop();\n        }\n        return w;\n    }\n};",
        "explanation": "Approach for this Problem:\nCreate a vector of pairs \"projects\" to store the minimum capital required and pure profit of each project.\nInitialize a variable \"n\" to the size of the input \"profits\" vector.\nSort the \"projects\" vector by the minimum capital required in ascending order.\nInitialize a variable \"i\" to 0 and a priority queue \"maximizeCapital\" to store the maximum profit we can get from a project.\nLoop k times and perform the following operations in each iteration:\na. While \"i\" is less than \"n\" and the minimum capital required for the project at index \"i\" is less than or equal to the current capital \"w\", push the profit of the project at index \"i\" to \"maximizeCapital\" and increment \"i\".\nb. If \"maximizeCapital\" is empty, break out of the loop.\nc. Add the maximum profit in \"maximizeCapital\" to \"w\" and pop it out of the priority queue.\nReturn the final value of \"w\"."
    },
    {
        "question_id": "31b3006f-5f6c-4ef0-953f-dac6be816b92",
        "title": "Exam Room",
        "difficulty": "Medium",
        "category": "Design Heap (Priority Queue) Ordered Set",
        "question_text": "There is an exam room with n seats in a single row labeled from 0 to n - 1.\n\nWhen a student enters the room, they must sit in the seat that maximizes the distance to the closest person. If there are multiple such seats, they sit in the seat with the lowest number. If no one is in the room, then the student sits at seat number 0.\n\nDesign a class that simulates the mentioned exam room.\n\nImplement the ExamRoom class:\n\nExamRoom(int n) Initializes the object of the exam room with the number of the seats n.\nint seat() Returns the label of the seat at which the next student will set.\nvoid leave(int p) Indicates that the student sitting at seat p will leave the room. It is guaranteed that there will be a student sitting at seat p.\n \n\nExample 1:\n\nInput\n[\"ExamRoom\", \"seat\", \"seat\", \"seat\", \"seat\", \"leave\", \"seat\"]\n[[10], [], [], [], [], [4], []]\nOutput\n[null, 0, 9, 4, 2, null, 5]\n\nExplanation\nExamRoom examRoom = new ExamRoom(10);\nexamRoom.seat(); // return 0, no one is in the room, then the student sits at seat number 0.\nexamRoom.seat(); // return 9, the student sits at the last seat number 9.\nexamRoom.seat(); // return 4, the student sits at the last seat number 4.\nexamRoom.seat(); // return 2, the student sits at the last seat number 2.\nexamRoom.leave(4);\nexamRoom.seat(); // return 5, the student sits at the last seat number 5.\n\n \n\nConstraints:\n\n1 <= n <= 109\nIt is guaranteed that there is a student sitting at seat p.\nAt most 104 calls will be made to seat and leave.",
        "solution": "class ExamRoom {\n    int N;\n    TreeSet<Integer> students;\n\n    public ExamRoom(int N) {\n        this.N = N;\n        students = new TreeSet();\n    }\n\n    public int seat() {\n        //Let's determine student, the position of the next\n        //student to sit down.\n        int student = 0;\n        if (students.size() > 0) {\n            //Tenatively, dist is the distance to the closest student,\n            //which is achieved by sitting in the position 'student'.\n            //We start by considering the left-most seat.\n            int dist = students.first();\n            Integer prev = null;\n            for (Integer s: students) {\n                if (prev != null) {\n                    //For each pair of adjacent students in positions (prev, s),\n                    //d is the distance to the closest student;\n                    //achieved at position prev + d.\n                    int d = (s - prev) / 2;\n                    if (d > dist) {\n                        dist = d;\n                        student = prev + d;\n                    }\n                }\n                prev = s;\n            }\n\n            //Considering the right-most seat.\n            if (N - 1 - students.last() > dist)\n                student = N - 1;\n        }\n\n        //Add the student to our sorted TreeSet of positions.\n        students.add(student);\n        return student;\n    }\n\n    public void leave(int p) {\n        students.remove(p);\n    }\n}",
        "explanation": "Intuition\n\nWe'll maintain ExamRoom.students, a sorted list (or TreeSet in Java) of positions the students are currently seated in.\n\nAlgorithm\n\nThe ExamRoom.leave(p) operation is clear - we will just list.remove (or TreeSet.remove) the student from ExamRoom.students.\n\nLet's focus on the ExamRoom.seat() : int operation. For each pair of adjacent students i and j, the maximum distance to the closest student is d = (j - i) / 2, achieved in the left-most seat i + d. Otherwise, we could also sit in the left-most seat, or the right-most seat.\n\nFinally, we should handle the case when there are no students separately.\n\nFor more details, please review the comments made in the implementations.\nComplexity Analysis\n\nTime Complexity: Each seat operation is O(P), (where P is the number of students sitting), as we iterate through every student. Each leave operation is O(P) (logP in Java).\n\nSpace Complexity: O(P), the space used to store the positions of each student sitting."
    },
    {
        "question_id": "0b43ca68-b71e-4e7e-92c4-243a0a47bfde",
        "title": "Minimum Cost to Hire K Workers",
        "difficulty": "Hard",
        "category": "Array Greedy Sorting Heap (Priority Queue)",
        "question_text": "There are n workers. You are given two integer arrays quality and wage where quality[i] is the quality of the ith worker and wage[i] is the minimum wage expectation for the ith worker.\n\nWe want to hire exactly k workers to form a paid group. To hire a group of k workers, we must pay them according to the following rules:\n\nEvery worker in the paid group must be paid at least their minimum wage expectation.\nIn the group, each worker's pay must be directly proportional to their quality. This means if a worker’s quality is double that of another worker in the group, then they must be paid twice as much as the other worker.\nGiven the integer k, return the least amount of money needed to form a paid group satisfying the above conditions. Answers within 10-5 of the actual answer will be accepted.\n\n \n\nExample 1:\n\nInput: quality = [10,20,5], wage = [70,50,30], k = 2\nOutput: 105.00000\nExplanation: We pay 70 to 0th worker and 35 to 2nd worker.\nExample 2:\n\nInput: quality = [3,1,10,10,1], wage = [4,8,2,2,7], k = 3\nOutput: 30.66667\nExplanation: We pay 4 to 0th worker, 13.33333 to 2nd and 3rd workers separately.\n \n\nConstraints:\n\nn == quality.length == wage.length\n1 <= k <= n <= 104\n1 <= quality[i], wage[i] <= 104",
        "solution": "class Solution {\npublic:\n    double mincostToHireWorkers(vector<int>& quality, vector<int>& wage,\n                                int k) {\n        int n = quality.size();\n        double totalCost = numeric_limits<double>::max();\n        double currentTotalQuality = 0;\n        // Store wage-to-quality ratio along with quality\n        vector<pair<double, int>> wageToQualityRatio;\n\n        // Calculate wage-to-quality ratio for each worker\n        for (int i = 0; i < n; i++) {\n            wageToQualityRatio.push_back(\n                {static_cast<double>(wage[i]) / quality[i], quality[i]});\n        }\n\n        // Sort workers based on their wage-to-quality ratio\n        sort(wageToQualityRatio.begin(), wageToQualityRatio.end());\n\n        // Use a priority queue to keep track of the highest quality workers\n        priority_queue<int> workers;\n\n        // Iterate through workers\n        for (int i = 0; i < n; i++) {\n            workers.push(wageToQualityRatio[i].second);\n            currentTotalQuality += wageToQualityRatio[i].second;\n\n            // If we have more than k workers,\n            // remove the one with the highest quality\n            if (workers.size() > k) {\n                currentTotalQuality -= workers.top();\n                workers.pop();\n            }\n\n            // If we have exactly k workers,\n            // calculate the total cost and update if it's the minimum\n            if (workers.size() == k) {\n                totalCost = min(totalCost, currentTotalQuality *\n                                               wageToQualityRatio[i].first);\n            }\n        }\n        return totalCost;\n    }\n};",
        "explanation": "Algorithm\nInitialize variables n to store the size of the input arrays (quality and wage), totalCost to store the minimum total cost (initially set to the maximum possible value) and currentTotalQuality to keep track of the sum of qualities of the current set of workers.\nCreate an array wageToQualityRatio to store the wage-to-quality ratio and the quality of each worker as pairs.\nCalculate the wage-to-quality ratio for each worker and store it in wageToQualityRatio.\nSort wageToQualityRatio in ascending order based on the wage-to-quality ratio.\nCreate a priority queue workers (max heap) to store the workers chosen for the paid group. The highest quality worker is stored at the top of the heap, so we can quickly remove them if we find a better candidate for the paid group.\nIterate through the sorted wageToQualityRatio:\nPush the current worker's quality to workers.\nUpdate currentTotalQuality by adding the current worker's quality.\nIf the size of workers exceeds k:\nRemove the worker with the highest quality from workers.\nUpdate currentTotalQuality by subtracting the removed worker's quality.\nIf the size of workers is equal to k:\nCalculate the total cost for the current set of workers by multiplying currentTotalQuality by the wage-to-quality ratio of the current worker.\nUpdate totalCost if the calculated cost is smaller than the current minimum cost.\nAfter iterating through all workers, return totalCost, which holds the minimum total cost for hiring k workers.\nReturn totalCost."
    },
    {
        "question_id": "01c5f472-0cea-452a-a414-0312d443b69e",
        "title": "Minimize Malware Spread",
        "difficulty": "Hard",
        "category": "Array Hash Table Depth-First Search Breadth-First Search Union Find Graph",
        "question_text": "You are given a network of n nodes represented as an n x n adjacency matrix graph, where the ith node is directly connected to the jth node if graph[i][j] == 1.\n\nSome nodes initial are initially infected by malware. Whenever two nodes are directly connected, and at least one of those two nodes is infected by malware, both nodes will be infected by malware. This spread of malware will continue until no more nodes can be infected in this manner.\n\nSuppose M(initial) is the final number of nodes infected with malware in the entire network after the spread of malware stops. We will remove exactly one node from initial.\n\nReturn the node that, if removed, would minimize M(initial). If multiple nodes could be removed to minimize M(initial), return such a node with the smallest index.\n\nNote that if a node was removed from the initial list of infected nodes, it might still be infected later due to the malware spread.\n\n \n\nExample 1:\n\nInput: graph = [[1,1,0],[1,1,0],[0,0,1]], initial = [0,1]\nOutput: 0\nExample 2:\n\nInput: graph = [[1,0,0],[0,1,0],[0,0,1]], initial = [0,2]\nOutput: 0\nExample 3:\n\nInput: graph = [[1,1,1],[1,1,1],[1,1,1]], initial = [1,2]\nOutput: 1\n \n\nConstraints:\n\nn == graph.length\nn == graph[i].length\n2 <= n <= 300\ngraph[i][j] is 0 or 1.\ngraph[i][j] == graph[j][i]\ngraph[i][i] == 1\n1 <= initial.length <= n\n0 <= initial[i] <= n - 1\nAll the integers in initial are unique.",
        "solution": "class Solution {\n    public int minMalwareSpread(int[][] graph, int[] initial) {\n        int N = graph.length;\n        DSU dsu = new DSU(N);\n        for (int i = 0; i < N; ++i)\n            for (int j = i+1; j < N; ++j)\n                if (graph[i][j] == 1)\n                    dsu.union(i, j);\n\n        int[] count = new int[N];\n        for (int node: initial)\n            count[dsu.find(node)]++;\n\n        int ans = -1, ansSize = -1;\n        for (int node: initial) {\n            int root = dsu.find(node);\n            if (count[root] == 1) {  // unique color\n                int rootSize = dsu.size(root);\n                if (rootSize > ansSize) {\n                    ansSize = rootSize;\n                    ans = node;\n                } else if (rootSize == ansSize && node < ans) {\n                    ansSize = rootSize;\n                    ans = node;\n                }\n            }\n        }\n\n        if (ans == -1) {\n            ans = Integer.MAX_VALUE;\n            for (int node: initial)\n                ans = Math.min(ans, node);\n        }\n        return ans;\n    }\n}\n\n\nclass DSU {\n    int[] p, sz;\n\n    DSU(int N) {\n        p = new int[N];\n        for (int x = 0; x < N; ++x)\n            p[x] = x;\n\n        sz = new int[N];\n        Arrays.fill(sz, 1);\n    }\n\n    public int find(int x) {\n        if (p[x] != x)\n            p[x] = find(p[x]);\n        return p[x];\n    }\n\n    public void union(int x, int y) {\n        int xr = find(x);\n        int yr = find(y);\n        p[xr] = yr;\n        sz[yr] += sz[xr];\n    }\n\n    public int size(int x) {\n        return sz[find(x)];\n    }\n}",
        "explanation": "Intuition and Algorithm\n\nAs in Approach 1, it is clear that we will need to consider components of the graph. A \"Disjoint Set Union\" (DSU) data structure is ideal for this.\n\nWe will skip the explanation of how a DSU structure is implemented. Please refer to https://leetcode.com/problems/redundant-connection/solution/ for a tutorial on DSU.\n\nTo our DSU, we can keep a side count of the size of each component. Whenever we union two components together, the size of those components are added.\n\nWith these details neatly handled by our DSU structure, we can continue in a similar manner to Approach 1: for each node in initial with a unique color, we will consider it as a candidate answer. If no node in initial have a unique color, then we will take min(initial) as the answer.\n\nNote that for brevity, our DSU implementation does not use union-by-rank. This makes the asymptotic time complexity larger.\nComplexity Analysis\n\nTime Complexity: O(N \n2\n ), where N is the length of graph, as the graph is given in adjacent matrix form.\n\nSpace Complexity: O(N)."
    },
    {
        "question_id": "4b70e2e6-8f47-41b6-9315-a7eba27a8ee1",
        "title": "Shortest Path with Alternating Colors",
        "difficulty": "Medium",
        "category": "Breadth-First Search Graph",
        "question_text": "You are given an integer n, the number of nodes in a directed graph where the nodes are labeled from 0 to n - 1. Each edge is red or blue in this graph, and there could be self-edges and parallel edges.\n\nYou are given two arrays redEdges and blueEdges where:\n\nredEdges[i] = [ai, bi] indicates that there is a directed red edge from node ai to node bi in the graph, and\nblueEdges[j] = [uj, vj] indicates that there is a directed blue edge from node uj to node vj in the graph.\nReturn an array answer of length n, where each answer[x] is the length of the shortest path from node 0 to node x such that the edge colors alternate along the path, or -1 if such a path does not exist.\n\n \n\nExample 1:\n\nInput: n = 3, redEdges = [[0,1],[1,2]], blueEdges = []\nOutput: [0,1,-1]\nExample 2:\n\nInput: n = 3, redEdges = [[0,1]], blueEdges = [[2,1]]\nOutput: [0,1,-1]\n \n\nConstraints:\n\n1 <= n <= 100\n0 <= redEdges.length, blueEdges.length <= 400\nredEdges[i].length == blueEdges[j].length == 2\n0 <= ai, bi, uj, vj < n",
        "solution": "enum class Color { kInit, kRed, kBlue };\n\nclass Solution {\n public:\n  vector<int> shortestAlternatingPaths(int n, vector<vector<int>>& redEdges,\n                                       vector<vector<int>>& blueEdges) {\n    vector<int> ans(n, -1);\n    vector<vector<pair<int, Color>>> graph(n);  // graph[u] := [(v, edgeColor)]\n    queue<pair<int, Color>> q{{{0, Color::kInit}}};  // [(u, prevColor)]\n\n    for (const vector<int>& edge : redEdges) {\n      const int u = edge[0];\n      const int v = edge[1];\n      graph[u].emplace_back(v, Color::kRed);\n    }\n\n    for (const vector<int>& edge : blueEdges) {\n      const int u = edge[0];\n      const int v = edge[1];\n      graph[u].emplace_back(v, Color::kBlue);\n    }\n\n    for (int step = 0; !q.empty(); ++step)\n      for (int sz = q.size(); sz > 0; --sz) {\n        const auto [u, prevColor] = q.front();\n        q.pop();\n        ans[u] = ans[u] == -1 ? step : ans[u];\n        for (auto& [v, edgeColor] : graph[u]) {\n          if (v == -1 || edgeColor == prevColor)\n            continue;\n          q.emplace(v, edgeColor);\n          v = -1;  // Mark (u, v) as used.\n        }\n      }\n\n    return ans;\n  }\n};",
        "explanation": "Intuition :\nHere we are given a graph with two types of edges (red and blue), the goal is to find the shortest path from node 0 to every other node such that no two consecutive edges have the same color.\nExplanation to Approach :\nSo we are using a breadth-first search (BFS) algorithm to traverse the graph, keeping track of the distance from node 0 to every other node and the previous edge color.\nThe graph is represented as an adjacency list, where graph[u] is a list of pairs (v, edgeColor) representing an edge from node u to node v with color edgeColor.\nThe BFS algorithm starts from node 0 and adds node v to the queue if it is not visited yet or if the color of the edge from u to v is different from the previous edge color.\nThe distance from node 0 to node v is incremented in each step.\nThe ans array is updated with the minimum distance found so far to each node. If a node is visited again, its distance in ans is not updated.\nThe algorithm terminates when the queue is empty, meaning that all reachable nodes have been visited.\nIf a node is not visited, its distance in ans remains -1, indicating that it is not reachable from node 0.\nComplexity :\nTime complexity : O(n)\nSpace complexity : O(n)"
    },
    {
        "question_id": "dd2ad649-eb7a-4433-abc0-950a29725154",
        "title": "Maximum Candies You Can Get from Boxes",
        "difficulty": "Hard",
        "category": "Array Breadth-First Search Graph",
        "question_text": "You have n boxes labeled from 0 to n - 1. You are given four arrays: status, candies, keys, and containedBoxes where:\n\nstatus[i] is 1 if the ith box is open and 0 if the ith box is closed,\ncandies[i] is the number of candies in the ith box,\nkeys[i] is a list of the labels of the boxes you can open after opening the ith box.\ncontainedBoxes[i] is a list of the boxes you found inside the ith box.\nYou are given an integer array initialBoxes that contains the labels of the boxes you initially have. You can take all the candies in any open box and you can use the keys in it to open new boxes and you also can use the boxes you find in it.\n\nReturn the maximum number of candies you can get following the rules above.\n\n \n\nExample 1:\n\nInput: status = [1,0,1,0], candies = [7,5,4,100], keys = [[],[],[1],[]], containedBoxes = [[1,2],[3],[],[]], initialBoxes = [0]\nOutput: 16\nExplanation: You will be initially given box 0. You will find 7 candies in it and boxes 1 and 2.\nBox 1 is closed and you do not have a key for it so you will open box 2. You will find 4 candies and a key to box 1 in box 2.\nIn box 1, you will find 5 candies and box 3 but you will not find a key to box 3 so box 3 will remain closed.\nTotal number of candies collected = 7 + 4 + 5 = 16 candy.\nExample 2:\n\nInput: status = [1,0,0,0,0,0], candies = [1,1,1,1,1,1], keys = [[1,2,3,4,5],[],[],[],[],[]], containedBoxes = [[1,2,3,4,5],[],[],[],[],[]], initialBoxes = [0]\nOutput: 6\nExplanation: You have initially box 0. Opening it you can find boxes 1,2,3,4 and 5 and their keys.\nThe total number of candies will be 6.\n \n\nConstraints:\n\nn == status.length == candies.length == keys.length == containedBoxes.length\n1 <= n <= 1000\nstatus[i] is either 0 or 1.\n1 <= candies[i] <= 1000\n0 <= keys[i].length <= n\n0 <= keys[i][j] < n\nAll values of keys[i] are unique.\n0 <= containedBoxes[i].length <= n\n0 <= containedBoxes[i][j] < n\nAll values of containedBoxes[i] are unique.\nEach box is contained in one box at most.\n0 <= initialBoxes.length <= n\n0 <= initialBoxes[i] < n",
        "solution": "class Solution {\npublic:\n    int maxCandies(vector<int>& status, vector<int>& candies, vector<vector<int>>& keys, vector<vector<int>>& containedBoxes, vector<int>& initialBoxes) \n    {\n        queue<int> q;\n        int result=0;\n        vector<bool> reachableClosedBoxes(status.size(),false);  //Only used to store boxes that are reached but closed.\n        for(int &i:initialBoxes)            //Push initial boxes that we can open in the queue.\n            if(status[i])\n                q.push(i);\n            else\n                reachableClosedBoxes[i]=true;\n        while(!q.empty())                   //Continue until no more boxes are left that can be opened.\n        {\n            result+=candies[q.front()];\t\t\t//Add candies we got.\n            for(int &i:keys[q.front()])\t\t\t\t//Open the box whose keys are found.\n            {\n                if(!status[i]&&reachableClosedBoxes[i])//If the box was previously closed and we already reached it,use it as an open box\n                    q.push(i);\n                status[i]=1;\n            }\n            for(int &i:containedBoxes[q.front()])\t\t//Push all the boxes within this box for then next cycle in the queue.\n                if(status[i])\n                    q.push(i);\n                else\n                    reachableClosedBoxes[i]=true;      //The box is closed, wait until we get the keys for this box.\n            q.pop();\n        }\n        return result;\n    }\n};",
        "explanation": "Observation\n\nTry and visualize how you'd proceed if this was a real life scenario\n\nWe would first open all the initial boxes.\nOpen all the boxes who's keys are present in these boxes, add all the candies in these opened boxes and queue up all the boxes that were inside these boxes.\nWe now move to the new boxes that we just got and repeat the same process for these with only difference that if these are closed and we don't have the keys to it we store it for opening later just in case we find the keys for these in a box later.\nWe stop when all the boxes are either opened or all the boxes left are closed and we don't have the keys for any of them.\nWe can thus use a simple queue to simulate the process in a BFS fashion.\n\nSolution\nInspired by comment from @StefanPochmann below.\nThis is updated to avoid the worst case when keys of i are contained in i+1. However due to the keys which can be duplicate inside each box we still might look at all the keys again and again after opening every box, thus not reducing the time complexity.\nSpace: O(n).\nTime: O(n^2). Since we can have duplicate keys in different boxes."
    },
    {
        "question_id": "42673741-bac1-4144-8888-976814c2655f",
        "title": "Number of Ways to Arrive at Destination",
        "difficulty": "Medium",
        "category": "Dynamic Programming Graph Topological Sort Shortest Path",
        "question_text": "You are in a city that consists of n intersections numbered from 0 to n - 1 with bi-directional roads between some intersections. The inputs are generated such that you can reach any intersection from any other intersection and that there is at most one road between any two intersections.\n\nYou are given an integer n and a 2D integer array roads where roads[i] = [ui, vi, timei] means that there is a road between intersections ui and vi that takes timei minutes to travel. You want to know in how many ways you can travel from intersection 0 to intersection n - 1 in the shortest amount of time.\n\nReturn the number of ways you can arrive at your destination in the shortest amount of time. Since the answer may be large, return it modulo 109 + 7.\n\n \n\nExample 1:\nInput: n = 7, roads = [[0,6,7],[0,1,2],[1,2,3],[1,3,3],[6,3,3],[3,5,1],[6,5,1],[2,5,1],[0,4,5],[4,6,2]]\nOutput: 4\nExplanation: The shortest amount of time it takes to go from intersection 0 to intersection 6 is 7 minutes.\nThe four ways to get there in 7 minutes are:\n- 0 ➝ 6\n- 0 ➝ 4 ➝ 6\n- 0 ➝ 1 ➝ 2 ➝ 5 ➝ 6\n- 0 ➝ 1 ➝ 3 ➝ 5 ➝ 6\nExample 2:\n\nInput: n = 2, roads = [[1,0,10]]\nOutput: 1\nExplanation: There is only one way to go from intersection 0 to intersection 1, and it takes 10 minutes.\n \n\nConstraints:\n\n1 <= n <= 200\nn - 1 <= roads.length <= n * (n - 1) / 2\nroads[i].length == 3\n0 <= ui, vi <= n - 1\n1 <= timei <= 109\nui != vi\nThere is at most one road connecting any two intersections.\nYou can reach any intersection from any other intersection.",
        "solution": "Input: n = 7, roads = [[0,6,7],[0,1,2],[1,2,3],[1,3,3],[6,3,3],[3,5,1],[6,5,1],[2,5,1],[0,4,5],[4,6,2]]\nOutput: 4\nExplanation: The shortest amount of time it takes to go from intersection 0 to intersection 6 is 7 minutes.\nThe four ways to get there in 7 minutes are:\n- 0 ➝ 6\n- 0 ➝ 4 ➝ 6\n- 0 ➝ 1 ➝ 2 ➝ 5 ➝ 6\n- 0 ➝ 1 ➝ 3 ➝ 5 ➝ 6\nExample 2:\n\nInput: n = 2, roads = [[1,0,10]]\nOutput: 1\nExplanation: There is only one way to go from intersection 0 to intersection 1, and it takes 10 minutes.\n \n\nConstraints:\n\n1 <= n <= 200\nn - 1 <= roads.length <= n * (n - 1) / 2\nroads[i].length == 3\n0 <= ui, vi <= n - 1\n1 <= timei <= 109\nui != vi\nThere is at most one road connecting any two intersections.\nYou can reach any intersection from any other intersection.",
        "explanation": "Algorithm\nDefine MOD = 1e9 + 7 for modular arithmetic.\n\nBuild an adjacency list graph where graph[i] stores {neighbor, travelTime} pairs.\n\nInitialize a min-heap (minHeap) for Dijkstra's algorithm.\n\nCreate shortestTime array to store the shortest time to each node, initialized to LLONG_MAX (or its equivalent in other preferred languages).\n\nCreate pathCount array to store the number of shortest paths to each node, initialized to 0.\n\nSet shortestTime[0] = 0 and pathCount[0] = 1 (starting node has distance 0 and one valid path).\n\nPush {0, 0} into minHeap to start processing.\n\nWhile minHeap is not empty:\n\nExtract the node currNode with the current shortest known time currTime.\nIf currTime > shortestTime[currNode], skip outdated distances.\nIterate over neighbors of currNode:\nIf a new shortest path is found:\nUpdate shortestTime[neighborNode].\nReset pathCount[neighborNode] to match pathCount[currNode].\nPush {shortestTime[neighborNode], neighborNode} into minHeap.\nIf an equally short path is found:\nAdd pathCount[currNode] to pathCount[neighborNode], modulo MOD.\nReturn pathCount[n - 1], the number of shortest paths to the last node.\n\nImplementation\nTime-saving coding tip:\n\nWhenever a problem involves calculating distances or counting paths, it's a good idea to use long long (or an equivalent large integer type) and apply the modulo operator when required. This helps prevent integer overflow and ensures accurate results, especially in graph and dynamic programming problems.\nComplexity Analysis\nLet N be the number of nodes in the graph and E be the number of edges in the given road connections.\n\nTime Complexity: O(N+ElogE)\n\nBuilding the adjacency list takes O(E) time, since we iterate over all the edges once.\n\nThe main part of the algorithm is Dijkstra’s algorithm using a min-heap. In this implementation, a node can be added to the heap multiple times (if a shorter path to it is found later). For each edge, we may perform a heap insertion, and the heap can grow up to size O(E) in the worst case. Each insertion or extraction from the heap takes O(logE) time. Thus, the total time spent on heap operations is O(ElogE).\n\nCombining both parts, the overall time complexity is: O(E)+O(ElogE)=O(N+ElogE).\n\nSpace complexity: O(N+E)\n\nThe adjacency list stores O(2⋅E) edges, but it requires O(N+2E)≈O(N+E) space in total, as it also includes the N nodes in the outer list. The priority queue stores at most O(N) elements at any time. Additionally, the shortestTime and pathCount arrays require O(N) space. Since the total space used is dominated by O(N+E) for storing the graph, the overall space complexity is O(N+E).\n\nOther auxiliary variables, such as integers and loop variables, contribute O(1) space, which is negligible compared to O(N+E). Therefore, the dominant space complexity remains O(N+E)."
    },
    {
        "question_id": "51051ad3-1813-4ddc-b665-1298037fdd70",
        "title": "Number of Ways to Arrive at Destination",
        "difficulty": "Medium",
        "category": "Dynamic Programming Graph Topological Sort Shortest Path",
        "question_text": "You are in a city that consists of n intersections numbered from 0 to n - 1 with bi-directional roads between some intersections. The inputs are generated such that you can reach any intersection from any other intersection and that there is at most one road between any two intersections.\n\nYou are given an integer n and a 2D integer array roads where roads[i] = [ui, vi, timei] means that there is a road between intersections ui and vi that takes timei minutes to travel. You want to know in how many ways you can travel from intersection 0 to intersection n - 1 in the shortest amount of time.\n\nReturn the number of ways you can arrive at your destination in the shortest amount of time. Since the answer may be large, return it modulo 109 + 7.\n\n \n\nExample 1:\nInput: n = 7, roads = [[0,6,7],[0,1,2],[1,2,3],[1,3,3],[6,3,3],[3,5,1],[6,5,1],[2,5,1],[0,4,5],[4,6,2]]\nOutput: 4\nExplanation: The shortest amount of time it takes to go from intersection 0 to intersection 6 is 7 minutes.\nThe four ways to get there in 7 minutes are:\n- 0 ➝ 6\n- 0 ➝ 4 ➝ 6\n- 0 ➝ 1 ➝ 2 ➝ 5 ➝ 6\n- 0 ➝ 1 ➝ 3 ➝ 5 ➝ 6\nExample 2:\n\nInput: n = 2, roads = [[1,0,10]]\nOutput: 1\nExplanation: There is only one way to go from intersection 0 to intersection 1, and it takes 10 minutes.\n \n\nConstraints:\n\n1 <= n <= 200\nn - 1 <= roads.length <= n * (n - 1) / 2\nroads[i].length == 3\n0 <= ui, vi <= n - 1\n1 <= timei <= 109\nui != vi\nThere is at most one road connecting any two intersections.\nYou can reach any intersection from any other intersection.",
        "solution": "class Solution {\npublic:\n    int countPaths(int n, vector<vector<int>>& roads) {\n        const int MOD = 1e9 + 7;\n\n        // Build adjacency list\n        vector<vector<pair<int, int>>> graph(n);\n        for (auto& road : roads) {\n            int startNode = road[0], endNode = road[1], travelTime = road[2];\n            graph[startNode].emplace_back(endNode, travelTime);\n            graph[endNode].emplace_back(startNode, travelTime);\n        }\n\n        // Min-Heap (priority queue) for Dijkstra\n        priority_queue<pair<long long, int>, vector<pair<long long, int>>,\n                       greater<>>\n            minHeap;\n\n        // Store shortest time to each node\n        vector<long long> shortestTime(n, LLONG_MAX);\n        // Number of ways to reach each node in shortest time\n        vector<int> pathCount(n, 0);\n\n        shortestTime[0] = 0;  // Distance to source is 0\n        pathCount[0] = 1;     // 1 way to reach node 0\n\n        minHeap.emplace(0, 0);  // {time, node}\n\n        while (!minHeap.empty()) {\n            long long currTime = minHeap.top().first;  // Current shortest time\n            int currNode = minHeap.top().second;\n            minHeap.pop();\n\n            // Skip outdated distances\n            if (currTime > shortestTime[currNode]) continue;\n\n            for (auto& [neighborNode, roadTime] : graph[currNode]) {\n                // Found a new shortest path → Update shortest time and reset\n                // path count\n                if (currTime + roadTime < shortestTime[neighborNode]) {\n                    shortestTime[neighborNode] = currTime + roadTime;\n                    pathCount[neighborNode] = pathCount[currNode];\n                    minHeap.emplace(shortestTime[neighborNode], neighborNode);\n                }\n                // Found another way with the same shortest time → Add to path\n                // count\n                else if (currTime + roadTime == shortestTime[neighborNode]) {\n                    pathCount[neighborNode] =\n                        (pathCount[neighborNode] + pathCount[currNode]) % MOD;\n                }\n            }\n        }\n\n        return pathCount[n - 1];\n    }\n};",
        "explanation": "Algorithm\nDefine MOD = 1e9 + 7 for modular arithmetic.\n\nBuild an adjacency list graph where graph[i] stores {neighbor, travelTime} pairs.\n\nInitialize a min-heap (minHeap) for Dijkstra's algorithm.\n\nCreate shortestTime array to store the shortest time to each node, initialized to LLONG_MAX (or its equivalent in other preferred languages).\n\nCreate pathCount array to store the number of shortest paths to each node, initialized to 0.\n\nSet shortestTime[0] = 0 and pathCount[0] = 1 (starting node has distance 0 and one valid path).\n\nPush {0, 0} into minHeap to start processing.\n\nWhile minHeap is not empty:\n\nExtract the node currNode with the current shortest known time currTime.\nIf currTime > shortestTime[currNode], skip outdated distances.\nIterate over neighbors of currNode:\nIf a new shortest path is found:\nUpdate shortestTime[neighborNode].\nReset pathCount[neighborNode] to match pathCount[currNode].\nPush {shortestTime[neighborNode], neighborNode} into minHeap.\nIf an equally short path is found:\nAdd pathCount[currNode] to pathCount[neighborNode], modulo MOD.\nReturn pathCount[n - 1], the number of shortest paths to the last node.\n\nImplementation\nTime-saving coding tip:\n\nWhenever a problem involves calculating distances or counting paths, it's a good idea to use long long (or an equivalent large integer type) and apply the modulo operator when required. This helps prevent integer overflow and ensures accurate results, especially in graph and dynamic programming problems."
    },
    {
        "question_id": "cd74b8f9-f380-4506-b66c-9a74e820a765",
        "title": "Find Closest Node to Given Two Nodes",
        "difficulty": "Medium",
        "category": "Depth-First Search Graph",
        "question_text": "You are given a directed graph of n nodes numbered from 0 to n - 1, where each node has at most one outgoing edge.\n\nThe graph is represented with a given 0-indexed array edges of size n, indicating that there is a directed edge from node i to node edges[i]. If there is no outgoing edge from i, then edges[i] == -1.\n\nYou are also given two integers node1 and node2.\n\nReturn the index of the node that can be reached from both node1 and node2, such that the maximum between the distance from node1 to that node, and from node2 to that node is minimized. If there are multiple answers, return the node with the smallest index, and if no possible answer exists, return -1.\n\nNote that edges may contain cycles.\n\n \n\nExample 1:\nInput: edges = [2,2,3,-1], node1 = 0, node2 = 1\nOutput: 2\nExplanation: The distance from node 0 to node 2 is 1, and the distance from node 1 to node 2 is 1.\nThe maximum of those two distances is 1. It can be proven that we cannot get a node with a smaller maximum distance than 1, so we return node 2.\nExample 2:\nInput: edges = [1,2,-1], node1 = 0, node2 = 2\nOutput: 2\nExplanation: The distance from node 0 to node 2 is 2, and the distance from node 2 to itself is 0.\nThe maximum of those two distances is 2. It can be proven that we cannot get a node with a smaller maximum distance than 2, so we return node 2.\n \n\nConstraints:\n\nn == edges.length\n2 <= n <= 105\n-1 <= edges[i] < n\nedges[i] != i\n0 <= node1, node2 < n",
        "solution": "class Solution {\npublic:\n    void bfs(int startNode, vector<int>& edges, vector<int>& dist) {\n        int n = edges.size();\n        queue<int> q;\n        q.push(startNode);\n\n        vector<bool> visit(n);\n        dist[startNode] = 0;\n\n        while (!q.empty()) {\n            int node = q.front();\n            q.pop();\n\n            if (visit[node]) {\n                continue;\n            }\n\n            visit[node] = true;\n            int neighbor = edges[node];\n            if (neighbor != -1 && !visit[neighbor]) {\n                dist[neighbor] = 1 + dist[node];\n                q.push(neighbor);\n            }\n        }\n    }\n\n    int closestMeetingNode(vector<int>& edges, int node1, int node2) {\n        int n = edges.size();\n        vector<int> dist1(n, numeric_limits<int>::max()), dist2(n, numeric_limits<int>::max());\n\n        bfs(node1, edges, dist1);\n        bfs(node2, edges, dist2);\n\n        int minDistNode = -1, minDistTillNow = numeric_limits<int>::max();\n        for (int currNode = 0; currNode < n; currNode++) {\n            if (minDistTillNow > max(dist1[currNode], dist2[currNode])) {\n                minDistNode = currNode;\n                minDistTillNow = max(dist1[currNode], dist2[currNode]);\n            }\n        }\n\n        return minDistNode;\n    }\n};",
        "explanation": "Algorithm\nInitialize two arrays, dist1 and dist2 storing the shortest distances from node1 and node2 to all the nodes. Initialize them with large values.\nStart a BFS traversal.\nWe use a function bfs to perform the traversal. It requires startNode, edges, dist as the parameters, where dist is the array that stores the shortest distances from startNode to all the nodes.\nStart with node1, edges, dist1.\nInitialize a queue with startNode in the queue.\nInitialize an array visit, storing a boolean for each node to indicate if a node is visited. Initialize it with false for all the nodes.\nThen, while the queue is not empty:\nDequeue the first node from the queue. If it has not been visited, mark it as visited. Otherwise, if it has been visited, repeat step 4.\nCheck if node has an outgoing edge. If there is no outgoing edge, we don't do anything.\nIf the node has an outgoing edge to another node called neighbor, and neighbor has not yet been visited, update the dist[neighbor] to dist[neighbor] = 1 + dist[node] and push the neighbor into the queue.\nPerform another BFS traversal with node2, edges, dist2 to get the shortest distances from node2 to every other node in dist2.\nInitialize two variables: minDistNode = -1, which is the answer to our problem, and minDistTillNow, which is the maximum between the distances from node1 to minDistNode and from node2 to minDistNode.\nRun a loop over all the nodes and check each node called currNode.\nIf minDistTillNow > max(dist1[currNode], dist2[currNode]), update minDistTillNow to minDistTillNow = max(dist1[currNode], dist2[currNode]) and update minDistNode to minDistNode = currNode.\nOtherwise, we do not update anything.\nReturn minDistNode."
    },
    {
        "question_id": "a263247e-b762-4730-aed6-f8bd3354271f",
        "title": "Find Two Non-overlapping Sub-arrays Each With Target Sum",
        "difficulty": "Medium",
        "category": "Array Hash Table Binary Search Dynamic Programming Sliding Windos",
        "question_text": "You are given an array of integers arr and an integer target.\n\nYou have to find two non-overlapping sub-arrays of arr each with a sum equal target. There can be multiple answers so you have to find an answer where the sum of the lengths of the two sub-arrays is minimum.\n\nReturn the minimum sum of the lengths of the two required sub-arrays, or return -1 if you cannot find such two sub-arrays.\n\n \n\nExample 1:\n\nInput: arr = [3,2,2,4,3], target = 3\nOutput: 2\nExplanation: Only two sub-arrays have sum = 3 ([3] and [3]). The sum of their lengths is 2.\nExample 2:\n\nInput: arr = [7,3,4,7], target = 7\nOutput: 2\nExplanation: Although we have three non-overlapping sub-arrays of sum = 7 ([7], [3,4] and [7]), but we will choose the first and third sub-arrays as the sum of their lengths is 2.\nExample 3:\n\nInput: arr = [4,3,2,6,2,3,4], target = 6\nOutput: -1\nExplanation: We have only one sub-array of sum = 6.\n \n\nConstraints:\n\n1 <= arr.length <= 105\n1 <= arr[i] <= 1000\n1 <= target <= 108",
        "solution": "class Solution {\n    public int minSumOfLengths(int[] arr, int target) {\n        HashMap<Integer,Integer> hmap=new HashMap<>();\n        int sum=0,lsize=Integer.MAX_VALUE,result=Integer.MAX_VALUE;\n        hmap.put(0,-1);\n        for(int i=0;i<arr.length;i++){\n            sum+=arr[i];\n            hmap.put(sum,i); // stores key as sum upto index i, and value as i.\n        }\n        sum=0;\n        for(int i=0;i<arr.length;i++){\n            sum+=arr[i];\n            if(hmap.get(sum-target)!=null){\n                lsize=Math.min(lsize,i-hmap.get(sum-target));      // stores minimum length of sub-array ending with index<= i with sum target. This ensures non- overlapping property.\n            }\n\t\t\t//hmap.get(sum+target) searches for any sub-array starting with index i+1 with sum target.\n            if(hmap.get(sum+target)!=null&&lsize<Integer.MAX_VALUE){\n                result=Math.min(result,hmap.get(sum+target)-i+lsize); // updates the result only if both left and right sub-array exists.\n            }\n        }\n        return result==Integer.MAX_VALUE?-1:result;\n    }\n}",
        "explanation": "Concept: First traverse through the array once and store the (key,value) pair as (sum(arr[0:i+1]),i) for 0<=i<size of arr. Put, (0,-1) in hashmap as default. Now traverse through the array again, and for every i, find the minimum value of length of sub-array on the left or starting with i whose value is equal to target. Find another sub-array starting with i+1, whose sum is target. Update the result with the minimum value of the sum of both the sub-array. This is possible because all values are positive and the value of sum is strictly increasing."
    },
    {
        "question_id": "6c64c3df-0642-4ac9-b8b9-0a12c97e2554",
        "title": "Count Numbers with Unique Digits",
        "difficulty": "Medium",
        "category": "Math Dynamic Programming Backtracking",
        "question_text": "Given an integer n, return the count of all numbers with unique digits, x, where 0 <= x < 10n.\n\n \n\nExample 1:\n\nInput: n = 2\nOutput: 91\nExplanation: The answer should be the total numbers in the range of 0 ≤ x < 100, excluding 11,22,33,44,55,66,77,88,99\nExample 2:\n\nInput: n = 0\nOutput: 1\n \n\nConstraints:\n\n0 <= n <= 8",
        "solution": "public int countNumbersWithUniqueDigits(int n) {\n        if (n == 0)     return 1;\n        \n        int res = 10;\n        int uniqueDigits = 9;\n        int availableNumber = 9;\n        while (n-- > 1 && availableNumber > 0) {\n            uniqueDigits = uniqueDigits * availableNumber;\n            res += uniqueDigits;\n            availableNumber--;\n        }\n        return res;\n    }",
        "explanation": "Following the hint. Let f(n) = count of number with unique digits of length n.\n\nf(1) = 10. (0, 1, 2, 3, ...., 9)\n\nf(2) = 9 * 9. Because for each number i from 1, ..., 9, we can pick j to form a 2-digit number ij and there are 9 numbers that are different from i for j to choose from.\n\nf(3) = f(2) * 8 = 9 * 9 * 8. Because for each number with unique digits of length 2, say ij, we can pick k to form a 3 digit number ijk and there are 8 numbers that are different from i and j for k to choose from.\n\nSimilarly f(4) = f(3) * 7 = 9 * 9 * 8 * 7....\n\n...\n\nf(10) = 9 * 9 * 8 * 7 * 6 * ... * 1\n\nf(11) = 0 = f(12) = f(13)....\n\nany number with length > 10 couldn't be unique digits number.\n\nThe problem is asking for numbers from 0 to 10^n. Hence return f(1) + f(2) + .. + f(n)\n\nAs @4acreg suggests, There are only 11 different ans. You can create a lookup table for it. This problem is O(1) in essence."
    }
]