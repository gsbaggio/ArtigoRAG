class Solution:
    def largestMagicSquare(self, grid: list[list[int]]) -> int:
        """
        Finds the size of the largest magic square within a given grid.

        The approach iterates through all possible square subgrids within the given grid,
        starting from the largest possible size and decreasing to 1. For each square subgrid,
        it checks if it is a magic square by verifying that all row sums, column sums, and
        diagonal sums are equal. The first magic square found (largest size) is returned.

        Time Complexity: O(min(m, n)^3 * m * n), where m and n are the dimensions of the grid.
        The min(m, n)^3 factor comes from iterating through all possible square sizes and positions.
        The m * n factor comes from calculating the row, column and diagonal sums for each square.

        Space Complexity: O(1). The algorithm uses a constant amount of extra space.

        Important Considerations:
        - The algorithm efficiently checks for magic squares by starting with the largest possible
          size and decreasing. This allows early termination once a magic square is found.
        - The row, column, and diagonal sums are calculated directly from the grid, avoiding the
          need for extra storage.
        """
        m = len(grid)
        n = len(grid[0])
        max_size = min(m, n)

        for size in range(max_size, 0, -1):
            for row in range(m - size + 1):
                for col in range(n - size + 1):
                    if self.isMagicSquare(grid, row, col, size):
                        return size
        return 1  # Every 1x1 grid is a magic square

    def isMagicSquare(self, grid: list[list[int]], row_start: int, col_start: int, size: int) -> bool:
        """
        Checks if a square subgrid within the given grid is a magic square.

        It calculates the sums of all rows, columns, and diagonals and compares them to
        determine if they are all equal.

        Time Complexity: O(size^2), where size is the size of the square subgrid.

        Space Complexity: O(1). The algorithm uses a constant amount of extra space.
        """
        magic_sum = -1

        # Check rows
        for i in range(row_start, row_start + size):
            row_sum = sum(grid[i][col_start:col_start + size])
            if magic_sum == -1:
                magic_sum = row_sum
            elif magic_sum != row_sum:
                return False

        # Check columns
        for j in range(col_start, col_start + size):
            col_sum = 0
            for i in range(row_start, row_start + size):
                col_sum += grid[i][j]
            if magic_sum != col_sum:
                return False

        # Check main diagonal
        diag_sum1 = 0
        for i in range(size):
            diag_sum1 += grid[row_start + i][col_start + i]
        if magic_sum != diag_sum1:
            return False

        # Check anti-diagonal
        diag_sum2 = 0
        for i in range(size):
            diag_sum2 += grid[row_start + i][col_start + size - 1 - i]
        if magic_sum != diag_sum2:
            return False

        return True