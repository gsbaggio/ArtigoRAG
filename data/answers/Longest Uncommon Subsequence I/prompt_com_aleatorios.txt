CURRENT QUESTION:
Given two strings a and b, return the length of the longest uncommon subsequence between a and b. If no such uncommon subsequence exists, return -1.

An uncommon subsequence between two strings is a string that is a subsequence of exactly one of them.

 

Example 1:

Input: a = "aba", b = "cdc"
Output: 3
Explanation: One longest uncommon subsequence is "aba" because "aba" is a subsequence of "aba" but not "cdc".
Note that "cdc" is also a longest uncommon subsequence.
Example 2:

Input: a = "aaa", b = "bbb"
Output: 3
Explanation: The longest uncommon subsequences are "aaa" and "bbb".
Example 3:

Input: a = "aaa", b = "aaa"
Output: -1
Explanation: Every subsequence of string a is also a subsequence of string b. Similarly, every subsequence of string b is also a subsequence of string a. So the answer would be -1.
 

Constraints:

1 <= a.length, b.length <= 100
a and b consist of lower-case English letters.

EXAMPLE QUESTIONS:
Example question 1:
Title: Sum of Subsequence Widths
Categorys: Array Math Sorting
Question text: The width of a sequence is the difference between the maximum and minimum elements in the sequence.

Given an array of integers nums, return the sum of the widths of all the non-empty subsequences of nums. Since the answer may be very large, return it modulo 109 + 7.

A subsequence is a sequence that can be derived from an array by deleting some or no elements without changing the order of the remaining elements. For example, [3,6,2,7] is a subsequence of the array [0,3,1,6,2,2,7].

 

Example 1:

Input: nums = [2,1,3]
Output: 6
Explanation: The subsequences are [1], [2], [3], [2,1], [2,3], [1,3], [2,1,3].
The corresponding widths are 0, 0, 0, 1, 1, 2, 2.
The sum of these widths is 6.
Example 2:

Input: nums = [2]
Output: 0
 

Constraints:

1 <= nums.length <= 105
1 <= nums[i] <= 105
Solution: class Solution {
    public int sumSubseqWidths(int[] A) {
        int MOD = 1_000_000_007;
        int N = A.length;
        Arrays.sort(A);

        long[] pow2 = new long[N];
        pow2[0] = 1;
        for (int i = 1; i < N; ++i)
            pow2[i] = pow2[i-1] * 2 % MOD;

        long ans = 0;
        for (int i = 0; i < N; ++i)
            ans = (ans + (pow2[i] - pow2[N-1-i]) * A[i]) % MOD;

        return (int) ans;
    }
}
Explanation: Mathematical
Intuition

Let's try to count the number of subsequences with minimum A[i] and maximum A[j].

Algorithm

We can sort the array as it doesn't change the answer. After sorting the array, this allows us to know that the number of subsequences with minimum A[i] and maximum A[j] is 2 
j−i−1
 . Hence, the desired answer is:

j>i
∑
​
 (2 
j−i−1
 )(A 
j
​
 −A 
i
​
 )

=( 
i=0
∑
n−2
​
  
j=i+1
∑
n−1
​
 (2 
j−i−1
 )(A 
j
​
 ))−( 
i=0
∑
n−2
​
  
j=i+1
∑
n−1
​
 (2 
j−i−1
 )(A 
i
​
 ))

=((2 
0
 A 
1
​
 +2 
1
 A 
2
​
 +2 
2
 A 
3
​
 +⋯)+(2 
0
 A 
2
​
 +2 
1
 A 
3
​
 +⋯)+(2 
0
 A 
3
​
 +2 
1
 A 
4
​
 +⋯)+⋯)
−( 
i=0
∑
n−2
​
 (2 
0
 +2 
1
 +⋯+2 
N−i−2
 )(A 
i
​
 ))

=( 
j=1
∑
n−1
​
 (2 
j
 −1)A 
j
​
 )−( 
i=0
∑
n−2
​
 (2 
N−i−1
 −1)A 
i
​
 )

= 
i=0
∑
n−1
​
 (((2 
i
 −1)A 
i
​
 )−((2 
N−i−1
 −1)A 
i
​
 ))

= 
i=0
∑
n−1
​
 (2 
i
 −2 
N−i−1
 )A 
i
​


        INSTRUCTIONS:
        Solve the current question.
        Provide:
        1. A complete and efficient code solution, optimized for both time and space complexity.
        2. A detailed explanation of the solution, including:
           - The intuition behind the approach;
           - Time and space complexity;
           - Important considerations about the algorithm.
        3. If the language has classes, implement in 'Solution' class. Any language is accepted.
        4. You can use the example questions as general references for coding patterns and structure, but solve the current problem independently.
        5. Don't use any external libraries. Don't need to import any libraries.
