public class Solution {
    public int calculate(String s) {
        Stack<Integer> stack = new Stack<>();
        int result = 0;
        int number = 0;
        int sign = 1;

        for (int i = 0; i < s.length(); i++) {
            char c = s.charAt(i);
            if (Character.isDigit(c)) {
                number = 10 * number + (int)(c - '0');
            } else if (c == '+') {
                result += sign * number;
                number = 0;
                sign = 1;
            } else if (c == '-') {
                result += sign * number;
                number = 0;
                sign = -1;
            } else if (c == '(') {
                stack.push(result);
                stack.push(sign);
                sign = 1;
                result = 0;
            } else if (c == ')') {
                result += sign * number;
                number = 0;
                result *= stack.pop();
                result += stack.pop();
            }
        }

        if (number != 0) {
            result += sign * number;
        }

        return result;
    }
}

Explanation:

We iterate through the expression string character by character.
If the character is a digit, we build up the number.
When we encounter an operator (+ or -), we update the result based on the current sign and number, and reset number for the next operand.
When encountering an opening parenthesis '(', we push the current result and sign onto the stack and reset result for the expression within the parentheses.
When encountering a closing parenthesis ')', we calculate the result within the parentheses, pop the sign and previous result from the stack, and update the result.
Finally, we handle the case where there's a number at the end of the expression string.
Time Complexity: O(n), where n is the length of the input string.
Space Complexity: O(n), where n is the length of the input string (used for the stack).

This solution efficiently evaluates the expression while following the order of operations and considering parentheses.