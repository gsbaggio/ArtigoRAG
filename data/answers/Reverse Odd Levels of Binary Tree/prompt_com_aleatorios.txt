CURRENT QUESTION:
Given the root of a perfect binary tree, reverse the node values at each odd level of the tree.

For example, suppose the node values at level 3 are [2,1,3,4,7,11,29,18], then it should become [18,29,11,7,4,3,1,2].
Return the root of the reversed tree.

A binary tree is perfect if all parent nodes have two children and all leaves are on the same level.

The level of a node is the number of edges along the path between it and the root node.

 

Example 1:
Input: root = [2,3,5,8,13,21,34]
Output: [2,5,3,8,13,21,34]
Explanation: 
The tree has only one odd level.
The nodes at level 1 are 3, 5 respectively, which are reversed and become 5, 3.
Example 2:
Input: root = [7,13,11]
Output: [7,11,13]
Explanation: 
The nodes at level 1 are 13, 11, which are reversed and become 11, 13.
Example 3:

Input: root = [0,1,2,0,0,0,0,1,1,1,1,2,2,2,2]
Output: [0,2,1,0,0,0,0,2,2,2,2,1,1,1,1]
Explanation: 
The odd levels have non-zero values.
The nodes at level 1 were 1, 2, and are 2, 1 after the reversal.
The nodes at level 3 were 1, 1, 1, 1, 2, 2, 2, 2, and are 2, 2, 2, 2, 1, 1, 1, 1 after the reversal.
 

Constraints:

The number of nodes in the tree is in the range [1, 214].
0 <= Node.val <= 105
root is a perfect binary tree.

EXAMPLE QUESTIONS:
Example question 1:
Title: Roman to Integer
Categorys: Hash Table Math String
Question text: Roman numerals are represented by seven different symbols: I, V, X, L, C, D and M.

Symbol       Value
I             1
V             5
X             10
L             50
C             100
D             500
M             1000
For example, 2 is written as II in Roman numeral, just two ones added together. 12 is written as XII, which is simply X + II. The number 27 is written as XXVII, which is XX + V + II.

Roman numerals are usually written largest to smallest from left to right. However, the numeral for four is not IIII. Instead, the number four is written as IV. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as IX. There are six instances where subtraction is used:

I can be placed before V (5) and X (10) to make 4 and 9. 
X can be placed before L (50) and C (100) to make 40 and 90. 
C can be placed before D (500) and M (1000) to make 400 and 900.
Given a roman numeral, convert it to an integer.

 

Example 1:

Input: s = "III"
Output: 3
Explanation: III = 3.
Example 2:

Input: s = "LVIII"
Output: 58
Explanation: L = 50, V= 5, III = 3.
Example 3:

Input: s = "MCMXCIV"
Output: 1994
Explanation: M = 1000, CM = 900, XC = 90 and IV = 4.
 

Constraints:

1 <= s.length <= 15
s contains only the characters ('I', 'V', 'X', 'L', 'C', 'D', 'M').
It is guaranteed that s is a valid roman numeral in the range [1, 3999].
Solution: class Solution {
public:
    int romanToInt(string s) {
        int res = 0;
        unordered_map<char, int> roman = {
            {'I', 1},
            {'V', 5},
            {'X', 10}, 
            {'L', 50},
            {'C', 100},
            {'D', 500},
            {'M', 1000}
        };

        for (int i = 0; i < s.size() - 1; i++) {
            if (roman[s[i]] < roman[s[i + 1]]) {
                res -= roman[s[i]];
            } else {
                res += roman[s[i]];
            }
        }

        return res + roman[s[s.size() - 1]];        
    }
};
Explanation: Approach
The description includes the example of 27. If the values are written from left to right in descending order, simply adding each number one by one will give the result.

XXVII
↓
10(X) + 10(X) + 5(V) + 1(I) + 1(I) = 27
LVIII
↓
50(L) + 5(V) + 1(I) + 1(I) + 1(I) = 58
But numbers like 4 and 9 are represented as a single number using two Roman numerals.

IV = 4
IX = 9
 Points

Basically, you just need to convert either one or two characters into a number to get the answer.

How do we determine if it’s one or two characters?
Since a single number can use up to two Roman characters, we loop through the string two characters at a time, shifting by one each time.

Let’s take a look at this example.

Input: s = "XIV"
In the first loop, we use X and I. In this case, the second character I is less than X. I is 1 and X is 10. That means we can simply add X to result variable, because 10 → 1 is a descending order. It's the same as 27 or 58 above.

res = 10
Next, we use I and V. In this case, the second character V is greater than I, because V is 5 and I is 1.

The description says "there are six instances where subtraction is used."

IV = 4
IX = 9
XL = 40
XC = 90
CD = 400
CM = 900
Look at all the first characters and the second characters. The first characters are less than the second characters.

I(1) + V(5) = 4
I(1) + X(10) = 9
X(10) + L(50) = 40
X(10) + C(100) = 90
C(100) + D(500) = 400
C(100) + M(1000) = 900
The current first character is I and the second character is V, so we are using two Roman characters to form a single number.

In this case, we subtract I(= 1) from result variable, because in the next loop, we will add V(= 5), so the total of I and V will be 4 in the end.

res = 9
The next two number is V and nothing(= out of bounds), so we stop iteration.

The last point is that as I told you, we should add V before return the answer, because one of values was out of bounds, that's why we couldn't add the last Roman chartacter which is V.

return res + 5
Before we start looping, we have HashMap to combine Roman and Integer, so that we can convert Roman to Integer easily.

In the solution code,

return res + roman[s[-1]]

s is input string
roman is HashMap


        INSTRUCTIONS:
        Solve the current question.
        Provide:
        1. A complete and efficient code solution, optimized for both time and space complexity.
        2. A detailed explanation of the solution, including:
           - The intuition behind the approach;
           - Time and space complexity;
           - Important considerations about the algorithm.
        3. If the language has classes, implement in 'Solution' class. Any language is accepted.
        4. You can use the example questions as general references for coding patterns and structure, but solve the current problem independently.
        5. Don't use any external libraries. Don't need to import any libraries.
