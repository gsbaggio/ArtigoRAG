#include <vector>
#include <unordered_map>
#include <string>
#include <cmath>
#include <limits>

using namespace std;

class Solution {
public:
    double minAreaFreeRect(vector<vector<int>>& points) {
        unordered_map<string, vector<pair<int, int>>> map;
        
        // Function to calculate squared distance between two points
        auto dist2 = [](const vector<int>& p1, const vector<int>& p2) {
            return (p1[0] - p2[0]) * (p1[0] - p2[0]) + (p1[1] - p2[1]) * (p1[1] - p2[1]);
        };
        
        // Function to calculate midpoint of two points
        auto midpoint = [](const vector<int>& p1, const vector<int>& p2) {
            int x = p1[0] + p2[0];
            int y = p1[1] + p2[1];
            return to_string(x) + "," + to_string(y);
        };
        
        int n = points.size();
        double minArea = numeric_limits<double>::max();
        
        // Iterate through all pairs of points
        for (int i = 0; i < n; ++i) {
            for (int j = i + 1; j < n; ++j) {
                int d2 = dist2(points[i], points[j]);
                string mid = midpoint(points[i], points[j]);
                
                // Check all pairs of points that share the same midpoint and diagonal length
                for (auto& [x, y] : map[mid + "," + to_string(d2)]) {
                    // Calculate the area of the rectangle
                    double area = sqrt(dist2(points[i], points[x])) * sqrt(dist2(points[i], points[y]));
                    minArea = min(minArea, area);
                }
                
                // Add the current pair to the map
                map[mid + "," + to_string(d2)].emplace_back(i, j);
            }
        }
        
        // If no rectangle was found, return 0
        return minArea == numeric_limits<double>::max() ? 0 : minArea;
    }
};