CURRENT QUESTION:
A password is said to be strong if it satisfies all the following criteria:

It has at least 8 characters.
It contains at least one lowercase letter.
It contains at least one uppercase letter.
It contains at least one digit.
It contains at least one special character. The special characters are the characters in the following string: "!@#$%^&*()-+".
It does not contain 2 of the same character in adjacent positions (i.e., "aab" violates this condition, but "aba" does not).
Given a string password, return true if it is a strong password. Otherwise, return false.

 

Example 1:

Input: password = "IloveLe3tcode!"
Output: true
Explanation: The password meets all the requirements. Therefore, we return true.
Example 2:

Input: password = "Me+You--IsMyDream"
Output: false
Explanation: The password does not contain a digit and also contains 2 of the same character in adjacent positions. Therefore, we return false.
Example 3:

Input: password = "1aB!"
Output: false
Explanation: The password does not meet the length requirement. Therefore, we return false.
 

Constraints:

1 <= password.length <= 100
password consists of letters, digits, and special characters: "!@#$%^&*()-+".

EXAMPLE QUESTIONS:
Example question 1:
Title: Arranging Coins
Categorys: Math Binary Search
Question text: You have n coins and you want to build a staircase with these coins. The staircase consists of k rows where the ith row has exactly i coins. The last row of the staircase may be incomplete.

Given the integer n, return the number of complete rows of the staircase you will build.

 

Example 1:
Input: n = 5
Output: 2
Explanation: Because the 3rd row is incomplete, we return 2.
Example 2:
Input: n = 8
Output: 3
Explanation: Because the 4th row is incomplete, we return 3.
 

Constraints:

1 <= n <= 231 - 1
Solution: import math

class Solution(object):
    def arrangeCoins(self, n):
        return int((math.sqrt(8 * n + 1) - 1) // 2)
Explanation: Intuition
This is about forming full staircase rows with coins: row i needs i coins. The total coins used for k full rows is the sum of 1 + 2 + ... + k = k(k+1)/2. Solve this inequality for k.

Approach
Use the quadratic formula to solve:

k(k + 1)/2 <= n
=> k² + k - 2n <= 0
Using the positive root of the quadratic equation, compute:

k = (sqrt(8n + 1) - 1) / 2
Then return the floor of k.

Complexity
Time Complexity: ( O(1) ) — single math operation.
Space Complexity: ( O(1) ) — no extra space.

Example question 2:
Title: Find Closest Node to Given Two Nodes
Categorys: Depth-First Search Graph
Question text: You are given a directed graph of n nodes numbered from 0 to n - 1, where each node has at most one outgoing edge.

The graph is represented with a given 0-indexed array edges of size n, indicating that there is a directed edge from node i to node edges[i]. If there is no outgoing edge from i, then edges[i] == -1.

You are also given two integers node1 and node2.

Return the index of the node that can be reached from both node1 and node2, such that the maximum between the distance from node1 to that node, and from node2 to that node is minimized. If there are multiple answers, return the node with the smallest index, and if no possible answer exists, return -1.

Note that edges may contain cycles.

 

Example 1:
Input: edges = [2,2,3,-1], node1 = 0, node2 = 1
Output: 2
Explanation: The distance from node 0 to node 2 is 1, and the distance from node 1 to node 2 is 1.
The maximum of those two distances is 1. It can be proven that we cannot get a node with a smaller maximum distance than 1, so we return node 2.
Example 2:
Input: edges = [1,2,-1], node1 = 0, node2 = 2
Output: 2
Explanation: The distance from node 0 to node 2 is 2, and the distance from node 2 to itself is 0.
The maximum of those two distances is 2. It can be proven that we cannot get a node with a smaller maximum distance than 2, so we return node 2.
 

Constraints:

n == edges.length
2 <= n <= 105
-1 <= edges[i] < n
edges[i] != i
0 <= node1, node2 < n
Solution: class Solution {
public:
    void bfs(int startNode, vector<int>& edges, vector<int>& dist) {
        int n = edges.size();
        queue<int> q;
        q.push(startNode);

        vector<bool> visit(n);
        dist[startNode] = 0;

        while (!q.empty()) {
            int node = q.front();
            q.pop();

            if (visit[node]) {
                continue;
            }

            visit[node] = true;
            int neighbor = edges[node];
            if (neighbor != -1 && !visit[neighbor]) {
                dist[neighbor] = 1 + dist[node];
                q.push(neighbor);
            }
        }
    }

    int closestMeetingNode(vector<int>& edges, int node1, int node2) {
        int n = edges.size();
        vector<int> dist1(n, numeric_limits<int>::max()), dist2(n, numeric_limits<int>::max());

        bfs(node1, edges, dist1);
        bfs(node2, edges, dist2);

        int minDistNode = -1, minDistTillNow = numeric_limits<int>::max();
        for (int currNode = 0; currNode < n; currNode++) {
            if (minDistTillNow > max(dist1[currNode], dist2[currNode])) {
                minDistNode = currNode;
                minDistTillNow = max(dist1[currNode], dist2[currNode]);
            }
        }

        return minDistNode;
    }
};
Explanation: Algorithm
Initialize two arrays, dist1 and dist2 storing the shortest distances from node1 and node2 to all the nodes. Initialize them with large values.
Start a BFS traversal.
We use a function bfs to perform the traversal. It requires startNode, edges, dist as the parameters, where dist is the array that stores the shortest distances from startNode to all the nodes.
Start with node1, edges, dist1.
Initialize a queue with startNode in the queue.
Initialize an array visit, storing a boolean for each node to indicate if a node is visited. Initialize it with false for all the nodes.
Then, while the queue is not empty:
Dequeue the first node from the queue. If it has not been visited, mark it as visited. Otherwise, if it has been visited, repeat step 4.
Check if node has an outgoing edge. If there is no outgoing edge, we don't do anything.
If the node has an outgoing edge to another node called neighbor, and neighbor has not yet been visited, update the dist[neighbor] to dist[neighbor] = 1 + dist[node] and push the neighbor into the queue.
Perform another BFS traversal with node2, edges, dist2 to get the shortest distances from node2 to every other node in dist2.
Initialize two variables: minDistNode = -1, which is the answer to our problem, and minDistTillNow, which is the maximum between the distances from node1 to minDistNode and from node2 to minDistNode.
Run a loop over all the nodes and check each node called currNode.
If minDistTillNow > max(dist1[currNode], dist2[currNode]), update minDistTillNow to minDistTillNow = max(dist1[currNode], dist2[currNode]) and update minDistNode to minDistNode = currNode.
Otherwise, we do not update anything.
Return minDistNode.

Example question 3:
Title: Symmetric Tree
Categorys: Tree Depth-First Search Breadth-First Search Binary Tree
Question text: Given the root of a binary tree, check whether it is a mirror of itself (i.e., symmetric around its center).

 

Example 1:
Input: root = [1,2,2,3,4,4,3]
Output: true
Example 2:
Input: root = [1,2,2,null,3,null,3]
Output: false
 

Constraints:

The number of nodes in the tree is in the range [1, 1000].
-100 <= Node.val <= 100
Solution: class Solution {
public:
    bool isMirror(TreeNode* left, TreeNode* right) {
    if (!left && !right) return true;
    if (!left || !right) return false;
    return (left->val == right->val) && isMirror(left->left, right->right) && isMirror(left->right, right->left);
}

bool isSymmetric(TreeNode* root) {
    if (!root) return true;
    return isMirror(root->left, root->right);
}

};
Explanation: Intuition
To check if a binary tree is symmetric, we need to compare its left subtree and right subtree. To do this, we can traverse the tree recursively and compare the left and right subtrees at each level. If they are symmetric, we continue the traversal. Otherwise, we can immediately return false.

Approach
We can define a recursive helper function that takes two nodes as input, one from the left subtree and one from the right subtree. The helper function returns true if both nodes are null, or if their values are equal and their subtrees are symmetric.

Complexity
Time complexity:The time complexity of the algorithm is O(n), where n is the number of nodes in the binary tree. We need to visit each node once to check if the tree is symmetric.
Space complexity:
The space complexity of the algorithm is O(h), where h is the height of the binary tree. In the worst case, the tree can be completely unbalanced, and the recursion stack can go as deep as the height of the tree


        INSTRUCTIONS:
        Solve the current question.
        Provide:
        1. A complete and efficient code solution, optimized for both time and space complexity.
        2. A detailed explanation of the solution, including:
           - The intuition behind the approach;
           - Time and space complexity;
           - Important considerations about the algorithm.
        3. If the language has classes, implement in 'Solution' class. Any language is accepted.
        4. You can use the example questions as general references for coding patterns and structure, but solve the current problem independently.
        5. Don't use any external libraries. Don't need to import any libraries.
