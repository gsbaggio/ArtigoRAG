class Solution:
    def minMalwareSpread(self, graph, initial):
        n = len(graph)
        self.visited = [False] * n
        
        # Step 1: Find all connected components
        def dfs(node, component):
            self.visited[node] = True
            component.append(node)
            for neighbor in range(n):
                if graph[node][neighbor] == 1 and not self.visited[neighbor]:
                    dfs(neighbor, component)
        
        components = []
        for node in range(n):
            if not self.visited[node]:
                component = []
                dfs(node, component)
                components.append(component)
        
        # Step 2: Calculate the size of each component
        component_sizes = {tuple(comp): len(comp) for comp in components}
        
        # Step 3: Track infected nodes per component
        infected_in_component = {}
        for comp in components:
            infected_nodes = [node for node in comp if node in initial]
            infected_in_component[tuple(comp)] = infected_nodes
        
        # Step 4: Determine the impact of removing each node
        max_reduction = 0
        best_node = min(initial)  # Default to the smallest index if no better option
        
        for node in initial:
            comp = tuple([c for c in components if node in c][0])
            infected_nodes = infected_in_component[comp]
            
            if len(infected_nodes) == 1:
                # Removing this node isolates the component
                reduction = component_sizes[comp]
                if reduction > max_reduction or (reduction == max_reduction and node < best_node):
                    max_reduction = reduction
                    best_node = node
        
        return best_node