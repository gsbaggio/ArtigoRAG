class Solution {
    public int minMalwareSpread(int[][] graph, int[] initial) {
        int N = graph.length;
        DSU dsu = new DSU(N);
        
        // Union all connected nodes
        for (int i = 0; i < N; ++i) {
            for (int j = i + 1; j < N; ++j) {
                if (graph[i][j] == 1) {
                    dsu.union(i, j);
                }
            }
        }

        // Count the number of initially infected nodes in each component
        int[] count = new int[N];
        for (int node : initial) {
            count[dsu.find(node)]++;
        }

        // Find the best node to remove
        int ans = -1, ansSize = -1;
        for (int node : initial) {
            int root = dsu.find(node);
            if (count[root] == 1) {  // Unique color (only one initially infected node in this component)
                int rootSize = dsu.size(root);
                if (rootSize > ansSize) {
                    ansSize = rootSize;
                    ans = node;
                } else if (rootSize == ansSize && node < ans) {
                    ans = node;
                }
            }
        }

        // If no unique component found, return the smallest index node from initial
        if (ans == -1) {
            ans = Integer.MAX_VALUE;
            for (int node : initial) {
                ans = Math.min(ans, node);
            }
        }
        return ans;
    }
}

class DSU {
    int[] parent;  // Parent array for finding the root of each node
    int[] size;    // Size array to keep track of the size of each component

    DSU(int N) {
        parent = new int[N];
        size = new int[N];
        for (int x = 0; x < N; ++x) {
            parent[x] = x;  // Each node is its own parent initially
            size[x] = 1;    // Each component starts with size 1
        }
    }

    // Find the root of the node x with path compression
    public int find(int x) {
        if (parent[x] != x) {
            parent[x] = find(parent[x]);  // Path compression
        }
        return parent[x];
    }

    // Union the components containing nodes x and y
    public void union(int x, int y) {
        int rootX = find(x);
        int rootY = find(y);
        if (rootX != rootY) {
            parent[rootX] = rootY;  // Union by linking rootX to rootY
            size[rootY] += size[rootX];  // Update the size of the component containing rootY
        }
    }

    // Get the size of the component containing node x
    public int size(int x) {
        return size[find(x)];
    }
}