class Solution:
    def minMalwareSpread(self, graph, initial):
        """
        Calculates the node to remove from the initial set to minimize the final malware spread.

        Args:
            graph (List[List[int]]): Adjacency matrix representing the network.
            initial (List[int]): List of initially infected nodes.

        Returns:
            int: The node to remove to minimize malware spread.
        """

        n = len(graph)
        initial_set = set(initial)

        def dfs(node, component):
            """
            Performs Depth-First Search to find all nodes in a connected component.

            Args:
                node (int): The starting node for the DFS.
                component (set): The set to store the nodes in the component.

            Returns:
                None
            """
            component.add(node)
            for neighbor in range(n):
                if graph[node][neighbor] == 1 and neighbor not in component:
                    dfs(neighbor, component)

        # 1. Identify Connected Components
        components = {}  # Maps a node to its connected component
        component_id = 0
        node_to_component_size = {}

        for node in range(n):
            if node not in components:
                component = set()
                dfs(node, component)
                
                # Assign a unique ID to the component
                for comp_node in component:
                    components[comp_node] = component_id
                
                node_to_component_size[component_id] = len(component)
                component_id += 1

        # 2. Count Initial Nodes per Component
        component_to_initial_nodes = {}
        for node in initial:
            comp_id = components[node]
            if comp_id not in component_to_initial_nodes:
                component_to_initial_nodes[comp_id] = []
            component_to_initial_nodes[comp_id].append(node)

        # 3. Calculate Saved Nodes by Removing Each Initial Node
        saved_nodes = {}
        for node_to_remove in initial:
            comp_id = components[node_to_remove]
            
            # If the component has only one initial node, removing it saves the entire component
            if len(component_to_initial_nodes[comp_id]) == 1:
                saved_nodes[node_to_remove] = node_to_component_size[comp_id]
            else:
                saved_nodes[node_to_remove] = 0  # Removing it doesn't save any nodes

        # 4. Find the Node to Remove that Saves the Most Nodes
        best_node = -1
        max_saved = -1

        for node in initial:
            if saved_nodes[node] > max_saved:
                max_saved = saved_nodes[node]
                best_node = node
            elif saved_nodes[node] == max_saved and node < best_node:
                best_node = node

        # If no node can save any nodes, return the smallest initial node
        if best_node == -1:
            return min(initial)

        return best_node

"""
Explanation:

1. Intuition:
   - The problem asks us to find a node in the 'initial' set such that removing it minimizes the final malware spread.
   - The key idea is to analyze connected components in the graph. If a connected component has only one initially infected node, removing that node will prevent the entire component from being infected.
   - If a connected component has multiple initially infected nodes, removing one of them won't prevent the component from being infected because the other infected nodes will still spread the malware.
   - Therefore, we want to find the node in 'initial' that, when removed, saves the largest connected component that would otherwise be infected due to only that node's presence.

2. Algorithm:
   - **Identify Connected Components:** Use Depth-First Search (DFS) to find all connected components in the graph. Assign a unique ID to each component and store the component size.
   - **Count Initial Nodes per Component:** For each connected component, count how many nodes from the 'initial' set are present in that component.
   - **Calculate Saved Nodes by Removing Each Initial Node:** Iterate through each node in the 'initial' set. For each node, determine the connected component it belongs to. If that component has only one initial node (the current node), then removing the current node will save the entire component. Otherwise, removing the node won't save any nodes.
   - **Find the Node to Remove that Saves the Most Nodes:** Find the node in 'initial' that, when removed, saves the maximum number of nodes. If there are multiple such nodes, choose the one with the smallest index.

3. Time and Space Complexity:
   - **Time Complexity:**
     - DFS: O(N^2) in the worst case, where N is the number of nodes (visiting each node and edge).
     - Identifying components: O(N)
     - Counting initial nodes per component: O(len(initial))
     - Calculating saved nodes: O(len(initial))
     - Finding the best node to remove: O(len(initial))
     - Overall: O(N^2)

   - **Space Complexity:**
     - components: O(N)
     - component_to_initial_nodes: O(N)
     - saved_nodes: O(len(initial))
     - DFS stack: O(N) in the worst case
     - Overall: O(N)

4. Important Considerations:
   - The graph is undirected, so `graph[i][j] == graph[j][i]`.
   - `graph[i][i] == 1`, meaning each node is connected to itself. This doesn't affect the connected component analysis.
   - The 'initial' set contains unique integers.
   - If removing any node doesn't save any nodes, return the smallest node in 'initial'.
"""