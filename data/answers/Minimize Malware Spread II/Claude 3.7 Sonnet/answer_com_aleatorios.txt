class Solution {
    public int minMalwareSpread(int[][] graph, int[] initial) {
        int n = graph.length;
        Arrays.sort(initial); // Sort to ensure we return the smallest index when tied
        
        // First calculate the baseline - how many nodes get infected with all initial nodes
        int baselineInfected = simulateSpread(graph, initial);
        
        int minInfected = n + 1; // More than possible max
        int bestNodeToRemove = -1;
        
        // Try removing each node from initial and see the effect
        for (int nodeToRemove : initial) {
            // Create a new initial array without the current node
            int[] newInitial = new int[initial.length - 1];
            int idx = 0;
            for (int node : initial) {
                if (node != nodeToRemove) {
                    newInitial[idx++] = node;
                }
            }
            
            // Calculate how many nodes get infected with this node removed
            int infected = simulateSpread(graph, newInitial);
            
            // Update our best option if this is better
            if (infected < minInfected) {
                minInfected = infected;
                bestNodeToRemove = nodeToRemove;
            }
        }
        
        return bestNodeToRemove;
    }
    
    private int simulateSpread(int[][] graph, int[] initial) {
        int n = graph.length;
        boolean[] infected = new boolean[n];
        Queue<Integer> queue = new LinkedList<>();
        
        // Mark all initial nodes as infected
        for (int node : initial) {
            infected[node] = true;
            queue.offer(node);
        }
        
        // BFS to spread the malware
        while (!queue.isEmpty()) {
            int curr = queue.poll();
            
            for (int neighbor = 0; neighbor < n; neighbor++) {
                if (graph[curr][neighbor] == 1 && !infected[neighbor]) {
                    infected[neighbor] = true;
                    queue.offer(neighbor);
                }
            }
        }
        
        // Count total infected nodes
        int count = 0;
        for (boolean isInfected : infected) {
            if (isInfected) count++;
        }
        
        return count;
    }
}