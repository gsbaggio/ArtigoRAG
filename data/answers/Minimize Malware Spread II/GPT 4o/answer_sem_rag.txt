class Solution:
    def minMalwareSpread(self, graph, initial):
        n = len(graph)
        
        # Step 1: Find connected components using DFS
        def dfs(node, component_id):
            for neighbor in range(n):
                if graph[node][neighbor] == 1 and neighbor not in visited:
                    visited.add(neighbor)
                    components[neighbor] = component_id
                    dfs(neighbor, component_id)
        
        visited = set()
        components = {}
        component_sizes = {}
        component_id = 0
        
        for i in range(n):
            if i not in visited:
                visited.add(i)
                components[i] = component_id
                dfs(i, component_id)
                component_id += 1
        
        # Calculate the size of each component
        for node in components:
            comp_id = components[node]
            component_sizes[comp_id] = component_sizes.get(comp_id, 0) + 1
        
        # Step 2: Count infections in each component
        infected_count = {}
        for node in initial:
            comp_id = components[node]
            infected_count[comp_id] = infected_count.get(comp_id, 0) + 1
        
        # Step 3: Simulate removal of each node in initial
        result = (-1, float('inf'))  # (node, minimized infection count)
        for node in initial:
            comp_id = components[node]
            if infected_count[comp_id] == 1:  # Unique infection in this component
                saved = component_sizes[comp_id]
            else:
                saved = 0
            
            # Choose the node with the maximum saved nodes, break ties by index
            if saved > result[1] or (saved == result[1] and node < result[0]):
                result = (node, saved)
        
        return result[0]