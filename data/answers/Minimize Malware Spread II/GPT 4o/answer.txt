class Solution:
    def minMalwareSpread(self, graph, initial):
        n = len(graph)
        
        # Helper function to perform DFS and find the size of connected components
        def dfs(node, visited, component):
            visited[node] = True
            component.append(node)
            for neighbor in range(n):
                if graph[node][neighbor] == 1 and not visited[neighbor]:
                    dfs(neighbor, visited, component)
        
        # Step 1: Find all connected components
        visited = [False] * n
        components = []
        for i in range(n):
            if not visited[i]:
                component = []
                dfs(i, visited, component)
                components.append(component)
        
        # Step 2: Map each node to its component
        node_to_component = {}
        for idx, component in enumerate(components):
            for node in component:
                node_to_component[node] = idx
        
        # Step 3: Count the number of initially infected nodes in each component
        infected_count = [0] * len(components)
        for node in initial:
            infected_count[node_to_component[node]] += 1
        
        # Step 4: Evaluate the impact of removing each node in `initial`
        best_node = float('inf')
        best_reduction = -1
        
        for node in initial:
            component_idx = node_to_component[node]
            if infected_count[component_idx] == 1:  # Only one infected node in this component
                component_size = len(components[component_idx])
                if component_size > best_reduction or (component_size == best_reduction and node < best_node):
                    best_reduction = component_size
                    best_node = node
        
        # Step 5: If no node uniquely reduces the spread, return the smallest index
        if best_node == float('inf'):
            return min(initial)
        
        return best_node