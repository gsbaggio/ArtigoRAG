class Solution:
    def minMalwareSpread(self, graph, initial):
        from collections import defaultdict

        def dfs(node, visited, component):
            visited[node] = True
            component.append(node)
            for neighbor in range(len(graph)):
                if graph[node][neighbor] == 1 and not visited[neighbor]:
                    dfs(neighbor, visited, component)

        n = len(graph)
        visited = [False] * n
        components = []

        # Step 1: Find all connected components
        for i in range(n):
            if not visited[i]:
                component = []
                dfs(i, visited, component)
                components.append(component)

        # Step 2: Count malware in each component
        component_map = {}
        malware_count = defaultdict(int)
        for component in components:
            for node in component:
                component_map[node] = component
                if node in initial:
                    malware_count[tuple(component)] += 1

        # Step 3: Evaluate the impact of removing each node
        best_node = float('inf')
        best_reduction = float('-inf')
        for node in initial:
            component = component_map[node]
            if malware_count[tuple(component)] == 1:  # Only one malware in the component
                reduction = len(component)
                if reduction > best_reduction or (reduction == best_reduction and node < best_node):
                    best_reduction = reduction
                    best_node = node

        # If no node can reduce the spread, return the smallest index
        return best_node if best_node != float('inf') else min(initial)