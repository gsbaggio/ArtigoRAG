class Solution {
    public int minimumDifference(int[] nums) {
        int n = nums.length / 2;
        int totalSum = 0;
        for (int num : nums) {
            totalSum += num;
        }

        // dp[i][j] is a set of possible sums using i numbers from the first half
        // such that the number of elements used is j.
        // We use a set to avoid duplicates.
        List<Set<Integer>> dp = new ArrayList<>();
        for (int i = 0; i <= n; i++) {
            dp.add(new HashSet<>());
        }
        dp.get(0).add(0);

        // Iterate through the first half of the array
        for (int i = 0; i < n; i++) {
            // Iterate backwards to avoid overwriting previous results
            for (int j = n - 1; j >= 0; j--) {
                // For each possible sum, add the current number to it
                for (int sum : dp.get(j)) {
                    dp.get(j + 1).add(sum + nums[i]);
                }
            }
        }

        int minDiff = Integer.MAX_VALUE;
        // Iterate through the second half of the array
        for (int i = 0; i < (1 << n); i++) {
            int count = 0;
            int sum = 0;
            for (int j = 0; j < n; j++) {
                if ((i & (1 << j)) != 0) {
                    count++;
                    sum += nums[n + j];
                }
            }

            // Calculate the other half sum
            int otherHalfCount = n - count;
            int otherHalfSum = totalSum / 2 - sum;

            // Find the closest sum in the dp array
            int closestSum = findClosest(dp.get(otherHalfCount), otherHalfSum);

            // Calculate the difference
            int diff = Math.abs(totalSum - 2 * (sum + closestSum));
            minDiff = Math.min(minDiff, diff);
        }

        return minDiff;
    }

    private int findClosest(Set<Integer> sums, int target) {
        int closest = Integer.MAX_VALUE;
        int minDiff = Integer.MAX_VALUE;
        for (int sum : sums) {
            int diff = Math.abs(sum - target);
            if (diff < minDiff) {
                minDiff = diff;
                closest = sum;
            }
        }
        return closest;
    }
}