CURRENT QUESTION:
You are given an integer array nums. Two players are playing a game with this array: player 1 and player 2.

Player 1 and player 2 take turns, with player 1 starting first. Both players start the game with a score of 0. At each turn, the player takes one of the numbers from either end of the array (i.e., nums[0] or nums[nums.length - 1]) which reduces the size of the array by 1. The player adds the chosen number to their score. The game ends when there are no more elements in the array.

Return true if Player 1 can win the game. If the scores of both players are equal, then player 1 is still the winner, and you should also return true. You may assume that both players are playing optimally.

 

Example 1:

Input: nums = [1,5,2]
Output: false
Explanation: Initially, player 1 can choose between 1 and 2. 
If he chooses 2 (or 1), then player 2 can choose from 1 (or 2) and 5. If player 2 chooses 5, then player 1 will be left with 1 (or 2). 
So, final score of player 1 is 1 + 2 = 3, and player 2 is 5. 
Hence, player 1 will never be the winner and you need to return false.
Example 2:

Input: nums = [1,5,233,7]
Output: true
Explanation: Player 1 first chooses 1. Then player 2 has to choose between 5 and 7. No matter which number player 2 choose, player 1 can choose 233.
Finally, player 1 has more score (234) than player 2 (12), so you need to return True representing player1 can win.
 

Constraints:

1 <= nums.length <= 20
0 <= nums[i] <= 107

EXAMPLE QUESTIONS:
Example question 1:
Title: Rotate Image
Categorys: Array Math Matrix
Question text: You are given an n x n 2D matrix representing an image, rotate the image by 90 degrees (clockwise).

You have to rotate the image in-place, which means you have to modify the input 2D matrix directly. DO NOT allocate another 2D matrix and do the rotation.

 

Example 1:
Input: matrix = [[1,2,3],[4,5,6],[7,8,9]]
Output: [[7,4,1],[8,5,2],[9,6,3]]
Example 2:
Input: matrix = [[5,1,9,11],[2,4,8,10],[13,3,6,7],[15,14,12,16]]
Output: [[15,13,2,5],[14,3,4,1],[12,6,8,9],[16,7,10,11]]
 

Constraints:

n == matrix.length == matrix[i].length
1 <= n <= 20
-1000 <= matrix[i][j] <= 1000
Solution: class Solution {
public:
    void rotate(vector<vector<int>>& matrix) {
        int row = matrix.size();
        for(int i=0;i<row; i++){
            for(int j=0; j<=i;j++){
                swap(matrix[i][j], matrix[j][i]);
            }
        }
        for(int i=0;i<row;i++){
            reverse(matrix[i].begin(), matrix[i].end());
        }
    }
};
Explanation: Approach
2 Steps to rotate image

Transpose the matrix
Swap the columns

Example question 2:
Title: Max Points on a Line
Categorys: Array Hash Table Math Geometry
Question text: Given an array of points where points[i] = [xi, yi] represents a point on the X-Y plane, return the maximum number of points that lie on the same straight line.
Example 1:
Input: points = [[1,1],[2,2],[3,3]]
Output: 3
Example 2:
Input: points = [[1,1],[3,2],[5,3],[4,1],[2,3],[1,4]]
Output: 4
Constraints:

1 <= points.length <= 300
points[i].length == 2
-104 <= xi, yi <= 104
All the points are unique.
Solution: class Solution {
public:
    int maxPoints(vector<vector<int>>& pt) {
        int ans=1; 
        int n=pt.size();
       // slope of every point with selected point
        for(int i=0;i<n-1;i++){
            map<double,int> mp;
            for(int j=i+1;j<n;j++){
                //calculating the slope
                double x = (double)(pt[j][1]-pt[i][1])/(double)(pt[j][0]-pt[i][0]);
                if(pt[j][1]-pt[i][1]<0 &&(pt[j][0]-pt[i][0])==0 ) //infinite slop for Perpendicular line
                mp[abs(x)]++; 
                else
               //storing the slop into map
                    mp[x]++;
            }
            // same slope w.r.t.that selected point
            int temp = 0;
            for(auto it:mp)
                temp = max(temp, it.second+1);    // +1 for the current point(point itself)
            ans = max(temp, ans);
        }
        return ans;
    }
};
Explanation: Intuition
Here we will calculate the slope
Approach
Idea is very simple

We will select point and for every selected point we will calculate the slope wr.t to another point and store into the map
In map we will store <slope,that selected point>
for example we have point :-[[1,1],[2,2],[3,3]......
we pick point [1,1]and for that [1,1] we will calculate the slope
w.r.t [2,2] ,[3,3]....... and store like this-
for understanding purpose i'm writing
mp[slope1,[1,1]]
mp[slope2,[1,1]]
mp[slope1,[1,1]].........
This type we will store the slope for [2,2] , [3,3],....
Ater storing the slope into map we will calculate the max point for that slope
For example after storing the slope map can look like this
[2/3,3]
[INF,1]//for perpendicular case
[1/3,2]...
find the max number of points having the same slope w.r.t. that selected point :-means which slope have maximum point
:- here 2/3 have 3 point so our answer will be 3+1(we are adding that point as well)

Example question 3:
Title: Final Array State After K Multiplication Operations II
Categorys: Array Heap (Priority Queue) Simulation
Question text: You are given an integer array nums, an integer k, and an integer multiplier.

You need to perform k operations on nums. In each operation:

Find the minimum value x in nums. If there are multiple occurrences of the minimum value, select the one that appears first.
Replace the selected minimum value x with x * multiplier.
After the k operations, apply modulo 109 + 7 to every value in nums.

Return an integer array denoting the final state of nums after performing all k operations and then applying the modulo.

 

Example 1:

Input: nums = [2,1,3,5,6], k = 5, multiplier = 2

Output: [8,4,6,5,6]

Explanation:

Operation	Result
After operation 1	[2, 2, 3, 5, 6]
After operation 2	[4, 2, 3, 5, 6]
After operation 3	[4, 4, 3, 5, 6]
After operation 4	[4, 4, 6, 5, 6]
After operation 5	[8, 4, 6, 5, 6]
After applying modulo	[8, 4, 6, 5, 6]
Example 2:

Input: nums = [100000,2000], k = 2, multiplier = 1000000

Output: [999999307,999999993]

Explanation:

Operation	Result
After operation 1	[100000, 2000000000]
After operation 2	[100000000000, 2000000000]
After applying modulo	[999999307, 999999993]
 

Constraints:

1 <= nums.length <= 104
1 <= nums[i] <= 109
1 <= k <= 109
1 <= multiplier <= 106
Solution: const long long mod = 1000000007;

class Solution {
public:
    long long power_mod(long long base, long long exp, long long mod) {
    long long result = 1;
    
    while (exp > 0) {
        if (exp % 2 == 1) {
            result = (result * base) % mod;
        }
        base = (base * base) % mod;
        exp = exp / 2;
    }
    // this function multiplies a number by itself n times in O(logn)
    return result;
}
    vector<int> getFinalState(vector<int>& nums, int k, int multiplier) {
        if (multiplier == 1) return nums; // do not miss this!!
        priority_queue <pair<long long,long long>, vector<pair<long long,long long>>, greater<pair<long long,long long>>> pq;
        int n = nums.size();
        for (int i = 0; i < n; i++) pq.push({nums[i],i});
        unordered_map<int,int> m,m1;
        // m for storing number of operations at each index
        //m1 to know if all elements have got an operation
        while (1){
            if ((int)m1.size() == n || k == 0) break; // no more operations or state achieved
            long long x = pq.top().first, y = pq.top().second;
            pq.pop();
            x *= multiplier; pq.push({x,y});
            m1[y]++; k--;
        }
        vector<long long> v(n); // to avoid integer overflow
        // This vector will store the elements after ideal state is achieved
        while (!pq.empty()){
            long long x = pq.top().first, y = pq.top().second;
            v[y] = x;
            pq.pop();
        }
        int rep = k/n, md = k%n;
        for (int i = 0; i < n; i++) pq.push({v[i],i});
        // I had to push it again because I did not declare v initially due to contest pressure. Better to do that.
        while (!pq.empty()){
            int x = pq.top().second;
            m[x] = rep;
            if (md > 0)m[x]++,md--;
            // index x has been assigned its number of operations
            pq.pop();
        }
        // Now just compute every value while calling power_mod funtion
        for (int i = 0; i < n; i++){
            long long mlt = power_mod(multiplier, m[i],mod);
            v[i] = ((v[i]%mod)*(mlt%mod))%mod;
            nums[i] = v[i];
        }
        return nums;
    }
};
Explanation: Intuition
The general idea is to divide the operations greedily among all indexes.

Every number after getting an operation should not remain as the smallest. So we will have to achieve that state first.

BY OBSERVATION
When all the elements get atleast an operation, we will achieve the above mentioned state. So we will first greedily assign them operation till all elements get atleast one operation.

Use priority queue min heap or multiset for that.

After this we can assign every index a number of operations through our initial general idea.

What about such large value of k?
The number of operations of each index may be huge due to this. The optimal approach is achieved in log(n) as the multiplier increases exponentially. Check out the function in the code. This is called Exponentiation by Squaring.

Complexity
Time complexity: O(nlogk)

Space complexity: O(n)


        INSTRUCTIONS:
        Solve the current question.
        Provide:
        1. A complete and efficient code solution, optimized for both time and space complexity.
        2. A detailed explanation of the solution, including:
           - The intuition behind the approach;
           - Time and space complexity;
           - Important considerations about the algorithm.
        3. If the language has classes, implement in 'Solution' class. Any language is accepted.
        4. You can use the example questions as general references for coding patterns and structure, but solve the current problem independently.
        5. Don't use any external libraries. Don't need to import any libraries.
